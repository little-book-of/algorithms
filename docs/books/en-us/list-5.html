<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Chapter 5. Dynamic Programming – The Little Book of Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../books/en-us/list-4.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-27c261d06b905028a18691de25d09dde.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../books/en-us/list-5.html"><span class="chapter-title">Chapter 5. Dynamic Programming</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">The Little Book of Algorithms</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Content</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/cheatsheet.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Cheatsheet</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/book.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/plan.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Plan</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-1.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 1. Foundations of Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-2.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 2. Sorting and searching</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-3.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 3. Data Structure in Action</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-4.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 4. Graph Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-5.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Chapter 5. Dynamic Programming</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#section-41.-dp-basic-and-state-transitions" id="toc-section-41.-dp-basic-and-state-transitions" class="nav-link active" data-scroll-target="#section-41.-dp-basic-and-state-transitions">Section 41. DP basic and state transitions</a>
  <ul class="collapse">
  <li><a href="#fibonacci-dp" id="toc-fibonacci-dp" class="nav-link" data-scroll-target="#fibonacci-dp">401 Fibonacci DP</a></li>
  <li><a href="#climbing-stairs" id="toc-climbing-stairs" class="nav-link" data-scroll-target="#climbing-stairs">402 Climbing Stairs</a></li>
  <li><a href="#grid-paths" id="toc-grid-paths" class="nav-link" data-scroll-target="#grid-paths">403 Grid Paths</a></li>
  <li><a href="#min-cost-path" id="toc-min-cost-path" class="nav-link" data-scroll-target="#min-cost-path">404 Min Cost Path</a></li>
  <li><a href="#coin-change-count-ways" id="toc-coin-change-count-ways" class="nav-link" data-scroll-target="#coin-change-count-ways">405 Coin Change (Count Ways)</a></li>
  <li><a href="#coin-change-min-coins" id="toc-coin-change-min-coins" class="nav-link" data-scroll-target="#coin-change-min-coins">406 Coin Change (Min Coins)</a></li>
  <li><a href="#knapsack-01" id="toc-knapsack-01" class="nav-link" data-scroll-target="#knapsack-01">407 Knapsack 0/1</a></li>
  <li><a href="#knapsack-unbounded" id="toc-knapsack-unbounded" class="nav-link" data-scroll-target="#knapsack-unbounded">408 Knapsack Unbounded</a></li>
  <li><a href="#longest-increasing-subsequence-dp" id="toc-longest-increasing-subsequence-dp" class="nav-link" data-scroll-target="#longest-increasing-subsequence-dp">409 Longest Increasing Subsequence (DP)</a></li>
  <li><a href="#edit-distance-levenshtein" id="toc-edit-distance-levenshtein" class="nav-link" data-scroll-target="#edit-distance-levenshtein">410 Edit Distance (Levenshtein)</a></li>
  </ul></li>
  <li><a href="#section-42.-classic-problems" id="toc-section-42.-classic-problems" class="nav-link" data-scroll-target="#section-42.-classic-problems">Section 42. Classic Problems</a>
  <ul class="collapse">
  <li><a href="#knapsack" id="toc-knapsack" class="nav-link" data-scroll-target="#knapsack">411 0/1 Knapsack</a></li>
  <li><a href="#subset-sum" id="toc-subset-sum" class="nav-link" data-scroll-target="#subset-sum">412 Subset Sum</a></li>
  <li><a href="#equal-partition" id="toc-equal-partition" class="nav-link" data-scroll-target="#equal-partition">413 Equal Partition</a></li>
  <li><a href="#count-of-subsets-with-sum" id="toc-count-of-subsets-with-sum" class="nav-link" data-scroll-target="#count-of-subsets-with-sum">414 Count of Subsets with Sum</a></li>
  <li><a href="#target-sum" id="toc-target-sum" class="nav-link" data-scroll-target="#target-sum">415 Target Sum</a></li>
  <li><a href="#unbounded-knapsack" id="toc-unbounded-knapsack" class="nav-link" data-scroll-target="#unbounded-knapsack">416 Unbounded Knapsack</a></li>
  <li><a href="#fractional-knapsack" id="toc-fractional-knapsack" class="nav-link" data-scroll-target="#fractional-knapsack">417 Fractional Knapsack</a></li>
  <li><a href="#coin-change-min-coins-1" id="toc-coin-change-min-coins-1" class="nav-link" data-scroll-target="#coin-change-min-coins-1">418 Coin Change (Min Coins)</a></li>
  <li><a href="#coin-change-count-ways-1" id="toc-coin-change-count-ways-1" class="nav-link" data-scroll-target="#coin-change-count-ways-1">419 Coin Change (Count Ways)</a></li>
  <li><a href="#multi-dimensional-knapsack" id="toc-multi-dimensional-knapsack" class="nav-link" data-scroll-target="#multi-dimensional-knapsack">420 Multi-Dimensional Knapsack</a></li>
  </ul></li>
  <li><a href="#section-43.-sequence-problems" id="toc-section-43.-sequence-problems" class="nav-link" data-scroll-target="#section-43.-sequence-problems">Section 43. Sequence Problems</a>
  <ul class="collapse">
  <li><a href="#longest-increasing-subsequence-on2-dp" id="toc-longest-increasing-subsequence-on2-dp" class="nav-link" data-scroll-target="#longest-increasing-subsequence-on2-dp">421 Longest Increasing Subsequence (O(n^2) DP)</a></li>
  <li><a href="#lis-patience-sorting-on-log-n-optimized" id="toc-lis-patience-sorting-on-log-n-optimized" class="nav-link" data-scroll-target="#lis-patience-sorting-on-log-n-optimized">422 LIS (Patience Sorting) – O(n log n) Optimized</a></li>
  <li><a href="#longest-common-subsequence-lcs" id="toc-longest-common-subsequence-lcs" class="nav-link" data-scroll-target="#longest-common-subsequence-lcs">423 Longest Common Subsequence (LCS)</a></li>
  <li><a href="#edit-distance-levenshtein-1" id="toc-edit-distance-levenshtein-1" class="nav-link" data-scroll-target="#edit-distance-levenshtein-1">424 Edit Distance (Levenshtein)</a></li>
  <li><a href="#longest-palindromic-subsequence" id="toc-longest-palindromic-subsequence" class="nav-link" data-scroll-target="#longest-palindromic-subsequence">425 Longest Palindromic Subsequence</a></li>
  <li><a href="#shortest-common-supersequence-scs" id="toc-shortest-common-supersequence-scs" class="nav-link" data-scroll-target="#shortest-common-supersequence-scs">426 Shortest Common Supersequence (SCS)</a></li>
  <li><a href="#longest-repeated-subsequence" id="toc-longest-repeated-subsequence" class="nav-link" data-scroll-target="#longest-repeated-subsequence">427 Longest Repeated Subsequence</a></li>
  <li><a href="#string-interleaving" id="toc-string-interleaving" class="nav-link" data-scroll-target="#string-interleaving">428 String Interleaving</a></li>
  <li><a href="#sequence-alignment-bioinformatics" id="toc-sequence-alignment-bioinformatics" class="nav-link" data-scroll-target="#sequence-alignment-bioinformatics">429 Sequence Alignment (Bioinformatics)</a></li>
  <li><a href="#diff-algorithm-myers-dp" id="toc-diff-algorithm-myers-dp" class="nav-link" data-scroll-target="#diff-algorithm-myers-dp">430 Diff Algorithm (Myers / DP)</a></li>
  </ul></li>
  <li><a href="#section-44.-matrix-and-chain-problems" id="toc-section-44.-matrix-and-chain-problems" class="nav-link" data-scroll-target="#section-44.-matrix-and-chain-problems">Section 44. Matrix and Chain Problems</a>
  <ul class="collapse">
  <li><a href="#matrix-chain-multiplication" id="toc-matrix-chain-multiplication" class="nav-link" data-scroll-target="#matrix-chain-multiplication">431 Matrix Chain Multiplication</a></li>
  <li><a href="#boolean-parenthesization" id="toc-boolean-parenthesization" class="nav-link" data-scroll-target="#boolean-parenthesization">432 Boolean Parenthesization</a></li>
  <li><a href="#burst-balloons" id="toc-burst-balloons" class="nav-link" data-scroll-target="#burst-balloons">433 Burst Balloons</a></li>
  <li><a href="#optimal-bst" id="toc-optimal-bst" class="nav-link" data-scroll-target="#optimal-bst">434 Optimal BST</a></li>
  <li><a href="#polygon-triangulation" id="toc-polygon-triangulation" class="nav-link" data-scroll-target="#polygon-triangulation">435 Polygon Triangulation</a></li>
  <li><a href="#matrix-path-sum" id="toc-matrix-path-sum" class="nav-link" data-scroll-target="#matrix-path-sum">436 Matrix Path Sum</a></li>
  <li><a href="#largest-square-submatrix" id="toc-largest-square-submatrix" class="nav-link" data-scroll-target="#largest-square-submatrix">437 Largest Square Submatrix</a></li>
  <li><a href="#max-rectangle-in-binary-matrix" id="toc-max-rectangle-in-binary-matrix" class="nav-link" data-scroll-target="#max-rectangle-in-binary-matrix">438 Max Rectangle in Binary Matrix</a></li>
  <li><a href="#submatrix-sum-queries" id="toc-submatrix-sum-queries" class="nav-link" data-scroll-target="#submatrix-sum-queries">439 Submatrix Sum Queries</a></li>
  <li><a href="#palindrome-partitioning" id="toc-palindrome-partitioning" class="nav-link" data-scroll-target="#palindrome-partitioning">440 Palindrome Partitioning</a></li>
  </ul></li>
  <li><a href="#section-45.-bitmask-dp-and-traveling-salesman" id="toc-section-45.-bitmask-dp-and-traveling-salesman" class="nav-link" data-scroll-target="#section-45.-bitmask-dp-and-traveling-salesman">Section 45. Bitmask DP and Traveling Salesman</a>
  <ul class="collapse">
  <li><a href="#traveling-salesman-problem-tsp-bitmask-dp-heldkarp" id="toc-traveling-salesman-problem-tsp-bitmask-dp-heldkarp" class="nav-link" data-scroll-target="#traveling-salesman-problem-tsp-bitmask-dp-heldkarp">441 Traveling Salesman Problem (TSP), Bitmask DP (Held–Karp)</a></li>
  <li><a href="#subset-dp-over-subsets-of-states" id="toc-subset-dp-over-subsets-of-states" class="nav-link" data-scroll-target="#subset-dp-over-subsets-of-states">442 Subset DP (Over Subsets of States)</a></li>
  <li><a href="#hamiltonian-path-dp-state-compression" id="toc-hamiltonian-path-dp-state-compression" class="nav-link" data-scroll-target="#hamiltonian-path-dp-state-compression">443 Hamiltonian Path DP (State Compression)</a></li>
  <li><a href="#assignment-problem-dp-mask-over-tasks" id="toc-assignment-problem-dp-mask-over-tasks" class="nav-link" data-scroll-target="#assignment-problem-dp-mask-over-tasks">444 Assignment Problem DP (Mask over Tasks)</a></li>
  <li><a href="#partition-into-two-sets-balanced-load" id="toc-partition-into-two-sets-balanced-load" class="nav-link" data-scroll-target="#partition-into-two-sets-balanced-load">445 Partition into Two Sets (Balanced Load)</a></li>
  <li><a href="#count-hamiltonian-cycles-bitmask-enumeration" id="toc-count-hamiltonian-cycles-bitmask-enumeration" class="nav-link" data-scroll-target="#count-hamiltonian-cycles-bitmask-enumeration">446 Count Hamiltonian Cycles (Bitmask Enumeration)</a></li>
  <li><a href="#steiner-tree-dp" id="toc-steiner-tree-dp" class="nav-link" data-scroll-target="#steiner-tree-dp">447 Steiner Tree DP</a></li>
  <li><a href="#sos-dp-sum-over-subsets" id="toc-sos-dp-sum-over-subsets" class="nav-link" data-scroll-target="#sos-dp-sum-over-subsets">448 SOS DP (Sum Over Subsets)</a></li>
  <li><a href="#bitmask-knapsack-state-compression" id="toc-bitmask-knapsack-state-compression" class="nav-link" data-scroll-target="#bitmask-knapsack-state-compression">449 Bitmask Knapsack (State Compression)</a></li>
  <li><a href="#bitmask-independent-set-graph-subset-optimization" id="toc-bitmask-independent-set-graph-subset-optimization" class="nav-link" data-scroll-target="#bitmask-independent-set-graph-subset-optimization">450 Bitmask Independent Set (Graph Subset Optimization)</a></li>
  </ul></li>
  <li><a href="#section-46.-digit-dp-and-sos-dp" id="toc-section-46.-digit-dp-and-sos-dp" class="nav-link" data-scroll-target="#section-46.-digit-dp-and-sos-dp">Section 46. Digit DP and SOS DP</a>
  <ul class="collapse">
  <li><a href="#count-numbers-with-property-digit-dp" id="toc-count-numbers-with-property-digit-dp" class="nav-link" data-scroll-target="#count-numbers-with-property-digit-dp">451 Count Numbers with Property (Digit DP)</a></li>
  <li><a href="#count-without-adjacent-duplicates" id="toc-count-without-adjacent-duplicates" class="nav-link" data-scroll-target="#count-without-adjacent-duplicates">452 Count Without Adjacent Duplicates</a></li>
  <li><a href="#sum-of-digits-in-range" id="toc-sum-of-digits-in-range" class="nav-link" data-scroll-target="#sum-of-digits-in-range">453 Sum of Digits in Range</a></li>
  <li><a href="#count-with-mod-condition-digit-sum-mod-m" id="toc-count-with-mod-condition-digit-sum-mod-m" class="nav-link" data-scroll-target="#count-with-mod-condition-digit-sum-mod-m">454 Count with Mod Condition (Digit Sum mod M)</a></li>
  <li><a href="#count-of-increasing-digits" id="toc-count-of-increasing-digits" class="nav-link" data-scroll-target="#count-of-increasing-digits">455 Count of Increasing Digits</a></li>
  <li><a href="#count-with-forbidden-digits" id="toc-count-with-forbidden-digits" class="nav-link" data-scroll-target="#count-with-forbidden-digits">456 Count with Forbidden Digits</a></li>
  <li><a href="#sos-dp-subset-sum" id="toc-sos-dp-subset-sum" class="nav-link" data-scroll-target="#sos-dp-subset-sum">457 SOS DP Subset Sum</a></li>
  <li><a href="#sos-dp-superset-sum" id="toc-sos-dp-superset-sum" class="nav-link" data-scroll-target="#sos-dp-superset-sum">458 SOS DP Superset Sum</a></li>
  <li><a href="#xor-basis-dp" id="toc-xor-basis-dp" class="nav-link" data-scroll-target="#xor-basis-dp">459 XOR Basis DP</a></li>
  <li><a href="#digit-dp-for-palindromes" id="toc-digit-dp-for-palindromes" class="nav-link" data-scroll-target="#digit-dp-for-palindromes">460 Digit DP for Palindromes</a></li>
  </ul></li>
  <li><a href="#section-47.-dp-optimizations" id="toc-section-47.-dp-optimizations" class="nav-link" data-scroll-target="#section-47.-dp-optimizations">Section 47. DP Optimizations</a>
  <ul class="collapse">
  <li><a href="#divide-conquer-dp-monotone-optimization" id="toc-divide-conquer-dp-monotone-optimization" class="nav-link" data-scroll-target="#divide-conquer-dp-monotone-optimization">461 Divide &amp; Conquer DP (Monotone Optimization)</a></li>
  <li><a href="#knuth-optimization" id="toc-knuth-optimization" class="nav-link" data-scroll-target="#knuth-optimization">462 Knuth Optimization</a></li>
  <li><a href="#convex-hull-trick-cht" id="toc-convex-hull-trick-cht" class="nav-link" data-scroll-target="#convex-hull-trick-cht">463 Convex Hull Trick (CHT)</a></li>
  <li><a href="#li-chao-tree" id="toc-li-chao-tree" class="nav-link" data-scroll-target="#li-chao-tree">464 Li Chao Tree</a></li>
  <li><a href="#slope-trick" id="toc-slope-trick" class="nav-link" data-scroll-target="#slope-trick">465 Slope Trick</a></li>
  <li><a href="#monotonic-queue-optimization" id="toc-monotonic-queue-optimization" class="nav-link" data-scroll-target="#monotonic-queue-optimization">466 Monotonic Queue Optimization</a></li>
  <li><a href="#bitset-dp" id="toc-bitset-dp" class="nav-link" data-scroll-target="#bitset-dp">467 Bitset DP</a></li>
  <li><a href="#offline-dp-queries" id="toc-offline-dp-queries" class="nav-link" data-scroll-target="#offline-dp-queries">468 Offline DP Queries</a></li>
  <li><a href="#dp-segment-tree" id="toc-dp-segment-tree" class="nav-link" data-scroll-target="#dp-segment-tree">469 DP + Segment Tree</a></li>
  <li><a href="#divide-conquer-knapsack" id="toc-divide-conquer-knapsack" class="nav-link" data-scroll-target="#divide-conquer-knapsack">470 Divide &amp; Conquer Knapsack</a></li>
  </ul></li>
  <li><a href="#section-48.-tree-dp-and-rerooting" id="toc-section-48.-tree-dp-and-rerooting" class="nav-link" data-scroll-target="#section-48.-tree-dp-and-rerooting">Section 48. Tree DP and Rerooting</a>
  <ul class="collapse">
  <li><a href="#subtree-sum-dp" id="toc-subtree-sum-dp" class="nav-link" data-scroll-target="#subtree-sum-dp">471 Subtree Sum DP</a></li>
  <li><a href="#diameter-dp" id="toc-diameter-dp" class="nav-link" data-scroll-target="#diameter-dp">472 Diameter DP</a></li>
  <li><a href="#independent-set-dp" id="toc-independent-set-dp" class="nav-link" data-scroll-target="#independent-set-dp">473 Independent Set DP</a></li>
  <li><a href="#vertex-cover-dp" id="toc-vertex-cover-dp" class="nav-link" data-scroll-target="#vertex-cover-dp">474 Vertex Cover DP</a></li>
  <li><a href="#path-counting-dp" id="toc-path-counting-dp" class="nav-link" data-scroll-target="#path-counting-dp">475 Path Counting DP</a></li>
  <li><a href="#dp-on-rooted-tree" id="toc-dp-on-rooted-tree" class="nav-link" data-scroll-target="#dp-on-rooted-tree">476 DP on Rooted Tree</a></li>
  <li><a href="#rerooting-technique" id="toc-rerooting-technique" class="nav-link" data-scroll-target="#rerooting-technique">477 Rerooting Technique</a></li>
  <li><a href="#distance-sum-rerooting" id="toc-distance-sum-rerooting" class="nav-link" data-scroll-target="#distance-sum-rerooting">478 Distance Sum Rerooting</a></li>
  <li><a href="#tree-coloring-dp" id="toc-tree-coloring-dp" class="nav-link" data-scroll-target="#tree-coloring-dp">479 Tree Coloring DP</a></li>
  <li><a href="#binary-search-on-tree-dp" id="toc-binary-search-on-tree-dp" class="nav-link" data-scroll-target="#binary-search-on-tree-dp">480 Binary Search on Tree DP</a></li>
  </ul></li>
  <li><a href="#section-49.-dp-reconstruction-and-traceback" id="toc-section-49.-dp-reconstruction-and-traceback" class="nav-link" data-scroll-target="#section-49.-dp-reconstruction-and-traceback">Section 49. DP Reconstruction and Traceback</a>
  <ul class="collapse">
  <li><a href="#reconstruct-lcs" id="toc-reconstruct-lcs" class="nav-link" data-scroll-target="#reconstruct-lcs">481 Reconstruct LCS</a></li>
  <li><a href="#reconstruct-lis" id="toc-reconstruct-lis" class="nav-link" data-scroll-target="#reconstruct-lis">482 Reconstruct LIS</a></li>
  <li><a href="#reconstruct-knapsack" id="toc-reconstruct-knapsack" class="nav-link" data-scroll-target="#reconstruct-knapsack">483 Reconstruct Knapsack</a></li>
  <li><a href="#edit-distance-alignment" id="toc-edit-distance-alignment" class="nav-link" data-scroll-target="#edit-distance-alignment">484 Edit Distance Alignment</a></li>
  <li><a href="#matrix-chain-parentheses" id="toc-matrix-chain-parentheses" class="nav-link" data-scroll-target="#matrix-chain-parentheses">485 Matrix Chain Parentheses</a></li>
  <li><a href="#coin-change-reconstruction" id="toc-coin-change-reconstruction" class="nav-link" data-scroll-target="#coin-change-reconstruction">486 Coin Change Reconstruction</a></li>
  <li><a href="#path-reconstruction-dp" id="toc-path-reconstruction-dp" class="nav-link" data-scroll-target="#path-reconstruction-dp">487 Path Reconstruction DP</a></li>
  <li><a href="#sequence-reconstruction" id="toc-sequence-reconstruction" class="nav-link" data-scroll-target="#sequence-reconstruction">488 Sequence Reconstruction</a></li>
  <li><a href="#multi-choice-reconstruction" id="toc-multi-choice-reconstruction" class="nav-link" data-scroll-target="#multi-choice-reconstruction">489 Multi-Choice Reconstruction</a></li>
  <li><a href="#traceback-visualization" id="toc-traceback-visualization" class="nav-link" data-scroll-target="#traceback-visualization">490 Traceback Visualization</a></li>
  </ul></li>
  <li><a href="#section-50.-meta-dp-and-optimization-templates" id="toc-section-50.-meta-dp-and-optimization-templates" class="nav-link" data-scroll-target="#section-50.-meta-dp-and-optimization-templates">Section 50. Meta-DP and Optimization Templates</a>
  <ul class="collapse">
  <li><a href="#state-compression-template" id="toc-state-compression-template" class="nav-link" data-scroll-target="#state-compression-template">491 State Compression Template</a></li>
  <li><a href="#transition-optimization-template" id="toc-transition-optimization-template" class="nav-link" data-scroll-target="#transition-optimization-template">492 Transition Optimization Template</a></li>
  <li><a href="#space-optimization-template" id="toc-space-optimization-template" class="nav-link" data-scroll-target="#space-optimization-template">493 Space Optimization Template</a></li>
  <li><a href="#multi-dimensional-dp-template" id="toc-multi-dimensional-dp-template" class="nav-link" data-scroll-target="#multi-dimensional-dp-template">494 Multi-Dimensional DP Template</a></li>
  <li><a href="#decision-monotonicity" id="toc-decision-monotonicity" class="nav-link" data-scroll-target="#decision-monotonicity">495 Decision Monotonicity</a></li>
  <li><a href="#monge-array-optimization" id="toc-monge-array-optimization" class="nav-link" data-scroll-target="#monge-array-optimization">496 Monge Array Optimization</a></li>
  <li><a href="#divide-conquer-template" id="toc-divide-conquer-template" class="nav-link" data-scroll-target="#divide-conquer-template">497 Divide &amp; Conquer Template</a></li>
  <li><a href="#rerooting-template" id="toc-rerooting-template" class="nav-link" data-scroll-target="#rerooting-template">498 Rerooting Template</a></li>
  <li><a href="#iterative-dp-pattern" id="toc-iterative-dp-pattern" class="nav-link" data-scroll-target="#iterative-dp-pattern">499 Iterative DP Pattern</a></li>
  <li><a href="#memoization-template" id="toc-memoization-template" class="nav-link" data-scroll-target="#memoization-template">500 Memoization Template</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Chapter 5. Dynamic Programming</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="section-41.-dp-basic-and-state-transitions" class="level1">
<h1>Section 41. DP basic and state transitions</h1>
<section id="fibonacci-dp" class="level3">
<h3 class="anchored" data-anchor-id="fibonacci-dp">401 Fibonacci DP</h3>
<p>Fibonacci is the hello-world of dynamic programming, a simple sequence that teaches the power of remembering past results. Instead of recomputing subproblems over and over, we store them. The result? A huge leap from exponential to linear time.</p>
<section id="what-problem-are-we-solving" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving">What Problem Are We Solving?</h4>
<p>The Fibonacci sequence is defined as:</p>
<p><span class="math display">\[
F(0) = 0, \quad F(1) = 1, \quad F(n) = F(n-1) + F(n-2)
\]</span></p>
<p>A naive recursive version recomputes the same values many times. For example, <code>F(5)</code> calls <code>F(4)</code> and <code>F(3)</code>, but <code>F(4)</code> also calls <code>F(3)</code> again, wasteful repetition.</p>
<p>Our goal is to avoid recomputation by caching results. That’s dynamic programming in a nutshell.</p>
</section>
<section id="how-does-it-work-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language">How Does It Work (Plain Language)?</h4>
<p>Think of Fibonacci as a ladder. You can climb to step <code>n</code> only if you know the number of ways to reach <code>n-1</code> and <code>n-2</code>. Instead of recalculating those steps every time, record them once, then reuse.</p>
<p>There are two main flavors of DP:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 32%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Top-Down (Memoization)</td>
<td>Recursion + caching</td>
<td>Store results in an array</td>
</tr>
<tr class="even">
<td>Bottom-Up (Tabulation)</td>
<td>Iteration from base cases</td>
<td>Build array from 0 up</td>
</tr>
</tbody>
</table>
<p>Let’s visualize the state filling:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>F(n-2)</th>
<th>F(n-1)</th>
<th>F(n) = F(n-1) + F(n-2)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>-</td>
<td>-</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>-</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="odd">
<td>4</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="even">
<td>5</td>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr class="odd">
<td>6</td>
<td>3</td>
<td>5</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Each new value reuses two old ones, no redundant work.</p>
</section>
<section id="tiny-code-easy-versions" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up Fibonacci)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter n: "</span><span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> printf<span class="op">(</span><span class="st">"0</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> printf<span class="op">(</span><span class="st">"1</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Fibonacci(</span><span class="sc">%d</span><span class="st">) = </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> n<span class="op">,</span> dp<span class="op">[</span>n<span class="op">]);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Memoized Fibonacci)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="at">@lru_cache</span>(maxsize<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib(n):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib(n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter n: "</span>))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Fibonacci("</span>, n, <span class="st">") ="</span>, fib(n))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters">Why It Matters</h4>
<ul>
<li>Demonstrates state definition: F(n) = F(n-1) + F(n-2)</li>
<li>Introduces overlapping subproblems and optimal substructure</li>
<li>First step toward mastering DP intuition</li>
<li>Reduces time complexity from exponential O(2ⁿ) to linear O(n)</li>
</ul>
<p>You learn that solving once and remembering is better than solving a hundred times.</p>
</section>
<section id="step-by-step-example" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example">Step-by-Step Example</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Calculation</th>
<th>Memo Table (Partial)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Base</td>
<td>F(0)=0, F(1)=1</td>
<td>[0, 1, <em>, </em>, <em>, </em>]</td>
</tr>
<tr class="even">
<td>F(2)</td>
<td>F(1)+F(0)=1</td>
<td>[0, 1, 1, <em>, </em>, _]</td>
</tr>
<tr class="odd">
<td>F(3)</td>
<td>F(2)+F(1)=2</td>
<td>[0, 1, 1, 2, <em>, </em>]</td>
</tr>
<tr class="even">
<td>F(4)</td>
<td>F(3)+F(2)=3</td>
<td>[0, 1, 1, 2, 3, _]</td>
</tr>
<tr class="odd">
<td>F(5)</td>
<td>F(4)+F(3)=5</td>
<td>[0, 1, 1, 2, 3, 5]</td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself">Try It Yourself</h4>
<ol type="1">
<li>Write Fibonacci recursively without memoization. Measure calls.</li>
<li>Add a dictionary or array for memoization, compare speeds.</li>
<li>Convert recursive to iterative (tabulation).</li>
<li>Optimize space: store only two variables instead of full array.</li>
<li>Print the full table of computed values.</li>
</ol>
</section>
<section id="test-cases" class="level4">
<h4 class="anchored" data-anchor-id="test-cases">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>Expected Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>Base case</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>Base case</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>1 + 0</td>
</tr>
<tr class="even">
<td>5</td>
<td>5</td>
<td>Sequence: 0,1,1,2,3,5</td>
</tr>
<tr class="odd">
<td>10</td>
<td>55</td>
<td>Smooth growth check</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity" class="level4">
<h4 class="anchored" data-anchor-id="complexity">Complexity</h4>
<ul>
<li>Time: O(n) for both memoization and tabulation</li>
<li>Space: O(n) for table; O(1) if optimized</li>
</ul>
<p>Fibonacci DP is the simplest proof that remembering pays off, it’s where dynamic programming begins, and efficiency is born.</p>
</section>
</section>
<section id="climbing-stairs" class="level3">
<h3 class="anchored" data-anchor-id="climbing-stairs">402 Climbing Stairs</h3>
<p>The climbing stairs problem is a friendly cousin of Fibonacci, same recurrence, different story. You’re standing at the bottom of a staircase with <code>n</code> steps. You can climb 1 step or 2 steps at a time. How many distinct ways can you reach the top?</p>
<p>This is one of the most intuitive gateways into dynamic programming: define states, relate them recursively, and reuse past computations.</p>
<section id="what-problem-are-we-solving-1" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-1">What Problem Are We Solving?</h4>
<p>We want the number of distinct ways to reach step <code>n</code>.</p>
<p>You can reach step <code>n</code> by:</p>
<ul>
<li>taking 1 step from <code>n-1</code>, or</li>
<li>taking 2 steps from <code>n-2</code>.</li>
</ul>
<p>So the recurrence is: <span class="math display">\[
dp[n] = dp[n-1] + dp[n-2]
\]</span></p>
<p>with base cases: <span class="math display">\[
dp[0] = 1, \quad dp[1] = 1
\]</span></p>
<p>This is structurally identical to Fibonacci, but with a combinatorial interpretation.</p>
</section>
<section id="how-does-it-work-plain-language-1" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-1">How Does It Work (Plain Language)?</h4>
<p>Think of each step as a checkpoint. To reach step <code>n</code>, you must come from either of the two prior checkpoints. If you already know how many ways there are to reach those, just add them.</p>
<p>Let’s illustrate with a table:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 20%">
<col style="width: 67%">
</colgroup>
<thead>
<tr class="header">
<th>Step (n)</th>
<th>Ways to Reach</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>Stay at ground</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>Single step</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>(1+1), (2)</td>
</tr>
<tr class="even">
<td>3</td>
<td>3</td>
<td>(1+1+1), (1+2), (2+1)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>5</td>
<td>(1+1+1+1), (2+1+1), (1+2+1), (1+1+2), (2+2)</td>
</tr>
<tr class="even">
<td>5</td>
<td>8</td>
<td>Previous two sums: 5 = 3+2</td>
</tr>
</tbody>
</table>
<p>Each new value is the sum of the previous two.</p>
</section>
<section id="tiny-code-easy-versions-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-1">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up Climbing Stairs)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of steps: "</span><span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Ways: 1</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Ways to climb </span><span class="sc">%d</span><span class="st"> steps: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> n<span class="op">,</span> dp<span class="op">[</span>n<span class="op">]);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Space Optimized)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter number of steps: "</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="dv">1</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> b, a <span class="op">+</span> b</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Ways to climb"</span>, n, <span class="st">"steps:"</span>, b)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-1" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-1">Why It Matters</h4>
<ul>
<li>Demonstrates state transitions: <code>dp[i]</code> depends on <code>dp[i-1]</code> and <code>dp[i-2]</code></li>
<li>Teaches bottom-up thinking and base case setup</li>
<li>Shows how recurrence translates to counting problems</li>
<li>Connects combinatorics with DP intuition</li>
</ul>
<p>Climbing stairs is a great mental bridge between pure math (recurrence) and applied reasoning (counting paths).</p>
</section>
<section id="step-by-step-example-1" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-1">Step-by-Step Example</h4>
<p>Let’s trace <code>n = 5</code>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>dp[i-2]</th>
<th>dp[i-1]</th>
<th>dp[i] = dp[i-1] + dp[i-2]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>-</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>-</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="odd">
<td>4</td>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr class="even">
<td>5</td>
<td>3</td>
<td>5</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>So, 8 ways to climb 5 steps.</p>
</section>
<section id="try-it-yourself-1" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-1">Try It Yourself</h4>
<ol type="1">
<li>Modify the code to allow 1, 2, or 3 steps at a time.</li>
<li>Print the entire <code>dp</code> table for small <code>n</code>.</li>
<li>Compare recursive vs iterative solutions.</li>
<li>Try to derive a formula, notice the Fibonacci pattern.</li>
<li>What if each step had a cost? Adapt it to Min Cost Climb.</li>
</ol>
</section>
<section id="test-cases-1" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-1">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>Expected Output</th>
<th>Ways</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>Do nothing</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>[1]</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>[1+1], [2]</td>
</tr>
<tr class="even">
<td>3</td>
<td>3</td>
<td>[1+1+1], [1+2], [2+1]</td>
</tr>
<tr class="odd">
<td>4</td>
<td>5</td>
<td>All combinations</td>
</tr>
<tr class="even">
<td>5</td>
<td>8</td>
<td>Grows like Fibonacci</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-1" class="level4">
<h4 class="anchored" data-anchor-id="complexity-1">Complexity</h4>
<ul>
<li>Time: O(n)</li>
<li>Space: O(n), reducible to O(1) with two variables</li>
</ul>
<p>Climbing stairs shows that dynamic programming isn’t just math, it’s about recognizing patterns in movement, growth, and memory.</p>
</section>
</section>
<section id="grid-paths" class="level3">
<h3 class="anchored" data-anchor-id="grid-paths">403 Grid Paths</h3>
<p>The grid path problem is a gentle step into 2D dynamic programming, where states depend on neighbors, not just previous elements. Imagine standing in the top-left corner of a grid, moving only right or down, trying to count how many ways lead to the bottom-right corner.</p>
<p>Each cell’s value is determined by paths reaching it from above or from the left, a perfect metaphor for how DP builds solutions layer by layer.</p>
<section id="what-problem-are-we-solving-2" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-2">What Problem Are We Solving?</h4>
<p>Given an <code>m × n</code> grid, find the number of distinct paths from <code>(0, 0)</code> to <code>(m-1, n-1)</code> when you can move only:</p>
<ul>
<li>Right <code>(x, y+1)</code></li>
<li>Down <code>(x+1, y)</code></li>
</ul>
<p>The recurrence: <span class="math display">\[
dp[i][j] = dp[i-1][j] + dp[i][j-1]
\]</span> with base cases: <span class="math display">\[
dp[0][j] = 1, \quad dp[i][0] = 1
\]</span> (since only one way exists along the first row or column)</p>
</section>
<section id="how-does-it-work-plain-language-2" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-2">How Does It Work (Plain Language)?</h4>
<p>Think of the grid like a city map, every intersection <code>(i, j)</code> can be reached from either the north <code>(i-1, j)</code> or the west <code>(i, j-1)</code>. So total routes = routes from north + routes from west.</p>
<p>Let’s visualize a <code>3×3</code> grid (0-indexed):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Cell (i,j)</th>
<th>Ways</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0)</td>
<td>1</td>
<td>Start</td>
</tr>
<tr class="even">
<td>(0,1)</td>
<td>1</td>
<td>Only from left</td>
</tr>
<tr class="odd">
<td>(0,2)</td>
<td>1</td>
<td>Only from left</td>
</tr>
<tr class="even">
<td>(1,0)</td>
<td>1</td>
<td>Only from top</td>
</tr>
<tr class="odd">
<td>(1,1)</td>
<td>2</td>
<td>(0,1)+(1,0)=2</td>
</tr>
<tr class="even">
<td>(1,2)</td>
<td>3</td>
<td>(0,2)+(1,1)=3</td>
</tr>
<tr class="odd">
<td>(2,0)</td>
<td>1</td>
<td>Only from top</td>
</tr>
<tr class="even">
<td>(2,1)</td>
<td>3</td>
<td>(1,1)+(2,0)=3</td>
</tr>
<tr class="odd">
<td>(2,2)</td>
<td>6</td>
<td>(1,2)+(2,1)=6</td>
</tr>
</tbody>
</table>
<p>So <code>dp[2][2] = 6</code> → 6 distinct paths.</p>
</section>
<section id="tiny-code-easy-versions-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-2">Tiny Code (Easy Versions)</h4>
<p>C (2D DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter rows and cols: "</span><span class="op">);</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>m<span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Unique paths: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Space Optimized)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter rows and cols: "</span>).split())</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique paths:"</span>, dp[<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-2" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-2">Why It Matters</h4>
<ul>
<li>Teaches 2D DP grids</li>
<li>Builds intuition for problems on lattices, matrices, grids</li>
<li>Foundation for min-cost path, maze traversal, robot movement</li>
<li>Encourages space optimization from 2D → 1D</li>
</ul>
<p>From counting paths to optimizing them, this grid is your DP canvas.</p>
</section>
<section id="step-by-step-example-2" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-2">Step-by-Step Example</h4>
<p>For a <code>3×3</code> grid:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>3</td>
<td>6</td>
</tr>
</tbody>
</table>
<p><code>dp[2][2] = 6</code> → six unique routes.</p>
</section>
<section id="try-it-yourself-2" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-2">Try It Yourself</h4>
<ol type="1">
<li>Modify the code to handle obstacles (<code>0</code> = block, <code>1</code> = open).</li>
<li>Print the DP table.</li>
<li>Implement using recursion + memoization.</li>
<li>Add a condition for moving right, down, and diagonal.</li>
<li>Compare with combinatorial formula: <span class="math inline">\(\binom{m+n-2}{m-1}\)</span>.</li>
</ol>
</section>
<section id="test-cases-2" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-2">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Grid Size</th>
<th>Expected Paths</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1×1</td>
<td>1</td>
<td>Only starting cell</td>
</tr>
<tr class="even">
<td>2×2</td>
<td>2</td>
<td>Right→Down, Down→Right</td>
</tr>
<tr class="odd">
<td>3×3</td>
<td>6</td>
<td>Classic case</td>
</tr>
<tr class="even">
<td>3×4</td>
<td>10</td>
<td>Combinatorics check</td>
</tr>
<tr class="odd">
<td>4×4</td>
<td>20</td>
<td>Pascal triangle pattern</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-2" class="level4">
<h4 class="anchored" data-anchor-id="complexity-2">Complexity</h4>
<ul>
<li>Time: O(m×n)</li>
<li>Space: O(m×n), reducible to O(n)</li>
</ul>
<p>Grid Paths reveal the essence of DP, every position depends on simpler ones. From here, you’ll learn to minimize, maximize, and traverse with purpose.</p>
</section>
</section>
<section id="min-cost-path" class="level3">
<h3 class="anchored" data-anchor-id="min-cost-path">404 Min Cost Path</h3>
<p>The Min Cost Path problem is where counting meets optimization. Instead of asking <em>“How many ways can I reach the end?”</em>, we ask <em>“What’s the cheapest way to get there?”</em>. You’re moving across a grid, cell by cell, each with a cost, and your goal is to reach the bottom-right corner while minimizing the total cost.</p>
<p>This is one of the most fundamental path optimization problems in dynamic programming.</p>
<section id="what-problem-are-we-solving-3" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-3">What Problem Are We Solving?</h4>
<p>Given a matrix <code>cost[m][n]</code>, where each cell represents a non-negative cost, find the minimum total cost path from <code>(0, 0)</code> to <code>(m-1, n-1)</code>, moving only right, down, or (optionally) diagonally down-right.</p>
<p>The recurrence: <span class="math display">\[
dp[i][j] = cost[i][j] + \min(dp[i-1][j], dp[i][j-1])
\]</span> If diagonal moves are allowed: <span class="math display">\[
dp[i][j] = cost[i][j] + \min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
\]</span></p>
<p>Base case: <span class="math display">\[
dp[0][0] = cost[0][0]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-3" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-3">How Does It Work (Plain Language)?</h4>
<p>Imagine hiking across a grid of terrain, where each cell has an energy cost. Every move you make adds to your total cost. You always want to choose the path that keeps your running total as small as possible.</p>
<p>The DP table records the minimum cost to reach each cell, building from the top-left to the bottom-right.</p>
<p>Let’s see an example grid:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Cell</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0)</td>
<td>1</td>
</tr>
<tr class="even">
<td>(0,1)</td>
<td>3</td>
</tr>
<tr class="odd">
<td>(0,2)</td>
<td>5</td>
</tr>
<tr class="even">
<td>(1,0)</td>
<td>2</td>
</tr>
<tr class="odd">
<td>(1,1)</td>
<td>1</td>
</tr>
<tr class="even">
<td>(1,2)</td>
<td>2</td>
</tr>
<tr class="odd">
<td>(2,0)</td>
<td>4</td>
</tr>
<tr class="even">
<td>(2,1)</td>
<td>3</td>
</tr>
<tr class="odd">
<td>(2,2)</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>We fill <code>dp[i][j]</code> = cost to reach <code>(i,j)</code>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>4</td>
<td>9</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
<tr class="odd">
<td>2</td>
<td>7</td>
<td>5</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Minimum cost = 5</p>
</section>
<section id="tiny-code-easy-versions-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-3">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter rows and cols: "</span><span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>m<span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cost<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter cost matrix:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>cost<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> cost<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> cost<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> cost<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> cost<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> MIN<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Min cost: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Optional Diagonal Move)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_cost_path(cost):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(cost), <span class="bu">len</span>(cost[<span class="dv">0</span>])</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> cost[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> cost[i][<span class="dv">0</span>]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> cost[<span class="dv">0</span>][j]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> cost[i][j] <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>cost <span class="op">=</span> [</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>],</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>]</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min cost path:"</span>, min_cost_path(cost))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-3" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-3">Why It Matters</h4>
<ul>
<li>Transitions from counting paths to optimizing paths</li>
<li>Introduces minimization recurrence</li>
<li>Basis for many grid problems (e.g.&nbsp;maze solving, image traversal, shortest paths)</li>
<li>Builds intuition for weighted DP</li>
</ul>
<p>This problem is a stepping stone toward Dijkstra’s and Bellman-Ford in graphs.</p>
</section>
<section id="step-by-step-example-3" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-3">Step-by-Step Example</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Cell</th>
<th>From Top</th>
<th>From Left</th>
<th>Min</th>
<th>Total Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0)</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="even">
<td>(0,1)</td>
<td>-</td>
<td>1+3</td>
<td>4</td>
<td>4</td>
</tr>
<tr class="odd">
<td>(1,0)</td>
<td>1+2</td>
<td>-</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="even">
<td>(1,1)</td>
<td>4+1</td>
<td>3+1</td>
<td>4</td>
<td>4</td>
</tr>
<tr class="odd">
<td>(2,2)</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Answer: 5</p>
</section>
<section id="try-it-yourself-3" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-3">Try It Yourself</h4>
<ol type="1">
<li>Add diagonal moves, compare results.</li>
<li>Add blocked cells (infinite cost).</li>
<li>Modify to find maximum cost path.</li>
<li>Reconstruct the path using a <code>parent</code> table.</li>
<li>Use a priority queue (Dijkstra) for non-grid graphs.</li>
</ol>
</section>
<section id="test-cases-3" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-3">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Grid</th>
<th>Expected Min Cost</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[1]]</td>
<td>1</td>
<td>Single cell</td>
</tr>
<tr class="even">
<td>[[1,2],[3,4]]</td>
<td>7</td>
<td>1→2→4</td>
</tr>
<tr class="odd">
<td>[[1,3,5],[2,1,2],[4,3,1]]</td>
<td>5</td>
<td>Optimal route</td>
</tr>
<tr class="even">
<td>[[5,9],[4,2]]</td>
<td>11</td>
<td>5→4→2</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-3" class="level4">
<h4 class="anchored" data-anchor-id="complexity-3">Complexity</h4>
<ul>
<li>Time: O(m×n)</li>
<li>Space: O(m×n), reducible to O(n)</li>
</ul>
<p>Min Cost Path turns the grid into a map of decisions, each cell asks, “What’s the cheapest way to reach me?” and the DP table answers with calm precision.</p>
</section>
</section>
<section id="coin-change-count-ways" class="level3">
<h3 class="anchored" data-anchor-id="coin-change-count-ways">405 Coin Change (Count Ways)</h3>
<p>You have coin denominations and an amount. How many distinct ways can you make that amount if you can use unlimited coins of each type? We count combinations where order does not matter. For example, with coins [1, 2, 5] there are 4 ways to make 5: <code>5</code>, <code>2+2+1</code>, <code>2+1+1+1</code>, <code>1+1+1+1+1</code>.</p>
<section id="what-problem-are-we-solving-4" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-4">What Problem Are We Solving?</h4>
<p>Given an array <code>coins[]</code> and an integer <code>amount</code>, compute the number of combinations to form <code>amount</code> using unlimited copies of each coin.</p>
<p>State and recurrence:</p>
<p><span class="math display">\[
dp[x] = \text{number of ways to make sum } x
\]</span> <span class="math display">\[
dp[0] = 1
\]</span> <span class="math display">\[
\text{for each coin } c:\quad \text{for } x \text{ from } c \text{ to } \text{amount}:\quad dp[x] \mathrel{+=} dp[x - c]
\]</span></p>
<p>Why this order: iterating coins on the outside ensures each combination is counted once. If you loop amounts on the outside and coins inside, you would count permutations.</p>
</section>
<section id="how-does-it-work-plain-language-4" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-4">How Does It Work (Plain Language)?</h4>
<p>Think of building the total from left to right. For each coin value <code>c</code>, you ask: if I must use <code>c</code> at least once, how many ways remain to fill <code>x - c</code>? Add those to the ways already known. Move forward increasing <code>x</code>, and repeat for the next coin. The table fills like a rolling tally.</p>
<p>Example with coins <code>[1, 2, 5]</code> and <code>amount = 5</code>:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>After processing</th>
<th>dp[0]</th>
<th>dp[1]</th>
<th>dp[2]</th>
<th>dp[3]</th>
<th>dp[4]</th>
<th>dp[5]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Init</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>One way to make 0: choose nothing</td>
</tr>
<tr class="even">
<td>Coin 1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Using 1s only</td>
</tr>
<tr class="odd">
<td>Coin 2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>Add ways that end with a 2</td>
</tr>
<tr class="even">
<td>Coin 5</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>Add ways that end with a 5</td>
</tr>
</tbody>
</table>
<p>Answer is <code>dp[5] = 4</code>.</p>
</section>
<section id="tiny-code-easy-versions-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-4">Tiny Code (Easy Versions)</h4>
<p>C (1D DP, combinations)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> amount<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of coin types and amount: "</span><span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>amount<span class="op">);</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> coins<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter coin values: "</span><span class="op">);</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>coins<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Use long long to avoid overflow for large counts</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>amount <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;=</span> amount<span class="op">;</span> x<span class="op">++)</span> dp<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c <span class="op">=</span> coins<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> c<span class="op">;</span> x <span class="op">&lt;=</span> amount<span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>x<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>x <span class="op">-</span> c<span class="op">];</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of ways: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>amount<span class="op">]);</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D DP, combinations)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>coins <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter coin values: "</span>).split()))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>amount <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter amount: "</span>))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (amount <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> coins:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(c, amount <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        dp[x] <span class="op">+=</span> dp[x <span class="op">-</span> c]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of ways:"</span>, dp[amount])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-4" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-4">Why It Matters</h4>
<ul>
<li>Introduces the idea of unbounded knapsack counting</li>
<li>Shows how loop ordering controls whether you count combinations or permutations</li>
<li>Forms a foundation for many counting DPs such as integer partitions and dice sum counts</li>
<li>Encourages space optimization with a single dimension</li>
</ul>
</section>
<section id="step-by-step-example-4" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-4">Step-by-Step Example</h4>
<p>Coins <code>[1, 3, 4]</code>, amount <code>6</code>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Update</th>
<th>dp array snapshot (index is amount)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Init</td>
<td>dp[0]=1</td>
<td>[1, 0, 0, 0, 0, 0, 0]</td>
</tr>
<tr class="even">
<td>Coin 1</td>
<td>fill x=1..6</td>
<td>[1, 1, 1, 1, 1, 1, 1]</td>
</tr>
<tr class="odd">
<td>Coin 3</td>
<td>x=3..6 add dp[x-3]</td>
<td>[1, 1, 1, 2, 2, 2, 3]</td>
</tr>
<tr class="even">
<td>Coin 4</td>
<td>x=4..6 add dp[x-4]</td>
<td>[1, 1, 1, 2, 3, 3, 4]</td>
</tr>
</tbody>
</table>
<p>Answer: <code>dp[6] = 4</code>.</p>
</section>
<section id="try-it-yourself-4" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-4">Try It Yourself</h4>
<ol type="1">
<li>Switch to permutations counting: loop <code>x</code> outside and <code>coins</code> inside. Compare results.</li>
<li>Add a cap per coin type and convert to a bounded version.</li>
<li>Sort coins and print one valid combination using a parent pointer array.</li>
<li>Use modulo arithmetic to avoid overflow: for example <code>10^9+7</code>.</li>
<li>Extend to count ways for every <code>x</code> from <code>0</code> to <code>amount</code> and print the full table.</li>
</ol>
</section>
<section id="test-cases-4" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-4">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Coins</th>
<th>Amount</th>
<th>Expected Ways</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[]</td>
<td>0</td>
<td>1</td>
<td>One empty way</td>
</tr>
<tr class="even">
<td>[]</td>
<td>5</td>
<td>0</td>
<td>No coins cannot form positive sum</td>
</tr>
<tr class="odd">
<td>[1]</td>
<td>4</td>
<td>1</td>
<td>Only 1+1+1+1</td>
</tr>
<tr class="even">
<td>[2]</td>
<td>3</td>
<td>0</td>
<td>Odd cannot be formed</td>
</tr>
<tr class="odd">
<td>[1,2,5]</td>
<td>5</td>
<td>4</td>
<td>Classic example</td>
</tr>
<tr class="even">
<td>[2,3,7]</td>
<td>12</td>
<td>4</td>
<td>Combinations only</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-4" class="level4">
<h4 class="anchored" data-anchor-id="complexity-4">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times \text{amount})\)</span> where <code>n</code> is number of coin types</li>
<li>Space: <span class="math inline">\(O(\text{amount})\)</span> with 1D DP</li>
</ul>
<p>Coin Change counting teaches you how state order and loop order shape the meaning of a DP. Once you feel this pattern, many counting problems become straightforward.</p>
</section>
</section>
<section id="coin-change-min-coins" class="level3">
<h3 class="anchored" data-anchor-id="coin-change-min-coins">406 Coin Change (Min Coins)</h3>
<p>Now we shift from <em>counting ways</em> to <em>finding the fewest coins</em>. Given a target amount and coin denominations, how can we form the sum using the minimum number of coins? This version of coin change turns counting into optimization, a small twist with big impact.</p>
<section id="what-problem-are-we-solving-5" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-5">What Problem Are We Solving?</h4>
<p>Given <code>coins[]</code> and a total <code>amount</code>, find the minimum number of coins needed to make up that amount. If it’s impossible, return -1.</p>
<p>We define: <span class="math display">\[
dp[x] = \text{minimum coins to make sum } x
\]</span> with base case: <span class="math display">\[
dp[0] = 0
\]</span> Recurrence: <span class="math display">\[
dp[x] = \min_{c \in coins,\ c \le x} (dp[x - c] + 1)
\]</span></p>
<p>Each <code>dp[x]</code> asks: “If I take coin <code>c</code>, what’s the best I can do with the remainder?”</p>
</section>
<section id="how-does-it-work-plain-language-5" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-5">How Does It Work (Plain Language)?</h4>
<p>You start from <code>0</code> and climb up, building the cheapest way to reach every amount. For each <code>x</code>, you try all coins <code>c</code> ≤ <code>x</code>. If you can make <code>x-c</code>, add one coin and see if that’s better than your current best.</p>
<p>It’s like choosing the shortest route to a destination using smaller hops.</p>
<p>Example: coins = <code>[1, 3, 4]</code>, amount = 6</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Amount (x)</th>
<th>dp[x]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>Base case</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1×1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>1+1</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>4</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>5</td>
<td>2</td>
<td>1+4</td>
</tr>
<tr class="odd">
<td>6</td>
<td>2</td>
<td>3+3</td>
</tr>
</tbody>
</table>
<p>So minimum = <code>2</code>.</p>
</section>
<section id="tiny-code-easy-versions-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-5">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> amount<span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of coins and amount: "</span><span class="op">);</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>amount<span class="op">);</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> coins<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter coin values: "</span><span class="op">);</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>coins<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>amount <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> x <span class="op">&lt;=</span> amount<span class="op">;</span> x<span class="op">++)</span> dp<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> x <span class="op">&lt;=</span> amount<span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> c <span class="op">=</span> coins<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>x <span class="op">-</span> c <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> MIN<span class="op">(</span>dp<span class="op">[</span>x<span class="op">],</span> dp<span class="op">[</span>x <span class="op">-</span> c<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>amount<span class="op">]</span> <span class="op">==</span> INF<span class="op">)</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Not possible</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Min coins: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>amount<span class="op">]);</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Straightforward DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>coins <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter coin values: "</span>).split()))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>amount <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter amount: "</span>))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [INF] <span class="op">*</span> (amount <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, amount <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> coins:</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">-</span> c <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            dp[x] <span class="op">=</span> <span class="bu">min</span>(dp[x], dp[x <span class="op">-</span> c] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min coins:"</span> <span class="cf">if</span> dp[amount] <span class="op">!=</span> INF <span class="cf">else</span> <span class="st">"Not possible"</span>, end<span class="op">=</span><span class="st">" "</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp[amount] <span class="cf">if</span> dp[amount] <span class="op">!=</span> INF <span class="cf">else</span> <span class="st">""</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-5" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-5">Why It Matters</h4>
<ul>
<li>Core unbounded optimization DP</li>
<li>Shows minimization recurrence with base infinity</li>
<li>Illustrates subproblem dependency: <code>dp[x]</code> depends on smaller sums</li>
<li>Connects directly to Knapsack, shortest path, and DP + BFS hybrids</li>
</ul>
<p>This version teaches you to mix greedy intuition with DP correctness.</p>
</section>
<section id="step-by-step-example-5" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-5">Step-by-Step Example</h4>
<p>Coins <code>[1, 3, 4]</code>, amount = 6</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>x</th>
<th>Try 1</th>
<th>Try 3</th>
<th>Try 4</th>
<th>dp[x]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>dp[0]+1=1</td>
<td>-</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>dp[1]+1=2</td>
<td>-</td>
<td>-</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>dp[2]+1=3</td>
<td>dp[0]+1=1</td>
<td>-</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>dp[3]+1=2</td>
<td>dp[1]+1=2</td>
<td>dp[0]+1=1</td>
<td>1</td>
</tr>
<tr class="even">
<td>5</td>
<td>dp[4]+1=2</td>
<td>dp[2]+1=3</td>
<td>dp[1]+1=2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>6</td>
<td>dp[5]+1=3</td>
<td>dp[3]+1=2</td>
<td>dp[2]+1=3</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Answer = <code>dp[6] = 2</code></p>
</section>
<section id="try-it-yourself-5" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-5">Try It Yourself</h4>
<ol type="1">
<li>Add code to reconstruct the actual coin set.</li>
<li>Compare greedy vs DP for coins <code>[1, 3, 4]</code>, amount = 6.</li>
<li>Modify to handle limited coin supply.</li>
<li>Use recursion + memoization and compare runtime.</li>
<li>Try edge cases: amount smaller than smallest coin.</li>
</ol>
</section>
<section id="test-cases-5" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-5">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Coins</th>
<th>Amount</th>
<th>Expected Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1]</td>
<td>3</td>
<td>3</td>
<td>Only 1s</td>
</tr>
<tr class="even">
<td>[2]</td>
<td>3</td>
<td>-1</td>
<td>Impossible</td>
</tr>
<tr class="odd">
<td>[1,3,4]</td>
<td>6</td>
<td>2</td>
<td>3+3 or 4+1+1</td>
</tr>
<tr class="even">
<td>[1,2,5]</td>
<td>11</td>
<td>3</td>
<td>5+5+1</td>
</tr>
<tr class="odd">
<td>[2,5,10]</td>
<td>0</td>
<td>0</td>
<td>No coins needed</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-5" class="level4">
<h4 class="anchored" data-anchor-id="complexity-5">Complexity</h4>
<ul>
<li>Time: O(n×amount)</li>
<li>Space: O(amount)</li>
</ul>
<p>Coin Change (Min Coins) is a masterclass in thinking minimally, every subproblem is a small decision toward the most efficient path.</p>
</section>
</section>
<section id="knapsack-01" class="level3">
<h3 class="anchored" data-anchor-id="knapsack-01">407 Knapsack 0/1</h3>
<p>The 0/1 Knapsack problem is one of the crown jewels of dynamic programming. You’re given a backpack with limited capacity and a set of items, each with a weight and a value. You must decide which items to pack so that the total value is maximized without exceeding the weight limit. You can either take an item (1) or leave it (0), hence the name.</p>
<section id="what-problem-are-we-solving-6" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-6">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li><code>n</code> items, each with <code>weight[i]</code> and <code>value[i]</code></li>
<li>capacity <code>W</code></li>
</ul>
<p>Find the maximum total value you can carry: <span class="math display">\[
dp[i][w] = \text{max value using first i items with capacity } w
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[i][w] = \max(
dp[i-1][w], \quad
value[i-1] + dp[i-1][w - weight[i-1]]
)
\]</span> if <code>weight[i-1] &lt;= w</code>, else <code>dp[i][w] = dp[i-1][w]</code>.</p>
<p>Base: <span class="math display">\[
dp[0][w] = 0, \quad dp[i][0] = 0
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-6" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-6">How Does It Work (Plain Language)?</h4>
<p>Think of your backpack as a <em>budget of space</em>. Each item is a trade-off:</p>
<ul>
<li>Include it → gain its value but lose capacity</li>
<li>Exclude it → keep capacity for others</li>
</ul>
<p>You make this decision for every item and every possible capacity.</p>
<p>We build a table where each cell <code>dp[i][w]</code> stores the best value you can achieve with the first <code>i</code> items and total capacity <code>w</code>.</p>
<p>Example: Items = [(w=1,v=1), (w=3,v=4), (w=4,v=5), (w=5,v=7)], W = 7</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(i/w\)</span></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="even">
<td>3</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>9</td>
</tr>
<tr class="odd">
<td>4</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>Answer = <code>9</code> (items 2 + 3)</p>
</section>
<section id="tiny-code-easy-versions-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-6">Tiny Code (Easy Versions)</h4>
<p>C (2D DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> W<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of items and capacity: "</span><span class="op">);</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>W<span class="op">);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt<span class="op">[</span>n<span class="op">],</span> val<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter weights: "</span><span class="op">);</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>wt<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter values: "</span><span class="op">);</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> w <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>wt<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&lt;=</span> w<span class="op">)</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>val<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w <span class="op">-</span> wt<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]],</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">]);</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">];</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>W<span class="op">]);</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Space Optimized)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter weights: "</span>).split()))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter values: "</span>).split()))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter capacity: "</span>))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(weights)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(W, weights[i] <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        dp[w] <span class="op">=</span> <span class="bu">max</span>(dp[w], values[i] <span class="op">+</span> dp[w <span class="op">-</span> weights[i]])</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, dp[W])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-6" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-6">Why It Matters</h4>
<ul>
<li>Teaches choice-based DP: include or exclude</li>
<li>Core of resource allocation, subset selection, budgeting problems</li>
<li>Foundation for advanced DPs (subset sum, partition, scheduling)</li>
<li>Introduces 2D → 1D space optimization</li>
</ul>
<p>This problem embodies the essence of decision-making in DP: to take or not to take.</p>
</section>
<section id="step-by-step-example-6" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-6">Step-by-Step Example</h4>
<p>Items: (w,v) = (1,1), (3,4), (4,5), (5,7), W=7</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Capacity</th>
<th>Action</th>
<th>dp</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>i=1</td>
<td>w≥1</td>
<td>Take (1,1)</td>
<td>+1 value</td>
</tr>
<tr class="even">
<td>i=2</td>
<td>w≥3</td>
<td>Take (3,4)</td>
<td>Replace low combos</td>
</tr>
<tr class="odd">
<td>i=3</td>
<td>w≥4</td>
<td>Combine (3+4) = 9</td>
<td>Max found</td>
</tr>
<tr class="even">
<td>i=4</td>
<td>w=7</td>
<td>Can’t beat 9</td>
<td>Done</td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-6" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-6">Try It Yourself</h4>
<ol type="1">
<li>Print selected items using a traceback table.</li>
<li>Compare 2D vs 1D versions.</li>
<li>Add constraint for exact weight match.</li>
<li>Try variants: maximize weight, minimize count, etc.</li>
<li>Modify for fractional weights → Greedy Fractional Knapsack.</li>
</ol>
</section>
<section id="test-cases-6" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-6">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Weights</th>
<th>Values</th>
<th>Capacity</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,2,3]</td>
<td>[10,15,40]</td>
<td>6</td>
<td>65</td>
<td>Take all</td>
</tr>
<tr class="even">
<td>[2,3,4,5]</td>
<td>[3,4,5,6]</td>
<td>5</td>
<td>7</td>
<td>(2,3)</td>
</tr>
<tr class="odd">
<td>[1,3,4,5]</td>
<td>[1,4,5,7]</td>
<td>7</td>
<td>9</td>
<td>(3,4)</td>
</tr>
<tr class="even">
<td>[2,5]</td>
<td>[5,10]</td>
<td>3</td>
<td>5</td>
<td>Only first fits</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-6" class="level4">
<h4 class="anchored" data-anchor-id="complexity-6">Complexity</h4>
<ul>
<li>Time: O(n×W)</li>
<li>Space: O(n×W) → O(W) optimized</li>
</ul>
<p>0/1 Knapsack is the archetype of dynamic programming, it’s all about balancing choices, constraints, and rewards.</p>
</section>
</section>
<section id="knapsack-unbounded" class="level3">
<h3 class="anchored" data-anchor-id="knapsack-unbounded">408 Knapsack Unbounded</h3>
<p>The Unbounded Knapsack problem is the free refill version of knapsack. You still want to maximize value under a capacity limit, but now each item can be chosen multiple times. It’s like packing snacks, you can grab as many as you want, as long as they fit in the bag.</p>
<section id="what-problem-are-we-solving-7" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-7">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li><code>n</code> items with <code>weight[i]</code> and <code>value[i]</code></li>
<li>capacity <code>W</code></li>
<li>Unlimited copies of each item</li>
</ul>
<p>Find the maximum value achievable without exceeding <code>W</code>.</p>
<p>State: <span class="math display">\[
dp[w] = \text{max value for capacity } w
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[w] = \max_{i: weight[i] \le w} (dp[w - weight[i]] + value[i])
\]</span></p>
<p>Base: <span class="math display">\[
dp[0] = 0
\]</span></p>
<p>Notice that this is similar to 0/1 Knapsack, but here we reuse items. The difference lies in the order of iteration.</p>
</section>
<section id="how-does-it-work-plain-language-7" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-7">How Does It Work (Plain Language)?</h4>
<p>Think of capacity <code>w</code> as a budget. For each capacity, you check all items, if one fits, you see what happens when you reuse it. Unlike 0/1 Knapsack (where each item can only be used once per combination), Unbounded Knapsack allows multiple selections.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Capacity (w)</th>
<th>Best Value</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>Empty</td>
</tr>
<tr class="even">
<td>1</td>
<td>15</td>
<td>1 copy of item(1,15)</td>
</tr>
<tr class="odd">
<td>2</td>
<td>30</td>
<td>2 copies</td>
</tr>
<tr class="even">
<td>3</td>
<td>45</td>
<td>3 copies</td>
</tr>
<tr class="odd">
<td>4</td>
<td>60</td>
<td>4 copies</td>
</tr>
</tbody>
</table>
<p>(If all items have same ratio, you’ll fill with the best one.)</p>
<p>Example: Items: <code>(w,v)</code> = (2,4), (3,7), (4,9), W = 7</p>
<ul>
<li>dp[2] = 4</li>
<li>dp[3] = 7</li>
<li>dp[4] = 9</li>
<li>dp[5] = max(dp[3]+4, dp[2]+7) = 11</li>
<li>dp[6] = max(dp[4]+4, dp[3]+7, dp[2]+9) = 14</li>
<li>dp[7] = max(dp[5]+4, dp[4]+7, dp[3]+9) = 16</li>
</ul>
<p>Answer = 16</p>
</section>
<section id="tiny-code-easy-versions-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-7">Tiny Code (Easy Versions)</h4>
<p>C (1D DP, Unbounded)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> W<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of items and capacity: "</span><span class="op">);</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>W<span class="op">);</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt<span class="op">[</span>n<span class="op">],</span> val<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter weights: "</span><span class="op">);</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>wt<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter values: "</span><span class="op">);</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> dp<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> wt<span class="op">[</span>i<span class="op">];</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>w<span class="op">],</span> val<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>w <span class="op">-</span> wt<span class="op">[</span>i<span class="op">]]);</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>W<span class="op">]);</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple Bottom-Up)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter weights: "</span>).split()))</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter values: "</span>).split()))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter capacity: "</span>))</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(weights)):</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(weights[i], W <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        dp[w] <span class="op">=</span> <span class="bu">max</span>(dp[w], values[i] <span class="op">+</span> dp[w <span class="op">-</span> weights[i]])</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, dp[W])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-7" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-7">Why It Matters</h4>
<ul>
<li>Demonstrates unbounded usage of elements</li>
<li>Basis for coin change (min), rod cutting, integer break</li>
<li>Highlights the importance of iteration order in DP</li>
<li>Connects counting (how many ways) to optimization (best way)</li>
</ul>
<p>This is where combinatorial explosion becomes manageable.</p>
</section>
<section id="step-by-step-example-7" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-7">Step-by-Step Example</h4>
<p>Items: (2,4), (3,7), (4,9), W = 7</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>w</th>
<th>dp[w]</th>
<th>Best Choice</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>none fits</td>
</tr>
<tr class="odd">
<td>2</td>
<td>4</td>
<td>(2)</td>
</tr>
<tr class="even">
<td>3</td>
<td>7</td>
<td>(3)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>9</td>
<td>(4)</td>
</tr>
<tr class="even">
<td>5</td>
<td>11</td>
<td>(2+3)</td>
</tr>
<tr class="odd">
<td>6</td>
<td>14</td>
<td>(3+3)</td>
</tr>
<tr class="even">
<td>7</td>
<td>16</td>
<td>(3+4)</td>
</tr>
</tbody>
</table>
<p>Answer: 16</p>
</section>
<section id="try-it-yourself-7" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-7">Try It Yourself</h4>
<ol type="1">
<li>Print the items used (store parent choice).</li>
<li>Compare 0/1 and Unbounded outputs.</li>
<li>Add a limit on copies, hybrid knapsack.</li>
<li>Change objective: minimize number of items.</li>
<li>Apply to Rod Cutting problem.</li>
</ol>
</section>
<section id="test-cases-7" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-7">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Weights</th>
<th>Values</th>
<th>W</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[2,3,4]</td>
<td>[4,7,9]</td>
<td>7</td>
<td>16</td>
<td>3+4</td>
</tr>
<tr class="even">
<td>[1,2,3]</td>
<td>[10,15,40]</td>
<td>6</td>
<td>90</td>
<td>six 1s</td>
</tr>
<tr class="odd">
<td>[5,10,20]</td>
<td>[10,30,50]</td>
<td>20</td>
<td>100</td>
<td>four 5s or one 20</td>
</tr>
<tr class="even">
<td>[2,5]</td>
<td>[5,10]</td>
<td>3</td>
<td>5</td>
<td>only one 2</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-7" class="level4">
<h4 class="anchored" data-anchor-id="complexity-7">Complexity</h4>
<ul>
<li>Time: O(n×W)</li>
<li>Space: O(W)</li>
</ul>
<p>Unbounded Knapsack is your first taste of infinite choice under constraint, a powerful idea that flows through many DP designs.</p>
</section>
</section>
<section id="longest-increasing-subsequence-dp" class="level3">
<h3 class="anchored" data-anchor-id="longest-increasing-subsequence-dp">409 Longest Increasing Subsequence (DP)</h3>
<p>The Longest Increasing Subsequence (LIS) problem is a classic, it’s all about finding the longest chain of numbers that strictly increases. You don’t have to keep them consecutive, just in order. This is a foundational DP problem that blends state definition, transitions, and comparisons beautifully.</p>
<section id="what-problem-are-we-solving-8" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-8">What Problem Are We Solving?</h4>
<p>Given an array <code>arr[]</code> of length <code>n</code>, find the length of the longest increasing subsequence, a sequence of indices <code>i₁ &lt; i₂ &lt; ... &lt; iₖ</code> such that: <span class="math display">\[
arr[i₁] &lt; arr[i₂] &lt; \cdots &lt; arr[iₖ]
\]</span></p>
<p>We want maximum length.</p>
<p>Recurrence: <span class="math display">\[
dp[i] = 1 + \max(dp[j]) \quad \text{for all } j &lt; i \text{ where } arr[j] &lt; arr[i]
\]</span> Otherwise: <span class="math display">\[
dp[i] = 1
\]</span></p>
<p>Base case: <span class="math display">\[
dp[0] = 1
\]</span></p>
<p>Answer: <span class="math display">\[
\max_i dp[i]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-8" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-8">How Does It Work (Plain Language)?</h4>
<p>You look at each number and ask: <em>“Can I extend an increasing sequence ending before me?”</em> If yes, take the longest one that fits and extend it by one.</p>
<p>It’s like building towers, each number stacks on top of a smaller one, extending the tallest possible stack.</p>
<p>Example: <code>arr = [10, 22, 9, 33, 21, 50, 41, 60]</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>arr[i]</th>
<th>dp[i]</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>10</td>
<td>1</td>
<td>start</td>
</tr>
<tr class="even">
<td>1</td>
<td>22</td>
<td>2</td>
<td>10→22</td>
</tr>
<tr class="odd">
<td>2</td>
<td>9</td>
<td>1</td>
<td>no smaller before</td>
</tr>
<tr class="even">
<td>3</td>
<td>33</td>
<td>3</td>
<td>10→22→33</td>
</tr>
<tr class="odd">
<td>4</td>
<td>21</td>
<td>2</td>
<td>10→21</td>
</tr>
<tr class="even">
<td>5</td>
<td>50</td>
<td>4</td>
<td>10→22→33→50</td>
</tr>
<tr class="odd">
<td>6</td>
<td>41</td>
<td>4</td>
<td>10→22→33→41</td>
</tr>
<tr class="even">
<td>7</td>
<td>60</td>
<td>5</td>
<td>10→22→33→50→60</td>
</tr>
</tbody>
</table>
<p>Answer = 5</p>
</section>
<section id="tiny-code-easy-versions-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-8">Tiny Code (Easy Versions)</h4>
<p>C (O(n²) DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of elements: "</span><span class="op">);</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter array: "</span><span class="op">);</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> MAX<span class="op">(</span>ans<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Length of LIS: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter array: "</span>).split()))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[j] <span class="op">&lt;</span> arr[i]:</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Length of LIS:"</span>, <span class="bu">max</span>(dp))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-8" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-8">Why It Matters</h4>
<ul>
<li>Core sequence DP, compares pairs, tracks best chain</li>
<li>Demonstrates O(n²) DP thinking</li>
<li>Foundation for LCS, Edit Distance, Patience Sorting (O(n log n))</li>
<li>Applied in stock analysis, genome sequences, and chain problems</li>
</ul>
<p>This problem teaches “look back and extend”, a key DP instinct.</p>
</section>
<section id="step-by-step-example-8" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-8">Step-by-Step Example</h4>
<p><code>arr = [3, 10, 2, 1, 20]</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>arr[i]</th>
<th>dp[i]</th>
<th>Best Chain</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>3</td>
<td>1</td>
<td>[3]</td>
</tr>
<tr class="even">
<td>1</td>
<td>10</td>
<td>2</td>
<td>[3,10]</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>1</td>
<td>[2]</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>1</td>
<td>[1]</td>
</tr>
<tr class="odd">
<td>4</td>
<td>20</td>
<td>3</td>
<td>[3,10,20]</td>
</tr>
</tbody>
</table>
<p>Answer = 3</p>
</section>
<section id="try-it-yourself-8" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-8">Try It Yourself</h4>
<ol type="1">
<li>Print the actual LIS using a <code>parent</code> array.</li>
<li>Convert to non-decreasing LIS (≤ instead of &lt;).</li>
<li>Compare with O(n log n) binary search version.</li>
<li>Adapt for longest decreasing subsequence.</li>
<li>Apply to 2D pairs (Russian Doll Envelopes).</li>
</ol>
</section>
<section id="test-cases-8" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-8">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,2,3,4,5]</td>
<td>5</td>
<td>Already increasing</td>
</tr>
<tr class="even">
<td>[5,4,3,2,1]</td>
<td>1</td>
<td>Only one element</td>
</tr>
<tr class="odd">
<td>[3,10,2,1,20]</td>
<td>3</td>
<td>[3,10,20]</td>
</tr>
<tr class="even">
<td>[10,22,9,33,21,50,41,60]</td>
<td>5</td>
<td>Classic example</td>
</tr>
<tr class="odd">
<td>[2,2,2,2]</td>
<td>1</td>
<td>Strictly increasing only</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-8" class="level4">
<h4 class="anchored" data-anchor-id="complexity-8">Complexity</h4>
<ul>
<li>Time: O(n²)</li>
<li>Space: O(n)</li>
</ul>
<p>LIS is the melody of DP, every element listens to its predecessors, finds harmony, and extends the tune to its fullest length.</p>
</section>
</section>
<section id="edit-distance-levenshtein" class="level3">
<h3 class="anchored" data-anchor-id="edit-distance-levenshtein">410 Edit Distance (Levenshtein)</h3>
<p>The Edit Distance (or Levenshtein distance) problem measures how different two strings are by counting the minimum number of operations needed to transform one into the other. The allowed operations are:</p>
<ul>
<li>Insert</li>
<li>Delete</li>
<li>Replace</li>
</ul>
<p>It’s the foundation of spell checkers, DNA sequence alignment, and fuzzy search, anywhere we need to measure “how close” two sequences are.</p>
<section id="what-problem-are-we-solving-9" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-9">What Problem Are We Solving?</h4>
<p>Given two strings <code>A</code> and <code>B</code>, find the minimum number of operations required to convert <code>A</code> → <code>B</code>.</p>
<p>Let:</p>
<ul>
<li><code>A</code> has length <code>m</code></li>
<li><code>B</code> has length <code>n</code></li>
</ul>
<p>State: <span class="math display">\[
dp[i][j] = \text{min edits to convert } A[0..i-1] \text{ to } B[0..j-1]
\]</span></p>
<p>Recurrence:</p>
<ol type="1">
<li>If <code>A[i-1] == B[j-1]</code>: <span class="math display">\[
dp[i][j] = dp[i-1][j-1]
\]</span></li>
<li>Else, take min of the three operations: <span class="math display">\[
dp[i][j] = 1 + \min(
dp[i-1][j],     \text{ (delete)}
dp[i][j-1],     \text{ (insert)}
dp[i-1][j-1]    \text{ (replace)}
)
\]</span></li>
</ol>
<p>Base: <span class="math display">\[
dp[0][j] = j,\quad dp[i][0] = i
\]</span> (empty string conversions)</p>
</section>
<section id="how-does-it-work-plain-language-9" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-9">How Does It Work (Plain Language)?</h4>
<p>Imagine editing a word character by character. At each step, compare the current letters:</p>
<ul>
<li>If they match → no cost, move diagonally.</li>
<li>If they differ → choose the cheapest fix (insert, delete, replace).</li>
</ul>
<p>The DP table builds all prefix transformations, from small strings to full ones.</p>
<p>Example: <code>A = "kitten"</code>, <code>B = "sitting"</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Operation</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Replace k → s</td>
<td>sitten</td>
<td></td>
</tr>
<tr class="even">
<td>Replace e → i</td>
<td>sittin</td>
<td></td>
</tr>
<tr class="odd">
<td>Insert g</td>
<td>sitting</td>
<td></td>
</tr>
</tbody>
</table>
<p>Answer = 3</p>
</section>
<section id="tiny-code-easy-versions-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-9">Tiny Code (Easy Versions)</h4>
<p>C (2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN3</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">,</span><span class="pp">c</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">&lt;</span><span class="pp">b</span><span class="op">?</span><span class="pp">a</span><span class="op">:</span><span class="pp">b</span><span class="op">)&lt;</span><span class="pp">c</span><span class="op">?(</span><span class="pp">a</span><span class="op">&lt;</span><span class="pp">b</span><span class="op">?</span><span class="pp">a</span><span class="op">:</span><span class="pp">b</span><span class="op">):</span><span class="pp">c</span><span class="op">)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> A<span class="op">[</span><span class="dv">100</span><span class="op">],</span> B<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter string A: "</span><span class="op">);</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> A<span class="op">);</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter string B: "</span><span class="op">);</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> B<span class="op">);</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>A<span class="op">[</span>m<span class="op">])</span> m<span class="op">++;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>B<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> MIN3<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Edit distance: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter string A: "</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter string B: "</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">len</span>(A), <span class="bu">len</span>(B)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>): dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>): dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> A[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> B[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edit distance:"</span>, dp[m][n])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-9" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-9">Why It Matters</h4>
<ul>
<li>Illustrates 2D DP on strings</li>
<li>Introduces transformation problems</li>
<li>Forms the backbone of spell correction, DNA alignment, diff tools</li>
<li>Beautifully captures state = prefix lengths pattern</li>
</ul>
<p>Edit Distance is the dictionary definition of “step-by-step transformation.”</p>
</section>
<section id="step-by-step-example-9" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-9">Step-by-Step Example</h4>
<p><code>A = "intention"</code>, <code>B = "execution"</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(A/B\)</span></th>
<th>“”</th>
<th>e</th>
<th>x</th>
<th>e</th>
<th>c</th>
<th>u</th>
<th>t</th>
<th>i</th>
<th>o</th>
<th>n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“”</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr class="even">
<td>i</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr class="odd">
<td>n</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr class="even">
<td>t</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr class="odd">
<td>e</td>
<td>4</td>
<td>3</td>
<td>4</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr class="even">
<td>n</td>
<td>5</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr class="odd">
<td>t</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr class="even">
<td>i</td>
<td>7</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr class="odd">
<td>o</td>
<td>8</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>6</td>
</tr>
<tr class="even">
<td>n</td>
<td>9</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Answer = 5 edits</p>
</section>
<section id="try-it-yourself-9" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-9">Try It Yourself</h4>
<ol type="1">
<li>Print actual edit sequence (backtrack).</li>
<li>Add costs: assign different weights for insert/delete/replace.</li>
<li>Try case-insensitive variant.</li>
<li>Compare with Longest Common Subsequence.</li>
<li>Implement recursive + memoized version.</li>
</ol>
</section>
<section id="test-cases-9" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-9">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“kitten”</td>
<td>“sitting”</td>
<td>3</td>
<td>classic</td>
</tr>
<tr class="even">
<td>“horse”</td>
<td>“ros”</td>
<td>3</td>
<td>leetcode</td>
</tr>
<tr class="odd">
<td>“flaw”</td>
<td>“lawn”</td>
<td>2</td>
<td>replace + insert</td>
</tr>
<tr class="even">
<td>“abc”</td>
<td>“yabd”</td>
<td>2</td>
<td>insert + replace</td>
</tr>
<tr class="odd">
<td>“”</td>
<td>“abc”</td>
<td>3</td>
<td>all inserts</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-9" class="level4">
<h4 class="anchored" data-anchor-id="complexity-9">Complexity</h4>
<ul>
<li>Time: O(m×n)</li>
<li>Space: O(m×n), reducible to O(n)</li>
</ul>
<p>Edit Distance teaches precision in DP: every cell means <em>“smallest change to fix this prefix”</em>. It’s the language of correction, one letter at a time.</p>
</section>
</section>
</section>
<section id="section-42.-classic-problems" class="level1">
<h1>Section 42. Classic Problems</h1>
<section id="knapsack" class="level3">
<h3 class="anchored" data-anchor-id="knapsack">411 0/1 Knapsack</h3>
<p>The 0/1 Knapsack is one of the most iconic problems in dynamic programming. It’s the perfect example of decision-making under constraints, each item can either be taken or left, but never split or repeated. The goal is to maximize total value within a fixed capacity.</p>
<p>This version focuses on understanding choice, capacity, and optimal substructure, the three pillars of DP.</p>
<section id="what-problem-are-we-solving-10" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-10">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li><code>n</code> items, each with weight <code>w[i]</code> and value <code>v[i]</code></li>
<li>a knapsack of capacity <code>W</code></li>
</ul>
<p>We want: <span class="math display">\[
\text{maximize total value} \quad \sum v[i]
\]</span> subject to <span class="math display">\[
\sum w[i] \le W
\]</span> and each item can be used at most once.</p>
<p>State definition: <span class="math display">\[
dp[i][w] = \text{max value using first } i \text{ items with capacity } w
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[i][w] =
\begin{cases}
dp[i-1][w], &amp; \text{if } w_{i-1} &gt; w,\\
\max\big(dp[i-1][w],\ dp[i-1][w - w_{i-1}] + v_{i-1}\big), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Base case: <span class="math display">\[
dp[0][w] = 0, \quad dp[i][0] = 0
\]</span></p>
<p>Answer: <span class="math display">\[
dp[n][W]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-10" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-10">How Does It Work (Plain Language)?</h4>
<p>At every step, you ask: “Should I take this item or leave it?” If it fits, compare:</p>
<ul>
<li>Not taking it → stick with previous best (<code>dp[i-1][w]</code>)</li>
<li>Taking it → add its value plus best value for remaining capacity (<code>dp[i-1][w - weight[i]] + value[i]</code>)</li>
</ul>
<p>The DP table stores the best possible value at every sub-capacity for each subset of items.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>Weight</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="even">
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>Capacity = 7 → Answer = 9 (items 2 + 3)</p>
</section>
<section id="tiny-code-easy-versions-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-10">Tiny Code (Easy Versions)</h4>
<p>C (2D DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> W<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of items and capacity: "</span><span class="op">);</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>W<span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt<span class="op">[</span>n<span class="op">],</span> val<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter weights: "</span><span class="op">);</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>wt<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter values: "</span><span class="op">);</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> w <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>wt<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&lt;=</span> w<span class="op">)</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>val<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w <span class="op">-</span> wt<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]],</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">]);</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">];</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>W<span class="op">]);</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D Optimized)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter weights: "</span>).split()))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter values: "</span>).split()))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter capacity: "</span>))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(weights)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(W, weights[i] <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        dp[w] <span class="op">=</span> <span class="bu">max</span>(dp[w], dp[w <span class="op">-</span> weights[i]] <span class="op">+</span> values[i])</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, dp[W])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-10" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-10">Why It Matters</h4>
<ul>
<li>Introduces decision-based DP: take or skip</li>
<li>Builds on recurrence intuition (state transition)</li>
<li>Forms basis for subset sum, equal partition, and resource allocation</li>
<li>Teaches capacity-dependent states</li>
</ul>
<p>It’s the first time you feel the <em>tension</em> between greedy desire and constrained reality, a DP classic.</p>
</section>
<section id="step-by-step-example-10" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-10">Step-by-Step Example</h4>
<p>Items: (w,v) = (1,1), (3,4), (4,5), (5,7), W = 7</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(i/w\)</span></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="even">
<td>3</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>9</td>
</tr>
<tr class="odd">
<td>4</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>Answer = 9</p>
</section>
<section id="try-it-yourself-10" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-10">Try It Yourself</h4>
<ol type="1">
<li>Add code to reconstruct chosen items.</li>
<li>Compare 2D vs 1D DP outputs.</li>
<li>Modify to minimize weight for a given value.</li>
<li>Visualize table transitions for small inputs.</li>
<li>Experiment with large weights, test performance.</li>
</ol>
</section>
<section id="test-cases-10" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-10">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Weights</th>
<th>Values</th>
<th>W</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,2,3]</td>
<td>[10,15,40]</td>
<td>6</td>
<td>65</td>
<td>all items fit</td>
</tr>
<tr class="even">
<td>[2,3,4,5]</td>
<td>[3,4,5,6]</td>
<td>5</td>
<td>7</td>
<td>(2,3)</td>
</tr>
<tr class="odd">
<td>[1,3,4,5]</td>
<td>[1,4,5,7]</td>
<td>7</td>
<td>9</td>
<td>(3,4)</td>
</tr>
<tr class="even">
<td>[2,5]</td>
<td>[5,10]</td>
<td>3</td>
<td>5</td>
<td>only first fits</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-10" class="level4">
<h4 class="anchored" data-anchor-id="complexity-10">Complexity</h4>
<ul>
<li>Time: O(n×W)</li>
<li>Space: O(n×W) → O(W) (optimized)</li>
</ul>
<p>0/1 Knapsack is the heartbeat of DP, every decision echoes the fundamental trade-off: <em>to take or not to take</em>.</p>
</section>
</section>
<section id="subset-sum" class="level3">
<h3 class="anchored" data-anchor-id="subset-sum">412 Subset Sum</h3>
<p>The Subset Sum problem is a fundamental example of boolean dynamic programming. Instead of maximizing or minimizing, we simply ask “Is it possible?”, can we pick a subset of numbers that adds up to a given target?</p>
<p>This problem forms the foundation for many combinatorial DP problems such as Equal Partition, Count of Subsets, Target Sum, and even Knapsack itself.</p>
<section id="what-problem-are-we-solving-11" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-11">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>An array <code>arr[]</code> of <code>n</code> positive integers</li>
<li>A target sum <code>S</code></li>
</ul>
<p>Determine whether there exists a subset of <code>arr[]</code> whose elements sum to exactly <code>S</code>.</p>
<p>We define: <span class="math display">\[
dp[i][s] = \text{true if subset of first } i \text{ elements can form sum } s
\]</span></p>
<p>Recurrence:</p>
<ul>
<li>If <code>arr[i-1] &gt; s</code>: [ dp[i][s] = dp[i-1][s]]</li>
<li>Else: [ dp[i][s] = dp[i-1][s] dp[i-1][s - arr[i-1]]]</li>
</ul>
<p>Base cases: <span class="math display">\[
dp[0][0] = \text{true}, \quad dp[0][s&gt;0] = \text{false}
\]</span></p>
<p>Answer: <span class="math display">\[
dp[n][S]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-11" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-11">How Does It Work (Plain Language)?</h4>
<p>Think of it as a yes/no table:</p>
<ul>
<li>Rows → items</li>
<li>Columns → sums</li>
</ul>
<p>Each cell asks: <em>“Can I form sum <code>s</code> using the first <code>i</code> items?”</em> The answer comes from either skipping or including the current item.</p>
<p>Example: <code>arr = [2, 3, 7, 8, 10]</code>, <code>S = 11</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(i/Sum\)</span></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="even">
<td>1 (2)</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="odd">
<td>2 (3)</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="even">
<td>3 (7)</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
</tr>
</tbody>
</table>
<p><code>dp[5][11] = True</code> → <code>[3, 8]</code> is one valid subset.</p>
</section>
<section id="tiny-code-easy-versions-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-11">Tiny Code (Easy Versions)</h4>
<p>C (2D Boolean Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> S<span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of elements and target sum: "</span><span class="op">);</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>S<span class="op">);</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter elements: "</span><span class="op">);</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>S <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> s <span class="op">&lt;=</span> S<span class="op">;</span> s<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> s <span class="op">&lt;=</span> S<span class="op">;</span> s<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> s<span class="op">)</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s<span class="op">];</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s <span class="op">-</span> arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]];</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Subset sum </span><span class="sc">%s</span><span class="st"> possible</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>S<span class="op">]</span> <span class="op">?</span> <span class="st">"is"</span> <span class="op">:</span> <span class="st">"is not"</span><span class="op">);</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D Optimization)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter elements: "</span>).split()))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter target sum: "</span>))</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (S <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(S, num <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        dp[s] <span class="op">=</span> dp[s] <span class="kw">or</span> dp[s <span class="op">-</span> num]</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Subset sum is possible"</span> <span class="cf">if</span> dp[S] <span class="cf">else</span> <span class="st">"Not possible"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-11" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-11">Why It Matters</h4>
<ul>
<li>Introduces boolean DP (true/false states)</li>
<li>Foundation for Equal Partition, Target Sum, and Count Subsets</li>
<li>Closely related to 0/1 Knapsack but without values</li>
<li>Perfect exercise for learning state dependency</li>
</ul>
<p>This problem captures the logic of feasibility: <em>“If I could make <code>s - arr[i]</code> before, then I can make <code>s</code> now.”</em></p>
</section>
<section id="step-by-step-example-11" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-11">Step-by-Step Example</h4>
<p>Array = [2, 3, 7, 8, 10], S = 11</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Consider</th>
<th>New True Sums</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>[0,2]</td>
<td>{2}</td>
</tr>
<tr class="even">
<td>3</td>
<td>[0,2,3,5]</td>
<td>{3,5}</td>
</tr>
<tr class="odd">
<td>7</td>
<td>[0,2,3,5,7,9,10,12]</td>
<td>{7,9,10}</td>
</tr>
<tr class="even">
<td>8</td>
<td>[0,2,3,5,7,8,9,10,11,12,13,15]</td>
<td>{11}</td>
</tr>
</tbody>
</table>
<p>Found 11.</p>
</section>
<section id="try-it-yourself-11" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-11">Try It Yourself</h4>
<ol type="1">
<li>Print one valid subset using a parent pointer table.</li>
<li>Count the total number of valid subsets (convert to count DP).</li>
<li>Try with duplicates, does it change anything?</li>
<li>Modify to check if sum is divisible by <code>k</code>.</li>
<li>Add negative numbers (use offset shifting).</li>
</ol>
</section>
<section id="test-cases-11" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-11">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>S</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[2,3,7,8,10]</td>
<td>11</td>
<td>True</td>
<td>3+8</td>
</tr>
<tr class="even">
<td>[1,2,3]</td>
<td>5</td>
<td>True</td>
<td>2+3</td>
</tr>
<tr class="odd">
<td>[1,2,5]</td>
<td>4</td>
<td>False</td>
<td>no subset</td>
</tr>
<tr class="even">
<td>[1,1,1,1]</td>
<td>2</td>
<td>True</td>
<td>1+1</td>
</tr>
<tr class="odd">
<td>[5,2,6,4]</td>
<td>13</td>
<td>True</td>
<td>5+4+4</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-11" class="level4">
<h4 class="anchored" data-anchor-id="complexity-11">Complexity</h4>
<ul>
<li>Time: O(n×S)</li>
<li>Space: O(n×S) → O(S) (optimized)</li>
</ul>
<p>Subset Sum is a cornerstone of DP, a yes/no version of Knapsack that teaches how logic flows through states, one sum at a time.</p>
</section>
</section>
<section id="equal-partition" class="level3">
<h3 class="anchored" data-anchor-id="equal-partition">413 Equal Partition</h3>
<p>The Equal Partition problem asks a natural question: can we divide a set of numbers into two subsets with equal sum? It’s a direct application of Subset Sum, reframed as a partitioning challenge. If the total sum is even, we check if there’s a subset that sums to half, that ensures the other subset sums to the same.</p>
<section id="what-problem-are-we-solving-12" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-12">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>An array <code>arr[]</code> of <code>n</code> positive integers</li>
</ul>
<p>Determine whether it can be partitioned into two subsets whose sums are equal.</p>
<p>Let total sum be <code>S</code>. We need to check:</p>
<ul>
<li>If <code>S</code> is odd → impossible</li>
<li>If <code>S</code> is even → check if Subset Sum to <code>S/2</code> is possible</li>
</ul>
<p>So the problem reduces to:</p>
<p><span class="math display">\[
\text{Is there a subset of } arr[] \text{ with sum } = S/2?
\]</span></p>
<p>We use the same recurrence from Subset Sum:</p>
<p><span class="math display">\[
dp[i][s] = dp[i-1][s] \lor dp[i-1][s - arr[i-1]]
\]</span></p>
<p>Base: <span class="math display">\[
dp[0][0] = \text{true}
\]</span></p>
<p>Answer: <span class="math display">\[
dp[n][S/2]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-12" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-12">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li>Compute total sum <code>S</code>.</li>
<li>If <code>S</code> is odd → cannot split evenly.</li>
<li>Otherwise, use Subset Sum DP to check if we can reach <code>S/2</code>. If yes, one subset forms <code>S/2</code>, and the remaining numbers automatically form the other half.</li>
</ol>
<p>Example: <code>arr = [1, 5, 11, 5]</code></p>
<ul>
<li>Sum = 22</li>
<li>Target = 11</li>
<li>Can we make 11? Yes → <code>[11]</code> and <code>[1,5,5]</code> are two halves.</li>
</ul>
</section>
<section id="tiny-code-easy-versions-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-12">Tiny Code (Easy Versions)</h4>
<p>C (2D DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of elements: "</span><span class="op">);</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter elements: "</span><span class="op">);</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> sum <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>sum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Cannot partition into equal sum subsets</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> target <span class="op">=</span> sum <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> s <span class="op">&lt;=</span> target<span class="op">;</span> s<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> s <span class="op">&lt;=</span> target<span class="op">;</span> s<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> s<span class="op">)</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s<span class="op">];</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s <span class="op">-</span> arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]];</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Equal partition </span><span class="sc">%s</span><span class="st"> possible</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>target<span class="op">]</span> <span class="op">?</span> <span class="st">"is"</span> <span class="op">:</span> <span class="st">"is not"</span><span class="op">);</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D Space Optimization)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter elements: "</span>).split()))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">sum</span>(arr)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> S <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Cannot partition into equal subsets"</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> S <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (target <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(target, num <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>            dp[s] <span class="op">=</span> dp[s] <span class="kw">or</span> dp[s <span class="op">-</span> num]</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Equal partition is possible"</span> <span class="cf">if</span> dp[target] <span class="cf">else</span> <span class="st">"Not possible"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-12" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-12">Why It Matters</h4>
<ul>
<li>Builds directly on Subset Sum</li>
<li>Demonstrates problem reduction in DP</li>
<li>Useful for balanced partitioning, load balancing, and fair division</li>
<li>Teaches thinking in terms of state feasibility</li>
</ul>
<p>Equal Partition shows how yes/no DPs can solve seemingly complex questions with simple logic.</p>
</section>
<section id="step-by-step-example-12" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-12">Step-by-Step Example</h4>
<p><code>arr = [1, 5, 11, 5]</code></p>
<ol type="1">
<li><code>S = 22</code> → <code>S/2 = 11</code></li>
<li>Use Subset Sum DP to check if <code>11</code> can be formed</li>
<li>True → subsets <code>[11]</code> and <code>[1,5,5]</code></li>
</ol>
<p>Another case: <code>arr = [1, 2, 3, 5]</code></p>
<ul>
<li><code>S = 11</code> (odd) → cannot partition.</li>
</ul>
</section>
<section id="try-it-yourself-12" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-12">Try It Yourself</h4>
<ol type="1">
<li>Print the actual subsets (traceback table).</li>
<li>Try arrays with duplicates.</li>
<li>Compare with total sum odd case.</li>
<li>Add constraint: must use at least one element in each subset.</li>
<li>Visualize dp table for small arrays.</li>
</ol>
</section>
<section id="test-cases-12" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-12">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>Sum</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,5,11,5]</td>
<td>22</td>
<td>True</td>
<td>11 and 11</td>
</tr>
<tr class="even">
<td>[1,2,3,5]</td>
<td>11</td>
<td>False</td>
<td>odd total</td>
</tr>
<tr class="odd">
<td>[3,3,3,3]</td>
<td>12</td>
<td>True</td>
<td>split evenly</td>
</tr>
<tr class="even">
<td>[2,2,2,2,2]</td>
<td>10</td>
<td>True</td>
<td>5+5</td>
</tr>
<tr class="odd">
<td>[1,1,3,4,7]</td>
<td>16</td>
<td>True</td>
<td>8+8</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-12" class="level4">
<h4 class="anchored" data-anchor-id="complexity-12">Complexity</h4>
<ul>
<li>Time: O(n × S/2)</li>
<li>Space: O(S/2) (optimized)</li>
</ul>
<p>Equal Partition is the first real taste of reduction in dynamic programming, take a bigger problem, express it as Subset Sum, and solve with the same machinery.</p>
</section>
</section>
<section id="count-of-subsets-with-sum" class="level3">
<h3 class="anchored" data-anchor-id="count-of-subsets-with-sum">414 Count of Subsets with Sum</h3>
<p>The Count of Subsets with Sum problem extends the Subset Sum idea. Instead of asking <em>“Is it possible to form this sum?”</em>, we ask <em>“In how many ways can we form it?”</em>. This transforms a boolean DP into a counting DP, where each state accumulates the number of combinations that yield a given sum.</p>
<section id="what-problem-are-we-solving-13" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-13">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>An array <code>arr[]</code> of <code>n</code> positive integers</li>
<li>A target sum <code>S</code></li>
</ul>
<p>We want the number of subsets whose elements sum exactly to <code>S</code>.</p>
<p>We define the state:</p>
<p><span class="math display">\[
dp[i][s] = \text{number of ways to form sum } s \text{ using first } i \text{ elements}
\]</span></p>
<p>The recurrence:</p>
<p><span class="math display">\[
dp[i][s] =
\begin{cases}
dp[i-1][s], &amp; \text{if } arr[i-1] &gt; s,\\
dp[i-1][s] + dp[i-1][s - arr[i-1]], &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Base cases:</p>
<p><span class="math display">\[
dp[0][0] = 1, \quad dp[0][s&gt;0] = 0
\]</span></p>
<p>Final answer:</p>
<p><span class="math display">\[
dp[n][S]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-13" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-13">How Does It Work (Plain Language)</h4>
<p>Each element gives two paths: include or exclude. If you include it, you count all subsets that formed <code>s - arr[i-1]</code> before. If you exclude it, you inherit all subsets that already formed <code>s</code>. So each cell accumulates total combinations from both branches.</p>
<p>Example: <code>arr = [2, 3, 5, 6, 8, 10]</code>, <code>S = 10</code></p>
<p>Ways to form 10:</p>
<ul>
<li><code>{10}</code></li>
<li><code>{2, 8}</code></li>
<li><code>{2, 3, 5}</code></li>
</ul>
<p>Answer = 3</p>
</section>
<section id="tiny-code-easy-versions-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-13">Tiny Code (Easy Versions)</h4>
<p>C (2D DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> S<span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of elements and target sum: "</span><span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>S<span class="op">);</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter elements: "</span><span class="op">);</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>S <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> s <span class="op">&lt;=</span> S<span class="op">;</span> s<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> s <span class="op">&lt;=</span> S<span class="op">;</span> s<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> s<span class="op">)</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s<span class="op">];</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>s<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>s <span class="op">-</span> arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]];</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of subsets: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>S<span class="op">]);</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D Space Optimized)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter elements: "</span>).split()))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter target sum: "</span>))</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (S <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(S, num <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        dp[s] <span class="op">+=</span> dp[s <span class="op">-</span> num]</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of subsets:"</span>, dp[S])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-13" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-13">Why It Matters</h4>
<ul>
<li>Extends Subset Sum from feasibility to counting</li>
<li>Foundation for Target Sum, Equal Partition Count, and Combinatorics DP</li>
<li>Shows how a small change in recurrence changes meaning</li>
<li>Demonstrates accumulation instead of boolean OR</li>
</ul>
<p>This is where DP transitions from <em>logic</em> to <em>combinatorics</em>, from “can I?” to “how many ways?”</p>
</section>
<section id="step-by-step-example-13" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-13">Step-by-Step Example</h4>
<p><code>arr = [2, 3, 5, 6, 8, 10]</code>, <code>S = 10</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>arr[i]</th>
<th>Ways to form 10</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>0</td>
<td>cannot reach 10 yet</td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td>0</td>
<td>2+3=5 only</td>
</tr>
<tr class="odd">
<td>3</td>
<td>5</td>
<td>1</td>
<td>{5}</td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td>1</td>
<td>{10}</td>
</tr>
<tr class="odd">
<td>5</td>
<td>8</td>
<td>2</td>
<td>{2,8}, {10}</td>
</tr>
<tr class="even">
<td>6</td>
<td>10</td>
<td>3</td>
<td>{10}, {2,8}, {2,3,5}</td>
</tr>
</tbody>
</table>
<p>Answer = 3</p>
</section>
<section id="a-gentle-proof-why-it-works" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works">A Gentle Proof (Why It Works)</h4>
<p>We build <code>dp[i][s]</code> using the inclusion-exclusion principle:</p>
<p>To form sum <code>s</code> using first <code>i</code> items, two possibilities exist:</p>
<ol type="1">
<li>Exclude <code>arr[i-1]</code>: all subsets that form <code>s</code> remain valid <span class="math display">\[ dp[i-1][s] \]</span></li>
<li>Include <code>arr[i-1]</code>: each subset that formed <code>s - arr[i-1]</code> now forms <code>s</code> <span class="math display">\[ dp[i-1][s - arr[i-1]] \]</span></li>
</ol>
<p>Thus:</p>
<p><span class="math display">\[
dp[i][s] = dp[i-1][s] + dp[i-1][s - arr[i-1]]
\]</span></p>
<p>No double counting occurs since each element is processed once, contributing to exactly one branch per subproblem. By building layer by layer, <code>dp[n][S]</code> accumulates all valid subset combinations summing to <code>S</code>.</p>
</section>
<section id="try-it-yourself-13" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-13">Try It Yourself</h4>
<ol type="1">
<li>Print all valid subsets using recursive backtracking.</li>
<li>Modify the DP to count subsets with sum ≤ target.</li>
<li>Add duplicates and compare results.</li>
<li>Apply modulo <span class="math inline">\(10^9 + 7\)</span> to handle large counts.</li>
<li>Extend to count subsets with sum difference = D.</li>
</ol>
</section>
<section id="test-cases-13" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-13">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>S</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[2,3,5,6,8,10]</td>
<td>10</td>
<td>3</td>
<td>{10}, {2,8}, {2,3,5}</td>
</tr>
<tr class="even">
<td>[1,1,1,1]</td>
<td>2</td>
<td>6</td>
<td>choose any 2</td>
</tr>
<tr class="odd">
<td>[1,2,3]</td>
<td>3</td>
<td>2</td>
<td>{3}, {1,2}</td>
</tr>
<tr class="even">
<td>[1,2,5]</td>
<td>4</td>
<td>0</td>
<td>no subset</td>
</tr>
<tr class="odd">
<td>[2,4,6,10]</td>
<td>16</td>
<td>2</td>
<td>{6,10}, {2,4,10}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-13" class="level4">
<h4 class="anchored" data-anchor-id="complexity-13">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times S)\)</span></li>
<li>Space: <span class="math inline">\(O(S)\)</span></li>
</ul>
<p>The Count of Subsets with Sum problem is a perfect illustration of how dynamic programming can evolve from feasibility to enumeration, counting every path that leads to success.</p>
</section>
</section>
<section id="target-sum" class="level3">
<h3 class="anchored" data-anchor-id="target-sum">415 Target Sum</h3>
<p>The Target Sum problem combines Subset Sum and sign assignment, instead of selecting elements, you assign + or − to each one so that their total equals a target value. It’s a beautiful example of how DP can turn algebraic constraints into combinatorial counting.</p>
<section id="what-problem-are-we-solving-14" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-14">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>An array <code>arr[]</code> of <code>n</code> non-negative integers</li>
<li>A target value <code>T</code></li>
</ul>
<p>Count the number of ways to assign + or − signs to elements so that:</p>
<p><span class="math display">\[
a_1 \pm a_2 \pm a_3 \pm \ldots \pm a_n = T
\]</span></p>
<p>Each element must appear once with either sign.</p>
<p>We define:</p>
<ul>
<li>Let total sum be <span class="math inline">\(S = \sum arr[i]\)</span></li>
</ul>
<p>If we split into two subsets <span class="math inline">\(P\)</span> (positive) and <span class="math inline">\(N\)</span> (negative), we have:</p>
<p><span class="math display">\[
\begin{cases}
P + N = S \
P - N = T
\end{cases}
\]</span></p>
<p>Solve these equations:</p>
<p><span class="math display">\[
P = \frac{S + T}{2}
\]</span></p>
<p>So the problem becomes count subsets whose sum = (S + T)/2.</p>
<p>If <span class="math inline">\((S + T)\)</span> is odd or <span class="math inline">\(T &gt; S\)</span>, answer = 0 (impossible).</p>
</section>
<section id="key-idea" class="level4">
<h4 class="anchored" data-anchor-id="key-idea">Key Idea</h4>
<p>Convert the sign problem into a subset counting problem:</p>
<p><span class="math display">\[
\text{Count subsets with sum } P = \frac{S + T}{2}
\]</span></p>
<p>Then use the recurrence from Count of Subsets with Sum:</p>
<p><span class="math display">\[
dp[i][p] =
\begin{cases}
dp[i-1][p], &amp; \text{if } arr[i-1] &gt; p,\\
dp[i-1][p] + dp[i-1][p - arr[i-1]], &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Base case:</p>
<p><span class="math display">\[
dp[0][0] = 1
\]</span></p>
<p>Answer:</p>
<p><span class="math display">\[
dp[n][P]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-14" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-14">How Does It Work (Plain Language)</h4>
<p>Think of each element as being placed on one of two sides: positive or negative. Instead of directly simulating signs, we compute how many subsets sum to <span class="math inline">\((S + T)/2\)</span>. That subset represents all numbers assigned <code>+</code>; the rest implicitly become <code>−</code>.</p>
<p>Example: <code>arr = [1, 1, 2, 3]</code>, <code>T = 1</code> Sum <code>S = 7</code> → <span class="math inline">\(P = (7 + 1)/2 = 4\)</span></p>
<p>So we count subsets summing to 4:</p>
<ul>
<li><code>{1, 3}</code></li>
<li><code>{1, 1, 2}</code> Answer = 2</li>
</ul>
</section>
<section id="tiny-code-easy-versions-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-14">Tiny Code (Easy Versions)</h4>
<p>C (2D DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> T<span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of elements and target: "</span><span class="op">);</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>T<span class="op">);</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter elements: "</span><span class="op">);</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> S <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> S <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>S <span class="op">+</span> T<span class="op">)</span> <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">||</span> T <span class="op">&gt;</span> S<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"No solutions</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> P <span class="op">=</span> <span class="op">(</span>S <span class="op">+</span> T<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>P <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> P<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> P<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]];</span></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of ways: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>P<span class="op">]);</span></span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D Space Optimized)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter elements: "</span>).split()))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter target: "</span>))</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">sum</span>(arr)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (S <span class="op">+</span> T) <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span> <span class="kw">or</span> T <span class="op">&gt;</span> S:</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"No solutions"</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> (S <span class="op">+</span> T) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (P <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(P, num <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>            dp[s] <span class="op">+=</span> dp[s <span class="op">-</span> num]</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Number of ways:"</span>, dp[P])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-14" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-14">Why It Matters</h4>
<ul>
<li>Transforms sign assignment into subset counting</li>
<li>Reinforces algebraic manipulation in DP</li>
<li>Foundation for expression evaluation, partition problems, and probabilistic sums</li>
<li>Demonstrates how mathematical reformulation simplifies state design</li>
</ul>
<p>It’s a powerful example of turning a tricky ± sum problem into a familiar counting DP.</p>
</section>
<section id="step-by-step-example-14" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-14">Step-by-Step Example</h4>
<p><code>arr = [1, 1, 2, 3]</code>, <code>T = 1</code> <span class="math inline">\(S = 7\)</span> → <span class="math inline">\(P = 4\)</span></p>
<p>Subsets summing to 4:</p>
<ul>
<li><code>{1, 3}</code></li>
<li><code>{1, 1, 2}</code></li>
</ul>
<p>Answer = 2</p>
</section>
<section id="a-gentle-proof-why-it-works-1" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-1">A Gentle Proof (Why It Works)</h4>
<p>Let the positive subset sum be <span class="math inline">\(P\)</span> and negative subset sum be <span class="math inline">\(N\)</span>. We have:</p>
<p><span class="math display">\[
P - N = T \quad \text{and} \quad P + N = S
\]</span></p>
<p>Adding both: <span class="math display">\[
2P = S + T \implies P = \frac{S + T}{2}
\]</span></p>
<p>Thus, any valid assignment of signs corresponds exactly to one subset summing to <span class="math inline">\(P\)</span>. Every subset of sum <span class="math inline">\(P\)</span> defines a unique sign configuration:</p>
<ul>
<li>Numbers in <span class="math inline">\(P\)</span> → positive</li>
<li>Numbers not in <span class="math inline">\(P\)</span> → negative</li>
</ul>
<p>So counting subsets with sum <span class="math inline">\(P\)</span> is equivalent to counting all valid sign assignments.</p>
</section>
<section id="try-it-yourself-14" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-14">Try It Yourself</h4>
<ol type="1">
<li>Handle zeros (they double the count).</li>
<li>Return all possible sign configurations.</li>
<li>Check with negative <code>T</code> (same symmetry).</li>
<li>Compare brute-force enumeration with DP result.</li>
<li>Modify for constraints like “at least k positive numbers”.</li>
</ol>
</section>
<section id="test-cases-14" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-14">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>T</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,1,2,3]</td>
<td>1</td>
<td>2</td>
<td>{1,3}, {1,1,2}</td>
</tr>
<tr class="even">
<td>[1,2,3]</td>
<td>0</td>
<td>2</td>
<td>{1,2,3} and {-1,-2,-3}</td>
</tr>
<tr class="odd">
<td>[2,2,2,2]</td>
<td>4</td>
<td>6</td>
<td>many ways</td>
</tr>
<tr class="even">
<td>[1,1,1,1]</td>
<td>0</td>
<td>6</td>
<td>symmetric partitions</td>
</tr>
<tr class="odd">
<td>[5,3,2,1]</td>
<td>5</td>
<td>2</td>
<td>{2,3}, {5}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-14" class="level4">
<h4 class="anchored" data-anchor-id="complexity-14">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times P)\)</span></li>
<li>Space: <span class="math inline">\(O(P)\)</span></li>
</ul>
<p>The Target Sum problem shows how algebra and DP meet: by reinterpreting signs as subsets, you turn a puzzle of pluses and minuses into a clean combinatorial count.</p>
</section>
</section>
<section id="unbounded-knapsack" class="level3">
<h3 class="anchored" data-anchor-id="unbounded-knapsack">416 Unbounded Knapsack</h3>
<p>The Unbounded Knapsack problem is the unlimited version of the classic 0/1 Knapsack. Here, each item can be chosen multiple times, as long as total weight stays within capacity. It’s one of the most elegant illustrations of reusable states in dynamic programming.</p>
<section id="what-problem-are-we-solving-15" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-15">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li><code>n</code> items, each with <code>weight[i]</code> and <code>value[i]</code></li>
<li>a knapsack of capacity <code>W</code></li>
</ul>
<p>Find the maximum total value achievable without exceeding capacity <code>W</code>. Each item can be used any number of times.</p>
<p>We define the state:</p>
<p><span class="math display">\[
dp[w] = \text{maximum value for capacity } w
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[w] = \max_{i: , weight[i] \le w} \big( dp[w - weight[i]] + value[i] \big)
\]</span></p>
<p>Base:</p>
<p><span class="math display">\[
dp[0] = 0
\]</span></p>
<p>Final answer:</p>
<p><span class="math display">\[
dp[W]
\]</span></p>
<p>The key difference from 0/1 Knapsack is order of iteration — for unbounded, we move forward through weights so items can be reused.</p>
</section>
<section id="how-does-it-work-plain-language-15" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-15">How Does It Work (Plain Language)</h4>
<p>Think of the capacity as a ladder. At each rung <code>w</code>, you check every item:</p>
<ul>
<li>If it fits, you ask: <em>“If I take this item, what’s the best I can do with the remaining space?”</em></li>
<li>Since items are reusable, you can add it again later.</li>
</ul>
<p>This way, every <code>dp[w]</code> builds from smaller capacities, each possibly using the same item again.</p>
<p>Example: Items = (weight, value): (2,4), (3,7), (4,9) <code>W = 7</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Capacity</th>
<th>dp[w]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>base</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>no item fits</td>
</tr>
<tr class="odd">
<td>2</td>
<td>4</td>
<td>one (2,4)</td>
</tr>
<tr class="even">
<td>3</td>
<td>7</td>
<td>one (3,7)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>9</td>
<td>one (4,9)</td>
</tr>
<tr class="even">
<td>5</td>
<td>11</td>
<td>(2,4)+(3,7)</td>
</tr>
<tr class="odd">
<td>6</td>
<td>14</td>
<td>(3,7)+(3,7)</td>
</tr>
<tr class="even">
<td>7</td>
<td>16</td>
<td>(3,7)+(4,9)</td>
</tr>
</tbody>
</table>
<p>Answer = 16</p>
</section>
<section id="tiny-code-easy-versions-15" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-15">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up 1D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&gt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> W<span class="op">;</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of items and capacity: "</span><span class="op">);</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>W<span class="op">);</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt<span class="op">[</span>n<span class="op">],</span> val<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter weights: "</span><span class="op">);</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>wt<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter values: "</span><span class="op">);</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> dp<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> wt<span class="op">[</span>i<span class="op">];</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>w<span class="op">],</span> val<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>w <span class="op">-</span> wt<span class="op">[</span>i<span class="op">]]);</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>W<span class="op">]);</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Iterative Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter weights: "</span>).split()))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter values: "</span>).split()))</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter capacity: "</span>))</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(weights)):</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(weights[i], W <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>        dp[w] <span class="op">=</span> <span class="bu">max</span>(dp[w], values[i] <span class="op">+</span> dp[w <span class="op">-</span> weights[i]])</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, dp[W])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-15" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-15">Why It Matters</h4>
<ul>
<li>Demonstrates reusable subproblems, items can appear multiple times</li>
<li>Connects to Coin Change (Min Coins) and Rod Cutting</li>
<li>Foundation for integer partition, resource allocation, and bounded-unbounded hybrid problems</li>
<li>Teaches forward iteration logic</li>
</ul>
<p>Unbounded Knapsack is the perfect showcase of DP with repetition.</p>
</section>
<section id="step-by-step-example-15" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-15">Step-by-Step Example</h4>
<p>Items: (2,4), (3,7), (4,9), <code>W = 7</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>w</th>
<th>dp[w]</th>
<th>Best Choice</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>base</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>none fits</td>
</tr>
<tr class="odd">
<td>2</td>
<td>4</td>
<td>(2)</td>
</tr>
<tr class="even">
<td>3</td>
<td>7</td>
<td>(3)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>9</td>
<td>(4)</td>
</tr>
<tr class="even">
<td>5</td>
<td>11</td>
<td>(2,3)</td>
</tr>
<tr class="odd">
<td>6</td>
<td>14</td>
<td>(3,3)</td>
</tr>
<tr class="even">
<td>7</td>
<td>16</td>
<td>(3,4)</td>
</tr>
</tbody>
</table>
<p>Answer = 16</p>
</section>
<section id="a-gentle-proof-why-it-works-2" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-2">A Gentle Proof (Why It Works)</h4>
<p>For each capacity <code>w</code>, we consider every item <code>i</code> such that <code>weight[i] ≤ w</code>. If we choose item <code>i</code>, we gain its value plus the best value achievable for the remaining space <code>w - weight[i]</code>:</p>
<p><span class="math display">\[
dp[w] = \max_i \big( value[i] + dp[w - weight[i]] \big)
\]</span></p>
<p>Unlike 0/1 Knapsack (which must avoid reuse), this recurrence allows reuse because <code>dp[w - weight[i]]</code> is computed before <code>dp[w]</code> in the same pass, meaning item <code>i</code> can contribute multiple times.</p>
<p>By filling the array from <code>0</code> to <code>W</code>, every capacity’s best value is derived from optimal substructures of smaller capacities.</p>
</section>
<section id="try-it-yourself-15" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-15">Try It Yourself</h4>
<ol type="1">
<li>Print chosen items by tracking predecessors.</li>
<li>Compare with 0/1 Knapsack results.</li>
<li>Add constraint: each item ≤ k copies.</li>
<li>Apply to Rod Cutting: <code>weight = length</code>, <code>value = price</code>.</li>
<li>Experiment with fractional weights (greedy fails here).</li>
</ol>
</section>
<section id="test-cases-15" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-15">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Weights</th>
<th>Values</th>
<th>W</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[2,3,4]</td>
<td>[4,7,9]</td>
<td>7</td>
<td>16</td>
<td>(3,4)</td>
</tr>
<tr class="even">
<td>[5,10,15]</td>
<td>[10,30,50]</td>
<td>20</td>
<td>100</td>
<td>four 5s or two 10s</td>
</tr>
<tr class="odd">
<td>[1,2,3]</td>
<td>[10,15,40]</td>
<td>6</td>
<td>90</td>
<td>six 1s</td>
</tr>
<tr class="even">
<td>[2,5]</td>
<td>[5,10]</td>
<td>3</td>
<td>5</td>
<td>one 2</td>
</tr>
<tr class="odd">
<td>[1,3,4,5]</td>
<td>[10,40,50,70]</td>
<td>8</td>
<td>160</td>
<td>multiples of 1 and 3</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-15" class="level4">
<h4 class="anchored" data-anchor-id="complexity-15">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times W)\)</span></li>
<li>Space: <span class="math inline">\(O(W)\)</span></li>
</ul>
<p>The Unbounded Knapsack captures the essence of reusable DP states, every step builds on smaller, self-similar subproblems, stacking value piece by piece until the capacity is full.</p>
</section>
</section>
<section id="fractional-knapsack" class="level3">
<h3 class="anchored" data-anchor-id="fractional-knapsack">417 Fractional Knapsack</h3>
<p>The Fractional Knapsack problem is a close cousin of the 0/1 Knapsack, but with a twist. Here, you can break items into fractions, taking partial weight to maximize total value. This problem is not solved by DP; it’s a greedy algorithm, serving as a contrast to show where DP is <em>not</em> needed.</p>
<section id="what-problem-are-we-solving-16" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-16">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li><code>n</code> items, each with <code>weight[i]</code> and <code>value[i]</code></li>
<li>a knapsack with capacity <code>W</code></li>
</ul>
<p>Find the maximum total value achievable by possibly taking fractions of items.</p>
<p>We define:</p>
<ul>
<li>Value density (ratio): <span class="math display">\[
\text{ratio}[i] = \frac{value[i]}{weight[i]}
\]</span></li>
</ul>
<p>To maximize value:</p>
<ol type="1">
<li>Sort items by decreasing ratio.</li>
<li>Take full items until you can’t.</li>
<li>Take a fraction of the next one to fill the remaining capacity.</li>
</ol>
<p>Answer is the sum of selected (full + partial) values.</p>
</section>
<section id="how-does-it-work-plain-language-16" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-16">How Does It Work (Plain Language)</h4>
<p>If each item can be split, the best approach is take the most valuable per unit weight first. It’s like filling your bag with gold dust, start with the richest dust, then move to less valuable kinds.</p>
<p>Example: Items:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>Value</th>
<th>Weight</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>60</td>
<td>10</td>
<td>6.0</td>
</tr>
<tr class="even">
<td>2</td>
<td>100</td>
<td>20</td>
<td>5.0</td>
</tr>
<tr class="odd">
<td>3</td>
<td>120</td>
<td>30</td>
<td>4.0</td>
</tr>
</tbody>
</table>
<p>Capacity = 50</p>
<ol type="1">
<li>Take all of Item 1 → weight 10, value 60</li>
<li>Take all of Item 2 → weight 20, value 100</li>
<li>Take 20/30 = 2/3 of Item 3 → weight 20, value 80</li>
</ol>
<p>Total = 60 + 100 + 80 = 240</p>
</section>
<section id="tiny-code-easy-versions-16" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-16">Tiny Code (Easy Versions)</h4>
<p>C (Greedy Algorithm)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Item <span class="op">{</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">,</span> weight<span class="op">;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> compare<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> r1 <span class="op">=</span> <span class="op">(</span><span class="dt">double</span><span class="op">)((</span><span class="kw">struct</span> Item <span class="op">*)</span>a<span class="op">)-&gt;</span>value <span class="op">/</span> <span class="op">((</span><span class="kw">struct</span> Item <span class="op">*)</span>a<span class="op">)-&gt;</span>weight<span class="op">;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> r2 <span class="op">=</span> <span class="op">(</span><span class="dt">double</span><span class="op">)((</span><span class="kw">struct</span> Item <span class="op">*)</span>b<span class="op">)-&gt;</span>value <span class="op">/</span> <span class="op">((</span><span class="kw">struct</span> Item <span class="op">*)</span>b<span class="op">)-&gt;</span>weight<span class="op">;</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>r1 <span class="op">&lt;</span> r2<span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> W<span class="op">;</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of items and capacity: "</span><span class="op">);</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>W<span class="op">);</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Item arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter value and weight:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">].</span>value<span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">].</span>weight<span class="op">);</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>arr<span class="op">,</span> n<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> Item<span class="op">),</span> compare<span class="op">);</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> totalValue <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> curWeight <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>curWeight <span class="op">+</span> arr<span class="op">[</span>i<span class="op">].</span>weight <span class="op">&lt;=</span> W<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>            curWeight <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">].</span>weight<span class="op">;</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>            totalValue <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">].</span>value<span class="op">;</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> remain <span class="op">=</span> W <span class="op">-</span> curWeight<span class="op">;</span></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>            totalValue <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">].</span>value <span class="op">*</span> <span class="op">((</span><span class="dt">double</span><span class="op">)</span>remain <span class="op">/</span> arr<span class="op">[</span>i<span class="op">].</span>weight<span class="op">);</span></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%.2f\n</span><span class="st">"</span><span class="op">,</span> totalValue<span class="op">);</span></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Greedy Implementation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>items <span class="op">=</span> []</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter number of items: "</span>))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter capacity: "</span>))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    v, w <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter value and weight: "</span>).split())</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    items.append((v, w, v <span class="op">/</span> w))</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>items.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">2</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>total_value <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>cur_weight <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v, w, r <span class="kw">in</span> items:</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cur_weight <span class="op">+</span> w <span class="op">&lt;=</span> W:</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        cur_weight <span class="op">+=</span> w</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>        total_value <span class="op">+=</span> v</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>        remain <span class="op">=</span> W <span class="op">-</span> cur_weight</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>        total_value <span class="op">+=</span> v <span class="op">*</span> (remain <span class="op">/</span> w)</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, <span class="bu">round</span>(total_value, <span class="dv">2</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-16" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-16">Why It Matters</h4>
<ul>
<li>Demonstrates where DP isn’t needed, a greedy choice property</li>
<li>Contrasts with 0/1 Knapsack (DP needed)</li>
<li>Builds intuition for ratio-based optimization</li>
<li>Appears in resource allocation, finance, optimization</li>
</ul>
<p>The Fractional Knapsack is the “continuous” version, you don’t choose <em>yes or no</em>, you pour the best parts until you run out of room.</p>
</section>
<section id="step-by-step-example-16" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-16">Step-by-Step Example</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>Value</th>
<th>Weight</th>
<th>Ratio</th>
<th>Take</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>60</td>
<td>10</td>
<td>6.0</td>
<td>Full</td>
</tr>
<tr class="even">
<td>2</td>
<td>100</td>
<td>20</td>
<td>5.0</td>
<td>Full</td>
</tr>
<tr class="odd">
<td>3</td>
<td>120</td>
<td>30</td>
<td>4.0</td>
<td>2/3</td>
</tr>
</tbody>
</table>
<p>Total = 240</p>
</section>
<section id="a-gentle-proof-why-it-works-3" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-3">A Gentle Proof (Why It Works)</h4>
<p>If all items can be divided arbitrarily, the optimal strategy is always to take the one with the highest value density first. Proof sketch:</p>
<ol type="1">
<li>Suppose an optimal solution skips a higher-ratio item to take a lower-ratio one.</li>
<li>Replacing part of the lower-ratio item with the higher-ratio one strictly increases total value.</li>
<li>Contradiction, thus, sorting by ratio is optimal.</li>
</ol>
<p>This property is called the greedy choice property. Because the problem satisfies both optimal substructure and greedy choice, a greedy algorithm suffices.</p>
</section>
<section id="try-it-yourself-16" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-16">Try It Yourself</h4>
<ol type="1">
<li>Compare results with 0/1 Knapsack for same items.</li>
<li>Add more items with identical ratios.</li>
<li>Implement sorting manually and test correctness.</li>
<li>Check behavior when capacity &lt; smallest weight.</li>
<li>Visualize partial fill using ratio chart.</li>
</ol>
</section>
<section id="test-cases-16" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-16">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 29%">
<col style="width: 24%">
<col style="width: 3%">
<col style="width: 12%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Values</th>
<th>Weights</th>
<th>W</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[60,100,120]</td>
<td>[10,20,30]</td>
<td>50</td>
<td>240</td>
<td>classic</td>
</tr>
<tr class="even">
<td>[10,5,15,7,6,18,3]</td>
<td>[2,3,5,7,1,4,1]</td>
<td>15</td>
<td>55.33</td>
<td>greedy mix</td>
</tr>
<tr class="odd">
<td>[25,50,75]</td>
<td>[5,10,15]</td>
<td>10</td>
<td>50</td>
<td>full item</td>
</tr>
<tr class="even">
<td>[5,10,15]</td>
<td>[1,2,3]</td>
<td>3</td>
<td>15</td>
<td>take all</td>
</tr>
<tr class="odd">
<td>[1,2,3]</td>
<td>[3,2,1]</td>
<td>3</td>
<td>5</td>
<td>highest ratio first</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-16" class="level4">
<h4 class="anchored" data-anchor-id="complexity-16">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \log n)\)</span> (for sorting)</li>
<li>Space: <span class="math inline">\(O(1)\)</span></li>
</ul>
<p>The Fractional Knapsack shows the power of greedy reasoning, sometimes, thinking locally optimal truly leads to the global best.</p>
</section>
</section>
<section id="coin-change-min-coins-1" class="level3">
<h3 class="anchored" data-anchor-id="coin-change-min-coins-1">418 Coin Change (Min Coins)</h3>
<p>The Coin Change (Min Coins) problem is about finding the <em>fewest number of coins</em> needed to make a given amount. Unlike the counting version, which sums all combinations, this one focuses on minimization, the shortest path to the target sum.</p>
<p>It’s a classic unbounded DP problem, where each coin can be used multiple times.</p>
<section id="what-problem-are-we-solving-17" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-17">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A list of coins <code>coins[]</code></li>
<li>A target amount <code>A</code></li>
</ul>
<p>Find the minimum number of coins needed to make amount <code>A</code>. If it’s impossible, return <code>-1</code>.</p>
<p>We define the state:</p>
<p><span class="math display">\[
dp[x] = \text{minimum coins required to make amount } x
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[x] = \min_{c \in coins,; c \le x} \big( dp[x - c] + 1 \big)
\]</span></p>
<p>Base:</p>
<p><span class="math display">\[
dp[0] = 0
\]</span></p>
<p>Final answer:</p>
<p><span class="math display">\[
dp[A]
\]</span></p>
<p>If no combination is possible, <code>dp[A]</code> will remain at infinity (or a large sentinel value).</p>
</section>
<section id="how-does-it-work-plain-language-17" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-17">How Does It Work (Plain Language)</h4>
<p>Think of building the amount step by step. For each value <code>x</code>, try all coins <code>c</code> that fit, and see which leads to the fewest total coins. Each state <code>dp[x]</code> represents the shortest chain from <code>0</code> to <code>x</code>.</p>
<p>It’s like climbing stairs to a target floor, each coin is a step size, and you want the path with the fewest steps.</p>
<p>Example: <code>coins = [1, 3, 4]</code>, <code>A = 6</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Amount</th>
<th>dp[x]</th>
<th>Choice</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>base</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>1+1</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>4</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>5</td>
<td>2</td>
<td>3+2</td>
</tr>
<tr class="odd">
<td>6</td>
<td>2</td>
<td>3+3</td>
</tr>
</tbody>
</table>
<p>Answer = 2 (3 + 3)</p>
</section>
<section id="tiny-code-easy-versions-17" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-17">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&lt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> A<span class="op">;</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of coins and amount: "</span><span class="op">);</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>A<span class="op">);</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> coins<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter coin values: "</span><span class="op">);</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>coins<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>A <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> A<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> x <span class="op">&lt;=</span> A<span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> c <span class="op">=</span> coins<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>x <span class="op">-</span> c <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> MIN<span class="op">(</span>dp<span class="op">[</span>x<span class="op">],</span> dp<span class="op">[</span>x <span class="op">-</span> c<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>A<span class="op">]</span> <span class="op">==</span> INF<span class="op">)</span> printf<span class="op">(</span><span class="st">"Not possible</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> printf<span class="op">(</span><span class="st">"Min coins: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>A<span class="op">]);</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple Iterative Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>coins <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter coin values: "</span>).split()))</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter amount: "</span>))</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [INF] <span class="op">*</span> (A <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, A <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> coins:</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">-</span> c <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>            dp[x] <span class="op">=</span> <span class="bu">min</span>(dp[x], dp[x <span class="op">-</span> c] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min coins:"</span> <span class="cf">if</span> dp[A] <span class="op">!=</span> INF <span class="cf">else</span> <span class="st">"Not possible"</span>, end<span class="op">=</span><span class="st">" "</span>)</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp[A] <span class="cf">if</span> dp[A] <span class="op">!=</span> INF <span class="cf">else</span> <span class="st">""</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-17" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-17">Why It Matters</h4>
<ul>
<li>Classic unbounded minimization DP</li>
<li>Core of many resource optimization problems</li>
<li>Foundation for graph shortest paths, minimum steps, edit operations</li>
<li>Contrasts with counting version (same recurrence, different aggregation)</li>
</ul>
<p>This problem shows how min replaces sum in DP to shift from “how many” to “how few”.</p>
</section>
<section id="step-by-step-example-17" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-17">Step-by-Step Example</h4>
<p>Coins = [1, 3, 4], A = 6</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>x</th>
<th>Choices</th>
<th>dp[x]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>-</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>dp[0]+1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>dp[1]+1</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>dp[0]+1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>dp[0]+1</td>
<td>1</td>
</tr>
<tr class="even">
<td>5</td>
<td>min(dp[2]+1, dp[1]+1)</td>
<td>2</td>
</tr>
<tr class="odd">
<td>6</td>
<td>min(dp[3]+1, dp[2]+1)</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Answer = 2 (3+3)</p>
</section>
<section id="a-gentle-proof-why-it-works-4" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-4">A Gentle Proof (Why It Works)</h4>
<p>The recurrence builds from smaller amounts upward. For each amount <code>x</code>, every coin <code>c</code> offers a path from <code>x - c</code> → <code>x</code>, adding 1 step.</p>
<p>By induction:</p>
<ul>
<li>Base case: <code>dp[0] = 0</code> (no coins to make 0).</li>
<li>Inductive step: assume optimal solutions exist for all <code>&lt; x</code>. Then, the minimal value among all <code>dp[x - c] + 1</code> is the fewest coins to form <code>x</code>.</li>
</ul>
<p>Since each <code>x</code> reuses optimal subsolutions, <code>dp[A]</code> is globally optimal.</p>
</section>
<section id="try-it-yourself-17" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-17">Try It Yourself</h4>
<ol type="1">
<li>Print the chosen coins (trace back <code>dp[x]</code>).</li>
<li>Add a coin that never helps (e.g., <code>[1, 3, 10]</code>, <code>A=6</code>).</li>
<li>Compare with greedy for <code>[1,3,4]</code> (fails).</li>
<li>Extend to limited coins (bounded knapsack).</li>
<li>Try larger <code>A</code> to see performance.</li>
</ol>
</section>
<section id="test-cases-17" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-17">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Coins</th>
<th>Amount</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,3,4]</td>
<td>6</td>
<td>2</td>
<td>3+3</td>
</tr>
<tr class="even">
<td>[2,5]</td>
<td>3</td>
<td>-1</td>
<td>not possible</td>
</tr>
<tr class="odd">
<td>[1,2,5]</td>
<td>11</td>
<td>3</td>
<td>5+5+1</td>
</tr>
<tr class="even">
<td>[9,6,5,1]</td>
<td>11</td>
<td>2</td>
<td>6+5</td>
</tr>
<tr class="odd">
<td>[2,3,7]</td>
<td>12</td>
<td>3</td>
<td>3+3+6</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-17" class="level4">
<h4 class="anchored" data-anchor-id="complexity-17">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times A)\)</span></li>
<li>Space: <span class="math inline">\(O(A)\)</span></li>
</ul>
<p>The Coin Change (Min Coins) problem is where unbounded DP meets optimization, building minimal paths to a target through simple, repeated decisions.</p>
</section>
</section>
<section id="coin-change-count-ways-1" class="level3">
<h3 class="anchored" data-anchor-id="coin-change-count-ways-1">419 Coin Change (Count Ways)</h3>
<p>The Coin Change (Count Ways) problem is about how many different ways you can make a given amount using available coins. Unlike the minimization version, here every combination matters, order doesn’t.</p>
<p>This is a perfect example of unbounded combinatorial DP, where each coin can be used multiple times, but arrangement order is irrelevant.</p>
<section id="what-problem-are-we-solving-18" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-18">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A list of coins <code>coins[]</code></li>
<li>A target amount <code>A</code></li>
</ul>
<p>Find the number of distinct combinations (unordered) that sum to <code>A</code>.</p>
<p>We define the state:</p>
<p><span class="math display">\[
dp[x] = \text{number of ways to make amount } x
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[x] = \sum_{c \in coins,; c \le x} dp[x - c]
\]</span></p>
<p>Base:</p>
<p><span class="math display">\[
dp[0] = 1
\]</span></p>
<p>To avoid counting the same combination multiple times (e.g., <code>[1,2]</code> and <code>[2,1]</code>), we iterate coins first, then amount.</p>
</section>
<section id="how-does-it-work-plain-language-18" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-18">How Does It Work (Plain Language)</h4>
<p>We count <em>combinations</em>, not <em>permutations</em>. That means <code>{1,2}</code> and <code>{2,1}</code> are considered the same way. So we fix each coin’s order, when processing a coin, we allow it to be reused, but not reordered with future coins.</p>
<p>Example: <code>coins = [1, 2, 5]</code>, <code>A = 5</code></p>
<p>Ways:</p>
<ul>
<li>1+1+1+1+1</li>
<li>1+1+1+2</li>
<li>1+2+2</li>
<li>5</li>
</ul>
<p>Answer = 4</p>
</section>
<section id="tiny-code-easy-versions-18" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-18">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb37"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> A<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of coins and amount: "</span><span class="op">);</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>A<span class="op">);</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> coins<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter coin values: "</span><span class="op">);</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>coins<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>A <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> A<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> coins<span class="op">[</span>i<span class="op">];</span> x <span class="op">&lt;=</span> A<span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>x<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>x <span class="op">-</span> coins<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of ways: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>A<span class="op">]);</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Iterative Combinations)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>coins <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter coin values: "</span>).split()))</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter amount: "</span>))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (A <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> coins:</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(c, A <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>        dp[x] <span class="op">+=</span> dp[x <span class="op">-</span> c]</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of ways:"</span>, dp[A])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-18" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-18">Why It Matters</h4>
<ul>
<li>Foundation of combinatorial DP</li>
<li>Basis for partition counting, compositional sums, and probability DP</li>
<li>Reinforces loop ordering importance, changing order counts permutations instead</li>
<li>Connects to integer partition problems in number theory</li>
</ul>
<p>It teaches you that <em>what you count</em> (order vs combination) depends on how you iterate.</p>
</section>
<section id="step-by-step-example-18" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-18">Step-by-Step Example</h4>
<p>Coins = [1, 2, 5], A = 5</p>
<p>Initialize <code>dp = [1, 0, 0, 0, 0, 0]</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Coin</th>
<th>State</th>
<th>dp array (after processing)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>all</td>
<td>[1, 1, 1, 1, 1, 1]</td>
</tr>
<tr class="even">
<td>2</td>
<td>adds combos using 2</td>
<td>[1, 1, 2, 2, 3, 3]</td>
</tr>
<tr class="odd">
<td>5</td>
<td>adds combos using 5</td>
<td>[1, 1, 2, 2, 3, 4]</td>
</tr>
</tbody>
</table>
<p>Answer = 4</p>
</section>
<section id="a-gentle-proof-why-it-works-5" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-5">A Gentle Proof (Why It Works)</h4>
<p>We fill <code>dp[x]</code> by summing contributions from each coin <code>c</code>: every time we use coin <code>c</code>, we move from subproblem <code>x - c</code> → <code>x</code>.</p>
<p><span class="math display">\[
dp[x] = \sum_{c \in coins} dp[x - c]
\]</span></p>
<p>But we must fix coin iteration order to ensure unique combinations. Iterating coins first ensures each combination is formed in a canonical order:</p>
<ul>
<li><code>1</code> before <code>2</code> before <code>5</code> So <code>{1,2}</code> appears once, not twice.</li>
</ul>
<p>By induction:</p>
<ul>
<li>Base: <code>dp[0] = 1</code> (one way: use nothing)</li>
<li>Step: each <code>dp[x]</code> counts valid combos by extending smaller sums.</li>
</ul>
</section>
<section id="try-it-yourself-18" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-18">Try It Yourself</h4>
<ol type="1">
<li>Swap loop order → count permutations.</li>
<li>Add coin <code>3</code> and compare growth.</li>
<li>Print all combinations via recursion.</li>
<li>Add modulo <span class="math inline">\(10^9 + 7\)</span> for large results.</li>
<li>Compare with Min Coins (same coins, different goal).</li>
</ol>
</section>
<section id="test-cases-18" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-18">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Coins</th>
<th>Amount</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,2,5]</td>
<td>5</td>
<td>4</td>
<td>classic</td>
</tr>
<tr class="even">
<td>[2,3,5,6]</td>
<td>10</td>
<td>5</td>
<td>multiple combos</td>
</tr>
<tr class="odd">
<td>[1]</td>
<td>3</td>
<td>1</td>
<td>only one way</td>
</tr>
<tr class="even">
<td>[2]</td>
<td>3</td>
<td>0</td>
<td>impossible</td>
</tr>
<tr class="odd">
<td>[1,2,3]</td>
<td>4</td>
<td>4</td>
<td>(1+1+1+1), (1+1+2), (2+2), (1+3)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-18" class="level4">
<h4 class="anchored" data-anchor-id="complexity-18">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times A)\)</span></li>
<li>Space: <span class="math inline">\(O(A)\)</span></li>
</ul>
<p>The Coin Change (Count Ways) problem captures the <em>combinatorial heart</em> of DP, a single recurrence, but with the magic of order-aware iteration, turns counting from chaos into clarity.</p>
</section>
</section>
<section id="multi-dimensional-knapsack" class="level3">
<h3 class="anchored" data-anchor-id="multi-dimensional-knapsack">420 Multi-Dimensional Knapsack</h3>
<p>The Multi-Dimensional Knapsack problem (also called the Multi-Constraint Knapsack) extends the classic 0/1 Knapsack into a richer, more realistic world. Here, each item consumes multiple types of resources (weight, volume, cost, etc.), and we must respect all constraints simultaneously.</p>
<p>It’s where the simplicity of one dimension gives way to the complexity of many.</p>
<section id="what-problem-are-we-solving-19" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-19">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li><p><code>n</code> items</p></li>
<li><p>Each item <code>i</code> has:</p>
<ul>
<li>value <code>v[i]</code></li>
<li>weights in <code>m</code> dimensions <code>w[i][1..m]</code></li>
</ul></li>
<li><p>Capacities <code>C[1..m]</code> for each dimension</p></li>
</ul>
<p>Select a subset of items maximizing total value, subject to:</p>
<p><span class="math display">\[
\forall j \in [1, m]: \sum_{i \in S} w[i][j] \le C[j]
\]</span></p>
<p>State definition:</p>
<p><span class="math display">\[
dp[c_1][c_2] \ldots [c_m] = \text{maximum value achievable with capacities } (c_1, \ldots, c_m)
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[\vec{c}] = \max \big( dp[\vec{c}],; dp[\vec{c} - \vec{w_i}] + v[i] \big)
\]</span></p>
<p>where <span class="math inline">\(\vec{c} - \vec{w_i}\)</span> means subtracting all weights component-wise.</p>
</section>
<section id="how-does-it-work-plain-language-19" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-19">How Does It Work (Plain Language)</h4>
<p>It’s like packing a spaceship with multiple limits, weight, volume, fuel usage, and every item drains each dimension differently. You can’t just fill to a single limit; every item’s cost affects all dimensions at once.</p>
<p>The DP grid is now multi-dimensional: you must iterate over every combination of capacities and decide to include or exclude each item.</p>
<p>Example (2D case): Items:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>Value</th>
<th>Weight</th>
<th>Volume</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>60</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="even">
<td>2</td>
<td>100</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>120</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Capacity: (W=5, V=7)</p>
<p>Answer: 160 (Items 1 + 2)</p>
</section>
<section id="tiny-code-2d-dp-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-2d-dp-example">Tiny Code (2D DP Example)</h4>
<p>C (2D Capacity, 0/1 Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&gt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> W<span class="op">,</span> V<span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of items, weight cap, volume cap: "</span><span class="op">);</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>W<span class="op">,</span> <span class="op">&amp;</span>V<span class="op">);</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> w<span class="op">[</span>n<span class="op">],</span> vol<span class="op">[</span>n<span class="op">],</span> val<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter weight, volume, value:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>w<span class="op">[</span>i<span class="op">],</span> <span class="op">&amp;</span>vol<span class="op">[</span>i<span class="op">],</span> <span class="op">&amp;</span>val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>V <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> W<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> V<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> wi <span class="op">=</span> W<span class="op">;</span> wi <span class="op">&gt;=</span> w<span class="op">[</span>i<span class="op">];</span> wi<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> vi <span class="op">=</span> V<span class="op">;</span> vi <span class="op">&gt;=</span> vol<span class="op">[</span>i<span class="op">];</span> vi<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>wi<span class="op">][</span>vi<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>wi<span class="op">][</span>vi<span class="op">],</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>                                 dp<span class="op">[</span>wi <span class="op">-</span> w<span class="op">[</span>i<span class="op">]][</span>vi <span class="op">-</span> vol<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>W<span class="op">][</span>V<span class="op">]);</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>items <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">60</span>), (<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">100</span>), (<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">120</span>)]</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>W, V <span class="op">=</span> <span class="dv">5</span>, <span class="dv">7</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(V<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(W<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> w, v, val <span class="kw">in</span> items:</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> wi <span class="kw">in</span> <span class="bu">range</span>(W, w<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> vi <span class="kw">in</span> <span class="bu">range</span>(V, v<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>            dp[wi][vi] <span class="op">=</span> <span class="bu">max</span>(dp[wi][vi], dp[wi<span class="op">-</span>w][vi<span class="op">-</span>v] <span class="op">+</span> val)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, dp[W][V])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-19" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-19">Why It Matters</h4>
<ul>
<li>Models real-world constraints, multiple resources</li>
<li>Core of operations research, resource allocation, logistics, multi-resource scheduling</li>
<li>Illustrates how DP dimensionality grows with complexity</li>
<li>Forces careful state design and iteration order</li>
</ul>
<p>When one dimension is not enough, this generalization captures tradeoffs across many.</p>
</section>
<section id="step-by-step-example-2d" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-2d">Step-by-Step Example (2D)</h4>
<p>Capacity: W=5, V=7 Items:</p>
<ol type="1">
<li>(2,3,60)</li>
<li>(3,4,100)</li>
<li>(4,5,120)</li>
</ol>
<p>We explore subsets:</p>
<ul>
<li>{1} → (2,3), value=60</li>
<li>{2} → (3,4), value=100</li>
<li>{3} → (4,5), value=120</li>
<li>{1,2} → (5,7), value=160 ✅ optimal</li>
<li>{1,3} → (6,8) ❌ exceeds</li>
<li>{2,3} → (7,9) ❌ exceeds</li>
</ul>
<p>Answer = 160</p>
</section>
<section id="a-gentle-proof-why-it-works-6" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-6">A Gentle Proof (Why It Works)</h4>
<p>By induction on item index and capacities:</p>
<p>Let <span class="math inline">\(dp[i][c_1][c_2] \ldots [c_m]\)</span> be the best value using first <code>i</code> items and capacity vector <span class="math inline">\((c_1, c_2, \ldots, c_m)\)</span>.</p>
<p>Two choices for each item:</p>
<ol type="1">
<li>Exclude → keep <span class="math inline">\(dp[i-1][\vec{c}]\)</span></li>
<li>Include → <span class="math inline">\(dp[i-1][\vec{c} - \vec{w_i}] + v[i]\)</span> (if feasible)</li>
</ol>
<p>Take the max.</p>
<p>Since all transitions only depend on smaller capacities, and each subproblem is optimal, overall DP converges to global optimum.</p>
</section>
<section id="try-it-yourself-19" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-19">Try It Yourself</h4>
<ol type="1">
<li>Add third dimension (e.g., “time”).</li>
<li>Compare with greedy (fails).</li>
<li>Visualize DP table for 2D.</li>
<li>Track chosen items with traceback.</li>
<li>Add unbounded variation (re-use items).</li>
</ol>
</section>
<section id="test-cases-19" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-19">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 47%">
<col style="width: 22%">
<col style="width: 12%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th>Items (W,V,Val)</th>
<th>Capacity (W,V)</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[(2,3,60),(3,4,100),(4,5,120)]</td>
<td>(5,7)</td>
<td>160</td>
<td>(1+2)</td>
</tr>
<tr class="even">
<td>[(1,2,10),(2,3,20),(3,3,40)]</td>
<td>(3,4)</td>
<td>40</td>
<td>single best</td>
</tr>
<tr class="odd">
<td>[(2,2,8),(2,3,9),(3,4,14)]</td>
<td>(4,5)</td>
<td>17</td>
<td>(1+2)</td>
</tr>
<tr class="even">
<td>[(3,2,10),(2,4,12),(4,3,18)]</td>
<td>(5,6)</td>
<td>22</td>
<td>(1+2)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-19" class="level4">
<h4 class="anchored" data-anchor-id="complexity-19">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times C_1 \times C_2 \times \ldots \times C_m)\)</span></li>
<li>Space: <span class="math inline">\(O(C_1 \times C_2 \times \ldots \times C_m)\)</span></li>
</ul>
<p>The Multi-Dimensional Knapsack is a reminder that every extra resource adds a new axis to your reasoning, and your DP table.</p>
</section>
</section>
</section>
<section id="section-43.-sequence-problems" class="level1">
<h1>Section 43. Sequence Problems</h1>
<section id="longest-increasing-subsequence-on2-dp" class="level3">
<h3 class="anchored" data-anchor-id="longest-increasing-subsequence-on2-dp">421 Longest Increasing Subsequence (O(n^2) DP)</h3>
<p>The Longest Increasing Subsequence (LIS) problem asks for the maximum length of a subsequence that is strictly increasing. Elements do not need to be contiguous, only in order.</p>
<section id="what-problem-are-we-solving-20" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-20">What Problem Are We Solving?</h4>
<p>Given an array <code>arr[0..n-1]</code>, find the maximum <code>k</code> such that there exist indices <code>0 ≤ i1 &lt; i2 &lt; ... &lt; ik &lt; n</code> with <span class="math display">\[
arr[i_1] &lt; arr[i_2] &lt; \cdots &lt; arr[i_k].
\]</span></p>
<p>Define the state <span class="math display">\[
dp[i] = \text{length of the LIS that ends at index } i.
\]</span></p>
<p>Recurrence <span class="math display">\[
dp[i] = 1 + \max_{;0 \le j &lt; i,; arr[j] &lt; arr[i]} dp[j], \quad \text{with } dp[i] \leftarrow 1 \text{ if no such } j.
\]</span></p>
<p>Answer <span class="math display">\[
\max_{0 \le i &lt; n} dp[i].
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-20" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-20">How Does It Work (Plain Language)</h4>
<p>For each position <code>i</code>, look back at all earlier positions <code>j &lt; i</code> with a smaller value. Any increasing subsequence ending at <code>j</code> can be extended by <code>arr[i]</code>. Pick the best among them and add one. If nothing is smaller, start a new subsequence of length 1 at <code>i</code>.</p>
<p>Example: <code>arr = [10, 22, 9, 33, 21, 50, 41, 60]</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>arr[i]</th>
<th>dp[i]</th>
<th>explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>10</td>
<td>1</td>
<td>start</td>
</tr>
<tr class="even">
<td>1</td>
<td>22</td>
<td>2</td>
<td>10 → 22</td>
</tr>
<tr class="odd">
<td>2</td>
<td>9</td>
<td>1</td>
<td>restart at 9</td>
</tr>
<tr class="even">
<td>3</td>
<td>33</td>
<td>3</td>
<td>10 → 22 → 33</td>
</tr>
<tr class="odd">
<td>4</td>
<td>21</td>
<td>2</td>
<td>10 → 21</td>
</tr>
<tr class="even">
<td>5</td>
<td>50</td>
<td>4</td>
<td>10 → 22 → 33 → 50</td>
</tr>
<tr class="odd">
<td>6</td>
<td>41</td>
<td>4</td>
<td>10 → 22 → 33 → 41</td>
</tr>
<tr class="even">
<td>7</td>
<td>60</td>
<td>5</td>
<td>10 → 22 → 33 → 50 → 60</td>
</tr>
</tbody>
</table>
<p>Answer is 5.</p>
</section>
<section id="tiny-code-easy-versions-19" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-19">Tiny Code (Easy Versions)</h4>
<p>C (O(n^2))</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter n: "</span><span class="op">);</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter array: "</span><span class="op">);</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i<span class="op">])</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> MAX<span class="op">(</span>ans<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LIS length: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (O(n^2))</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter array: "</span>).split()))</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[j] <span class="op">&lt;</span> arr[i]:</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LIS length:"</span>, <span class="bu">max</span>(dp) <span class="cf">if</span> dp <span class="cf">else</span> <span class="dv">0</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-20" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-20">Why It Matters</h4>
<ul>
<li>Archetypal sequence DP: define state on prefixes and extend with a choice.</li>
<li>Foundation for LCS, Edit Distance, patience sorting LIS in O(n log n), and 2D variants like Russian Doll Envelopes.</li>
<li>Useful in ranking, time series smoothing, and chain scheduling.</li>
</ul>
</section>
<section id="step-by-step-example-19" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-19">Step by Step Example</h4>
<p><code>arr = [3, 10, 2, 1, 20]</code></p>
<table class="caption-top table">
<colgroup>
<col style="width: 1%">
<col style="width: 9%">
<col style="width: 80%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th>i</th>
<th>arr[i]</th>
<th>candidates (dp[j]+1) with (arr[j] &lt; arr[i])</th>
<th>dp[i]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>3</td>
<td>,</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>10</td>
<td>dp[0]+1 = 2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>,</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>,</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>20</td>
<td>max( dp[0]+1=2, dp[1]+1=3, dp[2]+1=2, dp[3]+1=2 )</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Answer is 3.</p>
</section>
<section id="a-gentle-proof-why-it-works-7" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-7">A Gentle Proof (Why It Works)</h4>
<p>Let <code>OPT(i)</code> denote the LIS length that ends exactly at index <code>i</code>. Any LIS ending at <code>i</code> must either be just <code>[arr[i]]</code> of length 1, or extend a strictly smaller element at some <code>j &lt; i</code>. Therefore <span class="math display">\[
OPT(i) = \max\left( 1,; 1 + \max_{j&lt;i,;arr[j]&lt;arr[i]} OPT(j) \right).
\]</span> This depends only on optimal values from smaller indices, hence dynamic programming applies. The overall LIS is the maximum over all end positions: <span class="math display">\[
\text{LIS} = \max_i OPT(i).
\]</span> By induction on <code>i</code>, the recurrence computes <code>OPT(i)</code> correctly, so the final maximum is optimal.</p>
</section>
<section id="try-it-yourself-20" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-20">Try It Yourself</h4>
<ol type="1">
<li>Recover an actual LIS: keep a <code>parent[i]</code> pointing to the <code>j</code> that gave the best transition.</li>
<li>Change to nondecreasing subsequence: replace <code>&lt;</code> with <code>&lt;=</code>.</li>
<li>Compare with the O(n log n) patience sorting method and verify both lengths match.</li>
<li>Compute the number of LIS of maximum length using a parallel <code>cnt[i]</code>.</li>
<li>Extend to 2D pairs <code>(a,b)</code> by sorting on <code>a</code> and running LIS on <code>b</code> with careful tie handling.</li>
</ol>
</section>
<section id="test-cases-20" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-20">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,2,3,4,5]</td>
<td>5</td>
</tr>
<tr class="even">
<td>[5,4,3,2,1]</td>
<td>1</td>
</tr>
<tr class="odd">
<td>[3,10,2,1,20]</td>
<td>3</td>
</tr>
<tr class="even">
<td>[10,22,9,33,21,50,41,60]</td>
<td>5</td>
</tr>
<tr class="odd">
<td>[2,2,2,2]</td>
<td>1</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-20" class="level4">
<h4 class="anchored" data-anchor-id="complexity-20">Complexity</h4>
<ul>
<li>Time: (O(n^2))</li>
<li>Space: (O(n))</li>
</ul>
<p>This O(n^2) DP is the clearest path to LIS: define the end, look back to smaller ends, and grow the longest chain.</p>
</section>
</section>
<section id="lis-patience-sorting-on-log-n-optimized" class="level3">
<h3 class="anchored" data-anchor-id="lis-patience-sorting-on-log-n-optimized">422 LIS (Patience Sorting) – O(n log n) Optimized</h3>
<p>The Longest Increasing Subsequence (LIS) can be solved faster than the classic (O(n^2)) DP by using a clever idea inspired by patience sorting. Instead of building all sequences, we maintain a minimal tail array, each element represents the smallest possible tail of an increasing subsequence of a given length.</p>
<section id="what-problem-are-we-solving-21" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-21">What Problem Are We Solving?</h4>
<p>Given an array <code>arr[0..n-1]</code>, find the length of the longest strictly increasing subsequence in O(n log n) time.</p>
<p>We want <span class="math display">\[
\text{LIS length} = \max k \text{ such that } \exists i_1 &lt; i_2 &lt; \cdots &lt; i_k,; arr[i_1] &lt; arr[i_2] &lt; \cdots &lt; arr[i_k].
\]</span></p>
</section>
<section id="key-idea-1" class="level4">
<h4 class="anchored" data-anchor-id="key-idea-1">Key Idea</h4>
<p>Maintain an array <code>tails[]</code> where <code>tails[len]</code> = smallest tail value of any increasing subsequence of length <code>len+1</code>.</p>
<p>For each element <code>x</code> in the array:</p>
<ol type="1">
<li>Use binary search in <code>tails</code> to find the first position <code>pos</code> with <code>tails[pos] ≥ x</code>.</li>
<li>Replace <code>tails[pos]</code> with <code>x</code> (we found a better tail).</li>
<li>If <code>x</code> is larger than all tails, append it, subsequence grows.</li>
</ol>
<p>At the end, <code>len(tails)</code> = LIS length.</p>
</section>
<section id="how-does-it-work-plain-language-21" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-21">How Does It Work (Plain Language)</h4>
<p>Think of placing numbers onto piles (like patience solitaire):</p>
<ul>
<li>Each pile’s top is the smallest possible number ending an increasing subsequence of that length.</li>
<li>When a new number comes, place it on the leftmost pile whose top is ≥ the number.</li>
<li>If none exists, start a new pile.</li>
</ul>
<p>The number of piles equals the LIS length.</p>
<p>Example: <code>arr = [10, 22, 9, 33, 21, 50, 41, 60]</code></p>
<p>Process:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>x</th>
<th>tails (after processing x)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>[10]</td>
</tr>
<tr class="even">
<td>22</td>
<td>[10, 22]</td>
</tr>
<tr class="odd">
<td>9</td>
<td>[9, 22]</td>
</tr>
<tr class="even">
<td>33</td>
<td>[9, 22, 33]</td>
</tr>
<tr class="odd">
<td>21</td>
<td>[9, 21, 33]</td>
</tr>
<tr class="even">
<td>50</td>
<td>[9, 21, 33, 50]</td>
</tr>
<tr class="odd">
<td>41</td>
<td>[9, 21, 33, 41]</td>
</tr>
<tr class="even">
<td>60</td>
<td>[9, 21, 33, 41, 60]</td>
</tr>
</tbody>
</table>
<p>Answer = 5</p>
</section>
<section id="tiny-code-easy-versions-20" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-20">Tiny Code (Easy Versions)</h4>
<p>C (Using Binary Search)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lower_bound<span class="op">(</span><span class="dt">int</span> arr<span class="op">[],</span> <span class="dt">int</span> len<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> r <span class="op">=</span> len<span class="op">;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>l <span class="op">+</span> r<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>mid<span class="op">]</span> <span class="op">&lt;</span> x<span class="op">)</span> l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> r <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter n: "</span><span class="op">);</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter array: "</span><span class="op">);</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tails<span class="op">[</span>n<span class="op">],</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pos <span class="op">=</span> lower_bound<span class="op">(</span>tails<span class="op">,</span> len<span class="op">,</span> a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>        tails<span class="op">[</span>pos<span class="op">]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> len<span class="op">)</span> len<span class="op">++;</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LIS length: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> len<span class="op">);</span></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Using bisect)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> bisect</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter array: "</span>).split()))</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>tails <span class="op">=</span> []</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> arr:</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> bisect.bisect_left(tails, x)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pos <span class="op">==</span> <span class="bu">len</span>(tails):</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>        tails.append(x)</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>        tails[pos] <span class="op">=</span> x</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LIS length:"</span>, <span class="bu">len</span>(tails))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-21" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-21">Why It Matters</h4>
<ul>
<li>Reduces LIS from <span class="math inline">\(O(n^2)\)</span> to <span class="math inline">\(O(n \log n)\)</span></li>
<li>Introduces binary search in DP transitions</li>
<li>Demonstrates state compression, we track only <em>tails</em>, not all subproblems</li>
<li>Serves as basis for LIS reconstruction, LDS, Longest Bitonic Subsequence, and 2D LIS</li>
</ul>
<p>This technique shows how mathematical insight can collapse a DP table into a minimal structure.</p>
</section>
<section id="step-by-step-example-20" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-20">Step-by-Step Example</h4>
<p><code>arr = [3, 10, 2, 1, 20]</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>x</th>
<th>tails</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td>[3]</td>
</tr>
<tr class="even">
<td>10</td>
<td>[3,10]</td>
</tr>
<tr class="odd">
<td>2</td>
<td>[2,10]</td>
</tr>
<tr class="even">
<td>1</td>
<td>[1,10]</td>
</tr>
<tr class="odd">
<td>20</td>
<td>[1,10,20]</td>
</tr>
</tbody>
</table>
<p>Answer = 3</p>
</section>
<section id="a-gentle-proof-why-it-works-8" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-8">A Gentle Proof (Why It Works)</h4>
<p>Invariant:</p>
<ul>
<li><code>tails[k]</code> = minimal possible tail of any increasing subsequence of length <code>k+1</code>.</li>
</ul>
<p>When we place <code>x</code>:</p>
<ul>
<li>Replacing a tail keeps subsequences valid (shorter or equal tail → more chance to extend).</li>
<li>Appending <code>x</code> grows the length by one.</li>
</ul>
<p>By induction:</p>
<ul>
<li>Each <code>tails[k]</code> is nondecreasing with length.</li>
<li>Final size of <code>tails</code> equals the LIS length, because every pile represents a distinct subsequence length.</li>
</ul>
</section>
<section id="try-it-yourself-21" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-21">Try It Yourself</h4>
<ol type="1">
<li>Track predecessors to reconstruct one LIS.</li>
<li>Modify to nondecreasing subsequence with <code>bisect_right</code>.</li>
<li>Compare counts with (O(n^2)) version.</li>
<li>Visualize piles after each insertion.</li>
<li>Use on 2D sorted pairs <code>(a,b)</code> for envelope problems.</li>
</ol>
</section>
<section id="test-cases-21" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-21">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[10,22,9,33,21,50,41,60]</td>
<td>5</td>
<td>classic</td>
</tr>
<tr class="even">
<td>[3,10,2,1,20]</td>
<td>3</td>
<td>{3,10,20}</td>
</tr>
<tr class="odd">
<td>[1,2,3,4,5]</td>
<td>5</td>
<td>already increasing</td>
</tr>
<tr class="even">
<td>[5,4,3,2,1]</td>
<td>1</td>
<td>decreasing</td>
</tr>
<tr class="odd">
<td>[2,2,2,2]</td>
<td>1</td>
<td>constant</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-21" class="level4">
<h4 class="anchored" data-anchor-id="complexity-21">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \log n)\)</span> (binary search per element)</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>The Patience Sorting LIS turns a quadratic DP into a sleek logarithmic method, a masterclass in trading space for insight.</p>
</section>
</section>
<section id="longest-common-subsequence-lcs" class="level3">
<h3 class="anchored" data-anchor-id="longest-common-subsequence-lcs">423 Longest Common Subsequence (LCS)</h3>
<p>The Longest Common Subsequence (LCS) problem finds the longest sequence that appears in the same relative order (not necessarily contiguous) in both strings. It is one of the most fundamental two-sequence DPs, and the basis of algorithms like diff, edit distance, and DNA alignment.</p>
<section id="what-problem-are-we-solving-22" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-22">What Problem Are We Solving?</h4>
<p>Given two sequences <span class="math display">\[
X = x_1, x_2, \dots, x_m,\quad Y = y_1, y_2, \dots, y_n
\]</span> find the length of the longest sequence that is a subsequence of both.</p>
<p>Define the state:</p>
<p><span class="math display">\[
dp[i][j] = \text{LCS length of prefixes } X[0..i-1],, Y[0..j-1]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
0, &amp; \text{if } i = 0 \text{ or } j = 0,\\
dp[i-1][j-1] + 1, &amp; \text{if } x_{i-1} = y_{j-1},\\
\max\big(dp[i-1][j],\, dp[i][j-1]\big), &amp; \text{if } x_{i-1} \ne y_{j-1}.
\end{cases}
\]</span></p>
<p>Answer:</p>
<p><span class="math display">\[
dp[m][n]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-22" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-22">How Does It Work (Plain Language)</h4>
<p>We build a grid where each cell <code>dp[i][j]</code> represents the LCS of the first <code>i</code> characters of <code>X</code> and the first <code>j</code> characters of <code>Y</code>.</p>
<ul>
<li>If the characters match, extend the subsequence diagonally.</li>
<li>If not, skip one character (either from <code>X</code> or <code>Y</code>) and take the better result.</li>
</ul>
<p>Think of it as aligning the two strings, step by step, and keeping the longest matching order.</p>
<p>Example: <code>X = "ABCBDAB"</code>, <code>Y = "BDCAB"</code></p>
<p>The longest common subsequence is <code>"BCAB"</code>, length 4.</p>
</section>
<section id="tiny-code-easy-versions-21" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-21">Tiny Code (Easy Versions)</h4>
<p>C (Classic 2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&gt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> X<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter first string: "</span><span class="op">);</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> X<span class="op">);</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter second string: "</span><span class="op">);</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> Y<span class="op">);</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>X<span class="op">[</span>m<span class="op">])</span> m<span class="op">++;</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>Y<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>X<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> Y<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LCS length: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter first string: "</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter second string: "</span>)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">len</span>(X), <span class="bu">len</span>(Y)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> Y[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LCS length:"</span>, dp[m][n])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-22" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-22">Why It Matters</h4>
<ul>
<li>Classic two-dimensional DP template</li>
<li>Core for Edit Distance, Sequence Alignment, Diff tools</li>
<li>Demonstrates subproblem reuse via overlapping prefixes</li>
<li>Helps understand table-filling and backtracking reconstruction</li>
</ul>
<p>LCS is where dynamic programming meets string similarity.</p>
</section>
<section id="step-by-step-example-21" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-21">Step-by-Step Example</h4>
<p><code>X = "ABCBDAB"</code>, <code>Y = "BDCAB"</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>j</th>
<th>X[i-1], Y[j-1]</th>
<th>dp[i][j]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>A, B</td>
<td>0</td>
<td>mismatch</td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td>B, B</td>
<td>1</td>
<td>match</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2</td>
<td>C, D</td>
<td>1</td>
<td>carry max</td>
</tr>
<tr class="even">
<td>4</td>
<td>3</td>
<td>B, C</td>
<td>1</td>
<td>carry max</td>
</tr>
<tr class="odd">
<td>5</td>
<td>4</td>
<td>D, A</td>
<td>2</td>
<td>later match</td>
</tr>
<tr class="even">
<td>7</td>
<td>5</td>
<td>B, B</td>
<td>4</td>
<td>full subsequence</td>
</tr>
</tbody>
</table>
<p>Answer = 4 (<code>"BCAB"</code>)</p>
</section>
<section id="a-gentle-proof-why-it-works-9" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-9">A Gentle Proof (Why It Works)</h4>
<p>By induction on <code>i</code> and <code>j</code>:</p>
<ul>
<li>Base: <span class="math inline">\(dp[0][j] = dp[i][0] = 0\)</span> (empty prefix)</li>
<li>If <span class="math inline">\(x_{i-1} = y_{j-1}\)</span>, every common subsequence of <code>X[0..i-2]</code> and <code>Y[0..j-2]</code> can be extended by this match.</li>
<li>If not equal, longest subsequence must exclude one character, hence <code>max</code> of left and top cells.</li>
</ul>
<p>Since each subproblem depends only on smaller prefixes, filling the table row by row ensures all dependencies are ready.</p>
</section>
<section id="try-it-yourself-22" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-22">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct the actual LCS (store direction or traceback).</li>
<li>Modify to handle case-insensitive matches.</li>
<li>Compare with Edit Distance formula.</li>
<li>Visualize table diagonal matches.</li>
<li>Use it to find diff between two lines of text.</li>
</ol>
</section>
<section id="test-cases-22" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-22">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>X</th>
<th>Y</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“ABCBDAB”</td>
<td>“BDCAB”</td>
<td>4</td>
<td>“BCAB”</td>
</tr>
<tr class="even">
<td>“AGGTAB”</td>
<td>“GXTXAYB”</td>
<td>4</td>
<td>“GTAB”</td>
</tr>
<tr class="odd">
<td>“AAAA”</td>
<td>“AA”</td>
<td>2</td>
<td>subset</td>
</tr>
<tr class="even">
<td>“ABC”</td>
<td>“DEF”</td>
<td>0</td>
<td>none</td>
</tr>
<tr class="odd">
<td>“”</td>
<td>“ABC”</td>
<td>0</td>
<td>base case</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-22" class="level4">
<h4 class="anchored" data-anchor-id="complexity-22">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(m \times n)\)</span></li>
<li>Space: <span class="math inline">\(O(m \times n)\)</span>, or <span class="math inline">\(O(\min(m,n))\)</span> with rolling arrays</li>
</ul>
<p>The Longest Common Subsequence teaches you to align two worlds, character by character, building similarity from shared order, not proximity.</p>
</section>
</section>
<section id="edit-distance-levenshtein-1" class="level3">
<h3 class="anchored" data-anchor-id="edit-distance-levenshtein-1">424 Edit Distance (Levenshtein)</h3>
<p>The Edit Distance (or Levenshtein Distance) problem measures how <em>different</em> two strings are by counting the minimum number of operations needed to transform one into the other. The allowed operations are usually insert, delete, and replace.</p>
<p>This is one of the most elegant two-dimensional DPs, it captures transformation cost between sequences step by step.</p>
<section id="what-problem-are-we-solving-23" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-23">What Problem Are We Solving?</h4>
<p>Given two strings <span class="math display">\[
X = x_1, x_2, \dots, x_m,\quad Y = y_1, y_2, \dots, y_n
\]</span> find the minimum number of operations to convert <code>X</code> into <code>Y</code>, using:</p>
<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
<p>We define the state:</p>
<p><span class="math display">\[
dp[i][j] = \text{minimum edits to convert } X[0..i-1] \text{ into } Y[0..j-1]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
i, &amp; \text{if } j = 0,\\
j, &amp; \text{if } i = 0,\\
dp[i-1][j-1], &amp; \text{if } x_{i-1} = y_{j-1},\\
1 + \min\big(dp[i-1][j],\ dp[i][j-1],\ dp[i-1][j-1]\big), &amp; \text{if } x_{i-1} \ne y_{j-1}.
\end{cases}
\]</span></p>
<ul>
<li><span class="math inline">\(dp[i-1][j] + 1\)</span> → delete<br>
</li>
<li><span class="math inline">\(dp[i][j-1] + 1\)</span> → insert<br>
</li>
<li><span class="math inline">\(dp[i-1][j-1] + 1\)</span> → replace</li>
</ul>
<p>Answer:</p>
<p><span class="math display">\[
dp[m][n]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-23" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-23">How Does It Work (Plain Language)</h4>
<p>We build a 2D grid comparing prefixes of both strings.</p>
<p>Each cell answers: <em>“What’s the cheapest way to make <code>X[:i]</code> look like <code>Y[:j]</code>?”</em></p>
<ul>
<li>If characters match, carry over the diagonal value.</li>
<li>If they differ, take the smallest cost among inserting, deleting, or replacing.</li>
</ul>
<p>Think of typing corrections: every operation moves you closer to the target.</p>
<p>Example: <code>X = "kitten"</code>, <code>Y = "sitting"</code> Operations:</p>
<ul>
<li>Replace <code>k</code> → <code>s</code></li>
<li>Replace <code>e</code> → <code>i</code></li>
<li>Insert <code>g</code></li>
</ul>
<p>Answer = 3</p>
</section>
<section id="tiny-code-easy-versions-22" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-22">Tiny Code (Easy Versions)</h4>
<p>C (2D DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min3<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span> <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>m <span class="op">&lt;</span> c<span class="op">)</span> <span class="op">?</span> m <span class="op">:</span> c<span class="op">;</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> X<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter first string: "</span><span class="op">);</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> X<span class="op">);</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter second string: "</span><span class="op">);</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> Y<span class="op">);</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>X<span class="op">[</span>m<span class="op">])</span> m<span class="op">++;</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>Y<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> min3<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Edit distance: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Compact Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter first string: "</span>)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter second string: "</span>)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">len</span>(X), <span class="bu">len</span>(Y)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> Y[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edit distance:"</span>, dp[m][n])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-23" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-23">Why It Matters</h4>
<ul>
<li>Foundation for spell checking, DNA alignment, fuzzy matching, and diff tools</li>
<li>Demonstrates multi-option recurrence (3 choices per state)</li>
<li>Basis for weighted edit distances (cost per operation)</li>
<li>Shows how to encode sequence transformation into DP</li>
</ul>
<p>It’s one of the cleanest examples where DP reveals the shortest transformation path.</p>
</section>
<section id="step-by-step-example-22" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-22">Step-by-Step Example</h4>
<p><code>X = "kitten"</code>, <code>Y = "sitting"</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>j</th>
<th>X[:i]</th>
<th>Y[:j]</th>
<th>dp[i][j]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>“”</td>
<td>“”</td>
<td>0</td>
<td>base</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>“k”</td>
<td>“s”</td>
<td>1</td>
<td>replace</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>“ki”</td>
<td>“si”</td>
<td>1</td>
<td>carry</td>
</tr>
<tr class="even">
<td>3</td>
<td>3</td>
<td>“kit”</td>
<td>“sit”</td>
<td>1</td>
<td>carry</td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
<td>“kitt”</td>
<td>“sitt”</td>
<td>1</td>
<td>carry</td>
</tr>
<tr class="even">
<td>5</td>
<td>5</td>
<td>“kitte”</td>
<td>“sitti”</td>
<td>2</td>
<td>replace</td>
</tr>
<tr class="odd">
<td>6</td>
<td>6</td>
<td>“kitten”</td>
<td>“sittin”</td>
<td>2</td>
<td>replace</td>
</tr>
<tr class="even">
<td>6</td>
<td>7</td>
<td>“kitten”</td>
<td>“sitting”</td>
<td>3</td>
<td>insert</td>
</tr>
</tbody>
</table>
<p>Answer = 3</p>
</section>
<section id="a-gentle-proof-why-it-works-10" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-10">A Gentle Proof (Why It Works)</h4>
<p>For each prefix pair <code>(i, j)</code>:</p>
<ul>
<li><p>If last chars match: no new cost, inherit <code>dp[i-1][j-1]</code>.</p></li>
<li><p>Else:</p>
<ul>
<li>Delete <code>X[i-1]</code> → <code>dp[i-1][j] + 1</code></li>
<li>Insert <code>Y[j-1]</code> → <code>dp[i][j-1] + 1</code></li>
<li>Replace <code>X[i-1]</code> with <code>Y[j-1]</code> → <code>dp[i-1][j-1] + 1</code></li>
</ul></li>
</ul>
<p>We choose the minimal option. By induction on <code>(i, j)</code>, every <code>dp[i][j]</code> is optimal, since it uses optimal subsolutions from smaller prefixes.</p>
</section>
<section id="try-it-yourself-23" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-23">Try It Yourself</h4>
<ol type="1">
<li>Print the sequence of operations (traceback from <code>dp[m][n]</code>).</li>
<li>Change costs: make replace = 2, others = 1.</li>
<li>Compare with LCS: <code>EditDistance = m + n - 2 × LCS</code>.</li>
<li>Handle insert/delete only (turn it into LCS variant).</li>
<li>Try with words like <code>"intention"</code> → <code>"execution"</code>.</li>
</ol>
</section>
<section id="test-cases-23" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-23">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>X</th>
<th>Y</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“kitten”</td>
<td>“sitting”</td>
<td>3</td>
<td>replace, replace, insert</td>
</tr>
<tr class="even">
<td>“flaw”</td>
<td>“lawn”</td>
<td>2</td>
<td>replace, insert</td>
</tr>
<tr class="odd">
<td>“abc”</td>
<td>“abc”</td>
<td>0</td>
<td>same</td>
</tr>
<tr class="even">
<td>“abc”</td>
<td>“yabd”</td>
<td>2</td>
<td>replace, insert</td>
</tr>
<tr class="odd">
<td>“”</td>
<td>“abc”</td>
<td>3</td>
<td>inserts</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-23" class="level4">
<h4 class="anchored" data-anchor-id="complexity-23">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(m \times n)\)</span></li>
<li>Space: <span class="math inline">\(O(m \times n)\)</span>, or <span class="math inline">\(O(\min(m,n))\)</span> with rolling rows</li>
</ul>
<p>The Edit Distance captures the very essence of transformation, how to reshape one structure into another, one careful operation at a time.</p>
</section>
</section>
<section id="longest-palindromic-subsequence" class="level3">
<h3 class="anchored" data-anchor-id="longest-palindromic-subsequence">425 Longest Palindromic Subsequence</h3>
<p>The Longest Palindromic Subsequence (LPS) problem finds the longest sequence that reads the same forward and backward, not necessarily contiguous. It’s a classic two-dimensional DP, and a mirror image of the Longest Common Subsequence (LCS), but here, we compare a string with its reverse.</p>
<section id="what-problem-are-we-solving-24" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-24">What Problem Are We Solving?</h4>
<p>Given a string <span class="math display">\[
S = s_1, s_2, \dots, s_n
\]</span> find the length of the longest subsequence that is a palindrome.</p>
<p>Define the state:</p>
<p><span class="math display">\[
dp[i][j] = \text{LPS length in substring } S[i..j]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
1, &amp; \text{if } i = j,\\
2 + dp[i+1][j-1], &amp; \text{if } s_i = s_j,\\
\max\big(dp[i+1][j],\, dp[i][j-1]\big), &amp; \text{if } s_i \ne s_j.
\end{cases}
\]</span></p>
<p>Base case: <span class="math display">\[
dp[i][i] = 1
\]</span></p>
<p>Final answer: <span class="math display">\[
dp[0][n-1]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-24" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-24">How Does It Work (Plain Language)</h4>
<p>We expand outward between two indices <code>i</code> and <code>j</code>:</p>
<ul>
<li>If the characters match, they can wrap a smaller palindrome inside.</li>
<li>If not, skip one character (either start or end) and try again.</li>
</ul>
<p>Think of it as <em>folding the string onto itself</em>, one matching pair at a time.</p>
<p>Example: <code>S = "bbbab"</code></p>
<p>LPS = <code>"bbbb"</code> (length 4)</p>
</section>
<section id="tiny-code-easy-versions-23" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-23">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up 2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&gt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> S<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter string: "</span><span class="op">);</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> S<span class="op">);</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>S<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> len<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>S<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> len <span class="op">==</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>S<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>j<span class="op">])</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LPS length: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Clean DP Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter string: "</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(S)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    dp[i][i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> S[i] <span class="op">==</span> S[j]:</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> (dp[i<span class="op">+</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="cf">if</span> length <span class="op">&gt;</span> <span class="dv">2</span> <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">+</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LPS length:"</span>, dp[<span class="dv">0</span>][n<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-24" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-24">Why It Matters</h4>
<ul>
<li>Core DP on substrings (interval DP)</li>
<li>Connects to LCS: [ (S) = (S, (S))]</li>
<li>Foundation for Palindrome Partitioning, String Reconstruction, and DNA symmetry problems</li>
<li>Teaches two-pointer DP intuition</li>
</ul>
<p>The LPS shows how symmetry and substructure intertwine.</p>
</section>
<section id="step-by-step-example-23" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-23">Step-by-Step Example</h4>
<p><code>S = "bbbab"</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>j</th>
<th>S[i..j]</th>
<th>dp[i][j]</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>b</td>
<td>1</td>
<td>single char</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>b</td>
<td>1</td>
<td>single char</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>b</td>
<td>1</td>
<td>single char</td>
</tr>
<tr class="even">
<td>3</td>
<td>3</td>
<td>a</td>
<td>1</td>
<td>single char</td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
<td>b</td>
<td>1</td>
<td>single char</td>
</tr>
<tr class="even">
<td>2</td>
<td>4</td>
<td>“bab”</td>
<td>3</td>
<td>b + a + b</td>
</tr>
<tr class="odd">
<td>1</td>
<td>4</td>
<td>“bbab”</td>
<td>3</td>
<td>wrap b’s</td>
</tr>
<tr class="even">
<td>0</td>
<td>4</td>
<td>“bbbab”</td>
<td>4</td>
<td>b + (bb a b) + b</td>
</tr>
</tbody>
</table>
<p>Answer = 4 (<code>"bbbb"</code>)</p>
</section>
<section id="a-gentle-proof-why-it-works-11" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-11">A Gentle Proof (Why It Works)</h4>
<p>For substring <code>S[i..j]</code>:</p>
<ul>
<li><p>If <code>s_i == s_j</code>: both ends can contribute to a longer palindrome, add 2 around <code>dp[i+1][j-1]</code>.</p></li>
<li><p>If <code>s_i != s_j</code>: one of them can’t be in the palindrome, skip either <code>i</code> or <code>j</code> and take max.</p></li>
</ul>
<p>By filling increasing substring lengths, every subproblem is solved before it’s needed.</p>
</section>
<section id="try-it-yourself-24" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-24">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct one longest palindrome using backtracking.</li>
<li>Compare with <code>LCS(S, reverse(S))</code> result.</li>
<li>Try on <code>"cbbd"</code>, <code>"agbdba"</code>.</li>
<li>Modify to count number of distinct palindromic subsequences.</li>
<li>Visualize table diagonals (bottom-up growth).</li>
</ol>
</section>
<section id="test-cases-24" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-24">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>S</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“bbbab”</td>
<td>4</td>
<td>“bbbb”</td>
</tr>
<tr class="even">
<td>“cbbd”</td>
<td>2</td>
<td>“bb”</td>
</tr>
<tr class="odd">
<td>“agbdba”</td>
<td>5</td>
<td>“abdba”</td>
</tr>
<tr class="even">
<td>“abcd”</td>
<td>1</td>
<td>any single char</td>
</tr>
<tr class="odd">
<td>“aaa”</td>
<td>3</td>
<td>whole string</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-24" class="level4">
<h4 class="anchored" data-anchor-id="complexity-24">Complexity</h4>
<ul>
<li>Time: (O(n^2))</li>
<li>Space: (O(n^2)), reducible with rolling arrays</li>
</ul>
<p>The Longest Palindromic Subsequence is a mirror held up to your string, revealing the symmetry hidden within.</p>
</section>
</section>
<section id="shortest-common-supersequence-scs" class="level3">
<h3 class="anchored" data-anchor-id="shortest-common-supersequence-scs">426 Shortest Common Supersequence (SCS)</h3>
<p>The Shortest Common Supersequence (SCS) problem asks for the shortest string that contains both given strings as subsequences. It’s like merging two sequences together without breaking order, balancing overlap and inclusion.</p>
<p>This problem is a close companion to LCS, in fact, its length can be directly expressed in terms of the Longest Common Subsequence.</p>
<section id="what-problem-are-we-solving-25" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-25">What Problem Are We Solving?</h4>
<p>Given two strings <span class="math display">\[
X = x_1, x_2, \dots, x_m,\quad Y = y_1, y_2, \dots, y_n
\]</span> find the length of the shortest string that contains both as subsequences.</p>
<p>Define the state:</p>
<p><span class="math display">\[
dp[i][j] = \text{length of SCS of prefixes } X[0..i-1] \text{ and } Y[0..j-1]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
i, &amp; \text{if } j = 0,\\
j, &amp; \text{if } i = 0,\\
1 + dp[i-1][j-1], &amp; \text{if } x_{i-1} = y_{j-1},\\
1 + \min\big(dp[i-1][j],\ dp[i][j-1]\big), &amp; \text{if } x_{i-1} \ne y_{j-1}.
\end{cases}
\]</span></p>
<p>Answer: <span class="math display">\[
dp[m][n]
\]</span></p>
<p>Alternate formula: <span class="math display">\[
\text{SCS length} = m + n - \text{LCS length}
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-25" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-25">How Does It Work (Plain Language)</h4>
<p>If two characters match, you include it once and move diagonally. If they differ, include one character and move toward the smaller subproblem (skipping one side). You’re building the shortest merged string preserving both orders.</p>
<p>Think of it as stitching the two sequences together with minimal redundancy.</p>
<p>Example: <code>X = "AGGTAB"</code>, <code>Y = "GXTXAYB"</code></p>
<p>LCS = <code>"GTAB"</code> (length 4)</p>
<p>So: <span class="math display">\[
\text{SCS length} = 6 + 7 - 4 = 9
\]</span></p>
<p>SCS = <code>"AGXGTXAYB"</code></p>
</section>
<section id="tiny-code-easy-versions-24" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-24">Tiny Code (Easy Versions)</h4>
<p>C (DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&lt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> X<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter first string: "</span><span class="op">);</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> X<span class="op">);</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter second string: "</span><span class="op">);</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> Y<span class="op">);</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>X<span class="op">[</span>m<span class="op">])</span> m<span class="op">++;</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>Y<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> MIN<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"SCS length: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Straightforward DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter first string: "</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter second string: "</span>)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">len</span>(X), <span class="bu">len</span>(Y)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> Y[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SCS length:"</span>, dp[m][n])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-25" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-25">Why It Matters</h4>
<ul>
<li>Shows merging sequences with order preservation</li>
<li>Ties directly to LCS via the formula</li>
<li>Useful for file merging, version control, and sequence alignment</li>
<li>Demonstrates minimal superstructure over two DPs</li>
</ul>
<p>It’s the “union” counterpart to the “intersection” of LCS.</p>
</section>
<section id="step-by-step-example-24" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-24">Step-by-Step Example</h4>
<p><code>X = "AGGTAB"</code>, <code>Y = "GXTXAYB"</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compare A,G</td>
<td>differ</td>
<td>choose A</td>
</tr>
<tr class="even">
<td>Compare G,G</td>
<td>match</td>
<td>add G</td>
</tr>
<tr class="odd">
<td>Compare G,X</td>
<td>differ</td>
<td>add X</td>
</tr>
<tr class="even">
<td>Compare G,T</td>
<td>differ</td>
<td>add T</td>
</tr>
<tr class="odd">
<td>Compare T,X</td>
<td>differ</td>
<td>add X</td>
</tr>
<tr class="even">
<td>Compare A,A</td>
<td>match</td>
<td>add A</td>
</tr>
<tr class="odd">
<td>Compare B,B</td>
<td>match</td>
<td>add B</td>
</tr>
</tbody>
</table>
<p>SCS = <code>"AGXGTXAYB"</code></p>
<p>Length = 9</p>
</section>
<section id="a-gentle-proof-why-it-works-12" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-12">A Gentle Proof (Why It Works)</h4>
<p>Every SCS must include all characters of both strings in order.</p>
<ul>
<li>If last chars match: append once → <code>1 + dp[i-1][j-1]</code></li>
<li>Else, shortest option comes from skipping one character from either string.</li>
</ul>
<p>By induction on <code>(i, j)</code>, since subproblems solve strictly smaller prefixes, we get optimal length.</p>
<p>The equivalence <span class="math display">\[
|SCS| = m + n - |LCS|
\]</span> follows because overlapping LCS chars are counted twice when summing lengths, and must be subtracted once.</p>
</section>
<section id="try-it-yourself-25" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-25">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct actual SCS string (traceback from <code>dp[m][n]</code>).</li>
<li>Verify <code>|SCS| = |X| + |Y| - |LCS|</code>.</li>
<li>Compare SCS vs concatenation <code>X + Y</code>.</li>
<li>Apply to sequences with no overlap.</li>
<li>Test with identical strings (SCS = same string).</li>
</ol>
</section>
<section id="test-cases-25" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-25">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>X</th>
<th>Y</th>
<th>Expected Length</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“AGGTAB”</td>
<td>“GXTXAYB”</td>
<td>9</td>
<td>overlap GTAB</td>
</tr>
<tr class="even">
<td>“ABCBDAB”</td>
<td>“BDCAB”</td>
<td>9</td>
<td>shares BCAB</td>
</tr>
<tr class="odd">
<td>“HELLO”</td>
<td>“GEEK”</td>
<td>8</td>
<td>no big overlap</td>
</tr>
<tr class="even">
<td>“AB”</td>
<td>“AB”</td>
<td>2</td>
<td>identical</td>
</tr>
<tr class="odd">
<td>“AB”</td>
<td>“CD”</td>
<td>4</td>
<td>disjoint</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-25" class="level4">
<h4 class="anchored" data-anchor-id="complexity-25">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(m \times n)\)</span></li>
<li>Space: <span class="math inline">\(O(m \times n)\)</span>, or <span class="math inline">\(O(\min(m,n))\)</span> for length only</li>
</ul>
<p>The Shortest Common Supersequence weaves two strings into one, the tightest possible thread that holds both stories together.</p>
</section>
</section>
<section id="longest-repeated-subsequence" class="level3">
<h3 class="anchored" data-anchor-id="longest-repeated-subsequence">427 Longest Repeated Subsequence</h3>
<p>The Longest Repeated Subsequence (LRS) of a string is the longest subsequence that appears at least twice in the string without reusing the same index position. It is like LCS of a string with itself, with an extra constraint to avoid matching a character with itself.</p>
<section id="what-problem-are-we-solving-26" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-26">What Problem Are We Solving?</h4>
<p>Given a string <span class="math display">\[
S = s_1, s_2, \dots, s_n
\]</span> find the length of the longest subsequence that occurs at least twice in (S) with disjoint index positions.</p>
<p>Define the state by comparing the string with itself:</p>
<p><span class="math display">\[
dp[i][j] = \text{LRS length for } S[1..i] \text{ and } S[1..j]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
0, &amp; \text{if } i = 0 \text{ or } j = 0,\\
1 + dp[i-1][j-1], &amp; \text{if } s_i = s_j \text{ and } i \ne j,\\
\max\big(dp[i-1][j],\, dp[i][j-1]\big), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Answer: <span class="math display">\[
dp[n][n]
\]</span></p>
<p>The key difference from LCS is the constraint <span class="math inline">\(i \ne j\)</span> to prevent matching the same occurrence of a character.</p>
</section>
<section id="how-does-it-work-plain-language-26" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-26">How Does It Work (Plain Language)</h4>
<p>Think of aligning the string with itself. You are looking for common subsequences, but you are not allowed to match a character to its identical position. When characters match at different positions, you extend the repeated subsequence. When they do not match or are at the same position, you take the best from skipping one side.</p>
<p>Example: <code>S = "aabebcdd"</code> One LRS is <code>"abd"</code> with length 3.</p>
</section>
<section id="tiny-code-easy-versions-25" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-25">Tiny Code (Easy Versions)</h4>
<p>C (2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb53"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&gt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> S<span class="op">[</span><span class="dv">1005</span><span class="op">];</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter string: "</span><span class="op">);</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> S<span class="op">);</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="cf">while</span> <span class="op">(</span>S<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>S<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> i <span class="op">!=</span> j<span class="op">)</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LRS length: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Straightforward DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter string: "</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(S)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> S[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> S[j<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> i <span class="op">!=</span> j:</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LRS length:"</span>, dp[n][n])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-26" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-26">Why It Matters</h4>
<ul>
<li>Illustrates transforming a problem into LCS on the same string with a simple constraint.</li>
<li>Useful for detecting repeated patterns and compression signals.</li>
<li>Builds intuition for self-alignment DPs and index constraints.</li>
</ul>
</section>
<section id="step-by-step-example-25" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-25">Step by Step Example</h4>
<p><code>S = "aabebcdd"</code> Let us look at the alignment idea:</p>
<ul>
<li><p>Matching pairs at different indices:</p>
<ul>
<li><code>a</code> at positions 1 and 2 can contribute, but not with the same index.</li>
<li><code>b</code> at positions 3 and 6.</li>
<li><code>d</code> at positions 7 and 8.</li>
</ul></li>
</ul>
<p>A valid repeated subsequence is <code>"abd"</code> using indices <code>(1,3,7)</code> and <code>(2,6,8)</code>. Length (= 3).</p>
</section>
<section id="a-gentle-proof-why-it-works-13" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-13">A Gentle Proof (Why It Works)</h4>
<p>Consider LCS of (S) with itself:</p>
<ul>
<li>If you allowed matches at the same indices, you would trivially match every character with itself and get (n).</li>
<li>By forbidding matches where (i = j), any character contributes only when there exists another occurrence at a different index.</li>
<li>The recurrence mirrors LCS but enforces (i j).</li>
<li>By induction on (i, j), the table accumulates exactly the lengths of repeated subsequences, and the maximum at (dp[n][n]) is the LRS length.</li>
</ul>
</section>
<section id="try-it-yourself-26" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-26">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct one LRS by tracing back from (dp[n][n]) while respecting (i j).</li>
<li>Modify to count the number of distinct LRS of maximum length.</li>
<li>Compare LRS and LPS on the same string to see structural differences.</li>
<li>Handle ties when reconstructing to get the lexicographically smallest LRS.</li>
<li>Test behavior on strings with all unique characters.</li>
</ol>
</section>
<section id="test-cases-26" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-26">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>S</th>
<th>Expected LRS length</th>
<th>One LRS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“aabebcdd”</td>
<td>3</td>
<td>“abd”</td>
</tr>
<tr class="even">
<td>“axxxy”</td>
<td>2</td>
<td>“xx”</td>
</tr>
<tr class="odd">
<td>“aaaa”</td>
<td>3</td>
<td>“aaa”</td>
</tr>
<tr class="even">
<td>“abc”</td>
<td>0</td>
<td>“”</td>
</tr>
<tr class="odd">
<td>“aaba”</td>
<td>2</td>
<td>“aa”</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-26" class="level4">
<h4 class="anchored" data-anchor-id="complexity-26">Complexity</h4>
<ul>
<li>Time: (O(n^2))</li>
<li>Space: (O(n^2))</li>
</ul>
<p>The Longest Repeated Subsequence is LCS turned inward. Compare the string with itself, forbid identical positions, and the repeated pattern reveals itself.</p>
</section>
</section>
<section id="string-interleaving" class="level3">
<h3 class="anchored" data-anchor-id="string-interleaving">428 String Interleaving</h3>
<p>The String Interleaving problem asks whether a string <span class="math inline">\(S\)</span> can be formed by interleaving (or weaving together) two other strings <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> while preserving the relative order of characters from each.</p>
<p>It’s a dynamic programming problem that elegantly captures sequence merging under order constraints, similar in spirit to merging two sorted lists.</p>
<section id="what-problem-are-we-solving-27" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-27">What Problem Are We Solving?</h4>
<p>Given three strings <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span>, and <span class="math inline">\(S\)</span>, determine if <span class="math inline">\(S\)</span> is a valid interleaving of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</p>
<p>We define the state:</p>
<p><span class="math display">\[
dp[i][j] = \text{True if } S[0..i+j-1] \text{ can be formed by interleaving } X[0..i-1] \text{ and } Y[0..j-1]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
dp[i-1][j], &amp; \text{if } X[i-1] = S[i+j-1] \text{ and } dp[i-1][j],\\
dp[i][j-1], &amp; \text{if } Y[j-1] = S[i+j-1] \text{ and } dp[i][j-1],\\
dp[i-1][j] \lor dp[i][j-1], &amp; \text{if both conditions hold.}
\end{cases}
\]</span></p>
<p>Base conditions:</p>
<p><span class="math display">\[
dp[0][0] = \text{True}
\]</span></p>
<p><span class="math display">\[
dp[i][0] = dp[i-1][0] \land (X[i-1] = S[i-1])
\]</span></p>
<p><span class="math display">\[
dp[0][j] = dp[0][j-1] \land (Y[j-1] = S[j-1])
\]</span></p>
<p>Answer:</p>
<p><span class="math display">\[
dp[m][n]
\]</span></p>
<p>where <span class="math inline">\(m = |X|\)</span>, <span class="math inline">\(n = |Y|\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-27" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-27">How Does It Work (Plain Language)</h4>
<p>You have two input strings <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, and you’re asked whether you can merge them in order to get <span class="math inline">\(S\)</span>.</p>
<p>Each step, decide whether the next character in <span class="math inline">\(S\)</span> should come from <span class="math inline">\(X\)</span> or <span class="math inline">\(Y\)</span>, as long as you don’t break the order within either.</p>
<p>Imagine reading from two ribbons of characters, you can switch between them but never rearrange within a ribbon.</p>
<p>Example: <span class="math inline">\(X = \text{"abc"}\)</span>, <span class="math inline">\(Y = \text{"def"}\)</span>, <span class="math inline">\(S = \text{"adbcef"}\)</span></p>
<p>Valid interleaving: <span class="math inline">\(a\)</span> (from <span class="math inline">\(X\)</span>), <span class="math inline">\(d\)</span> (from <span class="math inline">\(Y\)</span>), <span class="math inline">\(b\)</span> (from <span class="math inline">\(X\)</span>), <span class="math inline">\(c\)</span> (from <span class="math inline">\(X\)</span>), <span class="math inline">\(e\)</span> (from <span class="math inline">\(Y\)</span>), <span class="math inline">\(f\)</span> (from <span class="math inline">\(Y\)</span>)</p>
</section>
<section id="tiny-code-easy-versions-26" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-26">Tiny Code (Easy Versions)</h4>
<p>C (2D Boolean DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb55"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isInterleave<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>X<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>Y<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>S<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>X<span class="op">),</span> n <span class="op">=</span> strlen<span class="op">(</span>Y<span class="op">);</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">+</span> n <span class="op">!=</span> strlen<span class="op">(</span>S<span class="op">))</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> dp<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&amp;&amp;</span> X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>i<span class="op">+</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">|=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> S<span class="op">[</span>i<span class="op">+</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">|=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> X<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">100</span><span class="op">],</span> S<span class="op">[</span><span class="dv">200</span><span class="op">];</span></span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter X: "</span><span class="op">);</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> X<span class="op">);</span></span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter Y: "</span><span class="op">);</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> Y<span class="op">);</span></span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter S: "</span><span class="op">);</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> S<span class="op">);</span></span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isInterleave<span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> S<span class="op">))</span></span>
<span id="cb55-36"><a href="#cb55-36" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Yes, S is an interleaving of X and Y.</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb55-37"><a href="#cb55-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb55-38"><a href="#cb55-38" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"No, S cannot be formed.</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb55-39"><a href="#cb55-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-40"><a href="#cb55-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb55-41"><a href="#cb55-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple DP Table)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter X: "</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter Y: "</span>)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter S: "</span>)</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">len</span>(X), <span class="bu">len</span>(Y)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(S) <span class="op">!=</span> m <span class="op">+</span> n:</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"No"</span>)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="kw">and</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> S[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> Y[j<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> S[j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> (X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> S[i<span class="op">+</span>j<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> dp[i<span class="op">-</span><span class="dv">1</span>][j]) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>                       (Y[j<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> S[i<span class="op">+</span>j<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Yes"</span> <span class="cf">if</span> dp[m][n] <span class="cf">else</span> <span class="st">"No"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-27" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-27">Why It Matters</h4>
<ul>
<li>Demonstrates two-sequence merging under order constraints</li>
<li>Core idea behind path interleaving, merge scheduling, and string weaving</li>
<li>Good stepping stone for problems involving 2D grid DPs and string constraints</li>
</ul>
</section>
<section id="step-by-step-example-26" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-26">Step-by-Step Example</h4>
<p><span class="math inline">\(X = \text{"abc"}\)</span>, <span class="math inline">\(Y = \text{"def"}\)</span>, <span class="math inline">\(S = \text{"adbcef"}\)</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>j</th>
<th>X[:i]</th>
<th>Y[:j]</th>
<th>dp[i][j]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>“”</td>
<td>“”</td>
<td>T</td>
<td>base</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>a</td>
<td>“”</td>
<td>T</td>
<td>a from X</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>a</td>
<td>d</td>
<td>T</td>
<td>d from Y</td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td>ab</td>
<td>d</td>
<td>T</td>
<td>b from X</td>
</tr>
<tr class="odd">
<td>3</td>
<td>1</td>
<td>abc</td>
<td>d</td>
<td>F</td>
<td>cannot match next</td>
</tr>
<tr class="even">
<td>3</td>
<td>2</td>
<td>abc</td>
<td>de</td>
<td>T</td>
<td>e from Y</td>
</tr>
<tr class="odd">
<td>3</td>
<td>3</td>
<td>abc</td>
<td>def</td>
<td>T</td>
<td>f from Y</td>
</tr>
</tbody>
</table>
<p>Answer: True</p>
</section>
<section id="a-gentle-proof-why-it-works-14" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-14">A Gentle Proof (Why It Works)</h4>
<p>At any point, we have used <span class="math inline">\(i + j\)</span> characters from <span class="math inline">\(S\)</span>:</p>
<ul>
<li>If last came from <span class="math inline">\(X\)</span>: <span class="math inline">\(X[i-1] = S[i+j-1]\)</span> and <span class="math inline">\(dp[i-1][j]\)</span> was True</li>
<li>If last came from <span class="math inline">\(Y\)</span>: <span class="math inline">\(Y[j-1] = S[i+j-1]\)</span> and <span class="math inline">\(dp[i][j-1]\)</span> was True</li>
</ul>
<p>By filling the table left-to-right, top-to-bottom, every prefix is validated before combining. Inductive reasoning ensures correctness for all prefixes.</p>
</section>
<section id="try-it-yourself-27" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-27">Try It Yourself</h4>
<ol type="1">
<li>Print one valid interleaving path</li>
<li>Modify to count total interleavings</li>
<li>Handle strings with duplicate characters carefully</li>
<li>Try on examples where <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> share common prefixes</li>
<li>Extend to three strings interleaving</li>
</ol>
</section>
<section id="test-cases-27" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-27">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>X</th>
<th>Y</th>
<th>S</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“abc”</td>
<td>“def”</td>
<td>“adbcef”</td>
<td>True</td>
</tr>
<tr class="even">
<td>“ab”</td>
<td>“cd”</td>
<td>“abcd”</td>
<td>True</td>
</tr>
<tr class="odd">
<td>“ab”</td>
<td>“cd”</td>
<td>“acbd”</td>
<td>True</td>
</tr>
<tr class="even">
<td>“ab”</td>
<td>“cd”</td>
<td>“acdb”</td>
<td>False</td>
</tr>
<tr class="odd">
<td>“aa”</td>
<td>“ab”</td>
<td>“aaba”</td>
<td>True</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-27" class="level4">
<h4 class="anchored" data-anchor-id="complexity-27">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(m \times n)\)</span></li>
<li>Space: <span class="math inline">\(O(m \times n)\)</span>, can be reduced to <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>The String Interleaving problem is about harmony, weaving two sequences together, letter by letter, in perfect order.</p>
</section>
</section>
<section id="sequence-alignment-bioinformatics" class="level3">
<h3 class="anchored" data-anchor-id="sequence-alignment-bioinformatics">429 Sequence Alignment (Bioinformatics)</h3>
<p>The Sequence Alignment problem asks how to best align two sequences (often DNA, RNA, or proteins) to measure their similarity, allowing for gaps and mismatches. It forms the foundation of bioinformatics, string similarity, and edit-based scoring systems.</p>
<p>Unlike edit distance, sequence alignment assigns scores for matches, mismatches, and gaps, and seeks a maximum score, not a minimal edit count.</p>
<section id="what-problem-are-we-solving-28" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-28">What Problem Are We Solving?</h4>
<p>Given two sequences <span class="math display">\[
X = x_1, x_2, \dots, x_m, \quad Y = y_1, y_2, \dots, y_n
\]</span> and scoring rules:</p>
<ul>
<li><span class="math inline">\(+1\)</span> for a match</li>
<li><span class="math inline">\(-1\)</span> for a mismatch</li>
<li><span class="math inline">\(-2\)</span> for a gap (insertion/deletion)</li>
</ul>
<p>we want to find an alignment of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> that maximizes the total score.</p>
<p>We define the state:</p>
<p><span class="math display">\[
dp[i][j] = \text{maximum alignment score between } X[0..i-1] \text{ and } Y[0..j-1]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\max
\begin{cases}
dp[i-1][j-1] + \text{score}(x_{i-1}, y_{j-1}) \
dp[i-1][j] + \text{gap penalty} \
dp[i][j-1] + \text{gap penalty}
\end{cases}
\]</span></p>
<p>Base:</p>
<p><span class="math display">\[
dp[i][0] = i \times \text{gap penalty}, \quad dp[0][j] = j \times \text{gap penalty}
\]</span></p>
<p>Answer: <span class="math inline">\(dp[m][n]\)</span></p>
</section>
<section id="how-does-it-work-plain-language-28" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-28">How Does It Work (Plain Language)</h4>
<p>We fill a grid where each cell <span class="math inline">\((i, j)\)</span> represents the best score to align the first <span class="math inline">\(i\)</span> characters of <span class="math inline">\(X\)</span> with the first <span class="math inline">\(j\)</span> of <span class="math inline">\(Y\)</span>.</p>
<p>At each step, we decide:</p>
<ol type="1">
<li>Match/Mismatch (<span class="math inline">\(x_{i-1}\)</span> with <span class="math inline">\(y_{j-1}\)</span>)</li>
<li>Insert a gap in <span class="math inline">\(Y\)</span> (skip character in <span class="math inline">\(X\)</span>)</li>
<li>Insert a gap in <span class="math inline">\(X\)</span> (skip character in <span class="math inline">\(Y\)</span>)</li>
</ol>
<p>The final cell holds the optimal alignment score. Tracing back reveals the aligned strings, with dashes representing gaps.</p>
<p>Example:</p>
<p><span class="math inline">\(X = \text{"GATTACA"}\)</span> <span class="math inline">\(Y = \text{"GCATGCU"}\)</span></p>
<p>One alignment:</p>
<pre><code>G A T T A C A -
| |   |   | |
G - C A T G C U</code></pre>
</section>
<section id="tiny-code-easy-versions-27" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-27">Tiny Code (Easy Versions)</h4>
<p>C (Global Alignment / Needleman–Wunsch)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb58"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">&gt;</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">?</span><span class="pp"> </span><span class="op">(</span><span class="pp">a</span><span class="op">)</span><span class="pp"> </span><span class="op">:</span><span class="pp"> </span><span class="op">(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> score<span class="op">(</span><span class="dt">char</span> a<span class="op">,</span> <span class="dt">char</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">==</span> b <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> X<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter X: "</span><span class="op">);</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> X<span class="op">);</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter Y: "</span><span class="op">);</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> Y<span class="op">);</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>X<span class="op">[</span>m<span class="op">])</span> m<span class="op">++;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>Y<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> gap <span class="op">=</span> <span class="op">-</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> gap<span class="op">;</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j <span class="op">*</span> gap<span class="op">;</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> match <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> score<span class="op">(</span>X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">],</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> delete <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> gap<span class="op">;</span></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> insert <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> gap<span class="op">;</span></span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> MAX<span class="op">(</span>match<span class="op">,</span> MAX<span class="op">(</span>delete<span class="op">,</span> insert<span class="op">));</span></span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max alignment score: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Clean Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter X: "</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter Y: "</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">len</span>(X), <span class="bu">len</span>(Y)</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>match, mismatch, gap <span class="op">=</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    dp[i][<span class="dv">0</span>] <span class="op">=</span> i <span class="op">*</span> gap</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][j] <span class="op">=</span> j <span class="op">*</span> gap</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>        score <span class="op">=</span> match <span class="cf">if</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> Y[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>        dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>            dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> score,</span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>            dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>            dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max alignment score:"</span>, dp[m][n])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-28" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-28">Why It Matters</h4>
<ul>
<li>Foundational in bioinformatics (DNA, RNA, protein comparison)</li>
<li>Used in spell correction, plagiarism detection, text similarity</li>
<li>Shows a weighted DP with scores, not just counts</li>
<li>Demonstrates path reconstruction with multiple decisions</li>
</ul>
<p>This is the generalization of edit distance to <em>scored alignment</em>.</p>
</section>
<section id="step-by-step-example-27" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-27">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(X = \text{"AGT"}\)</span>, <span class="math inline">\(Y = \text{"GTT"}\)</span> Match <span class="math inline">\(= +1\)</span>, Mismatch <span class="math inline">\(= -1\)</span>, Gap <span class="math inline">\(= -2\)</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>j</th>
<th><span class="math inline">\(X[0..i]\)</span></th>
<th><span class="math inline">\(Y[0..j]\)</span></th>
<th><span class="math inline">\(dp[i][j]\)</span></th>
<th>Choice</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>A, G</td>
<td>G</td>
<td>-1</td>
<td>mismatch</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>AG, GT</td>
<td>GT</td>
<td>+0</td>
<td>align G</td>
</tr>
<tr class="odd">
<td>3</td>
<td>3</td>
<td>AGT, GTT</td>
<td>GTT</td>
<td>+1</td>
<td>align T</td>
</tr>
</tbody>
</table>
<p>Answer = +1</p>
</section>
<section id="a-gentle-proof-why-it-works-15" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-15">A Gentle Proof (Why It Works)</h4>
<p>Each <span class="math inline">\(dp[i][j]\)</span> represents the best possible score achievable aligning <span class="math inline">\(X[0..i-1]\)</span> and <span class="math inline">\(Y[0..j-1]\)</span>. Induction ensures correctness:</p>
<ul>
<li>Base: <span class="math inline">\(dp[0][j], dp[i][0]\)</span> handle leading gaps</li>
<li>Step: At each <span class="math inline">\((i, j)\)</span>, you consider all valid transitions, match/mismatch, insert, delete, and take the max. Thus <span class="math inline">\(dp[m][n]\)</span> is globally optimal.</li>
</ul>
</section>
<section id="try-it-yourself-28" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-28">Try It Yourself</h4>
<ol type="1">
<li>Trace back to print alignment with gaps</li>
<li>Try different scoring systems</li>
<li>Compare global (Needleman–Wunsch) vs local (Smith–Waterman) alignment</li>
<li>Handle affine gaps (gap opening + extension)</li>
<li>Visualize grid paths as alignments</li>
</ol>
</section>
<section id="test-cases-28" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-28">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>X</th>
<th>Y</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“AGT”</td>
<td>“GTT”</td>
<td>1</td>
<td>one match</td>
</tr>
<tr class="even">
<td>“GATTACA”</td>
<td>“GCATGCU”</td>
<td>depends on scoring</td>
<td>classic</td>
</tr>
<tr class="odd">
<td>“ABC”</td>
<td>“ABC”</td>
<td>3</td>
<td>all match</td>
</tr>
<tr class="even">
<td>“ABC”</td>
<td>“DEF”</td>
<td>-3</td>
<td>all mismatch</td>
</tr>
<tr class="odd">
<td>“A”</td>
<td>“AAA”</td>
<td>-2</td>
<td>gaps added</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-28" class="level4">
<h4 class="anchored" data-anchor-id="complexity-28">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(m \times n)\)</span></li>
<li>Space: <span class="math inline">\(O(m \times n)\)</span> (can be reduced with row-rolling)</li>
</ul>
<p>The Sequence Alignment problem teaches that similarity is not just about matches, it’s about balancing alignments, mismatches, and gaps to find the best correspondence between two sequences.</p>
</section>
</section>
<section id="diff-algorithm-myers-dp" class="level3">
<h3 class="anchored" data-anchor-id="diff-algorithm-myers-dp">430 Diff Algorithm (Myers / DP)</h3>
<p>The Diff Algorithm compares two sequences and finds their shortest edit script (SES), the minimal sequence of insertions and deletions required to transform one into the other. It’s the heart of tools like <code>git diff</code> and <code>diff</code>, providing human-readable change summaries.</p>
<p>The Myers Algorithm is the most famous linear-space implementation, but the DP formulation builds on edit distance and LCS intuition.</p>
<section id="what-problem-are-we-solving-29" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-29">What Problem Are We Solving?</h4>
<p>Given two strings <span class="math display">\[
X = x_1, x_2, \dots, x_m, \quad Y = y_1, y_2, \dots, y_n
\]</span> find a minimal sequence of edits (insertions and deletions) to turn <span class="math inline">\(X\)</span> into <span class="math inline">\(Y\)</span>.</p>
<p>Each edit transforms one sequence toward the other, and matching characters are left untouched.</p>
<p>The minimal number of edits equals:</p>
<p><span class="math display">\[
\text{SES length} = m + n - 2 \times \text{LCS length}
\]</span></p>
<p>We can also explicitly trace the path to recover the diff.</p>
</section>
<section id="recurrence-dp-formulation" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-dp-formulation">Recurrence (DP Formulation)</h4>
<p>Let <span class="math inline">\(dp[i][j]\)</span> be the minimal number of edits to convert <span class="math inline">\(X[0..i-1]\)</span> into <span class="math inline">\(Y[0..j-1]\)</span>.</p>
<p>Then:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
i, &amp; \text{if } j = 0,\\
j, &amp; \text{if } i = 0,\\
dp[i-1][j-1], &amp; \text{if } x_{i-1} = y_{j-1},\\
1 + \min\big(dp[i-1][j],\, dp[i][j-1]\big), &amp; \text{if } x_{i-1} \ne y_{j-1}.
\end{cases}
\]</span></p>
<p>Answer: <span class="math display">\[
dp[m][n]
\]</span></p>
<p>The traceback reconstructs the sequence of operations:<br>
keeping, deleting, or inserting characters to transform <span class="math inline">\(X\)</span> into <span class="math inline">\(Y\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-29" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-29">How Does It Work (Plain Language)</h4>
<p>Imagine aligning two sequences line by line. When characters match, move diagonally (no cost). If they differ, you must either delete from <span class="math inline">\(X\)</span> or insert from <span class="math inline">\(Y\)</span>.</p>
<p>By walking through a grid of all prefix pairs, you can find the shortest edit path, the same logic as <code>git diff</code>.</p>
<p>Example: <span class="math inline">\(X = \text{"ABCABBA"}\)</span> <span class="math inline">\(Y = \text{"CBABAC"}\)</span></p>
<p>One minimal diff:</p>
<pre><code>- A
  B
  C
+ B
  A
  B
- B
+ A
  C</code></pre>
</section>
<section id="tiny-code-easy-versions-28" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-28">Tiny Code (Easy Versions)</h4>
<p>C (DP Traceback for Diff)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb61"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> X<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter X: "</span><span class="op">);</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> X<span class="op">);</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter Y: "</span><span class="op">);</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> Y<span class="op">);</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>X<span class="op">[</span>m<span class="op">])</span> m<span class="op">++;</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>Y<span class="op">[</span>n<span class="op">])</span> n<span class="op">++;</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> MIN<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Edit distance: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Traceback</span></span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> m<span class="op">,</span> j <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Diff:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">||</span> j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"  </span><span class="sc">%c\n</span><span class="st">"</span><span class="op">,</span> X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span> j<span class="op">--;</span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"- </span><span class="sc">%c\n</span><span class="st">"</span><span class="op">,</span> X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span></span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"+ </span><span class="sc">%c\n</span><span class="st">"</span><span class="op">,</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a>            j<span class="op">--;</span></span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-43"><a href="#cb61-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-44"><a href="#cb61-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb61-45"><a href="#cb61-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple Diff Reconstruction)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter X: "</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter Y: "</span>)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">len</span>(X), <span class="bu">len</span>(Y)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> Y[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>i, j <span class="op">=</span> m, n</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>ops <span class="op">=</span> []</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> X[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> Y[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>        ops.append(<span class="ss">f"  </span><span class="sc">{</span>X[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>        i <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[i][j] <span class="op">==</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true" tabindex="-1"></a>        ops.append(<span class="ss">f"- </span><span class="sc">{</span>X[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true" tabindex="-1"></a>        i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true" tabindex="-1"></a>        ops.append(<span class="ss">f"+ </span><span class="sc">{</span>Y[j<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true" tabindex="-1"></a>        j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb62-31"><a href="#cb62-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-32"><a href="#cb62-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edit distance:"</span>, dp[m][n])</span>
<span id="cb62-33"><a href="#cb62-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Diff:"</span>)</span>
<span id="cb62-34"><a href="#cb62-34" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> op <span class="kw">in</span> <span class="bu">reversed</span>(ops):</span>
<span id="cb62-35"><a href="#cb62-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(op)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-29" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-29">Why It Matters</h4>
<ul>
<li>Foundation of version control systems (<code>git diff</code>, <code>patch</code>)</li>
<li>Minimizes edit operations for transformation</li>
<li>Simplifies merge conflict resolution</li>
<li>Builds upon LCS and Edit Distance concepts</li>
<li>Demonstrates traceback-based reconstruction</li>
</ul>
<p>The diff is the human-readable face of dynamic programming, turning tables into insight.</p>
</section>
<section id="step-by-step-example-28" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-28">Step-by-Step Example</h4>
<p><span class="math inline">\(X = \text{"ABCABBA"}\)</span>, <span class="math inline">\(Y = \text{"CBABAC"}\)</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>- A</td>
<td>X starts with ‘A’ not in Y prefix</td>
</tr>
<tr class="even">
<td>B</td>
<td>match</td>
</tr>
<tr class="odd">
<td>C</td>
<td>match</td>
</tr>
<tr class="even">
<td>+ B</td>
<td>insert</td>
</tr>
<tr class="odd">
<td>A</td>
<td>match</td>
</tr>
<tr class="even">
<td>B</td>
<td>match</td>
</tr>
<tr class="odd">
<td>- B</td>
<td>delete</td>
</tr>
<tr class="even">
<td>+ A</td>
<td>insert</td>
</tr>
<tr class="odd">
<td>C</td>
<td>match</td>
</tr>
</tbody>
</table>
<p>Total edits = 4 (minimal)</p>
</section>
<section id="a-gentle-proof-why-it-works-16" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-16">A Gentle Proof (Why It Works)</h4>
<ul>
<li>If <span class="math inline">\(x_{i-1} = y_{j-1}\)</span>, skip both (no cost).</li>
<li>Otherwise, best path must add a new operation (insert/delete).</li>
<li><span class="math inline">\(dp[i][j]\)</span> stores minimal edits for prefixes. By induction, <span class="math inline">\(dp[m][n]\)</span> is the minimal SES length.</li>
</ul>
</section>
<section id="try-it-yourself-29" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-29">Try It Yourself</h4>
<ol type="1">
<li>Print diff symbols (+, -, space) in alignment view</li>
<li>Compare diff path with LCS path</li>
<li>Try with real words: <code>"kitten"</code> → <code>"sitting"</code></li>
<li>Modify cost: insertion/deletion weights</li>
<li>Use colors or indentation to visualize output</li>
</ol>
</section>
<section id="test-cases-29" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-29">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>X</th>
<th>Y</th>
<th>Edits</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“ABCABBA”</td>
<td>“CBABAC”</td>
<td>4</td>
<td>classic example</td>
</tr>
<tr class="even">
<td>“abc”</td>
<td>“abc”</td>
<td>0</td>
<td>identical</td>
</tr>
<tr class="odd">
<td>“abc”</td>
<td>“def”</td>
<td>6</td>
<td>all replaced</td>
</tr>
<tr class="even">
<td>“kitten”</td>
<td>“sitting”</td>
<td>3</td>
<td>classic</td>
</tr>
<tr class="odd">
<td>“”</td>
<td>“xyz”</td>
<td>3</td>
<td>all inserts</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-29" class="level4">
<h4 class="anchored" data-anchor-id="complexity-29">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(m \times n)\)</span></li>
<li>Space: <span class="math inline">\(O(m \times n)\)</span> (traceback needs full table)</li>
</ul>
<p>The Diff Algorithm transforms comparison into storytelling, showing precisely how one sequence evolves into another, one edit at a time.</p>
</section>
</section>
</section>
<section id="section-44.-matrix-and-chain-problems" class="level1">
<h1>Section 44. Matrix and Chain Problems</h1>
<section id="matrix-chain-multiplication" class="level3">
<h3 class="anchored" data-anchor-id="matrix-chain-multiplication">431 Matrix Chain Multiplication</h3>
<p>The Matrix Chain Multiplication problem asks for the most efficient way to parenthesize a product of matrices so that the total number of scalar multiplications is minimized. Matrix multiplication is associative, so the order of multiplication can change the cost dramatically even though the result is the same shape.</p>
<section id="what-problem-are-we-solving-30" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-30">What Problem Are We Solving?</h4>
<p>Given a chain of matrices <span class="math display">\[
A_1A_2\cdots A_n
\]</span> with dimensions <span class="math display">\[
A_i \text{ is } p_{i-1}\times p_i \quad (i=1..n),
\]</span> choose the parenthesization that minimizes scalar multiplications.</p>
<p>Define the state:</p>
<p><span class="math display">\[
dp[i][j] = \text{minimum cost to multiply } A_iA_{i+1}\cdots A_j
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][i] = 0
\]</span> <span class="math display">\[
dp[i][j] = \min_{i\le k&lt;j},\bigl(dp[i][k] + dp[k+1][j] + p_{i-1}p_kp_j\bigr)
\]</span></p>
<p>The last term is the cost of multiplying the two resulting matrices from the split at (k).</p>
<p>Answer:</p>
<p><span class="math display">\[
dp[1][n]
\]</span></p>
<p>Optionally keep a split table (split[i][j]) storing the (k) achieving the minimum to reconstruct the optimal parenthesization.</p>
</section>
<section id="how-does-it-work-plain-language-30" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-30">How Does It Work (Plain Language)</h4>
<p>Matrix-chain multiplication DP</p>
<p>Recurrence <span class="math display">\[
\begin{aligned}
m[i,i] &amp;= 0,\\
m[i,j] &amp;= \min_{i \le k &lt; j}\Big(m[i,k] + m[k+1,j] + p_{i-1}\,p_k\,p_j\Big)\qquad (i&lt;j),
\end{aligned}
\]</span> where matrices are <span class="math inline">\(A_i\)</span> of size <span class="math inline">\(p_{i-1}\times p_i\)</span>.</p>
<p>Example with dimensions <span class="math display">\[
p=[10,\,30,\,5,\,60],\quad
A_1:10\times30,\ A_2:30\times5,\ A_3:5\times60.
\]</span></p>
<p>Two ways to parenthesize:</p>
<ol type="1">
<li><p><span class="math inline">\((A_1A_2)A_3\)</span><br>
Cost <span class="math display">\[
(10\cdot 30\cdot 5) + (10\cdot 5\cdot 60)
= 1500 + 3000 = 4500.
\]</span></p></li>
<li><p><span class="math inline">\(A_1(A_2A_3)\)</span><br>
Cost <span class="math display">\[
(30\cdot 5\cdot 60) + (10\cdot 30\cdot 60)
= 9000 + 18000 = 27000.
\]</span></p></li>
</ol>
<p>Minimum cost is <span class="math inline">\(4500\)</span>, achieved by <span class="math inline">\((A_1A_2)A_3\)</span> with split <span class="math inline">\(k=1\)</span>.</p>
</section>
<section id="tiny-code-easy-versions-29" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-29">Tiny Code (Easy Versions)</h4>
<p>C (DP with reconstruction)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb63"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_optimal<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">,</span> <span class="dt">int</span> split<span class="op">[</span><span class="dv">105</span><span class="op">][</span><span class="dv">105</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> j<span class="op">)</span> <span class="op">{</span> printf<span class="op">(</span><span class="st">"A</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span> <span class="cf">return</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"("</span><span class="op">);</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> split<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    print_optimal<span class="op">(</span>i<span class="op">,</span> k<span class="op">,</span> split<span class="op">);</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">" x "</span><span class="op">);</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    print_optimal<span class="op">(</span>k<span class="op">+</span><span class="dv">1</span><span class="op">,</span> j<span class="op">,</span> split<span class="op">);</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">")"</span><span class="op">);</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of matrices: "</span><span class="op">);</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> p<span class="op">[</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter dimensions p0..pn: "</span><span class="op">);</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>p<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span><span class="dv">105</span><span class="op">][</span><span class="dv">105</span><span class="op">];</span></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> split<span class="op">[</span><span class="dv">105</span><span class="op">][</span><span class="dv">105</span><span class="op">];</span></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> LLONG_MAX<span class="op">;</span></span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i<span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a>                <span class="dt">long</span> <span class="dt">long</span> cost <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>k<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="bu">LL</span><span class="op">*</span>p<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]*</span>p<span class="op">[</span>k<span class="op">]*</span>p<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>cost <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> cost<span class="op">;</span></span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a>                    split<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Min scalar multiplications: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Optimal parenthesization: "</span><span class="op">);</span></span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a>    print_optimal<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> split<span class="op">);</span></span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (DP with reconstruction)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> matrix_chain_order(p):</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(p) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    split <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">-</span> length <span class="op">+</span> <span class="dv">2</span>):</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i, j):</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>                cost <span class="op">=</span> dp[i][k] <span class="op">+</span> dp[k<span class="op">+</span><span class="dv">1</span>][j] <span class="op">+</span> p[i<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>p[k]<span class="op">*</span>p[j]</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cost <span class="op">&lt;</span> dp[i][j]:</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">=</span> cost</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>                    split[i][j] <span class="op">=</span> k</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp, split</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_solution(split, i, j):</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> j:</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ss">f"A</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> split[i][j]</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"("</span> <span class="op">+</span> build_solution(split, i, k) <span class="op">+</span> <span class="st">" x "</span> <span class="op">+</span> build_solution(split, k<span class="op">+</span><span class="dv">1</span>, j) <span class="op">+</span> <span class="st">")"</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter p0..pn: "</span>).split()))</span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>dp, split <span class="op">=</span> matrix_chain_order(p)</span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(p) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min scalar multiplications:"</span>, dp[<span class="dv">1</span>][n])</span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optimal parenthesization:"</span>, build_solution(split, <span class="dv">1</span>, n))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-30" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-30">Why It Matters</h4>
<ul>
<li>Canonical example of interval DP and optimal binary partitioning</li>
<li>Shows how associativity allows many evaluation orders with different costs</li>
<li>Appears in query plan optimization, automatic differentiation scheduling, graphics and compiler optimization</li>
</ul>
</section>
<section id="step-by-step-example-29" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-29">Step by Step Example</h4>
<p>For (p = [5, 10, 3, 12, 5, 50, 6]) with (n=6):</p>
<ul>
<li>Try all splits for each subchain length</li>
<li>The DP eventually yields (dp[1][6] = 2010) and an optimal structure like (((A_1(A_2A_3))((A_4A_5)A_6))) Exact parentheses can vary among ties but the minimal cost is unique here.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-17" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-17">A Gentle Proof (Why It Works)</h4>
<p>Let (OPT(i,j)) be the optimal cost for <span class="math inline">\(A_i\cdots A_j\)</span>. In any optimal solution, the last multiplication splits the chain at some (k) with <span class="math inline">\(i\le k&lt;j\)</span>. The two sides must themselves be optimal, otherwise replacing one side by a better solution improves the total, contradicting optimality. Therefore <span class="math display">\[
OPT(i,j) = \min_{i\le k&lt;j}\bigl(OPT(i,k)+OPT(k+1,j)+p_{i-1}p_kp_j\bigr),
\]</span> with (OPT(i,i)=0). Since each subproblem uses strictly shorter chains, filling by increasing length computes all needed values before they are used.</p>
</section>
<section id="try-it-yourself-30" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-30">Try It Yourself</h4>
<ol type="1">
<li>Print not only one but all optimal parenthesizations when multiple (k) tie.</li>
<li>Add a second objective like minimizing depth after minimizing cost.</li>
<li>Compare greedy choices vs DP on random instances.</li>
<li>Extend to a cost model with addition cost or cache reuse.</li>
<li>Visualize the DP table and splits along diagonals.</li>
</ol>
</section>
<section id="test-cases-30" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-30">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 1%">
<col style="width: 22%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>p (p0..pn)</th>
<th>n</th>
<th>Expected min cost</th>
<th>One optimal parentheses</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[10,30,5,60]</td>
<td>3</td>
<td>4500</td>
<td>(A1 x A2) x A3</td>
</tr>
<tr class="even">
<td>[5,10,3,12,5,50,6]</td>
<td>6</td>
<td>2010</td>
<td>one optimal structure</td>
</tr>
<tr class="odd">
<td>[40,20,30,10,30]</td>
<td>4</td>
<td>26000</td>
<td>((A1 x (A2 x A3)) x A4) or tie variant</td>
</tr>
<tr class="even">
<td>[10,20,30]</td>
<td>2</td>
<td>6000</td>
<td>A1 x A2</td>
</tr>
<tr class="odd">
<td>[2,3,4,5]</td>
<td>3</td>
<td>64</td>
<td>(A1 x A2) x A3</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-30" class="level4">
<h4 class="anchored" data-anchor-id="complexity-30">Complexity</h4>
<ul>
<li>Time: (O(n^3)) for the triple loop over (i,j,k)</li>
<li>Space: (O(n^2)) for the DP and split tables</li>
</ul>
<p>Matrix Chain Multiplication is the textbook pattern for interval DP: pick a split, combine optimal subchains, and account for the boundary multiplication cost.</p>
</section>
</section>
<section id="boolean-parenthesization" class="level3">
<h3 class="anchored" data-anchor-id="boolean-parenthesization">432 Boolean Parenthesization</h3>
<p>The Boolean Parenthesization problem (also called the Boolean Expression Evaluation problem) asks: <em>Given a boolean expression consisting of <code>T</code> (true), <code>F</code> (false), and operators (<code>&amp;</code>, <code>|</code>, <code>^</code>), how many ways can we parenthesize it so that it evaluates to <code>True</code>?</em></p>
<p>It’s a classic DP over intervals problem where we explore all possible splits between operators, combining sub-results based on logic rules.</p>
<section id="what-problem-are-we-solving-31" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-31">What Problem Are We Solving?</h4>
<p>Given a boolean expression string like <code>T|F&amp;T^T</code>, count the number of ways to parenthesize it so that it evaluates to True.</p>
<p>We must consider both True and False counts for sub-expressions.</p>
<p>Let:</p>
<ul>
<li><span class="math inline">\(dpT[i][j]\)</span> = number of ways <span class="math inline">\(expr[i..j]\)</span> evaluates to True</li>
<li><span class="math inline">\(dpF[i][j]\)</span> = number of ways <span class="math inline">\(expr[i..j]\)</span> evaluates to False</li>
</ul>
<p>If expression length is <span class="math inline">\(n\)</span>, then we only consider operands at even indices and operators at odd indices.</p>
</section>
<section id="recurrence" class="level4">
<h4 class="anchored" data-anchor-id="recurrence">Recurrence</h4>
<p>For every split at operator <span class="math inline">\(k\)</span> between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>:</p>
<p>Let <span class="math inline">\(op = expr[k]\)</span></p>
<p>Compute:</p>
<p><span class="math display">\[
\text{TotalTrue} =
\begin{cases}
dpT[i][k-1]\cdot dpT[k+1][j], &amp; \text{if } op=\land,\\
dpT[i][k-1]\cdot dpT[k+1][j]\;+\;dpT[i][k-1]\cdot dpF[k+1][j]\;+\;dpF[i][k-1]\cdot dpT[k+1][j], &amp; \text{if } op=\lor,\\
dpT[i][k-1]\cdot dpF[k+1][j]\;+\;dpF[i][k-1]\cdot dpT[k+1][j], &amp; \text{if } op=\oplus.
\end{cases}
\]</span></p>
<p>Similarly for <span class="math inline">\(dpF[i][j]\)</span> using complementary logic.</p>
<p>Base cases:</p>
<p><span class="math display">\[
dpT[i][i] = 1 \text{ if expr[i] = 'T' else } 0
\]</span> <span class="math display">\[
dpF[i][i] = 1 \text{ if expr[i] = 'F' else } 0
\]</span></p>
<p>Answer = <span class="math inline">\(dpT[0][n-1]\)</span></p>
</section>
<section id="how-does-it-work-plain-language-31" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-31">How Does It Work (Plain Language)</h4>
<p>We cut the expression at each operator and combine the truth counts of the left and right sides according to boolean logic.</p>
<p>For each subexpression, we record:</p>
<ul>
<li>how many parenthesizations make it True</li>
<li>how many make it False</li>
</ul>
<p>Then we combine smaller subproblems to get bigger ones, just like Matrix Chain Multiplication, but using logic rules.</p>
<p>Example: Expression = <code>T|F&amp;T</code></p>
<p>We can group as:</p>
<ol type="1">
<li><code>(T|F)&amp;T</code> → True</li>
<li><code>T|(F&amp;T)</code> → True</li>
</ol>
<p>Answer = 2</p>
</section>
<section id="tiny-code-easy-versions-30" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-30">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb65"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">105</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dpT<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">],</span> dpF<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> expr<span class="op">[</span><span class="dv">105</span><span class="op">];</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter expression (T/F with &amp;|^): "</span><span class="op">);</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> expr<span class="op">);</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>        dpT<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>expr<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="ch">'T'</span><span class="op">);</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>        dpF<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>expr<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="ch">'F'</span><span class="op">);</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>            dpT<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dpF<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>                <span class="dt">char</span> op <span class="op">=</span> expr<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> lT <span class="op">=</span> dpT<span class="op">[</span>i<span class="op">][</span>k<span class="op">-</span><span class="dv">1</span><span class="op">],</span> lF <span class="op">=</span> dpF<span class="op">[</span>i<span class="op">][</span>k<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> rT <span class="op">=</span> dpT<span class="op">[</span>k<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> rF <span class="op">=</span> dpF<span class="op">[</span>k<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>op <span class="op">==</span> <span class="ch">'&amp;'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a>                    dpT<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> lT <span class="op">*</span> rT<span class="op">;</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a>                    dpF<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> lT <span class="op">*</span> rF <span class="op">+</span> lF <span class="op">*</span> rT <span class="op">+</span> lF <span class="op">*</span> rF<span class="op">;</span></span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>op <span class="op">==</span> <span class="ch">'|'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>                    dpT<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> lT <span class="op">*</span> rT <span class="op">+</span> lT <span class="op">*</span> rF <span class="op">+</span> lF <span class="op">*</span> rT<span class="op">;</span></span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>                    dpF<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> lF <span class="op">*</span> rF<span class="op">;</span></span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>op <span class="op">==</span> <span class="ch">'^'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a>                    dpT<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> lT <span class="op">*</span> rF <span class="op">+</span> lF <span class="op">*</span> rT<span class="op">;</span></span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a>                    dpF<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> lT <span class="op">*</span> rT <span class="op">+</span> lF <span class="op">*</span> rF<span class="op">;</span></span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of ways to get True: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dpT<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb65-45"><a href="#cb65-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Readable DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> <span class="bu">input</span>(<span class="st">"Enter expression (T/F with &amp;|^): "</span>)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(expr)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>dpT <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>dpF <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n, <span class="dv">2</span>):</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    dpT[i][i] <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> expr[i] <span class="op">==</span> <span class="st">'T'</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    dpF[i][i] <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> expr[i] <span class="op">==</span> <span class="st">'F'</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n<span class="op">+</span><span class="dv">1</span>, <span class="dv">2</span>):</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n<span class="op">-</span>length<span class="op">+</span><span class="dv">1</span>, <span class="dv">2</span>):</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, j, <span class="dv">2</span>):</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>            op <span class="op">=</span> expr[k]</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>            lT, lF <span class="op">=</span> dpT[i][k<span class="op">-</span><span class="dv">1</span>], dpF[i][k<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>            rT, rF <span class="op">=</span> dpT[k<span class="op">+</span><span class="dv">1</span>][j], dpF[k<span class="op">+</span><span class="dv">1</span>][j]</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> op <span class="op">==</span> <span class="st">'&amp;'</span>:</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>                dpT[i][j] <span class="op">+=</span> lT <span class="op">*</span> rT</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>                dpF[i][j] <span class="op">+=</span> lT <span class="op">*</span> rF <span class="op">+</span> lF <span class="op">*</span> rT <span class="op">+</span> lF <span class="op">*</span> rF</span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> op <span class="op">==</span> <span class="st">'|'</span>:</span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>                dpT[i][j] <span class="op">+=</span> lT <span class="op">*</span> rT <span class="op">+</span> lT <span class="op">*</span> rF <span class="op">+</span> lF <span class="op">*</span> rT</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>                dpF[i][j] <span class="op">+=</span> lF <span class="op">*</span> rF</span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:  <span class="co"># '^'</span></span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>                dpT[i][j] <span class="op">+=</span> lT <span class="op">*</span> rF <span class="op">+</span> lF <span class="op">*</span> rT</span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>                dpF[i][j] <span class="op">+=</span> lT <span class="op">*</span> rT <span class="op">+</span> lF <span class="op">*</span> rF</span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Ways to evaluate to True:"</span>, dpT[<span class="dv">0</span>][n<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-31" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-31">Why It Matters</h4>
<ul>
<li>Classic interval DP pattern with logical combination</li>
<li>Shows how state splitting applies beyond arithmetic</li>
<li>Foundation for boolean circuit optimization and expression counting problems</li>
<li>Reinforces divide by operator technique</li>
</ul>
</section>
<section id="step-by-step-example-30" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-30">Step-by-Step Example</h4>
<p>Expression = <code>T|F&amp;T</code></p>
<p>Subproblems:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Subexpr</th>
<th>Ways True</th>
<th>Ways False</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td>F</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td>T</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td>T</td>
<td>F</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>F&amp;T</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr class="even">
<td>T</td>
<td>F&amp;T</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Answer = 2</p>
</section>
<section id="a-gentle-proof-why-it-works-18" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-18">A Gentle Proof (Why It Works)</h4>
<p>Each subexpression can be split at an operator <span class="math inline">\(op_k\)</span>. The truth count of the whole depends only on the truth counts of its parts and the operator’s truth table. By combining all possible <span class="math inline">\(k\)</span> recursively, we count all valid parenthesizations. Overlapping subproblems arise when evaluating the same substring, so memoization or bottom-up filling ensures efficiency.</p>
</section>
<section id="try-it-yourself-31" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-31">Try It Yourself</h4>
<ol type="1">
<li>Extend to count False outcomes too.</li>
<li>Add modulo <span class="math inline">\(10^9+7\)</span> for large counts.</li>
<li>Print one valid parenthesization.</li>
<li>Try on expressions like <code>T^T^F</code> or <code>T|F&amp;T^T</code>.</li>
<li>Modify rules for custom logic systems.</li>
</ol>
</section>
<section id="test-cases-31" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-31">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Expression</th>
<th>Expected True Count</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>F&amp;T</td>
<td>2</td>
<td></td>
</tr>
<tr class="even">
<td>T<sup>T</sup>F</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>T^F</td>
<td>F</td>
<td>2</td>
<td></td>
</tr>
<tr class="even">
<td>T&amp;F</td>
<td>T</td>
<td>2</td>
<td></td>
</tr>
<tr class="odd">
<td>T</td>
<td>T&amp;F</td>
<td>F</td>
<td>5</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-31" class="level4">
<h4 class="anchored" data-anchor-id="complexity-31">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^3)\)</span> (split for every operator)</li>
<li>Space: <span class="math inline">\(O(n^2)\)</span> (2 DP tables)</li>
</ul>
<p>The Boolean Parenthesization problem is the logic mirror of Matrix Chain Multiplication, instead of minimizing cost, we’re counting truth through combinatorial structure.</p>
</section>
</section>
<section id="burst-balloons" class="level3">
<h3 class="anchored" data-anchor-id="burst-balloons">433 Burst Balloons</h3>
<p>The Burst Balloons problem is a classic interval DP challenge. You’re given a row of balloons, each with a number representing coins. When you burst a balloon, you gain coins equal to the product of its number and the numbers of its immediate neighbors. The task is to determine the maximum coins you can collect by choosing the optimal order of bursting.</p>
<section id="what-problem-are-we-solving-32" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-32">What Problem Are We Solving?</h4>
<p>Given an array <code>nums</code> of length <code>n</code>, when you burst balloon <code>i</code>, you gain <span class="math display">\[
\text{coins} = nums[i-1] \times nums[i] \times nums[i+1]
\]</span> where <code>nums[i-1]</code> and <code>nums[i+1]</code> are the adjacent balloons still unburst.</p>
<p>After bursting <code>i</code>, it is removed from the sequence, changing neighbor relationships.</p>
<p>We want to maximize total coins by choosing the best bursting order.</p>
<p>To simplify boundary conditions, pad the array with 1s at both ends: <span class="math display">\[
val = [1] + nums + [1]
\]</span></p>
<p>Define DP state: <span class="math display">\[
dp[i][j] = \text{maximum coins obtainable by bursting all balloons between } i \text{ and } j
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[i][j] = \max_{k \in (i, j)} \Big( dp[i][k] + dp[k][j] + val[i] \cdot val[k] \cdot val[j] \Big)
\]</span></p>
<p>Answer: <span class="math display">\[
dp[0][n+1]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-32" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-32">How Does It Work (Plain Language)</h4>
<p>Instead of thinking <em>“Which balloon to pop next?”</em>, think <em>“Which balloon to pop last?”</em> between two boundaries.</p>
<p>By fixing the last balloon <code>k</code> between <code>i</code> and <code>j</code>, its neighbors are guaranteed to be <code>i</code> and <code>j</code> at that moment, so the coins earned are easy to compute: <code>val[i] * val[k] * val[j]</code>.</p>
<p>Then we solve the smaller subproblems:</p>
<ul>
<li><code>dp[i][k]</code>: best coins from bursting balloons between <code>i</code> and <code>k</code></li>
<li><code>dp[k][j]</code>: best coins from bursting between <code>k</code> and <code>j</code></li>
</ul>
<p>Combine and take the best split.</p>
<p>This is the reverse of the intuitive “first burst” approach, making the subproblems independent.</p>
</section>
<section id="tiny-code-easy-versions-31" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-31">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb67"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">305</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define max</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of balloons: "</span><span class="op">);</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nums<span class="op">[</span>MAX<span class="op">],</span> val<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter balloon values: "</span><span class="op">);</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>nums<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>    val<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> val<span class="op">[</span>n<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> val<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>dp<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>dp<span class="op">));</span></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">&lt;=</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len<span class="op">;</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> cost <span class="op">=</span> val<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> val<span class="op">[</span>k<span class="op">]</span> <span class="op">*</span> val<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>k<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> cost<span class="op">);</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max coins: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Interval DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter balloon values: "</span>).split()))</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>val <span class="op">=</span> [<span class="dv">1</span>] <span class="op">+</span> nums <span class="op">+</span> [<span class="dv">1</span>]</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">2</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">2</span>)]</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n<span class="op">+</span><span class="dv">2</span>):</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n<span class="op">+</span><span class="dv">2</span><span class="op">-</span>length):</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> length</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, j):</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i][j], val[i]<span class="op">*</span>val[k]<span class="op">*</span>val[j] <span class="op">+</span> dp[i][k] <span class="op">+</span> dp[k][j])</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max coins:"</span>, dp[<span class="dv">0</span>][n<span class="op">+</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-32" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-32">Why It Matters</h4>
<ul>
<li>Exemplifies interval DP structure: choose a pivot balloon as the “last” action</li>
<li>Shows how reverse reasoning simplifies state independence</li>
<li>Appears in optimization over chains, trees, brackets, and games</li>
<li>Foundation for polygon triangulation and matrix multiplication variants</li>
</ul>
</section>
<section id="step-by-step-example-31" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-31">Step-by-Step Example</h4>
<p>Example: <code>nums = [3, 1, 5, 8]</code></p>
<p>Pad → <code>val = [1, 3, 1, 5, 8, 1]</code></p>
<p>Compute <code>dp[i][j]</code> for increasing intervals:</p>
<ul>
<li>Interval (1,4): choose <code>k=2</code> or <code>3</code>, compare costs</li>
<li>Gradually expand to full (0,5): Optimal = 167 coins</li>
</ul>
<p>One optimal order: <code>burst 1 → 5 → 3 → 8 → 1</code></p>
</section>
<section id="a-gentle-proof-why-it-works-19" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-19">A Gentle Proof (Why It Works)</h4>
<p>Each interval <code>(i,j)</code> can only depend on smaller intervals <code>(i,k)</code> and <code>(k,j)</code> because the last balloon <code>k</code> divides the chain cleanly. By fixing <code>k</code> as last, we ensure both sides are independent, they share no unburst balloons. Since every subproblem is smaller, bottom-up DP fills states without cycles. Thus, optimal substructure and overlapping subproblems guarantee correctness.</p>
</section>
<section id="try-it-yourself-32" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-32">Try It Yourself</h4>
<ol type="1">
<li>Implement a top-down memoized version with recursion.</li>
<li>Visualize the DP table as a triangle showing optimal splits.</li>
<li>Add reconstruction to print the burst order.</li>
<li>Try <code>[1,2,3]</code>, <code>[1,5]</code>, <code>[7,9,8]</code> to check intuition.</li>
<li>Compare performance for <code>n=300</code>.</li>
</ol>
</section>
<section id="test-cases-32" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-32">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>nums</th>
<th>Max Coins</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3,1,5,8]</td>
<td>167</td>
</tr>
<tr class="even">
<td>[1,5]</td>
<td>10</td>
</tr>
<tr class="odd">
<td>[2,2,2]</td>
<td>12</td>
</tr>
<tr class="even">
<td>[1,2,3]</td>
<td>12</td>
</tr>
<tr class="odd">
<td>[9]</td>
<td>9</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-32" class="level4">
<h4 class="anchored" data-anchor-id="complexity-32">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^3)\)</span> for all subintervals and splits</li>
<li>Space: <span class="math inline">\(O(n^2)\)</span> for DP table</li>
</ul>
<p>The Burst Balloons problem captures the essence of interval DP: choose the last action, build subproblems on either side, and let structure guide optimal order.</p>
</section>
</section>
<section id="optimal-bst" class="level3">
<h3 class="anchored" data-anchor-id="optimal-bst">434 Optimal BST</h3>
<p>The Optimal Binary Search Tree problem asks for the BST shape that minimizes the expected search cost given access frequencies. Even though all BSTs hold the same keys in-order, different shapes can have very different average lookup depths.</p>
<section id="what-problem-are-we-solving-33" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-33">What Problem Are We Solving?</h4>
<p>We have sorted keys <span class="math display">\[K_1&lt;K_2&lt;\dots&lt;K_n,\]</span> with successful-search probabilities (p_1,,p_n). Optionally, we may include probabilities (q_0,,q_n) for unsuccessful searches in the gaps between keys (classical formulation).</p>
<p>Goal: build a BST over these keys that minimizes expected comparisons.</p>
<p>Two standard DP models:</p>
<ol type="1">
<li>Full model with gaps ((p_i,q_i)). This is the textbook version.</li>
<li>Simplified model with only (p_i). Useful when you only care about successful hits.</li>
</ol>
</section>
<section id="dp-full-model-with-gaps" class="level4">
<h4 class="anchored" data-anchor-id="dp-full-model-with-gaps">DP: Full Model With Gaps</h4>
<p>Define DP over intervals of keys <span class="math inline">\((K_i,\dots,K_j)\)</span> with gaps on both sides.</p>
<p>Weight (total probability mass in the interval, including gaps): <span class="math display">\[
w[i][j]=
\begin{cases}
q_{i-1}, &amp; i&gt;j,\\
w[i][j-1] + p_j + q_j, &amp; i\le j.
\end{cases}
\]</span></p>
<p>Expected cost (including internal node comparisons): <span class="math display">\[
e[i][j]=
\begin{cases}
q_{i-1}, &amp; i&gt;j,\\
\displaystyle \min_{r=i}^{j}\big( e[i][r-1] + e[r+1][j] + w[i][j] \big), &amp; i\le j.
\end{cases}
\]</span></p>
<p>Answer: <span class="math inline">\(e[1][n]\)</span>.<br>
If you also keep <span class="math inline">\(root[i][j]\)</span> that stores the minimizing <span class="math inline">\(r\)</span>, you can reconstruct the tree.</p>
</section>
<section id="dp-simplified-model-success-only" class="level4">
<h4 class="anchored" data-anchor-id="dp-simplified-model-success-only">DP: Simplified Model (success-only)</h4>
<p>Sometimes you only have hit frequencies <span class="math inline">\(f_i\)</span>. Let the cost count depth with each comparison adding 1. Define <span class="math display">\[
dp[i][j]
= \text{minimum total weighted depth for } K_i,\ldots,K_j
\text{ when the root contributes 1 per key below it.}
\]</span></p>
<p>A convenient formulation uses prefix sums <span class="math display">\[
S[k]=\sum_{t=1}^{k} f_t, \qquad W(i,j)=S[j]-S[i-1].
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[i][j]=
\begin{cases}
0, &amp; i&gt;j,\\[4pt]
\displaystyle \min_{r=i}^{j}\big(dp[i][r-1]+dp[r+1][j]\big)+W(i,j), &amp; i\le j.
\end{cases}
\]</span></p>
<p>Answer: <span class="math inline">\(dp[1][n]\)</span>.<br>
The extra <span class="math inline">\(W(i,j)\)</span> accounts for the fact that choosing any root increases the depth of all keys in its subtrees by 1.</p>
</section>
<section id="how-does-it-work-plain-language-33" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-33">How Does It Work (Plain Language)</h4>
<p>Pick the root for a range of keys. Every key not chosen as root sits one level deeper, so its cost increases. The DP tries every candidate root and adds:</p>
<ul>
<li>the optimal cost of the left subtree</li>
<li>the optimal cost of the right subtree</li>
<li>the penalty for pushing all nonroot keys one level deeper (their total frequency)</li>
</ul>
<p>Choose the root that minimizes this sum for every interval.</p>
</section>
<section id="tiny-code-easy-versions-32" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-32">Tiny Code (Easy Versions)</h4>
<p>C (full model with gaps (p_i,q_i))</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb69"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;float.h&gt;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">205</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> e<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> w<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> rootIdx<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter n: "</span><span class="op">);</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> p<span class="op">[</span>MAXN<span class="op">],</span> q<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter p1..pn: "</span><span class="op">);</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lf</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>p<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter q0..qn: "</span><span class="op">);</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lf</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>q<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>        e<span class="op">[</span>i<span class="op">][</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> q<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>        w<span class="op">[</span>i<span class="op">][</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> q<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">+</span>len<span class="op">-</span><span class="dv">1</span> <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>            w<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> w<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> p<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> q<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a>            e<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> DBL_MAX<span class="op">;</span></span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> r <span class="op">=</span> i<span class="op">;</span> r <span class="op">&lt;=</span> j<span class="op">;</span> r<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a>                <span class="dt">double</span> cost <span class="op">=</span> e<span class="op">[</span>i<span class="op">][</span>r<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> e<span class="op">[</span>r<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> w<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb69-33"><a href="#cb69-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>cost <span class="op">&lt;</span> e<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb69-34"><a href="#cb69-34" aria-hidden="true" tabindex="-1"></a>                    e<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> cost<span class="op">;</span></span>
<span id="cb69-35"><a href="#cb69-35" aria-hidden="true" tabindex="-1"></a>                    rootIdx<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb69-36"><a href="#cb69-36" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb69-37"><a href="#cb69-37" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb69-38"><a href="#cb69-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-39"><a href="#cb69-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-40"><a href="#cb69-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-41"><a href="#cb69-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Optimal expected cost: </span><span class="sc">%.6f\n</span><span class="st">"</span><span class="op">,</span> e<span class="op">[</span><span class="dv">1</span><span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb69-42"><a href="#cb69-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// rootIdx[i][j] holds the chosen root for reconstruction</span></span>
<span id="cb69-43"><a href="#cb69-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb69-44"><a href="#cb69-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (simplified model with hit frequencies (f_i))</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, <span class="bu">input</span>(<span class="st">"Enter f1..fn: "</span>).split()))</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(f)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1-index for convenience</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> [<span class="fl">0.0</span>] <span class="op">+</span> f</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> [<span class="fl">0.0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>    S[i] <span class="op">=</span> S[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> f[i]</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> W(i, j):</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.0</span> <span class="cf">if</span> i <span class="op">&gt;</span> j <span class="cf">else</span> S[j] <span class="op">-</span> S[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="fl">0.0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">2</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">2</span>)]</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">2</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">2</span>)]</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">-</span> length <span class="op">+</span> <span class="dv">2</span>):</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>        best, arg <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>), <span class="op">-</span><span class="dv">1</span></span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(i, j<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> dp[i][r<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> dp[r<span class="op">+</span><span class="dv">1</span>][j] <span class="op">+</span> W(i, j)</span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cost <span class="op">&lt;</span> best:</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>                best, arg <span class="op">=</span> cost, r</span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>        dp[i][j], root[i][j] <span class="op">=</span> best, arg</span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optimal weighted cost:"</span>, <span class="bu">round</span>(dp[<span class="dv">1</span>][n], <span class="dv">6</span>))</span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true" tabindex="-1"></a><span class="co"># root[i][j] gives a root choice for reconstruction</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-33" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-33">Why It Matters</h4>
<ul>
<li>Models biased queries where some keys are far more popular</li>
<li>Canonical interval DP with a split and an additive per-interval penalty</li>
<li>Basis for query plan optimization, autocompletion tries, and decision tree shaping</li>
<li>Leads to advanced speedups like Knuth optimization when conditions hold</li>
</ul>
</section>
<section id="step-by-step-example-32" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-32">Step by Step Example</h4>
<p>Simplified model with (f = [0.3, 0.2, 0.5]) for (K_1&lt;K_2&lt;K_3).</p>
<ul>
<li><p>For length 1: (dp[i][i] = f_i)</p></li>
<li><p>For interval ([1,2]): try roots 1 or 2</p>
<ul>
<li>(r=1:&nbsp;dp[1][0]+dp[2][2]+(f_1+f_2)=0+0.2+0.5=0.7)</li>
<li>(r=2:&nbsp;dp[1][1]+dp[3][2]+0.5=0.3+0+0.5=0.8) choose (r=1).</li>
</ul></li>
<li><p>For ([1,3]): try (r=1,2,3) with penalty (W(1,3)=1.0) compute and pick the minimum. The DP returns the best shape and cost.</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-20" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-20">A Gentle Proof (Why It Works)</h4>
<p>Consider an optimal tree for keys ([i,j]) whose root is (r). All keys other than (K_r) move one level deeper, adding exactly (W(i,j)-p_r) to their cumulative cost. Splitting at (r) separates the instance into two independent subproblems ([i,r-1]) and ([r+1,j]). If either subtree were not optimal, replacing it by a better one would reduce total cost, contradicting optimality. Thus the recurrence that scans all roots and adds the interval weight is correct. The gap model adds (q)-probabilities to the interval weight (w[i][j]) and yields the classical formula.</p>
</section>
<section id="try-it-yourself-33" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-33">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct the tree using the stored <code>root</code> table and print it in preorder.</li>
<li>Compare the full model ((p,q)) versus the simplified model on the same data.</li>
<li>Normalize frequencies so (p_i + q_i = 1) and interpret (e[1][n]) as expected comparisons.</li>
<li>Experiment with Knuth optimization when the quadrangle inequality holds to reduce time toward (O(n^2)).</li>
<li>Stress test with skewed distributions where one key dominates.</li>
</ol>
</section>
<section id="test-cases-33" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-33">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 10%">
<col style="width: 38%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th>Keys</th>
<th>Model</th>
<th>Params</th>
<th>Expected behavior</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3 keys</td>
<td>simplified</td>
<td>(f=[0.3,0.2,0.5])</td>
<td>root tends to be key 3 or 1 depending on split costs</td>
</tr>
<tr class="even">
<td>4 keys</td>
<td>simplified</td>
<td>(f=[1,1,1,1])</td>
<td>more balanced tree wins</td>
</tr>
<tr class="odd">
<td>3 keys</td>
<td>full ((p,q))</td>
<td>(p=[0.3,0.2,0.4],&nbsp;q=[0.02,0.02,0.03,0.03])</td>
<td>gaps shift the optimal root</td>
</tr>
<tr class="even">
<td>1 key</td>
<td>either</td>
<td>single freq</td>
<td>cost equals (p_1) or (q_0+ p_1 + q_1)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-33" class="level4">
<h4 class="anchored" data-anchor-id="complexity-33">Complexity</h4>
<ul>
<li>Time: (O(n^3)) with the naive triple loop over ((i,j,r))</li>
<li>Space: (O(n^2)) for DP and root tables</li>
</ul>
<p>The Optimal BST DP captures a universal pattern: choose a split, add a per-interval penalty that reflects depth inflation, and combine optimal subtrees for the minimal expected search cost.</p>
</section>
</section>
<section id="polygon-triangulation" class="level3">
<h3 class="anchored" data-anchor-id="polygon-triangulation">435 Polygon Triangulation</h3>
<p>The Polygon Triangulation problem is a foundational geometric DP challenge. Given a convex polygon, the task is to divide it into non-overlapping triangles by drawing non-intersecting diagonals, minimizing the total weight—often the sum of triangle areas or edge lengths. It’s structurally similar to Matrix Chain Multiplication, with intervals, splits, and additive costs.</p>
<section id="what-problem-are-we-solving-34" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-34">What Problem Are We Solving?</h4>
<p>Given a convex polygon with vertices (V_0, V_1, , V_{n-1}), we want to triangulate it (partition into triangles using diagonals) such that the total cost is minimized.</p>
<p>Define cost as: <span class="math display">\[
\text{cost}(i,j,k) = \text{weight of triangle }(V_i, V_j, V_k)
\]</span> where weight could be:</p>
<ul>
<li>Area</li>
<li>Perimeter</li>
<li>Squared edge length sum (for generality)</li>
</ul>
<p>We define the DP state: <span class="math display">\[
dp[i][j] = \text{minimum triangulation cost between } V_i \text{ and } V_j
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[i][j] = \min_{i&lt;k&lt;j}\Big(dp[i][k] + dp[k][j] + \text{cost}(i,j,k)\Big)
\]</span></p>
<p>Base case: <span class="math display">\[
dp[i][i+1] = 0
\]</span></p>
<p>Final answer: (dp[0][n-1])</p>
</section>
<section id="how-does-it-work-plain-language-34" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-34">How Does It Work (Plain Language)</h4>
<p>You pick a vertex (k) between (i) and (j) to form a triangle ((V_i, V_k, V_j)). This triangle splits the polygon into two smaller polygons:</p>
<ul>
<li>One from (V_i) to (V_k)</li>
<li>Another from (V_k) to (V_j)</li>
</ul>
<p>We recursively find their optimal triangulations and add the triangle’s cost.</p>
<p>This is a divide-and-conquer on geometry. Every choice of diagonal corresponds to a split in the DP.</p>
</section>
<section id="tiny-code-easy-versions-33" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-33">Tiny Code (Easy Versions)</h4>
<p>C (Using area as cost)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb71"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;float.h&gt;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">105</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define min</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> dist<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx <span class="op">=</span> a<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">,</span> dy <span class="op">=</span> a<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy<span class="op">);</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> triangle_cost<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> s <span class="op">=</span> <span class="op">(</span>dist<span class="op">(</span>a<span class="op">,</span>b<span class="op">)</span> <span class="op">+</span> dist<span class="op">(</span>b<span class="op">,</span>c<span class="op">)</span> <span class="op">+</span> dist<span class="op">(</span>c<span class="op">,</span>a<span class="op">))</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> area <span class="op">=</span> sqrt<span class="op">(</span>s <span class="op">*</span> <span class="op">(</span>s <span class="op">-</span> dist<span class="op">(</span>a<span class="op">,</span>b<span class="op">))</span> <span class="op">*</span> <span class="op">(</span>s <span class="op">-</span> dist<span class="op">(</span>b<span class="op">,</span>c<span class="op">))</span> <span class="op">*</span> <span class="op">(</span>s <span class="op">-</span> dist<span class="op">(</span>c<span class="op">,</span>a<span class="op">)));</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> area<span class="op">;</span></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a>    Point v<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lf</span><span class="st"> </span><span class="sc">%lf</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>v<span class="op">[</span>i<span class="op">].</span>x<span class="op">,</span> <span class="op">&amp;</span>v<span class="op">[</span>i<span class="op">].</span>y<span class="op">);</span></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-29"><a href="#cb71-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dp<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb71-30"><a href="#cb71-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb71-31"><a href="#cb71-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb71-32"><a href="#cb71-32" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb71-33"><a href="#cb71-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-34"><a href="#cb71-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb71-35"><a href="#cb71-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb71-36"><a href="#cb71-36" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len<span class="op">;</span></span>
<span id="cb71-37"><a href="#cb71-37" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> DBL_MAX<span class="op">;</span></span>
<span id="cb71-38"><a href="#cb71-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb71-39"><a href="#cb71-39" aria-hidden="true" tabindex="-1"></a>                <span class="dt">double</span> cost <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> triangle_cost<span class="op">(</span>v<span class="op">[</span>i<span class="op">],</span> v<span class="op">[</span>j<span class="op">],</span> v<span class="op">[</span>k<span class="op">]);</span></span>
<span id="cb71-40"><a href="#cb71-40" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> cost<span class="op">);</span></span>
<span id="cb71-41"><a href="#cb71-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb71-42"><a href="#cb71-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb71-43"><a href="#cb71-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-44"><a href="#cb71-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-45"><a href="#cb71-45" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Min triangulation cost: </span><span class="sc">%.4f\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb71-46"><a href="#cb71-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-47"><a href="#cb71-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Perimeter cost)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(a, b):</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>] <span class="op">-</span> b[<span class="dv">0</span>], a[<span class="dv">1</span>] <span class="op">-</span> b[<span class="dv">1</span>])</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> triangle_cost(a, b, c):</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist(a,b) <span class="op">+</span> dist(b,c) <span class="op">+</span> dist(c,a)</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter number of vertices: "</span>))</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> [<span class="bu">tuple</span>(<span class="bu">map</span>(<span class="bu">float</span>, <span class="bu">input</span>().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length):</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> length</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>        dp[i][j] <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, j):</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i][j],</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>                           dp[i][k] <span class="op">+</span> dp[k][j] <span class="op">+</span> triangle_cost(v[i], v[k], v[j]))</span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min triangulation cost:"</span>, <span class="bu">round</span>(dp[<span class="dv">0</span>][n<span class="op">-</span><span class="dv">1</span>], <span class="dv">4</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-34" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-34">Why It Matters</h4>
<ul>
<li>Canonical geometric DP using intervals and triple splits</li>
<li>Underpins graphics, meshing, computational geometry, and 3D modeling</li>
<li>Shows that Matrix Chain Multiplication and Polygon Triangulation share a structural template</li>
<li>Reinforces how spatial reasoning maps to recurrence formulation</li>
</ul>
</section>
<section id="step-by-step-example-33" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-33">Step-by-Step Example</h4>
<p>Consider a quadrilateral with vertices: <span class="math display">\[
V_0=(0,0),; V_1=(1,0),; V_2=(1,1),; V_3=(0,1)
\]</span></p>
<p>Two triangulations:</p>
<ol type="1">
<li>Diagonal (V_0V_2): triangles ((V_0,V_1,V_2)) and ((V_0,V_2,V_3))</li>
<li>Diagonal (V_1V_3): triangles ((V_0,V_1,V_3)) and ((V_1,V_2,V_3))</li>
</ol>
<p>Both give same area (=1). DP would compute both and take the minimum.</p>
</section>
<section id="a-gentle-proof-why-it-works-21" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-21">A Gentle Proof (Why It Works)</h4>
<p>Every triangulation must include exactly (n-3) diagonals. Fixing a triangle ((V_i, V_k, V_j)) that uses diagonal (V_iV_j) partitions the polygon into two smaller convex polygons. Since subproblems do not overlap except at the boundary, their optimal solutions combine to the global optimum. By evaluating all (k) between (i) and (j), we guarantee we find the optimal split. The recurrence enumerates all possible triangulations implicitly.</p>
</section>
<section id="try-it-yourself-34" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-34">Try It Yourself</h4>
<ol type="1">
<li>Change the cost function to perimeter instead of area.</li>
<li>Print the sequence of triangles chosen by storing split points.</li>
<li>Visualize the triangulation order in 2D.</li>
<li>Compare complexity vs brute force enumeration.</li>
<li>Implement in memoized recursion style.</li>
</ol>
</section>
<section id="test-cases-34" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-34">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Vertices</th>
<th>Expected Min Cost (Area)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square (0,0),(1,0),(1,1),(0,1)</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>Triangle (0,0),(1,0),(0,1)</td>
<td>0.5</td>
</tr>
<tr class="odd">
<td>Pentagon (0,0),(1,0),(2,1),(1,2),(0,1)</td>
<td>Varies with shape</td>
</tr>
<tr class="even">
<td>(0,0),(2,0),(2,2),(0,2)</td>
<td>4.0</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-34" class="level4">
<h4 class="anchored" data-anchor-id="complexity-34">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^3)\)</span> (triply nested loop)</li>
<li>Space: <span class="math inline">\(O(n^2)\)</span> (DP table)</li>
</ul>
<p>Polygon Triangulation is the geometric twin of matrix-chain optimization, same recurrence, new meaning.</p>
</section>
</section>
<section id="matrix-path-sum" class="level3">
<h3 class="anchored" data-anchor-id="matrix-path-sum">436 Matrix Path Sum</h3>
<p>The Matrix Path Sum problem asks for a path from the top-left to the bottom-right of a grid that optimizes a score, typically the minimum total sum of visited cells, moving only right or down.</p>
<section id="what-problem-are-we-solving-35" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-35">What Problem Are We Solving?</h4>
<p>Given an <span class="math inline">\(m\times n\)</span> matrix <span class="math inline">\(A\)</span> of integers, find the minimum cost to go from <span class="math inline">\((0,0)\)</span> to <span class="math inline">\((m-1,n-1)\)</span> using moves <span class="math inline">\({,\text{right},\text{down},}\)</span>.</p>
<p>State: <span class="math display">\[
dp[i][j]=\text{minimum path sum to reach cell }(i,j)
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[i][j]=A[i][j]+\min\big(dp[i-1][j],,dp[i][j-1]\big)
\]</span></p>
<p>Borders: <span class="math display">\[
dp[0][0]=A[0][0],\quad
dp[i][0]=A[i][0]+dp[i-1][0],\quad
dp[0][j]=A[0][j]+dp[0][j-1]
\]</span></p>
<p>Answer: <span class="math display">\[
dp[m-1][n-1]
\]</span></p>
<p>Space optimization: keep one row <span class="math display">\[
\text{row}[j]=A[i][j]+\min(\text{row}[j],,\text{row}[j-1])
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-35" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-35">How Does It Work (Plain Language)</h4>
<p>Each cell’s best cost equals its value plus the better of the two ways you could have arrived: from above or from the left. Build the table row by row until the destination cell is filled.</p>
<p>Example: <span class="math display">\[
A=
\begin{bmatrix}
1&amp;3&amp;1\
1&amp;5&amp;1\
4&amp;2&amp;1
\end{bmatrix}
\]</span> Optimal sum is <span class="math inline">\(1+1+3+1+1=7\)</span> via path <span class="math inline">\((0,0)\to(1,0)\to(1,1)\to(1,2)\to(2,2)\)</span>.</p>
</section>
<section id="tiny-code-easy-versions-34" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-34">Tiny Code (Easy Versions)</h4>
<p>C (2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb73"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>m<span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> A<span class="op">[</span>m<span class="op">][</span>n<span class="op">],</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> MIN<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D Space Optimized)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>row <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>row[<span class="dv">0</span>] <span class="op">=</span> A[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    row[j] <span class="op">=</span> row[j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> A[<span class="dv">0</span>][j]</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    row[<span class="dv">0</span>] <span class="op">+=</span> A[i][<span class="dv">0</span>]</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>        row[j] <span class="op">=</span> A[i][j] <span class="op">+</span> <span class="bu">min</span>(row[j], row[j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(row[<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-35" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-35">Why It Matters</h4>
<ul>
<li>Core template for grid DP and shortest path on DAGs</li>
<li>Basis for image seam carving, robot motion on grids, spreadsheet cost flows</li>
<li>Demonstrates classic DP patterns: table fill, border initialization, and space rolling</li>
</ul>
</section>
<section id="step-by-step-example-34" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-34">Step-by-Step Example</h4>
<p>For <span class="math display">\[
A=
\begin{bmatrix}
5&amp;1&amp;3\
2&amp;8&amp;1\
4&amp;2&amp;1
\end{bmatrix}
\]</span> compute row by row:</p>
<ul>
<li><p>First row <span class="math inline">\(dp\)</span>: <span class="math inline">\([5,6,9]\)</span></p></li>
<li><p>First column <span class="math inline">\(dp\)</span>: <span class="math inline">\([5,7,11]\)</span></p></li>
<li><p>Fill inner:</p>
<ul>
<li><span class="math inline">\(dp[1][1]=8+\min(6,7)=14\)</span></li>
<li><span class="math inline">\(dp[1][2]=1+\min(9,14)=10\)</span></li>
<li><span class="math inline">\(dp[2][1]=2+\min(14,11)=13\)</span></li>
<li><span class="math inline">\(dp[2][2]=1+\min(10,13)=11\)</span></li>
</ul></li>
</ul>
<p>Answer <span class="math inline">\(=11\)</span>.</p>
</section>
<section id="a-gentle-proof-why-it-works-22" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-22">A Gentle Proof (Why It Works)</h4>
<p>Any optimal path to <span class="math inline">\((i,j)\)</span> must come from either <span class="math inline">\((i-1,j)\)</span> or <span class="math inline">\((i,j-1)\)</span> because moves are only right or down. If a cheaper route existed that did not pass through the cheaper of these two, replacing the prefix with the cheaper subpath would reduce the total cost, which is a contradiction. Hence the local recurrence using the minimum of top and left yields the global optimum when filled in topological order.</p>
</section>
<section id="try-it-yourself-35" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-35">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct the path: keep a parent pointer from each <span class="math inline">\((i,j)\)</span> to argmin of top or left.</li>
<li>Maximize sum instead of minimize by changing <span class="math inline">\(\min\)</span> to <span class="math inline">\(\max\)</span>.</li>
<li>Add obstacles: mark blocked cells with <span class="math inline">\(+\infty\)</span> and skip them.</li>
<li>Allow moves right, down, and diagonal down-right. Extend the recurrence to three predecessors.</li>
<li>Use large matrices and compare 2D DP vs 1D rolling performance.</li>
</ol>
</section>
<section id="test-cases-35" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-35">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Matrix</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[1,3,1],[1,5,1],[4,2,1]]</td>
<td>7</td>
</tr>
<tr class="even">
<td>[[5]]</td>
<td>5</td>
</tr>
<tr class="odd">
<td>[[1,2,3],[4,5,6]]</td>
<td>12</td>
</tr>
<tr class="even">
<td>[[1,1,1],[1,1,1],[1,1,1]]</td>
<td>5</td>
</tr>
<tr class="odd">
<td>[[5,1,3],[2,8,1],[4,2,1]]</td>
<td>11</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-35" class="level4">
<h4 class="anchored" data-anchor-id="complexity-35">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(mn)\)</span></li>
<li>Space: <span class="math inline">\(O(mn)\)</span> with full table or <span class="math inline">\(O(n)\)</span> with row rolling</li>
</ul>
<p>Matrix Path Sum is the go-to pattern for grid costs: initialize borders, sweep the table, and each cell is its value plus the best way to arrive.</p>
</section>
</section>
<section id="largest-square-submatrix" class="level3">
<h3 class="anchored" data-anchor-id="largest-square-submatrix">437 Largest Square Submatrix</h3>
<p>The Largest Square Submatrix problem asks for the size of the biggest square of 1s in a binary matrix. It’s a staple 2D DP problem, each cell’s value tells how large a square can end at that position.</p>
<section id="what-problem-are-we-solving-36" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-36">What Problem Are We Solving?</h4>
<p>Given a binary matrix <span class="math inline">\(A\)</span> of size <span class="math inline">\(m\times n\)</span>, find the side length of the largest all-1s square.</p>
<p>We define <span class="math display">\[
dp[i][j] = \text{side length of the largest square whose bottom right corner is at } (i,j).
\]</span></p>
<p>Recurrence: <span class="math display">\[
dp[i][j]=
\begin{cases}
A[i][j], &amp; i=0 \text{ or } j=0,\\
0, &amp; A[i][j]=0,\\
\min\{dp[i-1][j],\, dp[i][j-1],\, dp[i-1][j-1]\}+1, &amp; A[i][j]=1.
\end{cases}
\]</span></p>
<p>Answer: <span class="math display">\[
\max_{i,j} dp[i][j].
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-36" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-36">How Does It Work (Plain Language)</h4>
<p>Each cell says: <em>“How big a square of 1s can I end?”</em> If it’s a 1, we look up, left, and up-left, the smallest of those tells how big a square we can extend.</p>
<p>Intuition:</p>
<ul>
<li>A square can grow only if all its borders can.</li>
<li>So a 1 at ((i,j)) grows a square of size <code>1 + min(three neighbors)</code>.</li>
</ul>
<p>Example:</p>
<pre><code>1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0</code></pre>
<p>The largest square has side length 3.</p>
</section>
<section id="tiny-code-easy-versions-35" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-35">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb76"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>m<span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> A<span class="op">[</span>m<span class="op">][</span>n<span class="op">],</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">&lt;</span>n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_side <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">&lt;</span>n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>i<span class="op">==</span><span class="dv">0</span> <span class="op">||</span> j<span class="op">==</span><span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> MIN<span class="op">(</span>MIN<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]),</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&gt;</span> max_side<span class="op">)</span> max_side <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> max_side<span class="op">);</span></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>max_side <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> A[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>            max_side <span class="op">=</span> <span class="bu">max</span>(max_side, dp[i][j])</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_side)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-36" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-36">Why It Matters</h4>
<ul>
<li>Foundation of 2D DP problems (local recurrence on neighbors).</li>
<li>Directly extends to rectangles, histograms, obstacles, or weighted cells.</li>
<li>Used in image processing, pattern detection, bioinformatics grids.</li>
<li>Demonstrates how spatial structure can be captured by overlapping subproblems.</li>
</ul>
</section>
<section id="step-by-step-example-35" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-35">Step-by-Step Example</h4>
<p>Matrix: <span class="math display">\[
A =
\begin{bmatrix}
1 &amp; 1 &amp; 1 \
1 &amp; 1 &amp; 1 \
0 &amp; 1 &amp; 1
\end{bmatrix}
\]</span></p>
<p>Fill DP:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>DP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Row 2:</p>
<ul>
<li><span class="math inline">\(dp[1][1] = \min(1,1,1) + 1 = 2\)</span></li>
<li><span class="math inline">\(dp[1][2] = \min(1,1,1) + 1 = 2\)</span></li>
</ul>
<p>Row 3:</p>
<ul>
<li><span class="math inline">\(dp[2][2] = \min(2,2,1) + 1 = 2\)</span></li>
</ul>
<p><span class="math inline">\(\text{Max} = 2 \Rightarrow \text{square side} = 2\)</span></p>
</section>
<section id="a-gentle-proof-why-it-works-23" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-23">A Gentle Proof (Why It Works)</h4>
<p>A cell ((i,j)) can be the bottom-right corner of a square of side (k) iff:</p>
<ul>
<li>The cells directly above, left, and diagonal up-left can each form a square of side (k-1). So (dp[i][j]) is the largest (k) satisfying these. Filling top-down ensures each needed neighbor is ready, and taking the min keeps the square aligned.</li>
</ul>
</section>
<section id="try-it-yourself-36" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-36">Try It Yourself</h4>
<ol type="1">
<li>Modify to return area instead of side length.</li>
<li>Handle obstacles (cells with -1) as blocked.</li>
<li>Adapt to maximum rectangle of 1s (hint: histogram DP per row).</li>
<li>Output coordinates of top-left cell of the largest square.</li>
<li>Compare time between full and 1D-rolled DP.</li>
</ol>
</section>
<section id="test-cases-36" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-36">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Matrix</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[1,1,1],[1,1,1],[1,1,1]]</td>
<td>3</td>
</tr>
<tr class="even">
<td>[[0,1],[1,1]]</td>
<td>2</td>
</tr>
<tr class="odd">
<td>[[1,0,1],[1,1,1],[1,1,0]]</td>
<td>2</td>
</tr>
<tr class="even">
<td>[[1]]</td>
<td>1</td>
</tr>
<tr class="odd">
<td>[[0,0],[0,0]]</td>
<td>0</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-36" class="level4">
<h4 class="anchored" data-anchor-id="complexity-36">Complexity</h4>
<ul>
<li>Time: (O(mn))</li>
<li>Space: (O(mn)) or (O(n)) with rolling rows</li>
</ul>
<p>This problem is a clean showcase of local DP propagation, each cell grows the memory of its best square from three neighbors.</p>
</section>
</section>
<section id="max-rectangle-in-binary-matrix" class="level3">
<h3 class="anchored" data-anchor-id="max-rectangle-in-binary-matrix">438 Max Rectangle in Binary Matrix</h3>
<p>The Max Rectangle in Binary Matrix problem asks for the area of the largest rectangle containing only 1s in a binary matrix. It’s a powerful combination of 2D DP and stack-based histogram algorithms, every row is treated as the base of a histogram, and we compute the largest rectangle there.</p>
<section id="what-problem-are-we-solving-37" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-37">What Problem Are We Solving?</h4>
<p>Given a binary matrix <span class="math inline">\(A\)</span> of size <span class="math inline">\(m \times n\)</span>, find the maximum rectangular area consisting entirely of 1s.</p>
<p>Interpret each row as a histogram of heights and update per row: <span class="math display">\[
\text{height}[j]=
\begin{cases}
\text{height}[j]+1, &amp; A[i][j]=1,\\
0, &amp; A[i][j]=0.
\end{cases}
\]</span> At each row, compute the Largest Rectangle in Histogram on <span class="math inline">\(\text{height}\)</span>.</p>
<p>Equivalent 2D recurrence for heights: <span class="math display">\[
\text{height}[i][j]=
\begin{cases}
A[i][j]+\text{height}[i-1][j], &amp; A[i][j]=1,\\
0, &amp; A[i][j]=0.
\end{cases}
\]</span></p>
<p>Answer: <span class="math display">\[
\max_i \operatorname{LargestRectangle}\big(\text{height}[i]\big).
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-37" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-37">How Does It Work (Plain Language)</h4>
<p>Think of the matrix as stacked histograms:</p>
<ul>
<li>Each row builds on top of the one above.</li>
<li>A <code>1</code> extends the height; a <code>0</code> resets it.</li>
<li>For each row, we ask: “What’s the largest rectangle if this row were the bottom?”</li>
</ul>
<p>This converts a 2D problem into (m) histogram problems.</p>
<p>Example:</p>
<pre><code>1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0</code></pre>
<p>The largest rectangle of 1s has area 6.</p>
</section>
<section id="tiny-code-easy-versions-36" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-36">Tiny Code (Easy Versions)</h4>
<p>C (Using Stack for Histogram)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb79"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">205</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX2</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> largest_histogram<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>h<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stack<span class="op">[</span>MAX<span class="op">],</span> top <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> maxA <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur <span class="op">=</span> <span class="op">(</span>i <span class="op">==</span> n <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> h<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>top <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> h<span class="op">[</span>stack<span class="op">[</span>top<span class="op">]]</span> <span class="op">&gt;=</span> cur<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> height <span class="op">=</span> h<span class="op">[</span>stack<span class="op">[</span>top<span class="op">--]];</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> width <span class="op">=</span> <span class="op">(</span>top <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">?</span> i <span class="op">:</span> i <span class="op">-</span> stack<span class="op">[</span>top<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> area <span class="op">=</span> height <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>area <span class="op">&gt;</span> maxA<span class="op">)</span> maxA <span class="op">=</span> area<span class="op">;</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>        stack<span class="op">[++</span>top<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxA<span class="op">;</span></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>m<span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> A<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">[</span>MAX<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">},</span> maxArea <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a>            height<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">?</span> height<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> area <span class="op">=</span> largest_histogram<span class="op">(</span>height<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>area <span class="op">&gt;</span> maxArea<span class="op">)</span> maxArea <span class="op">=</span> area<span class="op">;</span></span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> maxArea<span class="op">);</span></span>
<span id="cb79-36"><a href="#cb79-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-37"><a href="#cb79-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Stack-Based)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> largest_histogram(h):</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    stack, maxA <span class="op">=</span> [], <span class="dv">0</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    h.append(<span class="dv">0</span>)</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(h):</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> stack <span class="kw">and</span> h[stack[<span class="op">-</span><span class="dv">1</span>]] <span class="op">&gt;=</span> x:</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>            height <span class="op">=</span> h[stack.pop()]</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>            width <span class="op">=</span> i <span class="cf">if</span> <span class="kw">not</span> stack <span class="cf">else</span> i <span class="op">-</span> stack[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>            maxA <span class="op">=</span> <span class="bu">max</span>(maxA, height <span class="op">*</span> width)</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>        stack.append(i)</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>    h.pop()</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxA</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>maxA <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>        height[j] <span class="op">=</span> height[j] <span class="op">+</span> <span class="dv">1</span> <span class="cf">if</span> A[i][j] <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a>    maxA <span class="op">=</span> <span class="bu">max</span>(maxA, largest_histogram(height))</span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxA)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-37" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-37">Why It Matters</h4>
<ul>
<li>Core of 2D maximal area problems</li>
<li>Connects DP (height propagation) and stack algorithms (histogram)</li>
<li>Used in image segmentation, pattern recognition, binary masks</li>
<li>Template for maximal submatrix under constraints</li>
</ul>
</section>
<section id="step-by-step-example-36" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-36">Step-by-Step Example</h4>
<p>For: <span class="math display">\[
A=
\begin{bmatrix}
1 &amp; 1 &amp; 1 \
1 &amp; 1 &amp; 1 \
1 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>Row 1: <code>[1,1,1]</code> → largest histogram = 3 Row 2: <code>[2,2,2]</code> → largest histogram = 6 Row 3: <code>[3,0,3]</code> → largest histogram = 3 Max = 6</p>
</section>
<section id="a-gentle-proof-why-it-works-24" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-24">A Gentle Proof (Why It Works)</h4>
<p>Each rectangle in the matrix can be identified by its bottom row and column range. The height array at row (i) encodes exactly the number of consecutive 1s above each column, including row (i). Thus every maximal rectangle’s bottom row is considered once, and the largest histogram algorithm ensures that for each height combination, the maximal area is found. Therefore, iterating all rows yields the global optimum.</p>
</section>
<section id="try-it-yourself-37" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-37">Try It Yourself</h4>
<ol type="1">
<li>Modify to return coordinates of top-left and bottom-right corners.</li>
<li>Extend to max rectangle of 0s by flipping bits.</li>
<li>Compare to Largest Square Submatrix, same idea, different recurrence.</li>
<li>Use rolling arrays for memory reduction.</li>
<li>Visualize histogram growth row by row.</li>
</ol>
</section>
<section id="test-cases-37" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-37">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 74%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Matrix</th>
<th>Expected Max Area</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]</td>
<td>6</td>
</tr>
<tr class="even">
<td>[[1,1,1],[1,1,1],[1,1,1]]</td>
<td>9</td>
</tr>
<tr class="odd">
<td>[[0,0],[0,0]]</td>
<td>0</td>
</tr>
<tr class="even">
<td>[[1]]</td>
<td>1</td>
</tr>
<tr class="odd">
<td>[[1,0,1],[1,1,1],[1,1,0]]</td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-37" class="level4">
<h4 class="anchored" data-anchor-id="complexity-37">Complexity</h4>
<ul>
<li>Time: (O(mn)) (each cell pushed/popped once across all rows)</li>
<li>Space: (O(n)) for histogram and stack</li>
</ul>
<p>This problem elegantly layers row-wise DP and histogram optimization, a universal method for maximal rectangles in 2D grids.</p>
</section>
</section>
<section id="submatrix-sum-queries" class="level3">
<h3 class="anchored" data-anchor-id="submatrix-sum-queries">439 Submatrix Sum Queries</h3>
<p>The Submatrix Sum Queries problem asks for the sum of all elements inside many rectangular regions of a 2D array. With a 2D prefix sum DP table, each query can be answered in <span class="math inline">\(O(1)\)</span> time after <span class="math inline">\(O(mn)\)</span> preprocessing.</p>
<section id="what-problem-are-we-solving-38" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-38">What Problem Are We Solving?</h4>
<p>Given an <span class="math inline">\(m\times n\)</span> matrix <span class="math inline">\(A\)</span> and many queries of the form <span class="math inline">\((r_1,c_1,r_2,c_2)\)</span> with <span class="math inline">\(0\le r_1\le r_2&lt;m\)</span> and <span class="math inline">\(0\le c_1\le c_2&lt;n\)</span>, compute:</p>
<p><span class="math display">\[
\text{Sum}(r_1,c_1,r_2,c_2)=\sum_{i=r_1}^{r_2}\sum_{j=c_1}^{c_2}A[i][j]
\]</span></p>
<p>Define the 2D prefix sum <span class="math inline">\(P\)</span> using 1-based indexing:</p>
<p><span class="math display">\[
P[i][j]=\sum_{x=1}^{i}\sum_{y=1}^{j}A[x-1][y-1], \quad 1\le i\le m,\ 1\le j\le n
\]</span></p>
<p>with <span class="math inline">\(P[0][*]=P[*][0]=0\)</span>.</p>
<p>Then any submatrix sum is:</p>
<p><span class="math display">\[
S=P[r_2+1][c_2+1]-P[r_1][c_2+1]-P[r_2+1][c_1]+P[r_1][c_1]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-38" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-38">How Does It Work (Plain Language)</h4>
<p>Precompute cumulative sums from the top-left corner. The sum of a rectangle is then the big prefix up to its bottom-right, minus the two prefixes above and left, plus back the overlap you subtracted twice. This is just inclusion-exclusion in 2D.</p>
<p>Example:</p>
<p><span class="math display">\[
A =
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
7 &amp; 8 &amp; 9
\end{bmatrix}
\]</span></p>
<p>Query <span class="math inline">\((r_1,c_1,r_2,c_2)=(1,1,2,2)\)</span> over <span class="math display">\[
\begin{bmatrix}
5 &amp; 6 \\
8 &amp; 9
\end{bmatrix}
\]</span> gives <span class="math inline">\(5+6+8+9=28\)</span>.</p>
</section>
<section id="tiny-code-easy-versions-37" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-37">Tiny Code (Easy Versions)</h4>
<p>C (2D Prefix Sum, many queries in O(1) each)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb81"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span> n<span class="op">,</span> q<span class="op">;</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>m<span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> A<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> P<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> P<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> P<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> rowsum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>            rowsum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>            P<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> P<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> rowsum<span class="op">;</span></span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>q<span class="op">);</span></span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>q<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> r1<span class="op">,</span> c1<span class="op">,</span> r2<span class="op">,</span> c2<span class="op">;</span></span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>r1<span class="op">,</span> <span class="op">&amp;</span>c1<span class="op">,</span> <span class="op">&amp;</span>r2<span class="op">,</span> <span class="op">&amp;</span>c2<span class="op">);</span></span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> S <span class="op">=</span> P<span class="op">[</span>r2<span class="op">+</span><span class="dv">1</span><span class="op">][</span>c2<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> P<span class="op">[</span>r1<span class="op">][</span>c2<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> P<span class="op">[</span>r2<span class="op">+</span><span class="dv">1</span><span class="op">][</span>c1<span class="op">]</span> <span class="op">+</span> P<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">];</span></span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> S<span class="op">);</span></span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (2D Prefix Sum)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>m, n <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    rowsum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>        rowsum <span class="op">+=</span> A[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>        P[i][j] <span class="op">=</span> P[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> rowsum</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>())</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(q):</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    r1, c1, r2, c2 <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> P[r2<span class="op">+</span><span class="dv">1</span>][c2<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> P[r1][c2<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> P[r2<span class="op">+</span><span class="dv">1</span>][c1] <span class="op">+</span> P[r1][c1]</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(S)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-38" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-38">Why It Matters</h4>
<ul>
<li>Turns many 2D range sum queries into <span class="math inline">\(O(1)\)</span> time each after <span class="math inline">\(O(mn)\)</span> preprocessing</li>
<li>Fundamental for integral images, heatmaps, terrain elevation maps, and data analytics</li>
<li>Building block for maximum submatrix sum, range average, and density queries</li>
</ul>
</section>
<section id="step-by-step-example-37" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-37">Step-by-Step Example</h4>
<p>Let <span class="math display">\[
A =
\begin{bmatrix}
2 &amp; -1 &amp; 3 \\
0 &amp; 4 &amp; 5 \\
7 &amp; 2 &amp; -6
\end{bmatrix}
\]</span></p>
<p>Query <span class="math inline">\((0,1,2,2)\)</span> covers the submatrix <span class="math display">\[
\begin{bmatrix}
-1 &amp; 3 \\
4 &amp; 5 \\
2 &amp; -6
\end{bmatrix}
\]</span> whose sum is <span class="math display">\[
-1 + 3 + 4 + 5 + 2 - 6 = 7.
\]</span></p>
<p>Check formula:</p>
<p><span class="math display">\[
S = P[3][3]-P[0][3]-P[3][1]+P[0][1] = 12-4-7+6 = 7
\]</span></p>
</section>
<section id="a-gentle-proof-why-it-works-25" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-25">A Gentle Proof (Why It Works)</h4>
<p>By definition, <span class="math inline">\(P[i][j]=\sum_{x\le i}\sum_{y\le j}A[x-1][y-1]\)</span>.</p>
<p>For rectangle <span class="math inline">\([r_1..r_2]\times[c_1..c_2]\)</span>:</p>
<ul>
<li><span class="math inline">\(P[r_2+1][c_2+1]\)</span>: total up to bottom-right</li>
<li>subtract <span class="math inline">\(P[r_1][c_2+1]\)</span>: remove rows above</li>
<li>subtract <span class="math inline">\(P[r_2+1][c_1]\)</span>: remove columns left</li>
<li>add <span class="math inline">\(P[r_1][c_1]\)</span>: restore overlap</li>
</ul>
<p>Thus, the inclusion-exclusion identity holds.</p>
</section>
<section id="try-it-yourself-38" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-38">Try It Yourself</h4>
<ol type="1">
<li>Extend to 3D prefix sums for cuboid queries</li>
<li>Support range average (divide sum by area)</li>
<li>Add modulo arithmetic for large sums</li>
<li>Handle sparse updates with a 2D Fenwick tree</li>
<li>Precompute prefix sum for probability maps or heat distributions</li>
</ol>
</section>
<section id="test-cases-38" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-38">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Matrix</th>
<th>Query <span class="math inline">\((r_1,c_1,r_2,c_2)\)</span></th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[1,2],[3,4]]</td>
<td>(0,0,1,1)</td>
<td>10</td>
</tr>
<tr class="even">
<td>[[1,2,3],[4,5,6],[7,8,9]]</td>
<td>(1,1,2,2)</td>
<td>28</td>
</tr>
<tr class="odd">
<td>[[2,-1,3],[0,4,5],[7,2,-6]]</td>
<td>(0,1,2,2)</td>
<td>7</td>
</tr>
<tr class="even">
<td>[[5]]</td>
<td>(0,0,0,0)</td>
<td>5</td>
</tr>
<tr class="odd">
<td>[[1,0,1],[0,1,0],[1,0,1]]</td>
<td>(0,0,2,2)</td>
<td>5</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-38" class="level4">
<h4 class="anchored" data-anchor-id="complexity-38">Complexity</h4>
<ul>
<li>Preprocessing: <span class="math inline">\(O(mn)\)</span></li>
<li>Query: <span class="math inline">\(O(1)\)</span></li>
<li>Space: <span class="math inline">\(O(mn)\)</span></li>
</ul>
<p>2D prefix sums are a foundational DP tool: preprocess once, then every submatrix sum is instant.</p>
</section>
</section>
<section id="palindrome-partitioning" class="level3">
<h3 class="anchored" data-anchor-id="palindrome-partitioning">440 Palindrome Partitioning</h3>
<p>The Palindrome Partitioning problem asks you to divide a string into the fewest possible substrings such that each substring is a palindrome. It’s a quintessential interval DP problem where we explore all split points, using precomputed palindrome checks to accelerate the recurrence.</p>
<section id="what-problem-are-we-solving-39" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-39">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(s\)</span> of length <span class="math inline">\(n\)</span>, find the minimum number of cuts needed so that every substring is a palindrome.</p>
<p>For example: <span class="math inline">\(s=\text{"aab"}\)</span> The best partition is <code>"aa" | "b"</code>, needing 1 cut.</p>
<p>We define:</p>
<ul>
<li><span class="math inline">\(dp[i]\)</span> = minimum cuts needed for substring <span class="math inline">\(s[0..i]\)</span></li>
<li><span class="math inline">\(pal[i][j] = 1\)</span> if <span class="math inline">\(s[i..j]\)</span> is palindrome, else <span class="math inline">\(0\)</span></li>
</ul>
<p>Recurrence: <span class="math display">\[
dp[i] =
\begin{cases}
0, &amp; \text{if } pal[0][i] = 1,\\
\min_{0 \le j &lt; i,\ pal[j+1][i] = 1} (dp[j] + 1), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Precompute <span class="math inline">\(pal[i][j]\)</span> using: <span class="math display">\[
pal[i][j] = (s[i]=s[j]) \land (j-i&lt;2 \lor pal[i+1][j-1])
\]</span></p>
<p>Answer: <span class="math inline">\(dp[n-1]\)</span></p>
</section>
<section id="how-does-it-work-plain-language-39" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-39">How Does It Work (Plain Language)</h4>
<p>We want to cut the string at points where the right substring is a palindrome. For each index <span class="math inline">\(i\)</span>, we find all <span class="math inline">\(j&lt;i\)</span> such that <span class="math inline">\(s[j+1..i]\)</span> is palindrome and take the minimum over <span class="math inline">\(dp[j]+1\)</span>.</p>
<p>To avoid <span class="math inline">\(O(n^3)\)</span>, we first precompute <span class="math inline">\(pal[i][j]\)</span> in <span class="math inline">\(O(n^2)\)</span>.</p>
<p>Example:</p>
<pre><code>s = "aab"
pal = 
a a b
1 1 0
  1 0
    1</code></pre>
<p>Cuts:</p>
<ul>
<li><span class="math inline">\(dp[0]=0\)</span> (<code>a</code>)</li>
<li><span class="math inline">\(dp[1]=0\)</span> (<code>aa</code>)</li>
<li><span class="math inline">\(dp[2]=1\)</span> (<code>aa|b</code>) → answer = 1</li>
</ul>
</section>
<section id="tiny-code-easy-versions-38" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-38">Tiny Code (Easy Versions)</h4>
<p>C (Bottom-Up DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb84"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MIN</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">1005</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> s<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> s<span class="op">);</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> pal<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> pal<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>len <span class="op">==</span> <span class="dv">2</span> <span class="op">||</span> pal<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> pal<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pal<span class="op">[</span><span class="dv">0</span><span class="op">][</span>i<span class="op">])</span> <span class="op">{</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="cf">continue</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INT_MAX<span class="op">;</span></span>
<span id="cb84-28"><a href="#cb84-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb84-29"><a href="#cb84-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>pal<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">][</span>i<span class="op">]</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb84-30"><a href="#cb84-30" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb84-31"><a href="#cb84-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb84-32"><a href="#cb84-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb84-33"><a href="#cb84-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-34"><a href="#cb84-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb84-35"><a href="#cb84-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb84-36"><a href="#cb84-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Readable)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="bu">input</span>().strip()</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>pal <span class="op">=</span> [[<span class="va">False</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>    pal[i][i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span>length<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[j] <span class="kw">and</span> (length <span class="op">==</span> <span class="dv">2</span> <span class="kw">or</span> pal[i<span class="op">+</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>            pal[i][j] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pal[<span class="dv">0</span>][i]:</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">min</span>(dp[j]<span class="op">+</span><span class="dv">1</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i) <span class="cf">if</span> pal[j<span class="op">+</span><span class="dv">1</span>][i])</span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp[<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-39" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-39">Why It Matters</h4>
<ul>
<li>Teaches interval DP with string-based state</li>
<li>Used in text segmentation, DNA sequence analysis, code parsing</li>
<li>Builds intuition for partitioning problems and precomputation synergy</li>
</ul>
</section>
<section id="step-by-step-example-38" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-38">Step-by-Step Example</h4>
<p><span class="math inline">\(s = \text{"banana"}\)</span></p>
<p>Palindromic substrings:</p>
<ul>
<li>Single letters</li>
<li><code>"ana"</code> at positions (1–3), (3–5)</li>
<li><code>"anana"</code> at (1–5)</li>
</ul>
<p>Compute <span class="math inline">\(dp\)</span>:</p>
<ul>
<li><span class="math inline">\(dp[0]=0\)</span></li>
<li><span class="math inline">\(dp[1]=1\)</span> (<code>b|a</code>)</li>
<li><span class="math inline">\(dp[2]=1\)</span> (<code>ba|n</code>)</li>
<li><span class="math inline">\(dp[3]=1\)</span> (<code>b|ana</code>)</li>
<li><span class="math inline">\(dp[4]=2\)</span> (<code>b|an|an</code>)</li>
<li><span class="math inline">\(dp[5]=1\)</span> (<code>b|anana</code>) → Answer = 1</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-26" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-26">A Gentle Proof (Why It Works)</h4>
<p>A valid partition ends at some position <span class="math inline">\(i\)</span>. If <span class="math inline">\(s[j+1..i]\)</span> is palindrome, then the cost to partition up to <span class="math inline">\(i\)</span> is <span class="math inline">\(dp[j]+1\)</span>. The optimal must choose the best such <span class="math inline">\(j\)</span>. By precomputing all palindrome substrings, each <span class="math inline">\(dp[i]\)</span> depends only on smaller indices, satisfying the principle of optimality.</p>
</section>
<section id="try-it-yourself-39" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-39">Try It Yourself</h4>
<ol type="1">
<li>Return the actual partitions using a parent array.</li>
<li>Modify to count all partitions instead of minimizing.</li>
<li>Adapt to palindromic subsequences (different structure).</li>
<li>Visualize DP and palindrome tables side by side.</li>
<li>Benchmark naive vs precomputed palindrome approaches.</li>
</ol>
</section>
<section id="test-cases-39" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-39">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>s</th>
<th>Expected Cuts</th>
<th>Example Partition</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“aab”</td>
<td>1</td>
<td>“aa”</td>
<td>“b”</td>
<td></td>
</tr>
<tr class="even">
<td>“racecar”</td>
<td>0</td>
<td>“racecar”</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>“banana”</td>
<td>1</td>
<td>“b”</td>
<td>“anana”</td>
<td></td>
</tr>
<tr class="even">
<td>“abc”</td>
<td>2</td>
<td>“a”</td>
<td>“b”</td>
<td>“c”</td>
</tr>
<tr class="odd">
<td>“a”</td>
<td>0</td>
<td>“a”</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-39" class="level4">
<h4 class="anchored" data-anchor-id="complexity-39">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2)\)</span></li>
<li>Space: <span class="math inline">\(O(n^2)\)</span> (can reduce palindrome table)</li>
</ul>
<p>Palindrome Partitioning is a model example of DP with precomputation, revealing how structure (palindromes) enables efficient segmentation.</p>
</section>
</section>
</section>
<section id="section-45.-bitmask-dp-and-traveling-salesman" class="level1">
<h1>Section 45. Bitmask DP and Traveling Salesman</h1>
<section id="traveling-salesman-problem-tsp-bitmask-dp-heldkarp" class="level3">
<h3 class="anchored" data-anchor-id="traveling-salesman-problem-tsp-bitmask-dp-heldkarp">441 Traveling Salesman Problem (TSP), Bitmask DP (Held–Karp)</h3>
<p>The Traveling Salesman Problem asks for the shortest tour that visits every city exactly once and returns to the start. With dynamic programming over subsets, we can solve it in <span class="math inline">\(O(n^2 2^n)\)</span>, which is optimal up to polynomial factors for exact exponential algorithms.</p>
<section id="what-problem-are-we-solving-40" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-40">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> cities and a distance matrix <span class="math inline">\(dist[i][j]\)</span>, find the minimum tour length that starts at city <span class="math inline">\(0\)</span>, visits all cities once, and returns to <span class="math inline">\(0\)</span>.</p>
<p>State (Held–Karp):</p>
<ul>
<li>Let <span class="math inline">\(dp[mask][i]\)</span> be the minimum cost to start at <span class="math inline">\(0\)</span>, visit exactly the set of cities in bitmask <span class="math inline">\(mask\)</span> (where bit <span class="math inline">\(k\)</span> set means city <span class="math inline">\(k\)</span> is visited), and end at city <span class="math inline">\(i\)</span>.</li>
<li>Base: <span class="math inline">\(dp[1\ll 0][0]=0\)</span></li>
</ul>
<p>Transition:</p>
<p><span class="math display">\[
dp[mask][i] = \min_{j \in mask,, j\ne i}; (dp[mask\setminus{i}][j] + dist[j][i])
\]</span></p>
<p>Answer:</p>
<p><span class="math display">\[
\min_{i\ne 0}; dp[(1\ll n)-1][i] + dist[i][0]
\]</span></p>
<p>Path reconstruction: store the predecessor for each <span class="math inline">\((mask,i)\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-40" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-40">How Does It Work (Plain Language)</h4>
<p>We build tours by growing the set of visited cities. For every subset and last city <span class="math inline">\(i\)</span>, we ask:</p>
<blockquote class="blockquote">
<p>“What was the best way to visit this subset without <span class="math inline">\(i\)</span>, then hop from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span>?”</p>
</blockquote>
<p>This reuses smaller subproblems to solve larger ones, until all cities are visited.</p>
</section>
<section id="tiny-code-easy-versions-39" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-39">Tiny Code (Easy Versions)</h4>
<p>C (Bitmask DP with Reconstruction)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb86"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">20</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF  </span><span class="dv">1000000000</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dist<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> prevCity<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>dist<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">;</span></span>
<span id="cb86-19"><a href="#cb86-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> N<span class="op">;</span> m<span class="op">++)</span></span>
<span id="cb86-20"><a href="#cb86-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb86-21"><a href="#cb86-21" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>m<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">,</span> prevCity<span class="op">[</span>m<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb86-22"><a href="#cb86-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-23"><a href="#cb86-23" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb86-24"><a href="#cb86-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-25"><a href="#cb86-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb86-26"><a href="#cb86-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">))</span> <span class="op">{</span></span>
<span id="cb86-27"><a href="#cb86-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> pmask <span class="op">=</span> mask <span class="op">^</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">);</span></span>
<span id="cb86-28"><a href="#cb86-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>pmask <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb86-29"><a href="#cb86-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="cf">if</span> <span class="op">(</span>pmask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>j<span class="op">))</span> <span class="op">{</span></span>
<span id="cb86-30"><a href="#cb86-30" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> val <span class="op">=</span> dp<span class="op">[</span>pmask<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dist<span class="op">[</span>j<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb86-31"><a href="#cb86-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;</span> dp<span class="op">[</span>mask<span class="op">][</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb86-32"><a href="#cb86-32" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>mask<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb86-33"><a href="#cb86-33" aria-hidden="true" tabindex="-1"></a>                    prevCity<span class="op">[</span>mask<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb86-34"><a href="#cb86-34" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb86-35"><a href="#cb86-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb86-36"><a href="#cb86-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb86-37"><a href="#cb86-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb86-38"><a href="#cb86-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-39"><a href="#cb86-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> all <span class="op">=</span> N <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> best <span class="op">=</span> INF<span class="op">,</span> last <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb86-40"><a href="#cb86-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb86-41"><a href="#cb86-41" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> val <span class="op">=</span> dp<span class="op">[</span>all<span class="op">][</span>i<span class="op">]</span> <span class="op">+</span> dist<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb86-42"><a href="#cb86-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;</span> best<span class="op">)</span> best <span class="op">=</span> val<span class="op">,</span> last <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb86-43"><a href="#cb86-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb86-44"><a href="#cb86-44" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Min tour cost: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> best<span class="op">);</span></span>
<span id="cb86-45"><a href="#cb86-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-46"><a href="#cb86-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> path<span class="op">[</span>MAXN<span class="op">+</span><span class="dv">1</span><span class="op">],</span> cnt <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb86-47"><a href="#cb86-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mask <span class="op">=</span> all<span class="op">,</span> cur <span class="op">=</span> last<span class="op">;</span></span>
<span id="cb86-48"><a href="#cb86-48" aria-hidden="true" tabindex="-1"></a>    path<span class="op">[--</span>cnt<span class="op">]</span> <span class="op">=</span> cur<span class="op">;</span></span>
<span id="cb86-49"><a href="#cb86-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>cur <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-50"><a href="#cb86-50" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> prevCity<span class="op">[</span>mask<span class="op">][</span>cur<span class="op">];</span></span>
<span id="cb86-51"><a href="#cb86-51" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">^=</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>cur<span class="op">);</span></span>
<span id="cb86-52"><a href="#cb86-52" aria-hidden="true" tabindex="-1"></a>        cur <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb86-53"><a href="#cb86-53" aria-hidden="true" tabindex="-1"></a>        path<span class="op">[--</span>cnt<span class="op">]</span> <span class="op">=</span> cur<span class="op">;</span></span>
<span id="cb86-54"><a href="#cb86-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb86-55"><a href="#cb86-55" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Tour: "</span><span class="op">);</span></span>
<span id="cb86-56"><a href="#cb86-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> path<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb86-57"><a href="#cb86-57" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"0</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb86-58"><a href="#cb86-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb86-59"><a href="#cb86-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Compact)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1015</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(sys.stdin.readline())</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, sys.stdin.readline().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[INF]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">1</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (mask <span class="op">&amp;</span> <span class="dv">1</span>) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (mask <span class="op">&amp;</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i)) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>        pmask <span class="op">=</span> mask <span class="op">^</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i)</span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pmask <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (pmask <span class="op">&amp;</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>j)) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>            dp[mask][i] <span class="op">=</span> <span class="bu">min</span>(dp[mask][i], dp[pmask][j] <span class="op">+</span> dist[j][i])</span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a>allmask <span class="op">=</span> N <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a>ans <span class="op">=</span> <span class="bu">min</span>(dp[allmask][i] <span class="op">+</span> dist[i][<span class="dv">0</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n))</span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ans)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-40" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-40">Why It Matters</h4>
<ul>
<li>Canonical bitmask DP example</li>
<li>Exact solution with best-known time complexity for general TSP</li>
<li>Template for subset-state DP problems: assignment, routing, path cover, Steiner tree</li>
</ul>
</section>
<section id="step-by-step-example-39" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-39">Step-by-Step Example</h4>
<p>Suppose</p>
<p><span class="math display">\[
dist =
\begin{bmatrix}
0 &amp; 10 &amp; 15 &amp; 20 \\
10 &amp; 0 &amp; 35 &amp; 25 \\
15 &amp; 35 &amp; 0 &amp; 30 \\
20 &amp; 25 &amp; 30 &amp; 0
\end{bmatrix}
\]</span></p>
<p>The optimal tour is <span class="math inline">\(0 \to 1 \to 3 \to 2 \to 0\)</span> with cost <span class="math inline">\(10+25+30+15=80\)</span>.</p>
</section>
<section id="a-gentle-proof-why-it-works-27" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-27">A Gentle Proof (Why It Works)</h4>
<p>For any subset <span class="math inline">\(S\)</span> containing <span class="math inline">\(0\)</span> and endpoint <span class="math inline">\(i\in S\)</span>, the optimal path visiting <span class="math inline">\(S\)</span> and ending at <span class="math inline">\(i\)</span> must come from some <span class="math inline">\(j\in S\setminus{i}\)</span> visiting <span class="math inline">\(S\setminus{i}\)</span> optimally and then edge <span class="math inline">\(j\to i\)</span>.</p>
<p>Thus:</p>
<p><span class="math display">\[
dp[S][i] = \min_{j\in S\setminus{i}}(dp[S\setminus{i}][j] + dist[j][i])
\]</span></p>
<p>By processing subsets in increasing size, dependencies are always ready before use.</p>
</section>
<section id="try-it-yourself-40" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-40">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct the tour path</li>
<li>Add must-visit or forbidden cities</li>
<li>Run on <span class="math inline">\(n=15\)</span> and observe scaling</li>
<li>Adapt to asymmetric TSP (<span class="math inline">\(dist[i][j]\ne dist[j][i]\)</span>)</li>
<li>Compare with brute-force <span class="math inline">\(O(n!)\)</span></li>
</ol>
</section>
<section id="test-cases-40" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-40">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>dist</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>[[0,5],[5,0]]</td>
<td>10</td>
</tr>
<tr class="even">
<td>3</td>
<td>[[0,1,10],[1,0,2],[10,2,0]]</td>
<td>13</td>
</tr>
<tr class="odd">
<td>4</td>
<td>[[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]</td>
<td>80</td>
</tr>
<tr class="even">
<td>4</td>
<td>[[0,3,4,2],[3,0,1,5],[4,1,0,6],[2,5,6,0]]</td>
<td>12</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-40" class="level4">
<h4 class="anchored" data-anchor-id="complexity-40">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2 2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(n 2^n)\)</span></li>
</ul>
<p>Held–Karp DP is the foundation for exponential-time optimization over subsets, bridging combinatorial search and dynamic programming.</p>
</section>
</section>
<section id="subset-dp-over-subsets-of-states" class="level3">
<h3 class="anchored" data-anchor-id="subset-dp-over-subsets-of-states">442 Subset DP (Over Subsets of States)</h3>
<p>Subset DP is a powerful pattern where each DP state represents a subset of elements. It’s used when problems depend on combinations of items, masks, or visited sets. You define transitions based on smaller subsets, building up to larger ones.</p>
<section id="what-problem-are-we-solving-41" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-41">What Problem Are We Solving?</h4>
<p>We want to compute some function <span class="math inline">\(dp[S]\)</span> over all subsets <span class="math inline">\(S\)</span> of a universe of size <span class="math inline">\(n\)</span> (where <span class="math inline">\(S\)</span> is represented as a bitmask).</p>
<p>Each <span class="math inline">\(dp[S]\)</span> depends on smaller subsets of <span class="math inline">\(S\)</span>, typically by adding or removing one element at a time.</p>
<p>Common forms:</p>
<ul>
<li>Subset sums: <span class="math inline">\(dp[S] = \sum_{T \subset S} f[T]\)</span></li>
<li>Maximums over subsets: <span class="math inline">\(dp[S] = \max_{T \subset S} f[T]\)</span></li>
<li>Counting configurations: <span class="math inline">\(dp[S] = \sum_{i \in S} dp[S \setminus {i}]\)</span></li>
</ul>
<p>The key idea: use bit operations and iterate through submasks efficiently.</p>
</section>
<section id="how-does-it-work-plain-language-41" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-41">How Does It Work (Plain Language)</h4>
<p>Think of each subset as a state. For example, if <span class="math inline">\(n=3\)</span>, the subsets are:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Mask</th>
<th>Binary</th>
<th>Subset</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>000</td>
<td>∅</td>
</tr>
<tr class="even">
<td>1</td>
<td>001</td>
<td>{0}</td>
</tr>
<tr class="odd">
<td>2</td>
<td>010</td>
<td>{1}</td>
</tr>
<tr class="even">
<td>3</td>
<td>011</td>
<td>{0,1}</td>
</tr>
<tr class="odd">
<td>4</td>
<td>100</td>
<td>{2}</td>
</tr>
<tr class="even">
<td>5</td>
<td>101</td>
<td>{0,2}</td>
</tr>
<tr class="odd">
<td>6</td>
<td>110</td>
<td>{1,2}</td>
</tr>
<tr class="even">
<td>7</td>
<td>111</td>
<td>{0,1,2}</td>
</tr>
</tbody>
</table>
<p>Transitions depend on the structure of the problem:</p>
<ul>
<li>Additive (sum over submasks)</li>
<li>Combinational (merge results)</li>
<li>Stepwise (add/remove one bit)</li>
</ul>
</section>
<section id="example-1-sum-over-subsets-sos-dp" class="level4">
<h4 class="anchored" data-anchor-id="example-1-sum-over-subsets-sos-dp">Example 1: Sum Over Subsets (SOS DP)</h4>
<p>We want <span class="math inline">\(F[S] = \sum_{T \subseteq S} A[T]\)</span>. Naively <span class="math inline">\(O(3^n)\)</span>, but SOS DP does it in <span class="math inline">\(O(n2^n)\)</span>.</p>
<p>Algorithm:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb88"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>n<span class="op">);</span> mask<span class="op">++)</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">))</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>      F<span class="op">[</span>mask<span class="op">]</span> <span class="op">+=</span> F<span class="op">[</span>mask <span class="op">^</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">)];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each iteration adds contributions from subsets missing bit <span class="math inline">\(i\)</span>.</p>
</section>
<section id="example-2-counting-paths-on-subsets" class="level4">
<h4 class="anchored" data-anchor-id="example-2-counting-paths-on-subsets">Example 2: Counting Paths on Subsets</h4>
<p>Suppose we count Hamiltonian paths on subsets: <span class="math display">\[
dp[S][i] = \sum_{j \in S, j \ne i} dp[S\setminus{i}][j]
\]</span> with base <span class="math inline">\(dp[{i}][i]=1\)</span>.</p>
<p>Iterate all subsets, and for each subset and endpoint, sum over possible predecessors.</p>
</section>
<section id="tiny-code-easy-versions-40" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-40">Tiny Code (Easy Versions)</h4>
<p>C (Sum Over Subsets Example)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb89"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> A<span class="op">[</span><span class="dv">8</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">};</span> <span class="co">// arbitrary base values</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> F<span class="op">[</span><span class="dv">8</span><span class="op">];</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>n<span class="op">);</span> mask<span class="op">++)</span> F<span class="op">[</span>mask<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>mask<span class="op">];</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>n<span class="op">);</span> mask<span class="op">++)</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">))</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>                F<span class="op">[</span>mask<span class="op">]</span> <span class="op">+=</span> F<span class="op">[</span>mask <span class="op">^</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">)];</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>n<span class="op">);</span> mask<span class="op">++)</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"F[</span><span class="sc">%d</span><span class="st">] = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> mask<span class="op">,</span> F<span class="op">[</span>mask<span class="op">]);</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Sum Over Subsets)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> A[:]</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span><span class="op">&lt;&lt;</span>n):</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mask <span class="op">&amp;</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i):</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>            F[mask] <span class="op">+=</span> F[mask <span class="op">^</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i)]</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(F)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-41" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-41">Why It Matters</h4>
<ul>
<li>Foundation for bitmask combinatorics</li>
<li>Speeds up subset convolutions, inclusion-exclusion, and fast zeta transforms</li>
<li>Essential in Steiner Tree DP, bitmask knapsack, and TSP variants</li>
</ul>
</section>
<section id="step-by-step-example-40" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-40">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(A = [1,2,3,4,5,6,7,8]\)</span>, <span class="math inline">\(n=3\)</span>.</p>
<p>We want <span class="math inline">\(F[S]=\sum_{T\subseteq S}A[T]\)</span>.</p>
<ul>
<li><span class="math inline">\(F[0]=A[0]=1\)</span></li>
<li><span class="math inline">\(F[1]=A[1]+A[0]=3\)</span></li>
<li><span class="math inline">\(F[3]=A[3]+A[2]+A[1]+A[0]=10\)</span></li>
</ul>
<p>At the end: <span class="math inline">\(F = [1,3,4,10,5,12,13,36]\)</span></p>
</section>
<section id="a-gentle-proof-why-it-works-28" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-28">A Gentle Proof (Why It Works)</h4>
<p>Each mask represents a subset <span class="math inline">\(S\)</span>. When we iterate bit <span class="math inline">\(i\)</span>, we add <span class="math inline">\(F[S\setminus{i}]\)</span> to <span class="math inline">\(F[S]\)</span> if <span class="math inline">\(i\in S\)</span>. This propagates values from smaller subsets to larger ones, accumulating all submask contributions. The loop order ensures every submask is processed before supersets containing it.</p>
</section>
<section id="try-it-yourself-41" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-41">Try It Yourself</h4>
<ol type="1">
<li>Implement Sum Over Supersets (SOS Superset) by flipping the condition.</li>
<li>Compute <span class="math inline">\(\max_{T\subseteq S} A[T]\)</span> instead of sum.</li>
<li>Use subset DP to count number of ways to cover a set with given subsets.</li>
<li>Combine subset DP with bitcount(mask) to handle per-size transitions.</li>
<li>Visualize subset lattice as a hypercube traversal.</li>
</ol>
</section>
<section id="test-cases-41" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-41">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>Expected F (Sum Over Subsets)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,2,3,4,5,6,7,8]</td>
<td>[1,3,4,10,5,12,13,36]</td>
</tr>
<tr class="even">
<td>[0,1,0,1,0,1,0,1]</td>
<td>[0,1,0,2,0,2,0,4]</td>
</tr>
<tr class="odd">
<td>[1,0,0,0,0,0,0,0]</td>
<td>[1,1,1,1,1,1,1,1]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-41" class="level4">
<h4 class="anchored" data-anchor-id="complexity-41">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(2^n)\)</span></li>
</ul>
<p>Subset DP is a unifying pattern for problems on sets, once you see the bitmask, think “DP over subsets”.</p>
</section>
</section>
<section id="hamiltonian-path-dp-state-compression" class="level3">
<h3 class="anchored" data-anchor-id="hamiltonian-path-dp-state-compression">443 Hamiltonian Path DP (State Compression)</h3>
<p>The Hamiltonian Path DP problem asks for the shortest path that visits every vertex exactly once, without needing to return to the start. It’s a close sibling of the Traveling Salesman Problem (TSP) but without the final return edge. Using bitmask DP, we can solve it in <span class="math inline">\(O(n^2 2^n)\)</span>.</p>
<section id="what-problem-are-we-solving-42" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-42">What Problem Are We Solving?</h4>
<p>Given a complete or weighted directed graph with <span class="math inline">\(n\)</span> vertices and a cost matrix <span class="math inline">\(dist[i][j]\)</span>, find the minimum-cost path that visits all vertices exactly once.</p>
<p>We don’t need to return to the starting node (unlike TSP).</p>
<p>Define the DP state:</p>
<ul>
<li><span class="math inline">\(dp[mask][i]\)</span>: the minimum cost to visit exactly the set of vertices in <span class="math inline">\(mask\)</span> and end at vertex <span class="math inline">\(i\)</span>.</li>
</ul>
<p>Base case:</p>
<p><span class="math display">\[
dp[1&lt;&lt;i][i] = 0 \quad \forall i
\]</span></p>
<p>Transition:</p>
<p><span class="math display">\[
dp[mask][i] = \min_{j \in mask,\ j \ne i}\big(dp[mask \setminus {i}][j] + dist[j][i]\big)
\]</span></p>
<p>Answer:</p>
<p><span class="math display">\[
\min_{i} dp[(1&lt;&lt;n)-1][i]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-42" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-42">How Does It Work (Plain Language)</h4>
<p>Imagine we’re constructing paths step by step:</p>
<ol type="1">
<li>Each mask represents which vertices we’ve already visited.</li>
<li>Each endpoint <span class="math inline">\(i\)</span> means we finish the path at vertex <span class="math inline">\(i\)</span>.</li>
<li>We build <span class="math inline">\(dp[mask][i]\)</span> from smaller subsets by adding one last vertex <span class="math inline">\(i\)</span>.</li>
</ol>
<p>At each step, we check all <span class="math inline">\(j\)</span> that could be the previous vertex in the path.</p>
<p>No need to add <span class="math inline">\(dist[i][start]\)</span> because we don’t return, it’s a path, not a cycle.</p>
</section>
<section id="tiny-code-easy-versions-41" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-41">Tiny Code (Easy Versions)</h4>
<p>C (Hamiltonian Path DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb91"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">20</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dist<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>dist<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">;</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>mask<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">)))</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> pmask <span class="op">=</span> mask <span class="op">^</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">);</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>pmask <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!(</span>pmask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>j<span class="op">)))</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> cost <span class="op">=</span> dp<span class="op">[</span>pmask<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dist<span class="op">[</span>j<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>cost <span class="op">&lt;</span> dp<span class="op">[</span>mask<span class="op">][</span>i<span class="op">])</span> dp<span class="op">[</span>mask<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> cost<span class="op">;</span></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> all <span class="op">=</span> N <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb91-39"><a href="#cb91-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb91-40"><a href="#cb91-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb91-41"><a href="#cb91-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>all<span class="op">][</span>i<span class="op">]</span> <span class="op">&lt;</span> best<span class="op">)</span></span>
<span id="cb91-42"><a href="#cb91-42" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> dp<span class="op">[</span>all<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb91-43"><a href="#cb91-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-44"><a href="#cb91-44" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Minimum Hamiltonian path cost: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> best<span class="op">);</span></span>
<span id="cb91-45"><a href="#cb91-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb91-46"><a href="#cb91-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Compact Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1015</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>())</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[INF]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span><span class="op">&lt;&lt;</span>i][i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (mask <span class="op">&amp;</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i)): <span class="cf">continue</span></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>        pmask <span class="op">=</span> mask <span class="op">^</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i)</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pmask <span class="op">==</span> <span class="dv">0</span>: <span class="cf">continue</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> (pmask <span class="op">&amp;</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>j)): <span class="cf">continue</span></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a>            dp[mask][i] <span class="op">=</span> <span class="bu">min</span>(dp[mask][i], dp[pmask][j] <span class="op">+</span> dist[j][i])</span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a>ans <span class="op">=</span> <span class="bu">min</span>(dp[N<span class="op">-</span><span class="dv">1</span>][i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n))</span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ans)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-42" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-42">Why It Matters</h4>
<ul>
<li>Fundamental state compression DP pattern</li>
<li>Useful when the problem involves visiting all nodes exactly once</li>
<li>Core for path planning, ordering constraints, and bitmask search</li>
</ul>
</section>
<section id="step-by-step-example-41" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-41">Step-by-Step Example</h4>
<p>Let</p>
<p><span class="math display">\[
dist =
\begin{bmatrix}
0 &amp; 1 &amp; 4 \
1 &amp; 0 &amp; 2 \
4 &amp; 2 &amp; 0
\end{bmatrix}
\]</span></p>
<p>Paths:</p>
<ul>
<li><span class="math inline">\(0 \to 1 \to 2\)</span>: <span class="math inline">\(1 + 2 = 3\)</span></li>
<li><span class="math inline">\(0 \to 2 \to 1\)</span>: <span class="math inline">\(4 + 2 = 6\)</span></li>
<li><span class="math inline">\(1 \to 0 \to 2\)</span>: <span class="math inline">\(1 + 4 = 5\)</span></li>
</ul>
<p>So minimum path = 3. <span class="math inline">\(dp[(1&lt;&lt;3)-1] = dp[7] = [5,3,5]\)</span>, <span class="math inline">\(\min=3\)</span>.</p>
</section>
<section id="a-gentle-proof-why-it-works-29" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-29">A Gentle Proof (Why It Works)</h4>
<p>We apply optimal substructure:</p>
<p>For each subset <span class="math inline">\(S\)</span> and endpoint <span class="math inline">\(i\)</span>, the optimal Hamiltonian path to <span class="math inline">\((S,i)\)</span> must extend an optimal path to <span class="math inline">\((S\setminus{i}, j)\)</span> by one edge <span class="math inline">\(j\to i\)</span>. This recurrence ensures no city is revisited and all are included once.</p>
<p>Each <span class="math inline">\(dp[mask][i]\)</span> depends only on smaller masks, so it can be built bottom-up.</p>
</section>
<section id="try-it-yourself-42" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-42">Try It Yourself</h4>
<ol type="1">
<li>Add start node constraint (fix path must start at 0).</li>
<li>Recover the actual path using a <code>parent</code> array.</li>
<li>Modify for maximum path (replace <code>min</code> with <code>max</code>).</li>
<li>Adapt for directed graphs with asymmetric costs.</li>
<li>Use bit tricks like <code>mask &amp; -mask</code> to iterate bits efficiently.</li>
</ol>
</section>
<section id="test-cases-42" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-42">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>dist</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td>[[0,1,4],[1,0,2],[4,2,0]]</td>
<td>3</td>
</tr>
<tr class="even">
<td>4</td>
<td>[[0,3,1,5],[3,0,6,7],[1,6,0,2],[5,7,2,0]]</td>
<td>6</td>
</tr>
<tr class="odd">
<td>2</td>
<td>[[0,5],[5,0]]</td>
<td>5</td>
</tr>
<tr class="even">
<td>3</td>
<td>[[0,9,9],[9,0,1],[9,1,0]]</td>
<td>10</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-42" class="level4">
<h4 class="anchored" data-anchor-id="complexity-42">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2 2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(n 2^n)\)</span></li>
</ul>
<p>Hamiltonian Path DP is the core structure for problems involving traversal of all nodes exactly once, simple, powerful, and a template for countless variants.</p>
</section>
</section>
<section id="assignment-problem-dp-mask-over-tasks" class="level3">
<h3 class="anchored" data-anchor-id="assignment-problem-dp-mask-over-tasks">444 Assignment Problem DP (Mask over Tasks)</h3>
<p>The Assignment Problem asks for the minimum total cost to assign <span class="math inline">\(n\)</span> workers to <span class="math inline">\(n\)</span> tasks with each worker doing exactly one task and each task done by exactly one worker. Besides the Hungarian algorithm, a clean solution for small <span class="math inline">\(n\)</span> is bitmask DP over subsets of tasks.</p>
<section id="what-problem-are-we-solving-43" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-43">What Problem Are We Solving?</h4>
<p>Given a cost matrix <span class="math inline">\(C\)</span> where <span class="math inline">\(C[i][j]\)</span> is the cost for worker <span class="math inline">\(i\)</span> to do task <span class="math inline">\(j\)</span>, find the minimum cost perfect matching between workers and tasks.</p>
<p>State definition:</p>
<ul>
<li>Let <span class="math inline">\(mask\)</span> encode which tasks have been taken.</li>
<li>Let <span class="math inline">\(i=\text{popcount}(mask)\)</span> be the number of already assigned workers, meaning we are about to assign worker <span class="math inline">\(i\)</span>.</li>
</ul>
<p>DP state:</p>
<p><span class="math display">\[
dp[mask]=\text{minimum total cost to assign the first } \text{popcount}(mask)\text{ workers to the set of tasks in }mask
\]</span></p>
<p>Transition:</p>
<p><span class="math display">\[
dp[mask\cup{j}]=\min\big(dp[mask]+C[i][j]\big)\quad\text{for all tasks }j\notin mask,\ i=\text{popcount}(mask)
\]</span></p>
<p>Base and answer:</p>
<p><span class="math display">\[
dp[0]=0,\qquad \text{Answer}=dp[(1\ll n)-1]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-43" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-43">How Does It Work (Plain Language)</h4>
<p>We process workers in order <span class="math inline">\(0,1,\dots,n-1\)</span>. The bitmask tells which tasks are already used. For the next worker <span class="math inline">\(i\)</span>, try assigning any free task <span class="math inline">\(j\)</span>, add its cost, and carry the best. This builds up all partial matchings until all tasks are taken.</p>
</section>
<section id="tiny-code-easy-versions-42" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-42">Tiny Code (Easy Versions)</h4>
<p>C (Bitmask DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb93"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">20</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF  </span><span class="dv">1000000000</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> C<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span>MAXN<span class="op">];</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span>n<span class="op">;</span>j<span class="op">++)</span></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,&amp;</span>C<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N<span class="op">=</span><span class="dv">1</span><span class="op">&lt;&lt;</span>n<span class="op">;</span></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m<span class="op">=</span><span class="dv">0</span><span class="op">;</span>m<span class="op">&lt;</span>N<span class="op">;</span>m<span class="op">++)</span> dp<span class="op">[</span>m<span class="op">]=</span>INF<span class="op">;</span></span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask<span class="op">=</span><span class="dv">0</span><span class="op">;</span>mask<span class="op">&lt;</span>N<span class="op">;</span>mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i <span class="op">=</span> __builtin_popcount<span class="op">(</span>mask<span class="op">);</span></span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i<span class="op">&gt;=</span>n <span class="op">||</span> dp<span class="op">[</span>mask<span class="op">]==</span>INF<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span>n<span class="op">;</span>j<span class="op">++)</span> <span class="cf">if</span> <span class="op">(!(</span>mask<span class="op">&amp;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>j<span class="op">)))</span> <span class="op">{</span></span>
<span id="cb93-25"><a href="#cb93-25" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> nmask <span class="op">=</span> mask<span class="op">|(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>j<span class="op">);</span></span>
<span id="cb93-26"><a href="#cb93-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>mask<span class="op">]+</span>C<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;</span> dp<span class="op">[</span>nmask<span class="op">])</span></span>
<span id="cb93-27"><a href="#cb93-27" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>nmask<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>mask<span class="op">]+</span>C<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb93-28"><a href="#cb93-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb93-29"><a href="#cb93-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb93-30"><a href="#cb93-30" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>N<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb93-31"><a href="#cb93-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb93-32"><a href="#cb93-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Compact)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1015</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(sys.stdin.readline())</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, sys.stdin.readline().split())) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [INF]<span class="op">*</span>N</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="bu">bin</span>(mask).count(<span class="st">"1"</span>)</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&gt;=</span> n <span class="kw">or</span> dp[mask] <span class="op">==</span> INF:</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (mask <span class="op">&gt;&gt;</span> j) <span class="op">&amp;</span> <span class="dv">1</span>: </span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a>        dp[mask <span class="op">|</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j)] <span class="op">=</span> <span class="bu">min</span>(dp[mask <span class="op">|</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j)], dp[mask] <span class="op">+</span> C[i][j])</span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-20"><a href="#cb94-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp[N<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-43" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-43">Why It Matters</h4>
<ul>
<li>Canonical example of state compression DP on subsets</li>
<li>Simple and reliable when <span class="math inline">\(n\le 20\)</span> or so</li>
<li>Baseline to compare with Hungarian algorithm and min cost flow</li>
<li>Template for richer constraints: forbidden pairs, bonuses, prerequisites</li>
</ul>
</section>
<section id="step-by-step-example-42" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-42">Step-by-Step Example</h4>
<p>Let</p>
<p><span class="math display">\[
C=
\begin{bmatrix}
9&amp;2&amp;7\
6&amp;4&amp;3\
5&amp;8&amp;1
\end{bmatrix}
\]</span></p>
<p>One optimal assignment is worker <span class="math inline">\(0\to1\)</span> (2), <span class="math inline">\(1\to2\)</span> (3), <span class="math inline">\(2\to0\)</span> (5) for total <span class="math inline">\(2+3+5=10\)</span>. The DP explores all masks, always extending by one free task for the next worker.</p>
</section>
<section id="a-gentle-proof-why-it-works-30" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-30">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(S\)</span> be a set of tasks and <span class="math inline">\(i=|S|\)</span>. Any optimal partial assignment of the first <span class="math inline">\(i\)</span> workers to <span class="math inline">\(S\)</span> must end by assigning worker <span class="math inline">\(i-1\)</span> to some <span class="math inline">\(j\in S\)</span>. Removing task <span class="math inline">\(j\)</span> yields an optimal solution to <span class="math inline">\((S\setminus{j}, i-1)\)</span> plus <span class="math inline">\(C[i-1][j]\)</span>. Reversing this gives the forward transition from <span class="math inline">\(dp[mask]\)</span> to <span class="math inline">\(dp[mask\cup{j}]\)</span> with <span class="math inline">\(i=\text{popcount}(mask)\)</span>. Since each transition increases the mask, filling masks in increasing popcount topologically respects dependencies.</p>
</section>
<section id="try-it-yourself-43" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-43">Try It Yourself</h4>
<ol type="1">
<li>Reconstruct the assignment by storing a parent task for each <span class="math inline">\(mask\)</span>.</li>
<li>Add forbidden pairs by skipping those <span class="math inline">\((i,j)\)</span>.</li>
<li>Add a bonus matrix <span class="math inline">\(B\)</span> and minimize <span class="math inline">\(\sum(C[i][j]-B[i][j])\)</span>.</li>
<li>Handle rectangular <span class="math inline">\(n\times m\)</span> by padding the smaller side with zero dummy costs.</li>
<li>Compare runtime against Hungarian on random instances.</li>
</ol>
</section>
<section id="test-cases-43" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-43">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 79%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(C\)</span></th>
<th>Expected min</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\begin{bmatrix}1 &amp; 2 \\ 2 &amp; 1\end{bmatrix}\)</span></td>
<td><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\begin{bmatrix}9 &amp; 2 &amp; 7 \\ 6 &amp; 4 &amp; 3 \\ 5 &amp; 8 &amp; 1\end{bmatrix}\)</span></td>
<td><span class="math inline">\(10\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\begin{bmatrix}4 &amp; 1 &amp; 3 \\ 2 &amp; 0 &amp; 5 \\ 3 &amp; 2 &amp; 2\end{bmatrix}\)</span></td>
<td><span class="math inline">\(5\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\begin{bmatrix}10\end{bmatrix}\)</span></td>
<td><span class="math inline">\(10\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-43" class="level4">
<h4 class="anchored" data-anchor-id="complexity-43">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2 2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(2^n)\)</span></li>
</ul>
<p>Bitmask DP for the assignment problem is a tidy blueprint: iterate masks, assign the next worker to a free task, and keep the cheapest extension until all tasks are taken.</p>
</section>
</section>
<section id="partition-into-two-sets-balanced-load" class="level3">
<h3 class="anchored" data-anchor-id="partition-into-two-sets-balanced-load">445 Partition into Two Sets (Balanced Load)</h3>
<p>The Partition Problem asks whether a given set of numbers can be split into two subsets with equal sum. In its optimization form, we aim to minimize the difference between subset sums. It’s a classic subset DP example that models balanced workloads, resource allocation, and load balancing.</p>
<section id="what-problem-are-we-solving-44" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-44">What Problem Are We Solving?</h4>
<p>Given an array <span class="math inline">\(A[0..n-1]\)</span>, partition it into two subsets <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> such that the difference of sums is minimized:</p>
<p><span class="math display">\[
\text{minimize } |sum(S_1) - sum(S_2)|
\]</span></p>
<p>Equivalently, find a subset with sum as close as possible to half the total:</p>
<p><span class="math display">\[
\text{target} = \left\lfloor \frac{\sum A}{2} \right\rfloor
\]</span></p>
<p>We use DP to find all achievable sums up to <code>target</code>.</p>
<p>Define boolean DP:</p>
<p><span class="math display">\[
dp[i][s] = 1 \text{ if some subset of the first } i \text{ elements has sum } s
\]</span></p>
<p>Transition:</p>
<p><span class="math display">\[
dp[i][s] = dp[i-1][s] \lor dp[i-1][s-A[i-1]] \quad \text{if } s\ge A[i-1]
\]</span></p>
<p>Answer:</p>
<p><span class="math display">\[
\text{Find largest } s\le target \text{ with } dp[n][s]=1,\ \text{difference} = total - 2s
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-44" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-44">How Does It Work (Plain Language)</h4>
<p>Think of it as filling a knapsack of capacity <code>target</code>. Each item can either go into the subset or stay out. We try all combinations of sums up to half the total, beyond that, the second subset mirrors it. The closest sum to <code>target</code> yields the minimal difference.</p>
</section>
<section id="tiny-code-easy-versions-43" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-43">Tiny Code (Easy Versions)</h4>
<p>C (Tabulation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb95"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXSUM </span><span class="dv">10000</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> A<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> A<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> target <span class="op">=</span> total <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>MAXSUM <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> target<span class="op">;</span> s <span class="op">&gt;=</span> A<span class="op">[</span>i<span class="op">];</span> s<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>s <span class="op">-</span> A<span class="op">[</span>i<span class="op">]])</span> dp<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> target<span class="op">;</span> s <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> s<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>s<span class="op">])</span> <span class="op">{</span> best <span class="op">=</span> s<span class="op">;</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb95-28"><a href="#cb95-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb95-29"><a href="#cb95-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-30"><a href="#cb95-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> diff <span class="op">=</span> total <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> best<span class="op">;</span></span>
<span id="cb95-31"><a href="#cb95-31" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Minimal difference: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> diff<span class="op">);</span></span>
<span id="cb95-32"><a href="#cb95-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb95-33"><a href="#cb95-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Concise Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split()))</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>(A)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>target <span class="op">=</span> total <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="va">False</span>]<span class="op">*</span>(target<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> A:</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(target, x<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dp[s<span class="op">-</span>x]:</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>            dp[s] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(target, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dp[s]:</span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Minimal difference:"</span>, total <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>s)</span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-44" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-44">Why It Matters</h4>
<ul>
<li>Models balanced partitioning of workloads, memory, or resources</li>
<li>Foundation for Subset Sum and Knapsack problems</li>
<li>Introduces boolean DP over sums, a crucial building block for combinatorial search</li>
</ul>
</section>
<section id="step-by-step-example-43" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-43">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(A=[1,6,11,5]\)</span>. Total <span class="math inline">\(=23\)</span>, target <span class="math inline">\(=11\)</span>.</p>
<p>Feasible sums: <span class="math inline">\({0,1,5,6,7,11,12,16,17,18,23}\)</span></p>
<p>Best <span class="math inline">\(s=11\)</span>, minimal difference <span class="math inline">\(23-2\cdot11=1\)</span>.</p>
<p>Partition: <span class="math inline">\([11]\)</span> and <span class="math inline">\([1,5,6]\)</span>.</p>
</section>
<section id="a-gentle-proof-why-it-works-31" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-31">A Gentle Proof (Why It Works)</h4>
<p>Each element either belongs to subset <span class="math inline">\(S_1\)</span> or <span class="math inline">\(S_2\)</span>. Let <span class="math inline">\(s_1\)</span> be sum of <span class="math inline">\(S_1\)</span>, <span class="math inline">\(s_2=total-s_1\)</span>. We want <span class="math inline">\(|s_1-s_2|\)</span> minimized → <span class="math inline">\(|total-2s_1|\)</span>. By exploring all achievable sums <span class="math inline">\(s_1\le total/2\)</span>, we find the <span class="math inline">\(s_1\)</span> closest to half. Boolean DP tracks reachability using inclusion-exclusion transitions.</p>
</section>
<section id="try-it-yourself-44" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-44">Try It Yourself</h4>
<ol type="1">
<li>Count number of balanced partitions (replace boolean with integer DP).</li>
<li>Add constraint “each subset must have at least <span class="math inline">\(k\)</span> elements.”</li>
<li>Extend to multi-set partitions (3 or more subsets).</li>
<li>Visualize reachable sums as boolean array transitions.</li>
<li>Compare with brute-force subset enumeration.</li>
</ol>
</section>
<section id="test-cases-44" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-44">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>Minimal Difference</th>
<th>Partition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,6,11,5]</td>
<td>1</td>
<td>[11] [1,5,6]</td>
</tr>
<tr class="even">
<td>[3,1,4,2,2]</td>
<td>0</td>
<td>[3,2] [4,2]</td>
</tr>
<tr class="odd">
<td>[1,2,7]</td>
<td>4</td>
<td>[7] [1,2]</td>
</tr>
<tr class="even">
<td>[2,2,2,2]</td>
<td>0</td>
<td>[2,2] [2,2]</td>
</tr>
<tr class="odd">
<td>[10,20,15,5]</td>
<td>0</td>
<td>[10,15] [20,5]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-44" class="level4">
<h4 class="anchored" data-anchor-id="complexity-44">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n\cdot sum)\)</span></li>
<li>Space: <span class="math inline">\(O(sum)\)</span></li>
</ul>
<p>The Partition DP is a gentle bridge from Subset Sum to balanced optimization, teaching how combinatorial structure guides numerical state transitions.</p>
</section>
</section>
<section id="count-hamiltonian-cycles-bitmask-enumeration" class="level3">
<h3 class="anchored" data-anchor-id="count-hamiltonian-cycles-bitmask-enumeration">446 Count Hamiltonian Cycles (Bitmask Enumeration)</h3>
<p>The Hamiltonian Cycle Counting problem asks: given a graph, how many distinct Hamiltonian cycles (closed tours visiting each vertex exactly once) exist? Unlike the shortest-path variants, this version focuses on counting all possible cycles using bitmask DP.</p>
<section id="what-problem-are-we-solving-45" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-45">What Problem Are We Solving?</h4>
<p>Given a graph <span class="math inline">\(G=(V,E)\)</span> with <span class="math inline">\(|V|=n\)</span>, count the number of distinct Hamiltonian cycles starting and ending at vertex <span class="math inline">\(0\)</span> that visit every vertex exactly once.</p>
<p>We define:</p>
<ul>
<li><span class="math inline">\(dp[mask][i]\)</span> = number of Hamiltonian paths starting at <span class="math inline">\(0\)</span>, visiting all vertices in <span class="math inline">\(mask\)</span>, and ending at <span class="math inline">\(i\)</span></li>
<li>Base: <span class="math inline">\(dp[1&lt;&lt;0][0]=1\)</span></li>
</ul>
<p>Transition:</p>
<p><span class="math display">\[
dp[mask][i] = \sum_{j\in mask,, j\ne i,,(j,i)\in E} dp[mask\setminus{i}][j]
\]</span></p>
<p>Answer (number of cycles):</p>
<p><span class="math display">\[
\sum_{i=1}^{n-1} dp[(1&lt;&lt;n)-1][i] \text{ if } (i,0)\in E
\]</span></p>
<p>Each valid end vertex <span class="math inline">\(i\)</span> must connect back to <span class="math inline">\(0\)</span> to complete the cycle.</p>
</section>
<section id="how-does-it-work-plain-language-45" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-45">How Does It Work (Plain Language)</h4>
<p>We build all possible paths from vertex <span class="math inline">\(0\)</span> that cover a subset of vertices and end at some <span class="math inline">\(i\)</span>. For each step, we extend smaller paths by adding a new endpoint <span class="math inline">\(i\)</span>. When all vertices are visited (<span class="math inline">\(mask=(1&lt;&lt;n)-1\)</span>), we check which endpoints connect back to <span class="math inline">\(0\)</span>. Summing these gives the total number of Hamiltonian cycles.</p>
<p>This is similar to the Held–Karp DP, but the operation is addition (counting) instead of minimization.</p>
</section>
<section id="tiny-code-easy-versions-44" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-44">Tiny Code (Easy Versions)</h4>
<p>C (Bitmask Counting DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb97"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">20</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>adj<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>adj<span class="op">));</span></span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> e <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> e <span class="op">&lt;</span> m<span class="op">;</span> e<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span> v<span class="op">;</span></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">,</span> <span class="op">&amp;</span>v<span class="op">);</span></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">=</span> adj<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// start at vertex 0</span></span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">);</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">)))</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> j <span class="op">||</span> <span class="op">!(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> j<span class="op">)))</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>adj<span class="op">[</span>j<span class="op">][</span>i<span class="op">])</span></span>
<span id="cb97-27"><a href="#cb97-27" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>mask<span class="op">][</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>mask <span class="op">^</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">)][</span>j<span class="op">];</span></span>
<span id="cb97-28"><a href="#cb97-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb97-29"><a href="#cb97-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb97-30"><a href="#cb97-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb97-31"><a href="#cb97-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-32"><a href="#cb97-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb97-33"><a href="#cb97-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> full <span class="op">=</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb97-34"><a href="#cb97-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb97-35"><a href="#cb97-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>adj<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">])</span> total <span class="op">+=</span> dp<span class="op">[</span>full<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb97-36"><a href="#cb97-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb97-37"><a href="#cb97-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-38"><a href="#cb97-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> total <span class="op">/</span> <span class="dv">2</span><span class="op">);</span> <span class="co">// divide by 2 for undirected graphs</span></span>
<span id="cb97-39"><a href="#cb97-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb97-40"><a href="#cb97-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Compact Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>n, m <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>adj <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    u, v <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    adj[u][v] <span class="op">=</span> adj[v][u] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">1</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (mask <span class="op">&amp;</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i)): <span class="cf">continue</span></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i<span class="op">==</span>j <span class="kw">or</span> <span class="kw">not</span> (mask <span class="op">&amp;</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>j)): <span class="cf">continue</span></span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> adj[j][i]:</span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a>                dp[mask][i] <span class="op">+=</span> dp[mask <span class="op">^</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>i)][j]</span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a>full <span class="op">=</span> N<span class="op">-</span><span class="dv">1</span></span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">sum</span>(dp[full][i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n) <span class="cf">if</span> adj[i][<span class="dv">0</span>])</span>
<span id="cb98-21"><a href="#cb98-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total <span class="op">//</span> <span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-45" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-45">Why It Matters</h4>
<ul>
<li>Demonstrates DP counting over subsets</li>
<li>Foundation for counting Hamiltonian paths, cycle covers, and tours</li>
<li>Appears in graph enumeration, combinatorial design, and traveling salesman counting</li>
</ul>
</section>
<section id="step-by-step-example-44" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-44">Step-by-Step Example</h4>
<p>Let the graph be a square (4-cycle):</p>
<p>Vertices: <span class="math inline">\(0,1,2,3\)</span></p>
<p>Edges: <span class="math inline">\((0,1),(1,2),(2,3),(3,0)\)</span> and <span class="math inline">\((0,3),(3,2),(2,1),(1,0)\)</span></p>
<p>All Hamiltonian cycles:</p>
<ul>
<li><span class="math inline">\(0\to1\to2\to3\to0\)</span></li>
<li><span class="math inline">\(0\to3\to2\to1\to0\)</span></li>
</ul>
<p>So total = 2.</p>
<p>The DP constructs these paths incrementally by adding one vertex at a time.</p>
</section>
<section id="a-gentle-proof-why-it-works-32" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-32">A Gentle Proof (Why It Works)</h4>
<p>Each DP state <span class="math inline">\((mask,i)\)</span> corresponds to unique partial paths visiting <span class="math inline">\(mask\)</span> and ending at <span class="math inline">\(i\)</span>. To form a path ending at <span class="math inline">\(i\)</span>, we must come from <span class="math inline">\(j\in mask\setminus{i}\)</span> with edge <span class="math inline">\((j,i)\)</span>. This ensures each path is counted exactly once.</p>
<p>At the full mask, we have all Hamiltonian paths starting at <span class="math inline">\(0\)</span> and ending at <span class="math inline">\(i\)</span>; connecting <span class="math inline">\(i\to0\)</span> closes the cycle.</p>
<p>Divide by 2 for undirected graphs since each cycle is counted twice (once clockwise, once counterclockwise).</p>
</section>
<section id="try-it-yourself-45" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-45">Try It Yourself</h4>
<ol type="1">
<li>Remove division by 2 for directed graphs.</li>
<li>Count Hamiltonian paths (no return edge).</li>
<li>Modify to track path sequences using parent arrays.</li>
<li>For large <span class="math inline">\(n\)</span>, compare with inclusion-exclusion counting.</li>
<li>Implement memoized recursion (top-down version).</li>
</ol>
</section>
<section id="test-cases-45" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-45">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle <span class="math inline">\((0-1-2-0)\)</span></td>
<td>1</td>
</tr>
<tr class="even">
<td>Square <span class="math inline">\((0-1-2-3-0)\)</span></td>
<td>2</td>
</tr>
<tr class="odd">
<td>Line <span class="math inline">\((0-1-2)\)</span></td>
<td>0</td>
</tr>
<tr class="even">
<td>Complete graph <span class="math inline">\(K_4\)</span></td>
<td><span class="math inline">\((4-1)!/2 = 3\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(K_5\)</span></td>
<td><span class="math inline">\((5-1)!/2 = 12\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-45" class="level4">
<h4 class="anchored" data-anchor-id="complexity-45">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2 2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(n 2^n)\)</span></li>
</ul>
<p>Counting Hamiltonian cycles via DP elegantly blends subset enumeration with path counting, offering an exact combinatorial count for small graphs.</p>
</section>
</section>
<section id="steiner-tree-dp" class="level3">
<h3 class="anchored" data-anchor-id="steiner-tree-dp">447 Steiner Tree DP</h3>
<p>The Steiner Tree problem asks for the minimum-cost subgraph that connects a given set of terminals in a weighted graph. You may use extra non-terminal vertices (Steiner nodes) if that reduces total cost. The classic exact DP for small numbers of terminals is the Dreyfus–Wagner subset DP.</p>
<section id="what-problem-are-we-solving-46" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-46">What Problem Are We Solving?</h4>
<p>Input: an undirected connected graph with nonnegative edge weights, and a terminal set <span class="math inline">\(T={t_1,\dots,t_k}\)</span>.</p>
<p>Goal: find a minimum-weight tree that connects all vertices in <span class="math inline">\(T\)</span>.</p>
<p>We use a subset DP over terminals and a root vertex:</p>
<ul>
<li>Precompute all-pairs shortest paths <span class="math inline">\(dist[u][v]\)</span>.</li>
<li>DP state: <span class="math inline">\(dp[S][v]=\)</span> minimum cost of a tree that connects all terminals in subset <span class="math inline">\(S\subseteq T\)</span> and whose tree is rooted at vertex <span class="math inline">\(v\)</span>.</li>
</ul>
<p>Initialization: <span class="math display">\[
dp[{t_i}][v]=dist[v][t_i]
\]</span></p>
<p>Combine subsets at the same root: <span class="math display">\[
dp[S][v]=\min_{\emptyset\ne A\subset S}\big(dp[A][v]+dp[S\setminus A][v]\big)
\]</span></p>
<p>Then allow the root to move via shortest paths: <span class="math display">\[
dp[S][v]=\min_{u}\big(dp[S][u]+dist[u][v]\big)
\]</span></p>
<p>Answer: <span class="math display">\[
\min_{v}dp[T][v]
\]</span></p>
<p>In practice we alternate subset-combine at fixed <span class="math inline">\(v\)</span> and a multi-source shortest-path relaxation for each <span class="math inline">\(S\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-46" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-46">How Does It Work (Plain Language)</h4>
<p>Think of building a Steiner tree by gluing together optimal trees for smaller terminal subsets at a meeting vertex <span class="math inline">\(v\)</span>. After merging, you are allowed to slide that meeting point anywhere in the graph using shortest paths. Repeat for all subsets until you cover all terminals.</p>
</section>
<section id="tiny-code-easy-version-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-python">Tiny Code (Easy Version, Python)</h4>
<p>Dreyfus–Wagner with Floyd–Warshall for <span class="math inline">\(dist\)</span> and Dijkstra-based relax per subset. Works for small <span class="math inline">\(k\)</span>.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1015</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> floyd_warshall(n, w):</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [row[:] <span class="cf">for</span> row <span class="kw">in</span> w]</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>        dist[i][i] <span class="op">=</span> <span class="bu">min</span>(dist[i][i], <span class="dv">0</span>)</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>            dik <span class="op">=</span> dist[i][k]</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dik <span class="op">==</span> INF: <span class="cf">continue</span></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>            rowi <span class="op">=</span> dist[i]</span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>            rowk <span class="op">=</span> dist[k]</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>                nd <span class="op">=</span> dik <span class="op">+</span> rowk[j]</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> nd <span class="op">&lt;</span> rowi[j]: rowi[j] <span class="op">=</span> nd</span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> steiner_tree(n, edges, terminals):</span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build dense weight matrix</span></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> [[INF]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>        w[u][u] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, c <span class="kw">in</span> edges:</span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c <span class="op">&lt;</span> w[u][v]:</span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a>            w[u][v] <span class="op">=</span> w[v][u] <span class="op">=</span> c</span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> floyd_warshall(n, w)</span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(terminals)</span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a>    term_index <span class="op">=</span> {t:i <span class="cf">for</span> i,t <span class="kw">in</span> <span class="bu">enumerate</span>(terminals)}</span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># dp[mask][v]</span></span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[INF]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span><span class="op">&lt;&lt;</span>k)]</span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> terminals:</span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> term_index[t]</span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-39"><a href="#cb99-39" aria-hidden="true" tabindex="-1"></a>            dp[m][v] <span class="op">=</span> dist[v][t]</span>
<span id="cb99-40"><a href="#cb99-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-41"><a href="#cb99-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># subset DP</span></span>
<span id="cb99-42"><a href="#cb99-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">1</span><span class="op">&lt;&lt;</span>k):</span>
<span id="cb99-43"><a href="#cb99-43" aria-hidden="true" tabindex="-1"></a>        <span class="co"># combine proper nonempty A subset at same root v</span></span>
<span id="cb99-44"><a href="#cb99-44" aria-hidden="true" tabindex="-1"></a>        sub <span class="op">=</span> (mask<span class="op">-</span><span class="dv">1</span>) <span class="op">&amp;</span> mask</span>
<span id="cb99-45"><a href="#cb99-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> sub:</span>
<span id="cb99-46"><a href="#cb99-46" aria-hidden="true" tabindex="-1"></a>            other <span class="op">=</span> mask <span class="op">^</span> sub</span>
<span id="cb99-47"><a href="#cb99-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> other:</span>
<span id="cb99-48"><a href="#cb99-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-49"><a href="#cb99-49" aria-hidden="true" tabindex="-1"></a>                    val <span class="op">=</span> dp[sub][v] <span class="op">+</span> dp[other][v]</span>
<span id="cb99-50"><a href="#cb99-50" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> val <span class="op">&lt;</span> dp[mask][v]:</span>
<span id="cb99-51"><a href="#cb99-51" aria-hidden="true" tabindex="-1"></a>                        dp[mask][v] <span class="op">=</span> val</span>
<span id="cb99-52"><a href="#cb99-52" aria-hidden="true" tabindex="-1"></a>            sub <span class="op">=</span> (sub<span class="op">-</span><span class="dv">1</span>) <span class="op">&amp;</span> mask</span>
<span id="cb99-53"><a href="#cb99-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-54"><a href="#cb99-54" aria-hidden="true" tabindex="-1"></a>        <span class="co"># root-move relaxation by Dijkstra over complete graph with dist metric</span></span>
<span id="cb99-55"><a href="#cb99-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># This is equivalent to: dp[mask] = metric-closure shortest-path from sources with potentials dp[mask]</span></span>
<span id="cb99-56"><a href="#cb99-56" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Implement 1 run of Dijkstra with initial costs dp[mask][*]</span></span>
<span id="cb99-57"><a href="#cb99-57" aria-hidden="true" tabindex="-1"></a>        pq <span class="op">=</span> [(dp[mask][v], v) <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb99-58"><a href="#cb99-58" aria-hidden="true" tabindex="-1"></a>        heapq.heapify(pq)</span>
<span id="cb99-59"><a href="#cb99-59" aria-hidden="true" tabindex="-1"></a>        seen <span class="op">=</span> [<span class="va">False</span>]<span class="op">*</span>n</span>
<span id="cb99-60"><a href="#cb99-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pq:</span>
<span id="cb99-61"><a href="#cb99-61" aria-hidden="true" tabindex="-1"></a>            d,v <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb99-62"><a href="#cb99-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> seen[v]: <span class="cf">continue</span></span>
<span id="cb99-63"><a href="#cb99-63" aria-hidden="true" tabindex="-1"></a>            seen[v] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb99-64"><a href="#cb99-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&gt;</span> dp[mask][v]: <span class="cf">continue</span></span>
<span id="cb99-65"><a href="#cb99-65" aria-hidden="true" tabindex="-1"></a>            row <span class="op">=</span> dist[v]</span>
<span id="cb99-66"><a href="#cb99-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-67"><a href="#cb99-67" aria-hidden="true" tabindex="-1"></a>                nd <span class="op">=</span> d <span class="op">+</span> row[u]</span>
<span id="cb99-68"><a href="#cb99-68" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> nd <span class="op">&lt;</span> dp[mask][u]:</span>
<span id="cb99-69"><a href="#cb99-69" aria-hidden="true" tabindex="-1"></a>                    dp[mask][u] <span class="op">=</span> nd</span>
<span id="cb99-70"><a href="#cb99-70" aria-hidden="true" tabindex="-1"></a>                    heapq.heappush(pq, (nd, u))</span>
<span id="cb99-71"><a href="#cb99-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-72"><a href="#cb99-72" aria-hidden="true" tabindex="-1"></a>    full <span class="op">=</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>k) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb99-73"><a href="#cb99-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(dp[full])</span>
<span id="cb99-74"><a href="#cb99-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-75"><a href="#cb99-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb99-76"><a href="#cb99-76" aria-hidden="true" tabindex="-1"></a><span class="co"># n = 5</span></span>
<span id="cb99-77"><a href="#cb99-77" aria-hidden="true" tabindex="-1"></a><span class="co"># edges = [(0,1,1),(1,2,1),(2,3,1),(3,4,1),(0,4,10),(1,4,2)]</span></span>
<span id="cb99-78"><a href="#cb99-78" aria-hidden="true" tabindex="-1"></a><span class="co"># terminals = [0,3,4]</span></span>
<span id="cb99-79"><a href="#cb99-79" aria-hidden="true" tabindex="-1"></a><span class="co"># print(steiner_tree(n, edges, terminals))</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Notes:</p>
<ul>
<li>For sparse graphs you can skip Floyd–Warshall and run Dijkstra inside the relax step using the original adjacency. Using the metric closure as above is simple and correct for nonnegative weights.</li>
</ul>
</section>
<section id="why-it-matters-46" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-46">Why It Matters</h4>
<ul>
<li>Exact algorithm for Steiner trees when the number of terminals <span class="math inline">\(k\)</span> is small</li>
<li>Standard approach in VLSI routing, network design, and phylogenetics</li>
<li>Teaches a powerful pattern: subset merge at a root plus shortest-path relaxation</li>
</ul>
</section>
<section id="step-by-step-example-45" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-45">Step-by-Step Example</h4>
<p>Suppose a 5-vertex path <span class="math inline">\(0\)</span>–<span class="math inline">\(1\)</span>–<span class="math inline">\(2\)</span>–<span class="math inline">\(3\)</span>–<span class="math inline">\(4\)</span> with unit weights and terminals <span class="math inline">\(T={0,3,4}\)</span>.</p>
<ul>
<li>Singletons: <span class="math inline">\(dp[{0}][v]=dist[v][0]\)</span>, etc.</li>
<li>Combine <span class="math inline">\({3}\)</span> and <span class="math inline">\({4}\)</span> at <span class="math inline">\(v=3\)</span> or <span class="math inline">\(v=4\)</span>, then relax along the path.</li>
<li>Finally combine with <span class="math inline">\({0}\)</span>; the optimal tree is edges <span class="math inline">\((0,1),(1,2),(2,3),(3,4)\)</span> with total cost <span class="math inline">\(4\)</span>.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-33" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-33">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(S\subseteq T\)</span> and <span class="math inline">\(v\)</span> be a meeting vertex of an optimal Steiner tree for <span class="math inline">\(S\)</span>. The tree decomposes into two subtrees whose terminal sets partition <span class="math inline">\(S\)</span>, and both subtrees meet at <span class="math inline">\(v\)</span>. Hence <span class="math display">\[
dp[S][v]\le dp[A][v]+dp[S\setminus A][v].
\]</span> Conversely, any combination at <span class="math inline">\(v\)</span> plus a shortest-path relocation of <span class="math inline">\(v\)</span> to another vertex is no worse than explicitly wiring with edges, due to triangle inequality from the metric closure. Induction over <span class="math inline">\(|S|\)</span> yields optimality.</p>
</section>
<section id="try-it-yourself-46" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-46">Try It Yourself</h4>
<ol type="1">
<li>Replace the Dijkstra relax with Bellman–Ford to allow zero edges with tight potentials.</li>
<li>Extract the actual Steiner tree: store the best split and predecessor during relaxation.</li>
<li>Compare metric-closure method vs relaxing on the original sparse graph.</li>
<li>Benchmark vs MST over terminals to see the benefit of Steiner vertices.</li>
<li>Add a constraint that certain vertices are forbidden as Steiner nodes.</li>
</ol>
</section>
<section id="test-cases-46" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-46">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 62%">
<col style="width: 11%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Terminals</th>
<th>Expected Steiner cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Path 0–1–2–3–4 with unit edges</td>
<td>{0,3,4}</td>
<td>4</td>
</tr>
<tr class="even">
<td>Triangle 0–1–2 with unit edges</td>
<td>{0,2}</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Square 0–1–2–3 with unit edges, diagonal 1–3 cost 1</td>
<td>{0,2,3}</td>
<td>2</td>
</tr>
<tr class="even">
<td>Star center 0 to 1..4 all cost 1</td>
<td>{1,2,3,4}</td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-46" class="level4">
<h4 class="anchored" data-anchor-id="complexity-46">Complexity</h4>
<ul>
<li>With metric closure and subset merge: <span class="math inline">\(O(3^k\cdot n + 2^k\cdot n\log n)\)</span> typical</li>
<li>Memory: <span class="math inline">\(O(2^k\cdot n)\)</span></li>
</ul>
<p>The Dreyfus–Wagner DP is the go-to exact method when <span class="math inline">\(k\)</span> is small: combine subsets at a root, then relax through shortest paths to let Steiner nodes emerge automatically.</p>
</section>
</section>
<section id="sos-dp-sum-over-subsets" class="level3">
<h3 class="anchored" data-anchor-id="sos-dp-sum-over-subsets">448 SOS DP (Sum Over Subsets)</h3>
<p>Sum Over Subsets (SOS DP) is a clever bitmask dynamic programming technique for computing values aggregated over all subsets of each mask efficiently, without enumerating all subset pairs explicitly.</p>
<section id="what-problem-are-we-solving-47" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-47">What Problem Are We Solving?</h4>
<p>Suppose you have an array <code>f[mask]</code> defined for all bitmasks of length <code>n</code>, and you want to compute:</p>
<p><span class="math display">\[
g[mask] = \sum_{sub \subseteq mask} f[sub]
\]</span></p>
<p>Naively, this requires iterating over all subsets of each mask, which takes <span class="math inline">\(O(3^n)\)</span>. With SOS DP, we can compute all <span class="math inline">\(g[mask]\)</span> in <span class="math inline">\(O(n2^n)\)</span> time.</p>
</section>
<section id="how-does-it-work-plain-language-47" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-47">How Does It Work (Plain Language)</h4>
<p>Think of each bit in the mask as a “dimension.” For each bit position <code>i</code>, if that bit is set in the mask, we can inherit contributions from the version where the bit was off. We build up sums by iterating over each bit dimension and folding smaller subsets upward.</p>
</section>
<section id="transition-formula" class="level4">
<h4 class="anchored" data-anchor-id="transition-formula">Transition Formula</h4>
<p>Let <code>dp[mask]</code> initially equal <code>f[mask]</code>. Then for each bit <code>i</code> from 0 to <code>n-1</code>:</p>
<pre class="text"><code>if mask has bit i set:
    dp[mask] += dp[mask ^ (1 &lt;&lt; i)]</code></pre>
<p>After processing all bits, <code>dp[mask]</code> holds the sum over all subsets of <code>mask</code>.</p>
</section>
<section id="example" class="level4">
<h4 class="anchored" data-anchor-id="example">Example</h4>
<p>Let <span class="math inline">\(n=3\)</span>, masks from <code>000</code> to <code>111</code>.</p>
<p>If <span class="math inline">\(f[mask]=1\)</span> for all masks, then:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>mask</th>
<th>subsets</th>
<th>g[mask]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>000</td>
<td>{000}</td>
<td>1</td>
</tr>
<tr class="even">
<td>001</td>
<td>{000,001}</td>
<td>2</td>
</tr>
<tr class="odd">
<td>010</td>
<td>{000,010}</td>
<td>2</td>
</tr>
<tr class="even">
<td>011</td>
<td>{000,001,010,011}</td>
<td>4</td>
</tr>
<tr class="odd">
<td>100</td>
<td>{000,100}</td>
<td>2</td>
</tr>
<tr class="even">
<td>111</td>
<td>all 8 subsets</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>The DP folds these results bit by bit.</p>
</section>
<section id="tiny-code-easy-versions-45" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-45">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb101"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">20</span><span class="op">)</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> f<span class="op">[</span>MAXN<span class="op">],</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">;</span></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>f<span class="op">[</span>mask<span class="op">]);</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>mask<span class="op">]</span> <span class="op">=</span> f<span class="op">[</span>mask<span class="op">];</span></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">))</span> <span class="op">{</span></span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>mask<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>mask <span class="op">^</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">)];</span></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span></span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st"> "</span><span class="op">,</span> dp<span class="op">[</span>mask<span class="op">]);</span></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"n: "</span>))</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split()))</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> f[:]</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mask <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i):</span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>            dp[mask] <span class="op">+=</span> dp[mask <span class="op">^</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)]</span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-47" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-47">Why It Matters</h4>
<ul>
<li>Core trick in bitmask convolution, subset transforms, XOR convolution, and mobius inversion.</li>
<li>Reduces <span class="math inline">\(O(3^n)\)</span> subset loops to <span class="math inline">\(O(n2^n)\)</span>.</li>
<li>Common in problems over subset sums, probabilistic DP, counting states, and game theory.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-34" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-34">A Gentle Proof (Why It Works)</h4>
<p>We can represent each mask as a binary vector of <span class="math inline">\(n\)</span> bits. Each bit dimension <span class="math inline">\(i\)</span> adds subsets with <span class="math inline">\(i\)</span>th bit unset. Inductively, after processing bit <span class="math inline">\(i\)</span>, each mask accumulates contributions from all subsets differing only in bits <span class="math inline">\(\le i\)</span>. By the end, every subset of <code>mask</code> has been included exactly once.</p>
<p>Formally, for each subset <span class="math inline">\(sub\subseteq mask\)</span>, there exists a sequence of bit additions leading from <span class="math inline">\(sub\)</span> to <span class="math inline">\(mask\)</span>, ensuring its inclusion.</p>
</section>
<section id="try-it-yourself-47" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-47">Try It Yourself</h4>
<ol type="1">
<li>Reverse the process to compute Sum Over Supersets instead.</li>
<li>Modify to compute product over subsets.</li>
<li>Apply to count subsets satisfying parity conditions.</li>
<li>Use SOS DP to precompute subset sums before a subset convolution.</li>
<li>Combine with inclusion-exclusion for faster combinatorial counting.</li>
</ol>
</section>
<section id="test-cases-47" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-47">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>f (input)</th>
<th>Expected dp (output)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>1 1 1 1</td>
<td>1 2 2 4</td>
</tr>
<tr class="even">
<td>2</td>
<td>1 2 3 4</td>
<td>1 3 4 10</td>
</tr>
<tr class="odd">
<td>3</td>
<td>all 1s</td>
<td>1 2 2 4 2 4 4 8</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-47" class="level4">
<h4 class="anchored" data-anchor-id="complexity-47">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(2^n)\)</span></li>
</ul>
<p>SOS DP is a cornerstone of bitmask dynamic programming, revealing structure across subsets without enumerating them explicitly.</p>
</section>
</section>
<section id="bitmask-knapsack-state-compression" class="level3">
<h3 class="anchored" data-anchor-id="bitmask-knapsack-state-compression">449 Bitmask Knapsack (State Compression)</h3>
<p>The Bitmask Knapsack technique encodes subsets of items using bitmasks, allowing you to represent selections, transitions, and constraints compactly. It’s a bridge between subset enumeration and dynamic programming, especially useful when the number of items is small (e.g.&nbsp;<span class="math inline">\(n \le 20\)</span>) but the value/weight range is large.</p>
<section id="what-problem-are-we-solving-48" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-48">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> items, each with weight <span class="math inline">\(w_i\)</span> and value <span class="math inline">\(v_i\)</span>, and capacity <span class="math inline">\(W\)</span>, choose a subset with total weight ≤ <span class="math inline">\(W\)</span> to maximize total value.</p>
<p>Instead of indexing DP by capacity, we can enumerate subsets via bitmask:</p>
<p><span class="math display">\[
best = \max_{\text{subset}} \sum_{i \in \text{subset}} v_i \quad \text{such that } \sum_{i \in \text{subset}} w_i \le W
\]</span></p>
<p>Each subset corresponds to an integer mask, where bit <span class="math inline">\(i\)</span> indicates inclusion of item <span class="math inline">\(i\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-48" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-48">How Does It Work (Plain Language)</h4>
<p>A bitmask is a snapshot of which items are taken. You precompute total weight and total value for each subset. Then simply iterate all masks, filter by capacity, and keep the best.</p>
<p>It’s exponential (<span class="math inline">\(2^n\)</span>) but works when <span class="math inline">\(n\)</span> is small and weights are large, where classical DP by weight is infeasible.</p>
</section>
<section id="transition-formula-1" class="level4">
<h4 class="anchored" data-anchor-id="transition-formula-1">Transition Formula</h4>
<p>For each mask:</p>
<ul>
<li>Compute <span class="math display">\[
total_w = \sum_{i:mask_i=1} w_i
\]</span> <span class="math display">\[
total_v = \sum_{i:mask_i=1} v_i
\]</span></li>
<li>If <span class="math inline">\(total_w \le W\)</span>, update answer: <span class="math display">\[
best = \max(best, total_v)
\]</span></li>
</ul>
<p>Or incrementally:</p>
<p><span class="math display">\[
dp[mask] = \sum_{i:mask_i=1} v_i
\]</span> <span class="math display">\[
weight[mask] = \sum_{i:mask_i=1} w_i
\]</span></p>
</section>
<section id="tiny-code-easy-versions-46" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-46">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb103"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">20</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXMASK </span><span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span><span class="pp">MAXN</span><span class="op">)</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> W<span class="op">;</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>W<span class="op">);</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> w<span class="op">[</span>n<span class="op">],</span> v<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>w<span class="op">[</span>i<span class="op">],</span> <span class="op">&amp;</span>v<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">;</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> total_w <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> total_v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">))</span> <span class="op">{</span></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>                total_w <span class="op">+=</span> w<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>                total_v <span class="op">+=</span> v<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>total_w <span class="op">&lt;=</span> W <span class="op">&amp;&amp;</span> total_v <span class="op">&gt;</span> best<span class="op">)</span></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> total_v<span class="op">;</span></span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb103-26"><a href="#cb103-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-27"><a href="#cb103-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> best<span class="op">);</span></span>
<span id="cb103-28"><a href="#cb103-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>n, W <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>w, v <span class="op">=</span> [], []</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    wi, vi <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>    w.append(wi)</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>    v.append(vi)</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>best <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> n):</span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>    total_w <span class="op">=</span> total_v <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mask <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i):</span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a>            total_w <span class="op">+=</span> w[i]</span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a>            total_v <span class="op">+=</span> v[i]</span>
<span id="cb104-15"><a href="#cb104-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total_w <span class="op">&lt;=</span> W:</span>
<span id="cb104-16"><a href="#cb104-16" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> <span class="bu">max</span>(best, total_v)</span>
<span id="cb104-17"><a href="#cb104-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-18"><a href="#cb104-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(best)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-48" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-48">Why It Matters</h4>
<ul>
<li>Works well when <span class="math inline">\(n\)</span> is small (e.g.&nbsp;<span class="math inline">\(n \le 20\)</span>) but weights/values are large</li>
<li>Natural fit for meet-in-the-middle and subset enumeration</li>
<li>Simplifies reasoning about combinations, constraints, and transitions</li>
<li>Found in traveling salesman variants, set packing, and team selection problems</li>
</ul>
</section>
<section id="step-by-step-example-46" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-46">Step-by-Step Example</h4>
<p>Items:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>w</th>
<th>v</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="even">
<td>1</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Capacity <span class="math inline">\(W=6\)</span>.</p>
<p>Subsets:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>mask</th>
<th>items</th>
<th>weight</th>
<th>value</th>
<th>feasible</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>000</td>
<td>{}</td>
<td>0</td>
<td>0</td>
<td>✓</td>
</tr>
<tr class="even">
<td>001</td>
<td>{0}</td>
<td>3</td>
<td>4</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>010</td>
<td>{1}</td>
<td>4</td>
<td>5</td>
<td>✓</td>
</tr>
<tr class="even">
<td>011</td>
<td>{0,1}</td>
<td>7</td>
<td>9</td>
<td>✗</td>
</tr>
<tr class="odd">
<td>100</td>
<td>{2}</td>
<td>2</td>
<td>3</td>
<td>✓</td>
</tr>
<tr class="even">
<td>101</td>
<td>{0,2}</td>
<td>5</td>
<td>7</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>110</td>
<td>{1,2}</td>
<td>6</td>
<td>8</td>
<td>✓</td>
</tr>
<tr class="even">
<td>111</td>
<td>{0,1,2}</td>
<td>9</td>
<td>12</td>
<td>✗</td>
</tr>
</tbody>
</table>
<p>Best feasible = mask <code>110</code> → value 8.</p>
</section>
<section id="a-gentle-proof-why-it-works-35" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-35">A Gentle Proof (Why It Works)</h4>
<p>Each subset is a distinct combination of items. Enumerating all <span class="math inline">\(2^n\)</span> subsets guarantees completeness. Feasibility is checked via total weight ≤ <span class="math inline">\(W\)</span>, ensuring no invalid subset contributes. Maximization over all feasible subsets returns the global optimum.</p>
<p>No overlapping subproblems, so no need for memoization. The entire search space is finite and explored.</p>
</section>
<section id="try-it-yourself-48" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-48">Try It Yourself</h4>
<ol type="1">
<li>Print all feasible subsets and their total values.</li>
<li>Combine with bitcount to restrict subset size.</li>
<li>Use meet-in-the-middle: split items into halves, enumerate each half, then merge results.</li>
<li>Extend to multi-dimensional capacity <span class="math inline">\((W_1,W_2,...)\)</span>.</li>
<li>Adapt to minimize weight for a target value instead.</li>
</ol>
</section>
<section id="test-cases-48" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-48">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Items</th>
<th>W</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(3,4),(4,5),(2,3)</td>
<td>6</td>
<td>8</td>
</tr>
<tr class="even">
<td>(2,3),(3,4),(4,5)</td>
<td>5</td>
<td>7</td>
</tr>
<tr class="odd">
<td>(1,1),(2,2),(3,3)</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-48" class="level4">
<h4 class="anchored" data-anchor-id="complexity-48">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(1)\)</span> (no DP table needed)</li>
</ul>
<p>Bitmask Knapsack is a brute-force DP with compression, a go-to technique for small <span class="math inline">\(n\)</span>, offering full flexibility when classical capacity-indexed DP would blow up.</p>
</section>
</section>
<section id="bitmask-independent-set-graph-subset-optimization" class="level3">
<h3 class="anchored" data-anchor-id="bitmask-independent-set-graph-subset-optimization">450 Bitmask Independent Set (Graph Subset Optimization)</h3>
<p>The Bitmask Independent Set DP enumerates all subsets of vertices in a graph to find the maximum-weight independent set, a set of vertices with no edges between any pair. It’s a classic exponential DP, efficient for small graphs (<span class="math inline">\(n \le 20\)</span>), using bit operations for adjacency and feasibility.</p>
<section id="what-problem-are-we-solving-49" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-49">What Problem Are We Solving?</h4>
<p>Given an undirected graph <span class="math inline">\(G=(V,E)\)</span> with vertex weights <span class="math inline">\(w_i\)</span>, find:</p>
<p><span class="math display">\[
\max \sum_{i \in S} w_i \quad \text{subject to } \forall (u,v) \in E,\ u,v \notin S
\]</span></p>
<p>That is, choose a subset <span class="math inline">\(S\)</span> of vertices with no adjacent pairs, maximizing total weight.</p>
<p>We represent each subset <span class="math inline">\(S\)</span> by a bitmask, where bit <span class="math inline">\(i=1\)</span> means vertex <span class="math inline">\(i\)</span> is included.</p>
</section>
<section id="how-does-it-work-plain-language-49" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-49">How Does It Work (Plain Language)</h4>
<p>We iterate over all <span class="math inline">\(2^n\)</span> subsets. For each subset, we check whether it forms an independent set by ensuring no edge connects two chosen vertices. If it’s valid, sum its vertex weights and update the best.</p>
<p>Precompute adjacency masks to quickly test validity.</p>
</section>
<section id="transition-check" class="level4">
<h4 class="anchored" data-anchor-id="transition-check">Transition / Check</h4>
<p>For each mask:</p>
<ol type="1">
<li><p>Validity<br>
A subset is independent if, for all vertices <span class="math inline">\(i\)</span> included, it contains no neighbor: <span class="math display">\[
(\,adj[i] \mathbin{\&amp;} mask\,) = 0
\]</span> where <span class="math inline">\(adj[i]\)</span> is the bitmask of neighbors of vertex <span class="math inline">\(i\)</span>.</p></li>
<li><p>Value <span class="math display">\[
value(mask) = \sum_{i:\,mask_i=1} w_i
\]</span></p></li>
<li><p>Best <span class="math display">\[
best = \max\!\bigl(best,\ value(mask)\bigr)
\]</span></p></li>
</ol>
</section>
<section id="tiny-code-easy-versions-47" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-47">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb105"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">20</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> w<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>w<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> adj<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> adj<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> e <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> e <span class="op">&lt;</span> m<span class="op">;</span> e<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span> v<span class="op">;</span></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">,</span> <span class="op">&amp;</span>v<span class="op">);</span></span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>u<span class="op">]</span> <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>v<span class="op">]</span> <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> u<span class="op">;</span></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">;</span></span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> N<span class="op">;</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ok <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> val <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb105-26"><a href="#cb105-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">))</span> <span class="op">{</span></span>
<span id="cb105-27"><a href="#cb105-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>adj<span class="op">[</span>i<span class="op">]</span> <span class="op">&amp;</span> mask<span class="op">)</span> <span class="op">{</span> ok <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb105-28"><a href="#cb105-28" aria-hidden="true" tabindex="-1"></a>                val <span class="op">+=</span> w<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb105-29"><a href="#cb105-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb105-30"><a href="#cb105-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb105-31"><a href="#cb105-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>ok <span class="op">&amp;&amp;</span> val <span class="op">&gt;</span> best<span class="op">)</span> best <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb105-32"><a href="#cb105-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-33"><a href="#cb105-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-34"><a href="#cb105-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> best<span class="op">);</span></span>
<span id="cb105-35"><a href="#cb105-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>n, m <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split()))</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>adj <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    u, v <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    adj[u] <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> v</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>    adj[v] <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> u</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>best <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> n):</span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>    ok <span class="op">=</span> <span class="va">True</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>    val <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mask <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i):</span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> adj[i] <span class="op">&amp;</span> mask:</span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>                ok <span class="op">=</span> <span class="va">False</span></span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a>            val <span class="op">+=</span> w[i]</span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ok:</span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> <span class="bu">max</span>(best, val)</span>
<span id="cb106-22"><a href="#cb106-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-23"><a href="#cb106-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(best)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-49" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-49">Why It Matters</h4>
<ul>
<li>Solves maximum independent set (MIS) for small graphs</li>
<li>Useful for exact solutions in constraint problems, treewidth-based DP, or bitmask search</li>
<li>A building block in graph coloring, maximum clique, dominating set, and subset optimization</li>
<li>Adaptable for unweighted (count) or weighted (sum) versions</li>
</ul>
</section>
<section id="step-by-step-example-47" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-47">Step-by-Step Example</h4>
<p>Graph: 4 vertices, edges <span class="math inline">\((0,1), (1,2), (2,3)\)</span> Weights: <span class="math inline">\([3, 2, 4, 1]\)</span></p>
<p>Independent sets:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Mask</th>
<th>Set</th>
<th>Valid</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0000</td>
<td>∅</td>
<td>✓</td>
<td>0</td>
</tr>
<tr class="even">
<td>0001</td>
<td>{0}</td>
<td>✓</td>
<td>3</td>
</tr>
<tr class="odd">
<td>0010</td>
<td>{1}</td>
<td>✓</td>
<td>2</td>
</tr>
<tr class="even">
<td>0100</td>
<td>{2}</td>
<td>✓</td>
<td>4</td>
</tr>
<tr class="odd">
<td>1000</td>
<td>{3}</td>
<td>✓</td>
<td>1</td>
</tr>
<tr class="even">
<td>0101</td>
<td>{0,2}</td>
<td>✗</td>
<td>,</td>
</tr>
<tr class="odd">
<td>1001</td>
<td>{0,3}</td>
<td>✓</td>
<td>4</td>
</tr>
<tr class="even">
<td>1100</td>
<td>{2,3}</td>
<td>✗</td>
<td>,</td>
</tr>
<tr class="odd">
<td>1010</td>
<td>{1,3}</td>
<td>✓</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Best = 4 (either {2} or {0,3})</p>
</section>
<section id="a-gentle-proof-why-it-works-36" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-36">A Gentle Proof (Why It Works)</h4>
<p>Each subset represents a candidate solution. A subset is feasible iff it contains no adjacent pair, ensured by the adjacency mask check. Since every subset is tested, the algorithm finds the global optimum by enumeration.</p>
<p>Bitmask feasibility check <span class="math inline">\((adj[i] \mathbin{\&amp;} mask) == 0\)</span> ensures constant-time validation per vertex, keeping complexity tight.</p>
</section>
<section id="try-it-yourself-49" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-49">Try It Yourself</h4>
<ol type="1">
<li>Modify to count all independent sets.</li>
<li>Restrict to subsets of exact size <span class="math inline">\(k\)</span>.</li>
<li>Add memoization to prune invalid masks early.</li>
<li>Combine with meet-in-the-middle for <span class="math inline">\(n=40\)</span>.</li>
<li>Flip edges to find maximum clique (complement graph).</li>
</ol>
</section>
<section id="test-cases-49" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-49">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Weights</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain 0–1–2–3</td>
<td>[3,2,4,1]</td>
<td>4</td>
</tr>
<tr class="even">
<td>Star center 0</td>
<td>[5,1,1,1,1]</td>
<td>5</td>
</tr>
<tr class="odd">
<td>Triangle</td>
<td>[1,2,3]</td>
<td>3</td>
</tr>
<tr class="even">
<td>Empty graph</td>
<td>[2,2,2]</td>
<td>6</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-49" class="level4">
<h4 class="anchored" data-anchor-id="complexity-49">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Bitmask Independent Set DP explores all subsets systematically, perfect when graphs are small but weights or constraints are complex.</p>
</section>
</section>
</section>
<section id="section-46.-digit-dp-and-sos-dp" class="level1">
<h1>Section 46. Digit DP and SOS DP</h1>
<section id="count-numbers-with-property-digit-dp" class="level3">
<h3 class="anchored" data-anchor-id="count-numbers-with-property-digit-dp">451 Count Numbers with Property (Digit DP)</h3>
<p>Digit DP is a method for counting numbers within a range that satisfy digit-level constraints, like no leading zeros, digit sum, specific digits, or forbidden patterns. This algorithm builds results by processing digits one by one while maintaining states for prefix constraints and current properties.</p>
<section id="what-problem-are-we-solving-50" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-50">What Problem Are We Solving?</h4>
<p>Given an integer <span class="math inline">\(N\)</span> and a property <span class="math inline">\(P\)</span> (like “sum of digits is even”), count how many integers in <span class="math inline">\([0, N]\)</span> satisfy <span class="math inline">\(P\)</span>.</p>
<p>Example: Count numbers <span class="math inline">\(\le 327\)</span> where the sum of digits is even.</p>
<p>We process each digit from most significant to least significant, maintaining:</p>
<ul>
<li>pos: current digit index</li>
<li>sum: accumulated property (e.g.&nbsp;sum of digits mod 2)</li>
<li>tight: whether we are bounded by <span class="math inline">\(N\)</span>’s prefix (0 = free, 1 = still tight)</li>
<li>leading: whether we’ve only seen leading zeros (optional)</li>
</ul>
<p>State: <span class="math display">\[
dp[pos][sum][tight]
\]</span></p>
<p>Transition over next digit <code>d</code> (0..limit):</p>
<ul>
<li>Update <code>next_sum = (sum + d) % 2</code></li>
<li>If <code>tight=1</code>, limit = digit at pos in <span class="math inline">\(N\)</span>, else 9</li>
<li>Move to next position</li>
</ul>
<p>Answer is sum over all valid end states satisfying the property.</p>
</section>
<section id="how-does-it-work-plain-language-50" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-50">How Does It Work (Plain Language)</h4>
<p>Digit DP works like counting with awareness: At each step, you choose the next digit, updating what you know (like current sum), while respecting the upper bound. By the time you process all digits, you’ve counted all valid numbers, no need to iterate up to <span class="math inline">\(N\)</span>!</p>
</section>
<section id="transition-formula-2" class="level4">
<h4 class="anchored" data-anchor-id="transition-formula-2">Transition Formula</h4>
<p>Let <span class="math inline">\(S\)</span> be the string of digits of <span class="math inline">\(N\)</span>. For each state:</p>
<p><span class="math display">\[
dp[pos][sum][tight] = \sum_{d=0}^{limit} dp[pos+1][(sum+d)\bmod M][tight \land (d==limit)]
\]</span></p>
<p>with base: <span class="math display">\[
dp[len][sum][tight] = 1 \text{ if property holds, else } 0
\]</span></p>
<p>Example: Property = sum of digits even → <span class="math inline">\(sum%2=0\)</span></p>
</section>
<section id="tiny-code-easy-versions-48" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-48">Tiny Code (Easy Versions)</h4>
<p>Python (Count numbers ≤ N with even digit sum)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_even_sum(n):</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    digits <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">str</span>(n)))</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(digits)</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">@lru_cache</span>(<span class="va">None</span>)</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(pos, sum_mod2, tight):</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> m:</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> sum_mod2 <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>        limit <span class="op">=</span> digits[pos] <span class="cf">if</span> tight <span class="cf">else</span> <span class="dv">9</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(limit <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> dp(pos <span class="op">+</span> <span class="dv">1</span>, (sum_mod2 <span class="op">+</span> d) <span class="op">%</span> <span class="dv">2</span>, tight <span class="kw">and</span> d <span class="op">==</span> limit)</span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(<span class="dv">0</span>, <span class="dv">0</span>, <span class="va">True</span>)</span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter N: "</span>))</span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_even_sum(N))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (Recursive Memoized DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb108"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> digits<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> memo<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> len<span class="op">;</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> sum_mod2<span class="op">,</span> <span class="dt">int</span> tight<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> len<span class="op">)</span> <span class="cf">return</span> sum_mod2 <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>pos<span class="op">][</span>sum_mod2<span class="op">][</span>tight<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>sum_mod2<span class="op">][</span>tight<span class="op">];</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> limit <span class="op">=</span> tight <span class="op">?</span> digits<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> limit<span class="op">;</span> d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>        res <span class="op">+=</span> dp<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="op">(</span>sum_mod2 <span class="op">+</span> d<span class="op">)</span> <span class="op">%</span> <span class="dv">2</span><span class="op">,</span> tight <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> limit<span class="op">));</span></span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>sum_mod2<span class="op">][</span>tight<span class="op">]</span> <span class="op">=</span> res<span class="op">;</span></span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> solve<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>    len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> n <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>        n <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> tmp <span class="op">=</span> digits<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">];</span></span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">]</span> <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>memo<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>memo<span class="op">));</span></span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb108-33"><a href="#cb108-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb108-34"><a href="#cb108-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-35"><a href="#cb108-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-36"><a href="#cb108-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> n<span class="op">;</span></span>
<span id="cb108-37"><a href="#cb108-37" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb108-38"><a href="#cb108-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> solve<span class="op">(</span>n<span class="op">));</span></span>
<span id="cb108-39"><a href="#cb108-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-50" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-50">Why It Matters</h4>
<ul>
<li><p>Fundamental to digit-based counting problems</p></li>
<li><p>Efficiently handles constraints on digits, sum, mod, parity, forbidden patterns</p></li>
<li><p>Avoids looping through large ranges (works in <span class="math inline">\(O(\text{len} \times \text{state})\)</span>)</p></li>
<li><p>Core idea behind counting numbers with:</p>
<ul>
<li>Even digit sum</li>
<li>Specific digits (e.g.&nbsp;no 4)</li>
<li>Digits increasing/decreasing</li>
<li>Remainder mod M conditions</li>
</ul></li>
</ul>
</section>
<section id="step-by-step-example-48" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-48">Step-by-Step Example</h4>
<p>Count numbers ≤ 327 with even digit sum.</p>
<p>We track sum mod 2:</p>
<ul>
<li><p>Start: pos=0, sum=0, tight=1</p></li>
<li><p>First digit: choose 0..3</p>
<ul>
<li>if 3 chosen → sum=1, next tight=1</li>
<li>else → free (tight=0)</li>
</ul></li>
<li><p>Continue until last digit</p></li>
<li><p>At end, count where sum=0 (even)</p></li>
</ul>
<p>Result: 164 numbers.</p>
</section>
<section id="a-gentle-proof-why-it-works-37" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-37">A Gentle Proof (Why It Works)</h4>
<p>At each position, <code>tight</code> ensures we never exceed N, and recursive branching over digits ensures coverage of all valid prefixes. By caching identical subproblems (same <code>pos</code>, <code>sum</code>, <code>tight</code>), we avoid recomputation. Thus, total states = <span class="math inline">\(O(len \times property_space \times 2)\)</span>.</p>
</section>
<section id="try-it-yourself-50" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-50">Try It Yourself</h4>
<ol type="1">
<li>Count numbers ≤ N with sum of digits divisible by 3.</li>
<li>Count numbers with no consecutive equal digits.</li>
<li>Count numbers with at most k nonzero digits.</li>
<li>Count numbers with digit product &lt; M.</li>
<li>Adapt for range [L, R] via <code>solve(R) - solve(L-1)</code>.</li>
</ol>
</section>
<section id="test-cases-50" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-50">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>N</th>
<th>Property</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>9</td>
<td>Even digit sum</td>
<td>5</td>
</tr>
<tr class="even">
<td>20</td>
<td>Even digit sum</td>
<td>10</td>
</tr>
<tr class="odd">
<td>327</td>
<td>Even digit sum</td>
<td>164</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-50" class="level4">
<h4 class="anchored" data-anchor-id="complexity-50">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(len \times M \times 2)\)</span></li>
<li>Space: <span class="math inline">\(O(len \times M \times 2)\)</span></li>
</ul>
<p>Digit DP transforms combinatorial counting into state-driven reasoning, digit by digit, a foundational trick for number-theoretic dynamic programming.</p>
</section>
</section>
<section id="count-without-adjacent-duplicates" class="level3">
<h3 class="anchored" data-anchor-id="count-without-adjacent-duplicates">452 Count Without Adjacent Duplicates</h3>
<p>This Digit DP problem counts numbers within a range that do not contain adjacent identical digits, a classic example where the state must remember the previous digit to enforce adjacency rules.</p>
<section id="what-problem-are-we-solving-51" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-51">What Problem Are We Solving?</h4>
<p>Given an integer <span class="math inline">\(N\)</span>, count how many integers in <span class="math inline">\([0, N]\)</span> have no two consecutive equal digits.</p>
<p>For example, up to <span class="math inline">\(N = 1234\)</span>:</p>
<ul>
<li>Valid: 1203 (no repeats)</li>
<li>Invalid: 1224 (two 2’s together)</li>
</ul>
<p>We’ll use Digit DP to explore all digit sequences up to <span class="math inline">\(N\)</span>, ensuring no adjacent duplicates.</p>
</section>
<section id="dp-state" class="level4">
<h4 class="anchored" data-anchor-id="dp-state">DP State</h4>
<p>Let the string of digits of <span class="math inline">\(N\)</span> be <code>S</code>, with length <code>len</code>.</p>
<p>State: <span class="math display">\[
dp[pos][prev][tight][leading]
\]</span></p>
<p>Where:</p>
<ul>
<li><code>pos</code>: current index (0-based)</li>
<li><code>prev</code>: previous digit (0–9, or 10 if none yet)</li>
<li><code>tight</code>: whether prefix equals <span class="math inline">\(N\)</span> so far (1 = bound, 0 = free)</li>
<li><code>leading</code>: whether we’ve seen only leading zeros (1 = true)</li>
</ul>
<p>Each state counts valid completions from position <code>pos</code> onward.</p>
</section>
<section id="transition" class="level4">
<h4 class="anchored" data-anchor-id="transition">Transition</h4>
<p>At position <code>pos</code>:</p>
<ul>
<li><p>Choose next digit <code>d</code> from 0 to <code>limit</code> (where <code>limit = S[pos]</code> if <code>tight = 1</code>, else 9)</p></li>
<li><p>Skip if <code>d == prev</code> and not <code>leading</code> (no adjacent duplicates)</p></li>
<li><p>Next state:</p>
<ul>
<li><code>next_prev = d</code> if not <code>leading</code> else 10</li>
<li><code>next_tight = tight and (d == limit)</code></li>
<li><code>next_leading = leading and (d == 0)</code></li>
</ul></li>
</ul>
<p>Sum all valid transitions.</p>
<p>Base: <span class="math display">\[
dp[len][prev][tight][leading] = 1
\]</span></p>
<p>when <code>pos == len</code> (end of number).</p>
</section>
<section id="how-does-it-work-plain-language-51" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-51">How Does It Work (Plain Language)</h4>
<p>We’re building numbers digit by digit:</p>
<ul>
<li><code>tight</code> keeps us within bounds.</li>
<li><code>prev</code> remembers the last chosen digit, to prevent repeating it.</li>
<li><code>leading</code> helps skip leading zeros (which don’t count as duplicates).</li>
</ul>
<p>By caching all combinations, we count every valid number exactly once.</p>
</section>
<section id="tiny-code-easy-versions-49" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-49">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_no_adjacent(N):</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    digits <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">str</span>(N)))</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(digits)</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">@lru_cache</span>(<span class="va">None</span>)</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(pos, prev, tight, leading):</span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> m:</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span>  <span class="co"># valid number</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>        limit <span class="op">=</span> digits[pos] <span class="cf">if</span> tight <span class="cf">else</span> <span class="dv">9</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(limit <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> leading <span class="kw">and</span> d <span class="op">==</span> prev:</span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span>  <span class="co"># no adjacent duplicates</span></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> dp(</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>                pos <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>                d <span class="cf">if</span> <span class="kw">not</span> leading <span class="cf">else</span> <span class="dv">10</span>,</span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>                tight <span class="kw">and</span> d <span class="op">==</span> limit,</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>                leading <span class="kw">and</span> d <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(<span class="dv">0</span>, <span class="dv">10</span>, <span class="va">True</span>, <span class="va">True</span>)</span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter N: "</span>))</span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_no_adjacent(N))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb110"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> digits<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> memo<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">11</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> len<span class="op">;</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> prev<span class="op">,</span> <span class="dt">int</span> tight<span class="op">,</span> <span class="dt">int</span> leading<span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> len<span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>pos<span class="op">][</span>prev<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>prev<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">];</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> limit <span class="op">=</span> tight <span class="op">?</span> digits<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> limit<span class="op">;</span> d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>leading <span class="op">&amp;&amp;</span> d <span class="op">==</span> prev<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> next_prev <span class="op">=</span> leading <span class="op">&amp;&amp;</span> d <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">10</span> <span class="op">:</span> d<span class="op">;</span></span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> next_tight <span class="op">=</span> tight <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> limit<span class="op">);</span></span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> next_leading <span class="op">=</span> leading <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>        res <span class="op">+=</span> dp<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> next_prev<span class="op">,</span> next_tight<span class="op">,</span> next_leading<span class="op">);</span></span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>prev<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> res<span class="op">;</span></span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> solve<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a>    len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> n <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a>        n <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb110-31"><a href="#cb110-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> tmp <span class="op">=</span> digits<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb110-32"><a href="#cb110-32" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">];</span></span>
<span id="cb110-33"><a href="#cb110-33" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">]</span> <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb110-34"><a href="#cb110-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb110-35"><a href="#cb110-35" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>memo<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>memo<span class="op">));</span></span>
<span id="cb110-36"><a href="#cb110-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb110-37"><a href="#cb110-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb110-38"><a href="#cb110-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-39"><a href="#cb110-39" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-40"><a href="#cb110-40" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> n<span class="op">;</span></span>
<span id="cb110-41"><a href="#cb110-41" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb110-42"><a href="#cb110-42" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> solve<span class="op">(</span>n<span class="op">));</span></span>
<span id="cb110-43"><a href="#cb110-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-51" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-51">Why It Matters</h4>
<ul>
<li><p>Classic Digit DP with “previous digit” state</p></li>
<li><p>Enables constraints like:</p>
<ul>
<li>No adjacent repeats</li>
<li>No increasing/decreasing sequences</li>
<li>No forbidden pairs</li>
</ul></li>
<li><p>Useful in pattern counting, PIN code generation, license plate validation</p></li>
</ul>
</section>
<section id="step-by-step-example-49" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-49">Step-by-Step Example</h4>
<p>Count numbers ≤ 120 with no adjacent duplicates:</p>
<ul>
<li><p>Leading zeros allowed at first</p></li>
<li><p>E.g. <code>101</code> ✓, <code>110</code> ✗</p></li>
<li><p>DP checks each digit:</p>
<ul>
<li><code>1?0</code> (pos=0, prev=10)</li>
<li>For next digit: skip equal to prev</li>
</ul></li>
<li><p>Total valid count = 91</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-38" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-38">A Gentle Proof (Why It Works)</h4>
<p>For each position, transitions ensure:</p>
<ul>
<li>Only digits ≤ bound if <code>tight=1</code></li>
<li>No consecutive duplicates via <code>d != prev</code></li>
<li>Leading zeros treated specially (ignored in duplicate check)</li>
</ul>
<p>By iterating through all valid digits and memoizing results, each subproblem (prefix constraint + previous digit) is solved once, ensuring completeness and correctness.</p>
</section>
<section id="try-it-yourself-51" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-51">Try It Yourself</h4>
<ol type="1">
<li>Count numbers ≤ N with no equal adjacent digits and sum of digits even.</li>
<li>Count numbers ≤ N with strictly increasing digits.</li>
<li>Modify to disallow adjacent 0’s only.</li>
<li>Combine with mod constraints (digit sum mod M).</li>
<li>Extend to handle exactly k equal pairs.</li>
</ol>
</section>
<section id="test-cases-51" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-51">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>N</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>9</td>
<td>10</td>
<td>0–9 all valid</td>
</tr>
<tr class="even">
<td>11</td>
<td>10</td>
<td>10 invalid</td>
</tr>
<tr class="odd">
<td>100</td>
<td>91</td>
<td>Only 9 invalids</td>
</tr>
<tr class="even">
<td>1234</td>
<td>820</td>
<td>Approx result</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-51" class="level4">
<h4 class="anchored" data-anchor-id="complexity-51">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(len \times 11 \times 2 \times 2 \times 10)\)</span></li>
<li>Space: <span class="math inline">\(O(len \times 11 \times 2 \times 2)\)</span></li>
</ul>
<p>Digit DP elegantly enforces local digit constraints (like adjacency) through memory of the previous digit, enabling fast counting across massive ranges.</p>
</section>
</section>
<section id="sum-of-digits-in-range" class="level3">
<h3 class="anchored" data-anchor-id="sum-of-digits-in-range">453 Sum of Digits in Range</h3>
<p>This Digit DP problem computes the sum of digits of all numbers in a given range <span class="math inline">\([0, N]\)</span>. Instead of enumerating numbers, we accumulate digit contributions position by position, respecting upper bounds.</p>
<section id="what-problem-are-we-solving-52" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-52">What Problem Are We Solving?</h4>
<p>Given a number <span class="math inline">\(N\)</span>, compute:</p>
<p><span class="math display">\[
S(N) = \sum_{x=0}^{N} \text{sum\_of\_digits}(x)
\]</span></p>
<p>For example:</p>
<ul>
<li><span class="math inline">\(S(13) = 1+0 + 1+1 + 1+2 + 1+3 = 55\)</span></li>
</ul>
<p>The goal is to compute <span class="math inline">\(S(N)\)</span> efficiently in <span class="math inline">\(O(\text{len} \times 2 \times M)\)</span>, not <span class="math inline">\(O(N)\)</span>.</p>
<p>You can also handle ranges: <span class="math display">\[
S(L,R) = S(R) - S(L-1)
\]</span></p>
</section>
<section id="dp-state-1" class="level4">
<h4 class="anchored" data-anchor-id="dp-state-1">DP State</h4>
<p>Let <span class="math inline">\(S\)</span> = list of digits of <span class="math inline">\(N\)</span>.</p>
<p>We define a recursive function: <span class="math display">\[
dp[pos][tight][sum]
\]</span></p>
<p>But instead of counting numbers, we also accumulate the total digit sum contribution.</p>
<p>So the function returns (count, total_sum), a pair:</p>
<ul>
<li><code>count</code>: number of valid numbers</li>
<li><code>sum</code>: sum of digits over all valid numbers</li>
</ul>
<p>State:</p>
<ul>
<li><code>pos</code>: current position (0..len-1)</li>
<li><code>tight</code>: whether we are still bounded by prefix</li>
<li><code>leading</code>: whether only leading zeros so far</li>
</ul>
</section>
<section id="transition-1" class="level4">
<h4 class="anchored" data-anchor-id="transition-1">Transition</h4>
<p>At each position, choose digit <code>d</code> in <code>[0, limit]</code> (limit = digit at pos if <code>tight = 1</code>, else 9)</p>
<p>Let <code>(cnt_next, sum_next)</code> = result from next position.</p>
<p>We add current digit’s contribution: <span class="math display">\[
total_sum += sum_next + d \times cnt_next
\]</span></p>
<p>If <code>leading</code> is true and <code>d=0</code>, then we don’t count that as a “real” leading digit.</p>
<p>Base case: <span class="math display">\[
dp[len][tight][leading] = (1, 0)
\]</span></p>
<p>(one valid number, sum = 0)</p>
</section>
<section id="how-does-it-work-plain-language-52" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-52">How Does It Work (Plain Language)</h4>
<p>Each recursive call counts how many numbers are possible from this prefix, and how much total digit sum they produce.</p>
<p>When you pick a digit <code>d</code>:</p>
<ul>
<li><code>d</code> contributes <code>d * cnt_next</code> to all numbers in this branch</li>
<li>Plus whatever the rest of the digits contribute recursively</li>
</ul>
<p>By caching <code>(count, sum)</code> per state, we reuse computations for repeated prefixes.</p>
</section>
<section id="tiny-code-easy-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version">Tiny Code (Easy Version)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_of_digits_upto(N):</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>    digits <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">str</span>(N)))</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(digits)</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">@lru_cache</span>(<span class="va">None</span>)</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(pos, tight, leading):</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> m:</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="dv">1</span>, <span class="dv">0</span>)  <span class="co"># (count, sum)</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>        limit <span class="op">=</span> digits[pos] <span class="cf">if</span> tight <span class="cf">else</span> <span class="dv">9</span></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>        total_count, total_sum <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(limit <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a>            cnt_next, sum_next <span class="op">=</span> dp(</span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a>                pos <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a>                tight <span class="kw">and</span> (d <span class="op">==</span> limit),</span>
<span id="cb111-19"><a href="#cb111-19" aria-hidden="true" tabindex="-1"></a>                leading <span class="kw">and</span> d <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb111-20"><a href="#cb111-20" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb111-21"><a href="#cb111-21" aria-hidden="true" tabindex="-1"></a>            total_count <span class="op">+=</span> cnt_next</span>
<span id="cb111-22"><a href="#cb111-22" aria-hidden="true" tabindex="-1"></a>            total_sum <span class="op">+=</span> sum_next <span class="op">+</span> (<span class="dv">0</span> <span class="cf">if</span> leading <span class="kw">and</span> d <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> d <span class="op">*</span> cnt_next)</span>
<span id="cb111-23"><a href="#cb111-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-24"><a href="#cb111-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (total_count, total_sum)</span>
<span id="cb111-25"><a href="#cb111-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-26"><a href="#cb111-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(<span class="dv">0</span>, <span class="va">True</span>, <span class="va">True</span>)[<span class="dv">1</span>]</span>
<span id="cb111-27"><a href="#cb111-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-28"><a href="#cb111-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_of_digits_range(L, R):</span>
<span id="cb111-29"><a href="#cb111-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum_of_digits_upto(R) <span class="op">-</span> sum_of_digits_upto(L <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb111-30"><a href="#cb111-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-31"><a href="#cb111-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb111-32"><a href="#cb111-32" aria-hidden="true" tabindex="-1"></a>L, R <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>(<span class="st">"Enter L R: "</span>).split())</span>
<span id="cb111-33"><a href="#cb111-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sum_of_digits_range(L, R))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (Recursive Pair Return via struct)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb112"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">long</span> <span class="dt">long</span> count<span class="op">,</span> sum<span class="op">;</span> <span class="op">}</span> Pair<span class="op">;</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> digits<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>Pair memo<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> vis<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> len<span class="op">;</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>Pair dp<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> tight<span class="op">,</span> <span class="dt">int</span> leading<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> len<span class="op">)</span> <span class="cf">return</span> <span class="op">(</span>Pair<span class="op">){</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>vis<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">])</span> <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">];</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> limit <span class="op">=</span> tight <span class="op">?</span> digits<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> total_count <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> total_sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> limit<span class="op">;</span> d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a>        Pair next <span class="op">=</span> dp<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> tight <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> limit<span class="op">),</span> leading <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>        total_count <span class="op">+=</span> next<span class="op">.</span>count<span class="op">;</span></span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>        total_sum <span class="op">+=</span> next<span class="op">.</span>sum <span class="op">+</span> <span class="op">(</span>leading <span class="op">&amp;&amp;</span> d <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="op">(</span><span class="dt">long</span> <span class="dt">long</span><span class="op">)</span>d <span class="op">*</span> next<span class="op">.</span>count<span class="op">);</span></span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>Pair<span class="op">){</span>total_count<span class="op">,</span> total_sum<span class="op">};</span></span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> solve<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-29"><a href="#cb112-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb112-30"><a href="#cb112-30" aria-hidden="true" tabindex="-1"></a>    len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb112-31"><a href="#cb112-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-32"><a href="#cb112-32" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> n <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb112-33"><a href="#cb112-33" aria-hidden="true" tabindex="-1"></a>        n <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb112-34"><a href="#cb112-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb112-35"><a href="#cb112-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb112-36"><a href="#cb112-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> tmp <span class="op">=</span> digits<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb112-37"><a href="#cb112-37" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">];</span></span>
<span id="cb112-38"><a href="#cb112-38" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">]</span> <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb112-39"><a href="#cb112-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb112-40"><a href="#cb112-40" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>vis<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>vis<span class="op">));</span></span>
<span id="cb112-41"><a href="#cb112-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">).</span>sum<span class="op">;</span></span>
<span id="cb112-42"><a href="#cb112-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb112-43"><a href="#cb112-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-44"><a href="#cb112-44" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-45"><a href="#cb112-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> L<span class="op">,</span> R<span class="op">;</span></span>
<span id="cb112-46"><a href="#cb112-46" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st"> </span><span class="sc">%lld</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>L<span class="op">,</span> <span class="op">&amp;</span>R<span class="op">);</span></span>
<span id="cb112-47"><a href="#cb112-47" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> solve<span class="op">(</span>R<span class="op">)</span> <span class="op">-</span> solve<span class="op">(</span>L <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb112-48"><a href="#cb112-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-52" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-52">Why It Matters</h4>
<ul>
<li><p>Computes digit sums over huge ranges in logarithmic time</p></li>
<li><p>Basis for many digit aggregation problems (count of 1’s, digit sum mod M, etc.)</p></li>
<li><p>Extensible to:</p>
<ul>
<li>Counting even/odd digits</li>
<li>Weighted digit sums (like <span class="math inline">\(d \times 10^{pos}\)</span>)</li>
<li>Property-based aggregation (e.g., sum of squares)</li>
</ul></li>
</ul>
</section>
<section id="step-by-step-example-50" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-50">Step-by-Step Example</h4>
<p>Compute sum of digits for all numbers ≤ 13:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Number</th>
<th>Sum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
</tr>
<tr class="even">
<td>5</td>
<td>5</td>
</tr>
<tr class="odd">
<td>6</td>
<td>6</td>
</tr>
<tr class="even">
<td>7</td>
<td>7</td>
</tr>
<tr class="odd">
<td>8</td>
<td>8</td>
</tr>
<tr class="even">
<td>9</td>
<td>9</td>
</tr>
<tr class="odd">
<td>10</td>
<td>1</td>
</tr>
<tr class="even">
<td>11</td>
<td>2</td>
</tr>
<tr class="odd">
<td>12</td>
<td>3</td>
</tr>
<tr class="even">
<td>13</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Total = 55 ✅</p>
<p>DP builds this by digit:</p>
<ul>
<li>Tens digit → repeats 10 times</li>
<li>Ones digit → contributes 0–9 repeatedly</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-39" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-39">A Gentle Proof (Why It Works)</h4>
<p>Each position contributes its digit value multiplied by the number of combinations of remaining positions. Digit DP captures this recursively: If a digit <code>d</code> is fixed at position <code>pos</code>, every completion of later positions includes that digit once, hence <code>d * count_of_suffix</code>. Summing over all digits at all positions gives the total sum.</p>
</section>
<section id="try-it-yourself-52" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-52">Try It Yourself</h4>
<ol type="1">
<li>Count sum of even digits only.</li>
<li>Compute sum of digits mod M.</li>
<li>Compute sum of squared digits.</li>
<li>Count total number of digits written in range.</li>
<li>Compute weighted sum (like <code>d * 10^pos</code> contributions).</li>
</ol>
</section>
<section id="test-cases-52" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-52">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Range</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–9</td>
<td>45</td>
</tr>
<tr class="even">
<td>0–13</td>
<td>55</td>
</tr>
<tr class="odd">
<td>10–99</td>
<td>855</td>
</tr>
<tr class="even">
<td>1–1000</td>
<td>13501</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-52" class="level4">
<h4 class="anchored" data-anchor-id="complexity-52">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(\text{len} \times 2 \times 2 \times 10)\)</span></li>
<li>Space: <span class="math inline">\(O(\text{len} \times 2 \times 2)\)</span></li>
</ul>
<p>Digit DP can aggregate digit-level properties over massive intervals, this sum version is its canonical “count + accumulate” template.</p>
</section>
</section>
<section id="count-with-mod-condition-digit-sum-mod-m" class="level3">
<h3 class="anchored" data-anchor-id="count-with-mod-condition-digit-sum-mod-m">454 Count with Mod Condition (Digit Sum mod M)</h3>
<p>Count numbers in a range whose digit sum satisfies a modular condition. The standard pattern tracks the digit-sum modulo <span class="math inline">\(M\)</span> while respecting the upper bound.</p>
<section id="what-problem-are-we-solving-53" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-53">What Problem Are We Solving?</h4>
<p>Given integers <span class="math inline">\(N,M,K\)</span>, count how many <span class="math inline">\(x\in[0,N]\)</span> satisfy: <span class="math display">\[
\big(\text{sum\_digits}(x)\big)\bmod M=K
\]</span> For a general range <span class="math inline">\([L,R]\)</span>, use <span class="math inline">\(f(R)-f(L-1)\)</span>.</p>
</section>
<section id="dp-state-2" class="level4">
<h4 class="anchored" data-anchor-id="dp-state-2">DP State</h4>
<p>Let the decimal string of <span class="math inline">\(N\)</span> be <span class="math inline">\(S\)</span>, length <span class="math inline">\(m\)</span>.</p>
<p>State: <span class="math display">\[
dp[pos][mod][tight][leading]
\]</span></p>
<ul>
<li><span class="math inline">\(pos\)</span>: index in <span class="math inline">\(S\)</span> (0-based, left to right)</li>
<li><span class="math inline">\(mod\)</span>: current value of digit-sum modulo <span class="math inline">\(M\)</span></li>
<li><span class="math inline">\(tight\in{0,1}\)</span>: still equal to <span class="math inline">\(S\)</span> prefix or already below</li>
<li><span class="math inline">\(leading\in{0,1}\)</span>: still placing only leading zeros</li>
</ul>
<p>Goal: count completions with final <span class="math inline">\(mod = K\)</span>.</p>
<p>Base: <span class="math display">\[
dp[m][mod][tight][leading] =
\begin{cases}
1, &amp; mod = K,\\
0, &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Transition (choose next digit <span class="math inline">\(d\)</span>):</p>
<ul>
<li><span class="math inline">\(limit = S[pos]\)</span> if <span class="math inline">\(tight = 1\)</span>, else <span class="math inline">\(9\)</span></li>
<li>Next states:
<ul>
<li><span class="math inline">\(next\_tight = tight \land (d = limit)\)</span><br>
</li>
<li><span class="math inline">\(next\_leading = leading \land (d = 0)\)</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
  next\_mod =
    \begin{cases}
    mod, &amp; \text{if } next\_leading = 1,\\
    (mod + d) \bmod M, &amp; \text{otherwise.}
    \end{cases}
\]</span></p>
<p>Then <span class="math display">\[
dp[pos][mod][tight][leading]
= \sum_{d=0}^{limit}
dp[pos+1][next\_mod][next\_tight][next\_leading].
\]</span></p>
</section>
<section id="tiny-code-easy-versions-50" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-50">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_mod_sum_upto(N, M, K):</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">str</span>(N)))</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(S)</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">@lru_cache</span>(<span class="va">None</span>)</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(pos, mod, tight, leading):</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> m:</span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> mod <span class="op">==</span> K <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>        limit <span class="op">=</span> S[pos] <span class="cf">if</span> tight <span class="cf">else</span> <span class="dv">9</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(limit <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>            ntight <span class="op">=</span> tight <span class="kw">and</span> (d <span class="op">==</span> limit)</span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a>            nleading <span class="op">=</span> leading <span class="kw">and</span> (d <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a>            nmod <span class="op">=</span> mod <span class="cf">if</span> nleading <span class="cf">else</span> (mod <span class="op">+</span> d) <span class="op">%</span> M</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> dp(pos <span class="op">+</span> <span class="dv">1</span>, nmod, ntight, nleading)</span>
<span id="cb113-18"><a href="#cb113-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb113-19"><a href="#cb113-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-20"><a href="#cb113-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(<span class="dv">0</span>, <span class="dv">0</span>, <span class="va">True</span>, <span class="va">True</span>)</span>
<span id="cb113-21"><a href="#cb113-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-22"><a href="#cb113-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_mod_sum_range(L, R, M, K):</span>
<span id="cb113-23"><a href="#cb113-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> L <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb113-24"><a href="#cb113-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count_mod_sum_upto(R, M, K)</span>
<span id="cb113-25"><a href="#cb113-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_mod_sum_upto(R, M, K) <span class="op">-</span> count_mod_sum_upto(L <span class="op">-</span> <span class="dv">1</span>, M, K)</span>
<span id="cb113-26"><a href="#cb113-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-27"><a href="#cb113-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Example:</span></span>
<span id="cb113-28"><a href="#cb113-28" aria-hidden="true" tabindex="-1"></a><span class="co"># print(count_mod_sum_range(0, 327, 7, 3))</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> memo<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">200</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> vis<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">200</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> digits<span class="op">[</span><span class="dv">20</span><span class="op">],</span> mlen<span class="op">,</span> M<span class="op">,</span> K<span class="op">;</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> solve_dp<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> mod<span class="op">,</span> <span class="dt">int</span> tight<span class="op">,</span> <span class="dt">int</span> leading<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> mlen<span class="op">)</span> <span class="cf">return</span> mod <span class="op">==</span> K<span class="op">;</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>vis<span class="op">[</span>pos<span class="op">][</span>mod<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">])</span> <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>mod<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">];</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>pos<span class="op">][</span>mod<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> limit <span class="op">=</span> tight <span class="op">?</span> digits<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> limit<span class="op">;</span> d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ntight <span class="op">=</span> tight <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> limit<span class="op">);</span></span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> nleading <span class="op">=</span> leading <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> nmod <span class="op">=</span> nleading <span class="op">?</span> mod <span class="op">:</span> <span class="op">(</span>mod <span class="op">+</span> d<span class="op">)</span> <span class="op">%</span> M<span class="op">;</span></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> solve_dp<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> nmod<span class="op">,</span> ntight<span class="op">,</span> nleading<span class="op">);</span></span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>mod<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> total<span class="op">;</span></span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> count_upto<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> N<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb114-26"><a href="#cb114-26" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> m<span class="op">;</span> K <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb114-27"><a href="#cb114-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp<span class="op">[</span><span class="dv">20</span><span class="op">],</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb114-28"><a href="#cb114-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>N <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> tmp<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)(</span>N <span class="op">%</span> <span class="dv">10</span><span class="op">);</span> N <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb114-29"><a href="#cb114-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>len <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> tmp<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb114-30"><a href="#cb114-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span> digits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> tmp<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">];</span></span>
<span id="cb114-31"><a href="#cb114-31" aria-hidden="true" tabindex="-1"></a>    mlen <span class="op">=</span> len<span class="op">;</span></span>
<span id="cb114-32"><a href="#cb114-32" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>vis<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>vis<span class="op">));</span></span>
<span id="cb114-33"><a href="#cb114-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> solve_dp<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb114-34"><a href="#cb114-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb114-35"><a href="#cb114-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-36"><a href="#cb114-36" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> count_range<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> L<span class="op">,</span> <span class="dt">long</span> <span class="dt">long</span> R<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-37"><a href="#cb114-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_upto<span class="op">(</span>R<span class="op">,</span> m<span class="op">,</span> k<span class="op">)</span> <span class="op">-</span> count_upto<span class="op">(</span>L <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> m<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb114-38"><a href="#cb114-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb114-39"><a href="#cb114-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-40"><a href="#cb114-40" aria-hidden="true" tabindex="-1"></a><span class="co">// Example usage in main:</span></span>
<span id="cb114-41"><a href="#cb114-41" aria-hidden="true" tabindex="-1"></a><span class="co">// int main(){ long long L=0,R=327; int M=7,K=3; printf("%lld\n", count_range(L,R,M,K)); }</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Notes:</p>
<ul>
<li>The array bound <code>200</code> for <code>mod</code> assumes <span class="math inline">\(M\le 200\)</span>. Increase if needed.</li>
</ul>
</section>
<section id="why-it-matters-53" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-53">Why It Matters</h4>
<ul>
<li><p>Core Digit DP for number-theory style constraints</p></li>
<li><p>Handles many variants by changing the carried statistic to modulo form</p></li>
<li><p>Building block for problems like:</p>
<ul>
<li>Count with digit sum equal to <span class="math inline">\(S\)</span> (set <span class="math inline">\(M\)</span> large enough and target <span class="math inline">\(K=S\)</span> with careful state)</li>
<li>Count with digit sum in a set (sum over multiple <span class="math inline">\(K\)</span>)</li>
<li>Multi-condition states (e.g., digit sum mod <span class="math inline">\(M\)</span> and parity)</li>
</ul></li>
</ul>
</section>
<section id="step-by-step-example-51" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-51">Step-by-Step Example</h4>
<p>Count <span class="math inline">\(x\in[0,99]\)</span> with digit sum mod <span class="math inline">\(3\)</span> equal to <span class="math inline">\(0\)</span>.</p>
<ul>
<li>The DP carries <span class="math inline">\(mod\in{0,1,2}\)</span>.</li>
<li>At each position, branch over <span class="math inline">\(d\in[0..9]\)</span> with tight until you pass the bound 99.</li>
<li>The answer is <span class="math inline">\(34\)</span>.</li>
</ul>
<p>(This small case can also be verified by combinatorics: roughly one third of two-digit-with-leading-zero numbers.)</p>
</section>
<section id="a-gentle-proof-why-it-works-40" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-40">A Gentle Proof (Why It Works)</h4>
<p>Every number corresponds to one path of digit choices. The state <span class="math inline">\((pos,mod,tight,leading)\)</span> uniquely captures all information that influences future feasibility and the final condition <span class="math inline">\(mod=K\)</span>. Since the transition only depends on the current state and chosen digit, memoizing these states yields a complete and non-overlapping partition of the search space.</p>
</section>
<section id="try-it-yourself-53" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-53">Try It Yourself</h4>
<ol type="1">
<li>Count numbers with digit sum mod <span class="math inline">\(M\)</span> in a set <span class="math inline">\(S\)</span> by summing answers over <span class="math inline">\(K\in S\)</span>.</li>
<li>Count numbers with digit sum exactly <span class="math inline">\(S\)</span> by replacing <span class="math inline">\(mod\)</span> with a bounded sum state and capping at <span class="math inline">\(S\)</span>.</li>
<li>Combine with no adjacent duplicates by adding a <code>prev</code> digit to the state.</li>
<li>Compute numbers with sum of squares of digits mod <span class="math inline">\(M\)</span> equal to <span class="math inline">\(K\)</span>.</li>
<li>Extend to base-<span class="math inline">\(B\)</span> by changing the limit from 9 to <span class="math inline">\(B-1\)</span>.</li>
</ol>
</section>
<section id="test-cases-53" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-53">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(N\)</span></th>
<th><span class="math inline">\(M\)</span></th>
<th><span class="math inline">\(K\)</span></th>
<th>Expected idea</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>9</td>
<td>3</td>
<td>0</td>
<td>4 numbers (0,3,6,9)</td>
</tr>
<tr class="even">
<td>20</td>
<td>2</td>
<td>0</td>
<td>about half of 0..20</td>
</tr>
<tr class="odd">
<td>99</td>
<td>3</td>
<td>0</td>
<td>34</td>
</tr>
<tr class="even">
<td>327</td>
<td>7</td>
<td>3</td>
<td>computed via code</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-53" class="level4">
<h4 class="anchored" data-anchor-id="complexity-53">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(len\cdot M\cdot 2\cdot 2\cdot 10)\)</span></li>
<li>Space: <span class="math inline">\(O(len\cdot M\cdot 2\cdot 2)\)</span></li>
</ul>
<p>This is the standard mod-carry Digit DP: thread the property through the digits modulo <span class="math inline">\(M\)</span>, respect the bound with <code>tight</code>, and account for leading zeros cleanly.</p>
</section>
</section>
<section id="count-of-increasing-digits" class="level3">
<h3 class="anchored" data-anchor-id="count-of-increasing-digits">455 Count of Increasing Digits</h3>
<p>We want to count all integers in a range that have strictly increasing digits, every digit is larger than the one before it. For example, <code>123</code>, <code>149</code>, and <code>7</code> qualify, but <code>133</code>, <code>321</code>, or <code>224</code> do not.</p>
<section id="what-problem-are-we-solving-54" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-54">What Problem Are We Solving?</h4>
<p>Given an upper bound <span class="math inline">\(N\)</span>, count integers <span class="math inline">\(x\)</span> in <span class="math inline">\([0, N]\)</span> such that:</p>
<p><span class="math display">\[
\text{digits}(x) = [d_0, d_1, \dots, d_k] \implies d_0 &lt; d_1 &lt; \dots &lt; d_k
\]</span></p>
<p>Example: For <span class="math inline">\(N=500\)</span>, valid numbers include <code>1, 2, …, 9, 12, 13, …, 49, 123, 134, …, 489</code>, etc.</p>
<p>We can model this with Digit DP tracking the previous digit to ensure the increasing condition.</p>
</section>
<section id="dp-state-3" class="level4">
<h4 class="anchored" data-anchor-id="dp-state-3">DP State</h4>
<p>Let <span class="math inline">\(S\)</span> = list of digits of <span class="math inline">\(N\)</span>.</p>
<p>State: <span class="math display">\[
dp[pos][prev][tight][leading]
\]</span></p>
<p>Where:</p>
<ul>
<li><code>pos</code>: index of current digit (0-based)</li>
<li><code>prev</code>: last chosen digit (0–9, or 10 for “none yet”)</li>
<li><code>tight</code>: whether we’re still prefix-equal to <span class="math inline">\(N\)</span></li>
<li><code>leading</code>: whether we’ve only placed leading zeros (so far no real digits)</li>
</ul>
</section>
<section id="transition-2" class="level4">
<h4 class="anchored" data-anchor-id="transition-2">Transition</h4>
<p>At each position:</p>
<ul>
<li><p>Determine <code>limit = S[pos]</code> if <code>tight=1</code>, else 9.</p></li>
<li><p>Loop <code>d</code> from 0 to <code>limit</code>.</p></li>
<li><p>Skip <code>d &lt;= prev</code> if not <code>leading</code> (must strictly increase).</p></li>
<li><p>Update:</p>
<ul>
<li><code>next_tight = tight and (d == limit)</code></li>
<li><code>next_leading = leading and (d == 0)</code></li>
<li><code>next_prev = prev if next_leading else d</code></li>
</ul></li>
</ul>
<p>Sum results of recursive calls.</p>
<p>Base: <span class="math display">\[
dp[len][prev][tight][leading] = 1
\]</span> since one valid number is formed.</p>
</section>
<section id="how-does-it-work-plain-language-53" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-53">How Does It Work (Plain Language)</h4>
<p>We build the number one digit at a time:</p>
<ul>
<li>If we’ve started (not leading), each new digit must be greater than the previous one.</li>
<li>If we’re still leading, any zero is fine.</li>
<li><code>tight</code> ensures we never exceed <span class="math inline">\(N\)</span>’s prefix. By exploring all possible digits under these rules, we count every strictly increasing number ≤ <span class="math inline">\(N\)</span>.</li>
</ul>
</section>
<section id="tiny-code-easy-versions-51" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-51">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_increasing_digits(N):</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">str</span>(N)))</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(S)</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">@lru_cache</span>(<span class="va">None</span>)</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(pos, prev, tight, leading):</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> m:</span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span>  <span class="co"># reached end, valid number</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>        limit <span class="op">=</span> S[pos] <span class="cf">if</span> tight <span class="cf">else</span> <span class="dv">9</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(limit <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> leading <span class="kw">and</span> d <span class="op">&lt;=</span> prev:</span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span>  <span class="co"># must strictly increase</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>            ntight <span class="op">=</span> tight <span class="kw">and</span> (d <span class="op">==</span> limit)</span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>            nleading <span class="op">=</span> leading <span class="kw">and</span> (d <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>            nprev <span class="op">=</span> prev <span class="cf">if</span> nleading <span class="cf">else</span> d</span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> dp(pos <span class="op">+</span> <span class="dv">1</span>, nprev, ntight, nleading)</span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(<span class="dv">0</span>, <span class="dv">10</span>, <span class="va">True</span>, <span class="va">True</span>)</span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>(<span class="st">"Enter N: "</span>))</span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_increasing_digits(N))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb116"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> memo<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">11</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> vis<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">11</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> digits<span class="op">[</span><span class="dv">20</span><span class="op">],</span> len<span class="op">;</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> prev<span class="op">,</span> <span class="dt">int</span> tight<span class="op">,</span> <span class="dt">int</span> leading<span class="op">)</span> <span class="op">{</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> len<span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>vis<span class="op">[</span>pos<span class="op">][</span>prev<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">])</span> <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>prev<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">];</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>pos<span class="op">][</span>prev<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> limit <span class="op">=</span> tight <span class="op">?</span> digits<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> limit<span class="op">;</span> d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>leading <span class="op">&amp;&amp;</span> d <span class="op">&lt;=</span> prev<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ntight <span class="op">=</span> tight <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> limit<span class="op">);</span></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> nleading <span class="op">=</span> leading <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> nprev <span class="op">=</span> nleading <span class="op">?</span> prev <span class="op">:</span> d<span class="op">;</span></span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>        res <span class="op">+=</span> dp<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> nprev<span class="op">,</span> ntight<span class="op">,</span> nleading<span class="op">);</span></span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>prev<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> res<span class="op">;</span></span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> solve<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb116-28"><a href="#cb116-28" aria-hidden="true" tabindex="-1"></a>    len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb116-29"><a href="#cb116-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb116-30"><a href="#cb116-30" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> n <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb116-31"><a href="#cb116-31" aria-hidden="true" tabindex="-1"></a>        n <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb116-32"><a href="#cb116-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb116-33"><a href="#cb116-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>len <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> digits<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb116-34"><a href="#cb116-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb116-35"><a href="#cb116-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> t <span class="op">=</span> digits<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb116-36"><a href="#cb116-36" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">];</span></span>
<span id="cb116-37"><a href="#cb116-37" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">]</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb116-38"><a href="#cb116-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb116-39"><a href="#cb116-39" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>vis<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>vis<span class="op">));</span></span>
<span id="cb116-40"><a href="#cb116-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb116-41"><a href="#cb116-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb116-42"><a href="#cb116-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-43"><a href="#cb116-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb116-44"><a href="#cb116-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> N<span class="op">;</span></span>
<span id="cb116-45"><a href="#cb116-45" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>N<span class="op">);</span></span>
<span id="cb116-46"><a href="#cb116-46" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> solve<span class="op">(</span>N<span class="op">));</span></span>
<span id="cb116-47"><a href="#cb116-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-54" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-54">Why It Matters</h4>
<ul>
<li><p>Builds understanding of monotonic digit constraints</p></li>
<li><p>Template for counting:</p>
<ul>
<li>Strictly increasing digits</li>
<li>Strictly decreasing digits</li>
<li>Non-decreasing digits (just change condition to <code>d &lt; prev</code>)</li>
</ul></li>
<li><p>Appears in combinatorial enumeration and digit ordering problems</p></li>
</ul>
</section>
<section id="step-by-step-example-52" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-52">Step-by-Step Example</h4>
<p>For <span class="math inline">\(N=130\)</span>:</p>
<p>Valid numbers include:</p>
<pre><code>0–9
12, 13
23
...
123</code></pre>
<p>Invalid examples:</p>
<ul>
<li><code>11</code> (equal digits)</li>
<li><code>21</code> (decreasing)</li>
</ul>
<p>DP automatically filters these based on the <code>d &gt; prev</code> rule.</p>
</section>
<section id="a-gentle-proof-why-it-works-41" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-41">A Gentle Proof (Why It Works)</h4>
<p>Each path corresponds to a unique number ≤ <span class="math inline">\(N\)</span>. The rule <code>d &gt; prev</code> enforces strictly increasing order. The DP ensures no overcounting because each prefix <code>(pos, prev, tight, leading)</code> fully determines future choices.</p>
</section>
<section id="try-it-yourself-54" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-54">Try It Yourself</h4>
<ol type="1">
<li>Modify to count strictly decreasing numbers (<code>d &lt; prev</code>).</li>
<li>Count non-decreasing numbers (<code>d &gt;= prev</code>).</li>
<li>Enforce exact length <span class="math inline">\(k\)</span> via a <code>len_used</code> parameter.</li>
<li>Add mod conditions (sum mod M).</li>
<li>Compute sum of all increasing numbers instead of count.</li>
</ol>
</section>
<section id="test-cases-54" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-54">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>N</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>9</td>
<td>10</td>
<td>0–9 valid</td>
</tr>
<tr class="even">
<td>12</td>
<td>12</td>
<td>10 numbers 0–9, plus 12 and 13</td>
</tr>
<tr class="odd">
<td>99</td>
<td>45</td>
<td>All 1–2-digit increasing numbers</td>
</tr>
<tr class="even">
<td>321</td>
<td>84</td>
<td>Derived by DP</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-54" class="level4">
<h4 class="anchored" data-anchor-id="complexity-54">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(len \times 11 \times 2 \times 2 \times 10)\)</span></li>
<li>Space: <span class="math inline">\(O(len \times 11 \times 2 \times 2)\)</span></li>
</ul>
<p>Digit DP with monotonic digit constraints transforms ordering problems into state-space counting, a fundamental technique for combinatorial digit analysis.</p>
</section>
</section>
<section id="count-with-forbidden-digits" class="level3">
<h3 class="anchored" data-anchor-id="count-with-forbidden-digits">456 Count with Forbidden Digits</h3>
<p>Count how many integers in a range avoid a given set of forbidden digits. This is a basic Digit DP where the state remembers whether we are still tight to the upper bound and whether we have only placed leading zeros.</p>
<section id="what-problem-are-we-solving-55" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-55">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(N\)</span> and a set <span class="math inline">\(F\subseteq{0,1,\dots,9}\)</span> of forbidden digits, count integers <span class="math inline">\(x\in[0,N]\)</span> whose standard decimal representation contains no digit from <span class="math inline">\(F\)</span>.</p>
<p>Convention: leading zeros are allowed during the DP but do not count as real digits, so a leading zero is always permitted even if <span class="math inline">\(0\in F\)</span>.</p>
<p>For a general range <span class="math inline">\([L,R]\)</span> return <span class="math inline">\(f(R)-f(L-1)\)</span>.</p>
</section>
<section id="dp-state-4" class="level4">
<h4 class="anchored" data-anchor-id="dp-state-4">DP State</h4>
<p>Let <span class="math inline">\(S\)</span> be the digit list of <span class="math inline">\(N\)</span>, length <span class="math inline">\(m\)</span>.</p>
<p>State: <span class="math display">\[
dp[pos][tight][leading]
\]</span></p>
<ul>
<li><span class="math inline">\(pos\)</span>: index in <span class="math inline">\([0,m)\)</span></li>
<li><span class="math inline">\(tight\in{0,1}\)</span>: 1 if the prefix equals <span class="math inline">\(N\)</span> so far</li>
<li><span class="math inline">\(leading\in{0,1}\)</span>: 1 if all chosen digits are leading zeros</li>
</ul>
</section>
<section id="transition-3" class="level4">
<h4 class="anchored" data-anchor-id="transition-3">Transition</h4>
<p>At position <span class="math inline">\(pos\)</span> choose digit <span class="math inline">\(d\in[0,\text{limit}]\)</span>, where <span class="math inline">\(\text{limit}=S[pos]\)</span> if <span class="math inline">\(tight=1\)</span> else <span class="math inline">\(9\)</span>.</p>
<p>Reject <span class="math inline">\(d\)</span> if it is a real digit that is forbidden:</p>
<ul>
<li>If <span class="math inline">\(leading=1\)</span> and <span class="math inline">\(d=0\)</span>, accept regardless of <span class="math inline">\(F\)</span>.</li>
<li>Otherwise require <span class="math inline">\(d\notin F\)</span>.</li>
</ul>
<p>Next state:</p>
<ul>
<li><span class="math inline">\(next_tight = tight\land(d=\text{limit})\)</span></li>
<li><span class="math inline">\(next_leading = leading\land(d=0)\)</span></li>
</ul>
<p>Recurrence: <span class="math display">\[
dp[pos][tight][leading] = \sum_{d=0}^{\text{limit}} \mathbf{1}\big(\text{allowed}(d,leading)\big)\cdot dp[pos+1][next_tight][next_leading]
\]</span></p>
<p>Base: <span class="math display">\[
dp[m][tight][leading]=1
\]</span></p>
<p>Answer is <span class="math inline">\(dp[0][1][1]\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-54" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-54">How Does It Work (Plain Language)</h4>
<p>We build the number left to right. If we have not surpassed <span class="math inline">\(N\)</span> yet, the next digit is restricted by <span class="math inline">\(N\)</span> at that position. Leading zeros are virtual padding and do not trigger the forbidden check. The DP counts all valid completions from each prefix.</p>
</section>
<section id="tiny-code-easy-versions-52" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-52">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_without_forbidden(N, forbidden):</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">str</span>(N)))</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(S)</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> <span class="bu">set</span>(forbidden)</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">@lru_cache</span>(<span class="va">None</span>)</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(pos, tight, leading):</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> m:</span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>        limit <span class="op">=</span> S[pos] <span class="cf">if</span> tight <span class="cf">else</span> <span class="dv">9</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(limit <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>            ntight <span class="op">=</span> tight <span class="kw">and</span> (d <span class="op">==</span> limit)</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>            nleading <span class="op">=</span> leading <span class="kw">and</span> (d <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>            <span class="co"># allow leading zero regardless of F</span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> nleading <span class="kw">and</span> d <span class="kw">in</span> F:</span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> dp(pos <span class="op">+</span> <span class="dv">1</span>, ntight, nleading)</span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(<span class="dv">0</span>, <span class="va">True</span>, <span class="va">True</span>)</span>
<span id="cb118-24"><a href="#cb118-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-25"><a href="#cb118-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_range_without_forbidden(L, R, forbidden):</span>
<span id="cb118-26"><a href="#cb118-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> L <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb118-27"><a href="#cb118-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count_without_forbidden(R, forbidden)</span>
<span id="cb118-28"><a href="#cb118-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_without_forbidden(R, forbidden) <span class="op">-</span> count_without_forbidden(L <span class="op">-</span> <span class="dv">1</span>, forbidden)</span>
<span id="cb118-29"><a href="#cb118-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-30"><a href="#cb118-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Example:</span></span>
<span id="cb118-31"><a href="#cb118-31" aria-hidden="true" tabindex="-1"></a><span class="co"># print(count_range_without_forbidden(0, 327, {3,4}))</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb119"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> memo<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> vis<span class="op">[</span><span class="dv">20</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> digits<span class="op">[</span><span class="dv">20</span><span class="op">],</span> len<span class="op">;</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> forbid<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> tight<span class="op">,</span> <span class="dt">int</span> leading<span class="op">)</span> <span class="op">{</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> len<span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>vis<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">])</span> <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">];</span></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> limit <span class="op">=</span> tight <span class="op">?</span> digits<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> limit<span class="op">;</span> d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ntight <span class="op">=</span> tight <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> limit<span class="op">);</span></span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> nleading <span class="op">=</span> leading <span class="op">&amp;&amp;</span> <span class="op">(</span>d <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>nleading <span class="op">&amp;&amp;</span> forbid<span class="op">[</span>d<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span> <span class="co">// real digit must not be forbidden</span></span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> dp<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> ntight<span class="op">,</span> nleading<span class="op">);</span></span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>pos<span class="op">][</span>tight<span class="op">][</span>leading<span class="op">]</span> <span class="op">=</span> total<span class="op">;</span></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> solve_upto<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>    len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> digits<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb119-30"><a href="#cb119-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>N <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> digits<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)(</span>N <span class="op">%</span> <span class="dv">10</span><span class="op">);</span> N <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb119-31"><a href="#cb119-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">/</span><span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb119-32"><a href="#cb119-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> t <span class="op">=</span> digits<span class="op">[</span>i<span class="op">];</span> digits<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> digits<span class="op">[</span>len<span class="op">-</span><span class="dv">1</span><span class="op">-</span>i<span class="op">];</span> digits<span class="op">[</span>len<span class="op">-</span><span class="dv">1</span><span class="op">-</span>i<span class="op">]</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb119-33"><a href="#cb119-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb119-34"><a href="#cb119-34" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>vis<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>vis<span class="op">));</span></span>
<span id="cb119-35"><a href="#cb119-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb119-36"><a href="#cb119-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb119-37"><a href="#cb119-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-38"><a href="#cb119-38" aria-hidden="true" tabindex="-1"></a><span class="co">// Example main</span></span>
<span id="cb119-39"><a href="#cb119-39" aria-hidden="true" tabindex="-1"></a><span class="co">// int main(void){</span></span>
<span id="cb119-40"><a href="#cb119-40" aria-hidden="true" tabindex="-1"></a><span class="co">//     long long L,R; int k,x;</span></span>
<span id="cb119-41"><a href="#cb119-41" aria-hidden="true" tabindex="-1"></a><span class="co">//     scanf("%lld %lld %d",&amp;L,&amp;R,&amp;k);</span></span>
<span id="cb119-42"><a href="#cb119-42" aria-hidden="true" tabindex="-1"></a><span class="co">//     memset(forbid,0,sizeof(forbid));</span></span>
<span id="cb119-43"><a href="#cb119-43" aria-hidden="true" tabindex="-1"></a><span class="co">//     for(int i=0;i&lt;k;i++){ scanf("%d",&amp;x); forbid[x]=1; }</span></span>
<span id="cb119-44"><a href="#cb119-44" aria-hidden="true" tabindex="-1"></a><span class="co">//     long long ans = solve_upto(R) - solve_upto(L-1);</span></span>
<span id="cb119-45"><a href="#cb119-45" aria-hidden="true" tabindex="-1"></a><span class="co">//     printf("%lld\n", ans);</span></span>
<span id="cb119-46"><a href="#cb119-46" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-55" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-55">Why It Matters</h4>
<ul>
<li>Canonical Digit DP that filters digits by a local constraint</li>
<li>Models problems with digit blacklists, keypad rules, license formats, or numeral-system restrictions</li>
<li>Serves as a base to combine with additional states like digit sum or adjacency constraints</li>
</ul>
</section>
<section id="step-by-step-example-53" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-53">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(F={3,4}\)</span> and <span class="math inline">\(N=327\)</span>.</p>
<ul>
<li>At each position, digits <span class="math inline">\({3,4}\)</span> are disallowed unless we are still in leading zeros.</li>
<li>The DP explores all prefixes bounded by <span class="math inline">\(327\)</span> and sums valid completions.</li>
<li>Use the Python snippet to compute the exact count.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-42" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-42">A Gentle Proof (Why It Works)</h4>
<p>Every number in <span class="math inline">\([0,N]\)</span> corresponds to a unique path of digit choices. The predicate allowed<span class="math inline">\((d,leading)\)</span> ensures that once a real digit is placed, it is not forbidden. The pair <span class="math inline">\((pos,tight)\)</span> ensures we do not exceed <span class="math inline">\(N\)</span>. Since subproblems depend only on these three parameters, memoization counts each equivalence class of prefixes exactly once.</p>
</section>
<section id="try-it-yourself-55" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-55">Try It Yourself</h4>
<ol type="1">
<li>Forbid multiple digits, e.g.&nbsp;<span class="math inline">\(F={1,3,7}\)</span>.</li>
<li>Forbid a set that includes <span class="math inline">\(0\)</span> and verify that leading zeros still pass.</li>
<li>Combine with a sum modulo condition by adding a <span class="math inline">\(mod\)</span> state.</li>
<li>Combine with no adjacent duplicates by adding a <span class="math inline">\(prev\)</span> state.</li>
<li>Switch to base <span class="math inline">\(B\)</span> by changing the limit from <span class="math inline">\(9\)</span> to <span class="math inline">\(B-1\)</span>.</li>
</ol>
</section>
<section id="test-cases-55" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-55">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 9%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th><span class="math inline">\(N\)</span></th>
<th><span class="math inline">\(F\)</span></th>
<th>Expected idea</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>99</td>
<td><span class="math inline">\({9}\)</span></td>
<td>Count of two-digit-with-leading-zero numbers using digits 0..8</td>
</tr>
<tr class="even">
<td>327</td>
<td><span class="math inline">\({3,4}\)</span></td>
<td>Computed by code</td>
</tr>
<tr class="odd">
<td>1000</td>
<td><span class="math inline">\({1}\)</span></td>
<td>All numbers without digit 1</td>
</tr>
<tr class="even">
<td>0</td>
<td>any <span class="math inline">\(F\)</span></td>
<td>1 (the number 0)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-55" class="level4">
<h4 class="anchored" data-anchor-id="complexity-55">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(len\cdot 2\cdot 2\cdot 10)\)</span></li>
<li>Space: <span class="math inline">\(O(len\cdot 2\cdot 2)\)</span></li>
</ul>
<p>This pattern is the simplest Digit DP guard: screen digits against a blacklist while handling bounds and leading zeros correctly.</p>
</section>
</section>
<section id="sos-dp-subset-sum" class="level3">
<h3 class="anchored" data-anchor-id="sos-dp-subset-sum">457 SOS DP Subset Sum</h3>
<p>Sum Over Subsets (SOS) DP is a powerful bitmask technique used to precompute values over all subsets of a given mask. One of its core applications is the Subset Sum over bitmasks, efficiently computing <span class="math inline">\(f(S) = \sum_{T \subseteq S} g(T)\)</span> for all <span class="math inline">\(S\)</span>.</p>
<section id="what-problem-are-we-solving-56" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-56">What Problem Are We Solving?</h4>
<p>Given an array <code>g</code> of size <span class="math inline">\(2^n\)</span> indexed by bitmasks, compute a new array <code>f</code> such that:</p>
<p><span class="math display">\[
f[S] = \sum_{T \subseteq S} g[T]
\]</span></p>
<p>A naive approach iterates through all subsets for each <span class="math inline">\(S\)</span>, which takes <span class="math inline">\(O(3^n)\)</span>. SOS DP reduces this to <span class="math inline">\(O(n \cdot 2^n)\)</span>, making it feasible for <span class="math inline">\(n \le 20\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-55" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-55">How Does It Work (Plain Language)</h4>
<p>We treat each bit as a dimension. For each bit position <span class="math inline">\(i\)</span> (from 0 to <span class="math inline">\(n-1\)</span>):</p>
<ul>
<li><p>For each mask <span class="math inline">\(S\)</span>:</p>
<ul>
<li>If bit <span class="math inline">\(i\)</span> is set in <span class="math inline">\(S\)</span>, add contribution from <span class="math inline">\(S\)</span> with bit <span class="math inline">\(i\)</span> cleared.</li>
</ul></li>
</ul>
<p>This accumulates sums over all subsets, one bit at a time.</p>
</section>
<section id="recurrence-1" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-1">Recurrence</h4>
<p>Let <code>f</code> initially equal <code>g</code>. Then:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\text{for } i = 0,\dots,n-1:\\
&amp;\quad \text{for } S = 0,\dots,\ \texttt{(1&lt;&lt;n)}-1:\\
&amp;\quad\quad \text{if } \bigl(S \mathbin{\&amp;} \texttt{(1&lt;&lt;i)}\bigr) \ne 0:\quad
f[S] \mathrel{+}= f\!\left[S^{\text{without } i}\right]
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(S^{\text{without } i} = S \oplus \texttt{(1&lt;&lt;i)}\)</span> removes bit <span class="math inline">\(i\)</span>.</p>
<p>After processing all bits, <code>f[S]</code> holds the sum over all subsets of <span class="math inline">\(S\)</span>.</p>
</section>
<section id="tiny-code-easy-versions-53" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-53">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sos_subset_sum(g, n):</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> g[:]  <span class="co"># copy</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> S <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> n):</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> S <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i):</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>                f[S] <span class="op">+=</span> f[S <span class="op">^</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)]</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]  <span class="co"># g[mask]</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> sos_subset_sum(g, n)</span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(f)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb121"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sos_subset_sum<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> f<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> S <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> S <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">);</span> S<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>S <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">))</span> <span class="op">{</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>                f<span class="op">[</span>S<span class="op">]</span> <span class="op">+=</span> f<span class="op">[</span>S <span class="op">^</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">)];</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> f<span class="op">[</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">};</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>    sos_subset_sum<span class="op">(</span>f<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">);</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st"> "</span><span class="op">,</span> f<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-56" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-56">Why It Matters</h4>
<ul>
<li>Foundation for bitmask DP transforms (e.g.&nbsp;subset convolution, inclusion-exclusion).</li>
<li>Enables fast enumeration of subset properties (sums, counts, etc.).</li>
<li>Reusable building block in probabilistic DP, polynomial transforms, and game DP.</li>
</ul>
</section>
<section id="step-by-step-example-54" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-54">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(n=2\)</span>, masks <span class="math inline">\(00,01,10,11\)</span> and <span class="math inline">\(g=[1,2,3,4]\)</span>:</p>
<p>Initialize <span class="math inline">\(f=g\)</span>.</p>
<ol type="1">
<li><p>Bit <span class="math inline">\(i=0\)</span>:</p>
<ul>
<li><span class="math inline">\(S=01\)</span>: <span class="math inline">\(f[01]+=f[00] \implies 2+1=3\)</span></li>
<li><span class="math inline">\(S=11\)</span>: <span class="math inline">\(f[11]+=f[10] \implies 4+3=7\)</span></li>
</ul></li>
</ol>
<p><span class="math inline">\(f=[1,3,3,7]\)</span></p>
<ol start="2" type="1">
<li><p>Bit <span class="math inline">\(i=1\)</span>:</p>
<ul>
<li><span class="math inline">\(S=10\)</span>: <span class="math inline">\(f[10]+=f[00] \implies 3+1=4\)</span></li>
<li><span class="math inline">\(S=11\)</span>: <span class="math inline">\(f[11]+=f[01] \implies 7+3=10\)</span></li>
</ul></li>
</ol>
<p>Final <span class="math inline">\(f=[1,3,4,10]\)</span></p>
<p>Check:</p>
<ul>
<li><span class="math inline">\(f[11] = g[00]+g[01]+g[10]+g[11] = 1+2+3+4=10\)</span> ✓</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-43" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-43">A Gentle Proof (Why It Works)</h4>
<p>Each bit is processed independently. At iteration <span class="math inline">\(i\)</span>, each mask <span class="math inline">\(S\)</span> accumulates contributions from all subsets differing only at bit <span class="math inline">\(i\)</span>. After processing all bits, every subset <span class="math inline">\(T\subseteq S\)</span> is visited exactly once.</p>
<p>By induction:</p>
<ul>
<li>Base: <span class="math inline">\(i=0\)</span>, <span class="math inline">\(f[S]\)</span> contains <span class="math inline">\(g[S]\)</span>.</li>
<li>Step: adding <span class="math inline">\(f[S^{\text{without }i}]\)</span> ensures inclusion of subsets missing bit <span class="math inline">\(i\)</span>.</li>
</ul>
<p>Thus, after <span class="math inline">\(n\)</span> passes, <span class="math inline">\(f[S]\)</span> sums over all subsets.</p>
</section>
<section id="try-it-yourself-56" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-56">Try It Yourself</h4>
<ol type="1">
<li>Change sum to product (if <span class="math inline">\(f[S]*=f[S^{\text{without }i}]\)</span>).</li>
<li>Compute <span class="math inline">\(f[S]=\sum_{T\supseteq S} g[T]\)</span> (see Superset DP).</li>
<li>Combine SOS DP with inclusion-exclusion to count valid subsets.</li>
<li>Apply to subset convolution problems.</li>
<li>Use modulo arithmetic for large values.</li>
</ol>
</section>
<section id="test-cases-56" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-56">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>g (input)</th>
<th>f (output)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>[1,2,3,4]</td>
<td>[1,3,4,10]</td>
</tr>
<tr class="even">
<td>3</td>
<td>[1,1,1,1,1,1,1,1]</td>
<td>[1,2,2,4,2,4,4,8]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[0,1,2,3,4,5,6,7]</td>
<td>computed by code</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-56" class="level4">
<h4 class="anchored" data-anchor-id="complexity-56">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \cdot 2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(2^n)\)</span></li>
</ul>
<p>SOS DP transforms the exponential subset-sum enumeration into a structured linear pass across dimensions, making subset-based computation tractable for small <span class="math inline">\(n\)</span>.</p>
</section>
</section>
<section id="sos-dp-superset-sum" class="level3">
<h3 class="anchored" data-anchor-id="sos-dp-superset-sum">458 SOS DP Superset Sum</h3>
<p>Sum Over Supersets computes for every mask the aggregate over all of its supersets. It complements the usual SOS DP over subsets.</p>
<section id="what-problem-are-we-solving-57" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-57">What Problem Are We Solving?</h4>
<p>Given an array <code>g</code> of size <span class="math inline">\(2^n\)</span> indexed by bitmasks, compute <code>h</code> such that <span class="math display">\[
h[S]=\sum_{T\supseteq S}g[T].
\]</span> Naively this is <span class="math inline">\(O(3^n)\)</span>. With SOS Superset DP it is <span class="math inline">\(O(n\cdot 2^n)\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-56" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-56">How Does It Work (Plain Language)</h4>
<p>Process bits one by one. For each bit <span class="math inline">\(i\)</span>, if a mask <span class="math inline">\(S\)</span> has bit <span class="math inline">\(i\)</span> unset, then every superset that turns this bit on is of the form <span class="math inline">\(S\cup{i}=S\oplus(1&lt;&lt;i)\)</span>. So we can accumulate from that neighbor upward.</p>
</section>
<section id="recurrence-2" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-2">Recurrence</h4>
<p>Initialize <span class="math inline">\(h = g\)</span>. For each bit <span class="math inline">\(i = 0..n-1\)</span>:</p>
<p>For every mask <span class="math inline">\(S\)</span>:</p>
<p>If <span class="math inline">\((S \mathbin{\&amp;} (1 &lt;&lt; i)) == 0\)</span>, then <span class="math display">\[
    h[S] += h[S \oplus (1 &lt;&lt; i)].
    \]</span> After all bits, <span class="math inline">\(h[S]\)</span> equals the sum over all supersets of <span class="math inline">\(S\)</span>.</p>
</section>
<section id="tiny-code" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code">Tiny Code</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sos_superset_sum(g, n):</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> g[:]  <span class="co"># copy</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> S <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> n):</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (S <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>                h[S] <span class="op">+=</span> h[S <span class="op">|</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)]</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]  <span class="co"># g[mask]</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> sos_superset_sum(g, n)</span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(h)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb123"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sos_superset_sum<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> h<span class="op">[],</span> <span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> S<span class="op">=</span><span class="dv">0</span><span class="op">;</span>S<span class="op">&lt;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>n<span class="op">);</span>S<span class="op">++){</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">((</span>S<span class="op">&amp;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">))==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>                h<span class="op">[</span>S<span class="op">]+=</span>h<span class="op">[</span>S<span class="op">|(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">)];</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">=</span><span class="dv">3</span><span class="op">;</span></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> h<span class="op">[</span><span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">3</span><span class="op">]={</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">};</span></span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a>    sos_superset_sum<span class="op">(</span>h<span class="op">,</span>n<span class="op">);</span></span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>n<span class="op">);</span>i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld</span><span class="st"> "</span><span class="op">,</span> h<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb123-19"><a href="#cb123-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-57" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-57">Why It Matters</h4>
<ul>
<li>Dual of subset SOS DP.</li>
<li>Core for transforms like zeta and Möbius on the subset lattice.</li>
<li>Useful for queries like: for each feature set <span class="math inline">\(S\)</span>, aggregate values over all supersets that contain <span class="math inline">\(S\)</span>.</li>
</ul>
</section>
<section id="step-by-step-example-55" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-55">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(n=2\)</span>, masks <span class="math inline">\(00,01,10,11\)</span> and <span class="math inline">\(g=[1,2,3,4]\)</span>.</p>
<p>Process bit <span class="math inline">\(i=0\)</span>:</p>
<ul>
<li><span class="math inline">\(S=00\)</span>: <span class="math inline">\(h[00]+=h[01]\Rightarrow 1+2=3\)</span></li>
<li><span class="math inline">\(S=10\)</span>: <span class="math inline">\(h[10]+=h[11]\Rightarrow 3+4=7\)</span></li>
</ul>
<p>Now <span class="math inline">\(h=[3,2,7,4]\)</span>.</p>
<p>Process bit <span class="math inline">\(i=1\)</span>:</p>
<ul>
<li><span class="math inline">\(S=00\)</span>: <span class="math inline">\(h[00]+=h[10]\Rightarrow 3+7=10\)</span></li>
<li><span class="math inline">\(S=01\)</span>: <span class="math inline">\(h[01]+=h[11]\Rightarrow 2+4=6\)</span></li>
</ul>
<p>Final <span class="math inline">\(h=[10,6,7,4]\)</span>, which matches</p>
<ul>
<li><span class="math inline">\(h[00]=g[00]+g[01]+g[10]+g[11]=10\)</span></li>
<li><span class="math inline">\(h[01]=g[01]+g[11]=6\)</span></li>
<li><span class="math inline">\(h[10]=g[10]+g[11]=7\)</span></li>
<li><span class="math inline">\(h[11]=g[11]=4\)</span>.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-44" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-44">A Gentle Proof (Why It Works)</h4>
<p>Fix a bit order. When processing bit <span class="math inline">\(i\)</span>, for any <span class="math inline">\(S\)</span> with bit <span class="math inline">\(i\)</span> unset, every superset of <span class="math inline">\(S\)</span> either keeps bit <span class="math inline">\(i\)</span> off or turns it on. Before processing <span class="math inline">\(i\)</span>, <span class="math inline">\(h[S]\)</span> accumulates supersets with bit <span class="math inline">\(i\)</span> off. Adding <span class="math inline">\(h[S\cup{i}]\)</span> brings in all supersets with bit <span class="math inline">\(i\)</span> on. Induct over bits to conclude all supersets are included exactly once.</p>
</section>
<section id="try-it-yourself-57" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-57">Try It Yourself</h4>
<ol type="1">
<li>Convert this to compute maximum over supersets by replacing plus with max.</li>
<li>Combine with subset SOS to precompute both directions for fast subset-superset queries.</li>
<li>Apply modulo arithmetic to prevent overflow.</li>
<li>Implement the Möbius inversion on supersets to invert the transform.</li>
<li>Extend to bitwise operations where aggregation depends on bit counts.</li>
</ol>
</section>
<section id="test-cases-57" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-57">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>g input</th>
<th>h output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>[1,2,3,4]</td>
<td>[10,6,7,4]</td>
</tr>
<tr class="even">
<td>3</td>
<td>all 1s</td>
<td>[8,4,4,2,4,2,2,1]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[0,1,2,3,4,5,6,7]</td>
<td>computed by code</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-57" class="level4">
<h4 class="anchored" data-anchor-id="complexity-57">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n\cdot 2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(2^n)\)</span></li>
</ul>
<p>SOS Superset DP is the natural mirror of subset SOS. Use it whenever queries demand aggregating over all sets that contain a given mask.</p>
</section>
</section>
<section id="xor-basis-dp" class="level3">
<h3 class="anchored" data-anchor-id="xor-basis-dp">459 XOR Basis DP</h3>
<p>The XOR Basis DP technique helps count or generate all possible XOR values from a set of numbers efficiently. It constructs a linear basis over GF(2) and enables solving problems like counting distinct XORs, finding minimum/maximum XOR, and combining with digit DP or bitmask states.</p>
<section id="what-problem-are-we-solving-58" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-58">What Problem Are We Solving?</h4>
<p>Given a list of numbers <span class="math inline">\(A = [a_1, a_2, \dots, a_n]\)</span>, we want to:</p>
<ul>
<li>Find how many distinct XOR values can be formed from subsets of <span class="math inline">\(A\)</span>.</li>
<li>Or find maximum/minimum possible XOR.</li>
<li>Or answer queries on possible XOR combinations.</li>
</ul>
<p>The XOR operation forms a vector space over <span class="math inline">\(\mathbb{F}_2\)</span>, and each number contributes a vector. The XOR basis provides a compact representation of all subset XORs.</p>
</section>
<section id="core-idea" class="level4">
<h4 class="anchored" data-anchor-id="core-idea">Core Idea</h4>
<p>Maintain an array <code>basis</code> representing independent bit vectors. Insert each number into the basis (Gaussian elimination over GF(2)):</p>
<ul>
<li>For each bit from high to low, if that bit is set and not represented, store the number.</li>
<li>If it is already represented, XOR with the current basis vector to reduce it.</li>
</ul>
<p>At the end, the number of independent vectors is the rank <span class="math inline">\(r\)</span>, and the number of distinct XORs is <span class="math inline">\(2^r\)</span>.</p>
</section>
<section id="dp-perspective" class="level4">
<h4 class="anchored" data-anchor-id="dp-perspective">DP Perspective</h4>
<p>The state represents a basis built from a prefix of the array. You can define:</p>
<p><span class="math display">\[
dp[i] = \text{XOR basis after processing first } i \text{ elements}
\]</span></p>
<p>To count distinct XORs after all elements:</p>
<p><span class="math display">\[
\text{count} = 2^{\text{rank}}
\]</span></p>
<p>If you need to build combinations (e.g.&nbsp;count of XOR &lt; M), combine basis construction with digit DP constraints.</p>
</section>
<section id="tiny-code-easy-versions-54" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-54">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> xor_basis(arr):</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    basis <span class="op">=</span> []</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> arr:</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> b <span class="kw">in</span> basis:</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> <span class="bu">min</span>(x, x <span class="op">^</span> b)</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x:</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>            basis.append(x)</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> basis</span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_distinct_xors(arr):</span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>    basis <span class="op">=</span> xor_basis(arr)</span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="bu">len</span>(basis)  <span class="co"># 2^rank</span></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">5</span>]</span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a>basis <span class="op">=</span> xor_basis(A)</span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Basis:"</span>, basis)</span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Distinct XORs:"</span>, count_distinct_xors(A))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb125"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> insert_basis<span class="op">(</span><span class="dt">int</span> basis<span class="op">[],</span> <span class="dt">int</span> <span class="op">*</span>sz<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="op">*</span>sz<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>x <span class="op">^</span> basis<span class="op">[</span>i<span class="op">])</span> <span class="op">&lt;</span> x<span class="op">)</span> x <span class="op">^=</span> basis<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>    basis<span class="op">[(*</span>sz<span class="op">)++]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> basis<span class="op">[</span><span class="dv">32</span><span class="op">],</span> sz <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a>        insert_basis<span class="op">(</span>basis<span class="op">,</span> <span class="op">&amp;</span>sz<span class="op">,</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Rank: </span><span class="sc">%d\n</span><span class="st">Distinct XORs: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> sz<span class="op">,</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> sz<span class="op">);</span></span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-58" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-58">Why It Matters</h4>
<ul>
<li><p>Forms the foundation for subset XOR problems.</p></li>
<li><p>Used in:</p>
<ul>
<li>Counting distinct XORs</li>
<li>Maximum XOR subset</li>
<li>XOR-constrained digit DP</li>
<li>Gaussian elimination in <span class="math inline">\(\mathbb{F}_2\)</span></li>
</ul></li>
</ul>
<p>It’s the bitwise analog of linear algebra, solving over GF(2).</p>
</section>
<section id="step-by-step-example-56" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-56">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(A = [3, 10, 5]\)</span>:</p>
<ul>
<li>Binary: <span class="math inline">\(3=011\)</span>, <span class="math inline">\(10=1010\)</span>, <span class="math inline">\(5=0101\)</span></li>
<li>Insert 3 → basis = {3}</li>
<li>Insert 10 → independent, basis = {3,10}</li>
<li>Insert 5 → can be reduced: <span class="math inline">\(5⊕3=6\)</span>, <span class="math inline">\(6⊕10=12\)</span> → independent, basis = {3,10,5}</li>
</ul>
<p>Rank <span class="math inline">\(r=3\)</span>, number of distinct XORs = <span class="math inline">\(2^3=8\)</span>.</p>
<p>All subset XORs:</p>
<pre><code>0, 3, 5, 6, 10, 11, 12, 15</code></pre>
</section>
<section id="a-gentle-proof-why-it-works-45" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-45">A Gentle Proof (Why It Works)</h4>
<p>Each basis vector represents a new independent bit dimension. Every subset XOR corresponds to a linear combination over <span class="math inline">\(\mathbb{F}_2\)</span> of the basis. If there are <span class="math inline">\(r\)</span> independent vectors, there are <span class="math inline">\(2^r\)</span> possible linear combinations (subsets), hence <span class="math inline">\(2^r\)</span> distinct XORs.</p>
</section>
<section id="try-it-yourself-58" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-58">Try It Yourself</h4>
<ol type="1">
<li>Modify to find maximum XOR subset (XOR greedily from MSB down).</li>
<li>Combine with digit DP to count numbers with XOR constraints (<span class="math inline">\(&lt; M\)</span>).</li>
<li>Track reconstruction: which subset forms a target XOR.</li>
<li>Apply to path XOR queries in trees (via prefix basis merging).</li>
<li>Extend to multiset bases or online updates.</li>
</ol>
</section>
<section id="test-cases-58" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-58">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3,10,5]</td>
<td>8</td>
<td>3 independent vectors</td>
</tr>
<tr class="even">
<td>[1,2,3]</td>
<td>4</td>
<td>Rank = 2</td>
</tr>
<tr class="odd">
<td>[1,1,1]</td>
<td>2</td>
<td>Rank = 1</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-58" class="level4">
<h4 class="anchored" data-anchor-id="complexity-58">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \cdot \text{bitwidth})\)</span></li>
<li>Space: <span class="math inline">\(O(\text{bitwidth})\)</span></li>
</ul>
<p>XOR Basis DP is the digital geometry of sets under XOR, every number a vector, every subset a linear combination, every question a path through binary space.</p>
</section>
</section>
<section id="digit-dp-for-palindromes" class="level3">
<h3 class="anchored" data-anchor-id="digit-dp-for-palindromes">460 Digit DP for Palindromes</h3>
<p>Digit DP for Palindromes counts all numbers within a given range that are palindromic, numbers that read the same forward and backward. It’s a symmetric DP that constructs digits from both ends simultaneously, respecting tight bounds from the original number.</p>
<section id="what-problem-are-we-solving-59" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-59">What Problem Are We Solving?</h4>
<p>Given two integers <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span>, count the palindromes in <span class="math inline">\([L, R]\)</span>.</p>
<p>Example: in <span class="math inline">\([1, 200]\)</span>, palindromes are <span class="math inline">\(1,2,\dots,9,11,22,\dots,99,101,111,\dots,191\)</span>, total 28.</p>
<p>Naively iterating and checking each number is <span class="math inline">\(O(N)\)</span>, which is too slow for large <span class="math inline">\(N\)</span>. We want an <span class="math inline">\(O(d \times 10^{d/2})\)</span> approach using Digit DP with symmetry.</p>
</section>
<section id="core-idea-1" class="level4">
<h4 class="anchored" data-anchor-id="core-idea-1">Core Idea</h4>
<p>We can build a number digit by digit from the outside in, ensuring the number remains a palindrome at each step.</p>
<p>For a given length <span class="math inline">\(len\)</span>, we only need to choose digits for the first half; the second half is determined.</p>
<p>The tight constraints ensure we stay <span class="math inline">\(\le R\)</span> (or <span class="math inline">\(\le L-1\)</span> for inclusive ranges).</p>
</section>
<section id="dp-definition" class="level4">
<h4 class="anchored" data-anchor-id="dp-definition">DP Definition</h4>
<p>Let <span class="math inline">\(S\)</span> = digits of <span class="math inline">\(N\)</span>, length <span class="math inline">\(len\)</span>.</p>
<p>State: <span class="math display">\[
dp[pos][tight][leading]
\]</span></p>
<p>Where:</p>
<ul>
<li><code>pos</code> is the current index from the left half (<span class="math inline">\(0 \le pos &lt; \frac{len}{2}\)</span>)</li>
<li><code>tight</code> means prefix equals <span class="math inline">\(N\)</span> so far</li>
<li><code>leading</code> means we’ve placed only leading zeros</li>
</ul>
<p>The recursion places one digit at <code>pos</code>, mirrors it at <code>len-1-pos</code>, and recurses inward.</p>
</section>
<section id="transition-4" class="level4">
<h4 class="anchored" data-anchor-id="transition-4">Transition</h4>
<p>For each <code>digit</code> in <span class="math inline">\([0, limit]\)</span>:</p>
<ul>
<li>If <code>leading</code> and <code>digit==0</code>, we can skip counting it as a real digit.</li>
<li>Mirror digit into the symmetric position.</li>
<li>Update tightness if <code>digit == limit</code>.</li>
<li>Recurse inward until halfway.</li>
</ul>
<p>When reaching middle, count 1 valid palindrome.</p>
</section>
<section id="algorithm-outline" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-outline">Algorithm Outline</h4>
<p>To count palindromes ≤ <span class="math inline">\(N\)</span>:</p>
<ol type="1">
<li>Convert <span class="math inline">\(N\)</span> to string <code>S</code></li>
<li>Run <code>dfs(pos=0, tight=True, leading=True)</code></li>
<li>If building full palindrome (not half-only), check mirrored structure</li>
</ol>
<p>Count in <span class="math inline">\([L, R]\)</span> as: <span class="math display">\[
f(R) - f(L-1)
\]</span></p>
</section>
<section id="tiny-code-easy-versions-55" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-55">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_palindromes_upto(N):</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">str</span>(N)))</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(S)</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">@lru_cache</span>(<span class="va">None</span>)</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(pos, tight, leading, half):</span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span>:</span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span>  <span class="co"># one palindrome formed</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>        limit <span class="op">=</span> S[pos] <span class="cf">if</span> tight <span class="cf">else</span> <span class="dv">9</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(limit <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> leading <span class="kw">and</span> d <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>                total <span class="op">+=</span> dfs(pos <span class="op">+</span> <span class="dv">1</span>, tight <span class="kw">and</span> d <span class="op">==</span> limit, <span class="va">True</span>, half <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>                total <span class="op">+=</span> dfs(pos <span class="op">+</span> <span class="dv">1</span>, tight <span class="kw">and</span> d <span class="op">==</span> limit, <span class="va">False</span>, half <span class="op">+</span> [d])</span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(<span class="dv">0</span>, <span class="va">True</span>, <span class="va">True</span>, ())</span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-22"><a href="#cb127-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_palindromes(L, R):</span>
<span id="cb127-23"><a href="#cb127-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_palindromes_upto(R) <span class="op">-</span> count_palindromes_upto(L <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb127-24"><a href="#cb127-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-25"><a href="#cb127-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb127-26"><a href="#cb127-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_palindromes(<span class="dv">1</span>, <span class="dv">200</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (half-construction)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb128"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> count_palindromes_upto<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> s<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>    sprintf<span class="op">(</span>s<span class="op">,</span> <span class="st">"</span><span class="sc">%lld</span><span class="st">"</span><span class="op">,</span> N<span class="op">);</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> half <span class="op">=</span> <span class="op">(</span>len <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build prefix half and mirror</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>half <span class="op">*</span> <span class="dv">4</span><span class="op">));</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Conceptual only, use recursion or base-10 enumeration for actual code</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Simpler approach: iterate half, build full palindrome, check ≤ N</span></span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> start <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> len<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb128-20"><a href="#cb128-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> half_len <span class="op">=</span> <span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb128-21"><a href="#cb128-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> base <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb128-22"><a href="#cb128-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> half_len<span class="op">;</span> j<span class="op">++)</span> base <span class="op">*=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb128-23"><a href="#cb128-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> x <span class="op">=</span> base<span class="op">;</span> x <span class="op">&lt;</span> base <span class="op">*</span> <span class="dv">10</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb128-24"><a href="#cb128-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">long</span> <span class="dt">long</span> y <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb128-25"><a href="#cb128-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span><span class="op">)</span> y <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb128-26"><a href="#cb128-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">long</span> <span class="dt">long</span> z <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb128-27"><a href="#cb128-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb128-28"><a href="#cb128-28" aria-hidden="true" tabindex="-1"></a>                z <span class="op">=</span> z <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> <span class="op">(</span>y <span class="op">%</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb128-29"><a href="#cb128-29" aria-hidden="true" tabindex="-1"></a>                y <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb128-30"><a href="#cb128-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb128-31"><a href="#cb128-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>z <span class="op">&lt;=</span> N<span class="op">)</span> count<span class="op">++;</span></span>
<span id="cb128-32"><a href="#cb128-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb128-33"><a href="#cb128-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb128-34"><a href="#cb128-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb128-35"><a href="#cb128-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb128-36"><a href="#cb128-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-37"><a href="#cb128-37" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb128-38"><a href="#cb128-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> L <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> R <span class="op">=</span> <span class="dv">200</span><span class="op">;</span></span>
<span id="cb128-39"><a href="#cb128-39" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> count_palindromes_upto<span class="op">(</span>R<span class="op">)</span> <span class="op">-</span> count_palindromes_upto<span class="op">(</span>L <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb128-40"><a href="#cb128-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-59" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-59">Why It Matters</h4>
<ul>
<li><p>Palindromic counting appears in:</p>
<ul>
<li>Digit constraints (e.g.&nbsp;special number sets)</li>
<li>Symmetric number combinatorics</li>
<li>Patterned sequence generation</li>
</ul></li>
<li><p>Builds intuition for bidirectional DP where digits mirror.</p></li>
</ul>
</section>
<section id="step-by-step-example-57" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-57">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(N = 200\)</span>:</p>
<ul>
<li>Length 3 → half = 2</li>
<li>Choose first half (00–19), mirror → <code>00–99</code> → <code>0,11,22,...,191</code></li>
<li>Apply bounds: only ≤200 → count = 28</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-46" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-46">A Gentle Proof (Why It Works)</h4>
<p>Every palindrome is uniquely determined by its first half. For each valid half respecting the upper bound, exactly one mirrored number exists. Tightness ensures no overflow beyond <span class="math inline">\(N\)</span>. Leading-zero handling ensures numbers like <code>00100</code> are excluded.</p>
</section>
<section id="try-it-yourself-59" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-59">Try It Yourself</h4>
<ol type="1">
<li>Count even-length palindromes only.</li>
<li>Count palindromes with a fixed digit sum.</li>
<li>Modify to count palindromic primes by adding primality check.</li>
<li>Combine with digit constraints (e.g.&nbsp;no 3s).</li>
<li>Count numbers that become palindromes after reversal operations.</li>
</ol>
</section>
<section id="test-cases-59" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-59">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>L</th>
<th>R</th>
<th>Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>9</td>
<td>9</td>
<td>Single-digit palindromes</td>
</tr>
<tr class="even">
<td>10</td>
<td>99</td>
<td>9</td>
<td>11,22,…,99</td>
</tr>
<tr class="odd">
<td>1</td>
<td>200</td>
<td>28</td>
<td>Up to 191</td>
</tr>
<tr class="even">
<td>100</td>
<td>999</td>
<td>90</td>
<td>All 3-digit palindromes</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-59" class="level4">
<h4 class="anchored" data-anchor-id="complexity-59">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(d \times 10^{d/2})\)</span></li>
<li>Space: <span class="math inline">\(O(d)\)</span></li>
</ul>
<p>Digit DP for Palindromes bridges arithmetic and symmetry, constructing mirrored structures digit by digit under bound constraints.</p>
</section>
</section>
</section>
<section id="section-47.-dp-optimizations" class="level1">
<h1>Section 47. DP Optimizations</h1>
<section id="divide-conquer-dp-monotone-optimization" class="level3">
<h3 class="anchored" data-anchor-id="divide-conquer-dp-monotone-optimization">461 Divide &amp; Conquer DP (Monotone Optimization)</h3>
<p>When a DP transition is a 1D convolution of the form <span class="math inline">\(dp[i][j]=\min\limits_{k&lt;j}\big(dp[i-1][k]+C(k,j)\big)\)</span>, and the argmin is monotone (<span class="math inline">\(opt[i][j]\le opt[i][j+1]\)</span>), you can compute a whole layer <span class="math inline">\(dp[i][*]\)</span> in <span class="math inline">\(O(n)\)</span> splits with divide and conquer instead of <span class="math inline">\(O(n^2)\)</span>. Typical total is <span class="math inline">\(O(K,n\log n)\)</span> or <span class="math inline">\(O(K,n)\)</span> depending on implementation.</p>
<section id="what-problem-are-we-solving-60" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-60">What Problem Are We Solving?</h4>
<p>Speed up DP layers with transitions <span class="math display">\[
dp[j]=\min_{k&lt;j}\big(prev[k]+C(k,j)\big),
\]</span> for <span class="math inline">\(j\)</span> in an interval, where the optimal index <span class="math inline">\(opt[j]\in[\text{optL},\text{optR}]\)</span> and satisfies <span class="math display">\[
opt[j]\le opt[j+1]\quad\text{(monotone decision property).}
\]</span></p>
<p>This structure appears in:</p>
<ul>
<li><span class="math inline">\(K\)</span>-partitioning of arrays with convex segment cost</li>
<li>1D facility placement and line breaking with convex penalties</li>
<li>Some shortest path on DAG layers with convex arc costs</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-57" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-57">How Does It Work (Plain Language)</h4>
<p>Compute the current DP layer on a segment <span class="math inline">\([L,R]\)</span> by solving the midpoint <span class="math inline">\(M\)</span>, searching its best <span class="math inline">\(k\)</span> only in <span class="math inline">\([optL,optR]\)</span>. The best index <span class="math inline">\(opt[M]\)</span> splits the problem:</p>
<ul>
<li>Left half <span class="math inline">\([L,M-1]\)</span> only needs candidates in <span class="math inline">\([optL,opt[M]]\)</span></li>
<li>Right half <span class="math inline">\([M+1,R]\)</span> only needs <span class="math inline">\([opt[M],optR]\)</span></li>
</ul>
<p>Recursively repeat until intervals are size 1. Monotonicity guarantees these candidate ranges.</p>
</section>
<section id="preconditions-checklist" class="level4">
<h4 class="anchored" data-anchor-id="preconditions-checklist">Preconditions checklist</h4>
<p>You can use divide and conquer DP if:</p>
<ol type="1">
<li>Transition is <span class="math inline">\(dp[j]=\min_{k&lt;j}(prev[k]+C(k,j))\)</span>.</li>
<li>The optimal index is monotone in <span class="math inline">\(j\)</span>. A sufficient condition is quadrangle inequality or Monge property of <span class="math inline">\(C\)</span>: <span class="math display">\[
C(a,c)+C(b,d)\le C(a,d)+C(b,c)\quad\text{for }a\le b\le c\le d.
\]</span></li>
</ol>
</section>
<section id="tiny-code-template" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-template">Tiny Code (Template)</h4>
<p>C++ style pseudocode (drop in C with minor edits)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb129"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Compute one layer dp_cur[lo..hi], given dp_prev and cost C(k,j).</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Assumes optimal indices are monotone.</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compute<span class="op">(</span><span class="dt">int</span> lo<span class="op">,</span> <span class="dt">int</span> hi<span class="op">,</span> <span class="dt">int</span> optL<span class="op">,</span> <span class="dt">int</span> optR<span class="op">,</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;&amp;</span> dp_prev<span class="op">,</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>             vector<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;&amp;</span> dp_cur<span class="op">,</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>             <span class="kw">auto</span><span class="op">&amp;&amp;</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>lo <span class="op">&gt;</span> hi<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>lo <span class="op">+</span> hi<span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> best <span class="op">=</span> LLONG_MAX<span class="op">;</span></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best_k <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> start <span class="op">=</span> optL<span class="op">,</span> end <span class="op">=</span> min<span class="op">(</span>optR<span class="op">,</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> start<span class="op">;</span> k <span class="op">&lt;=</span> end<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> val <span class="op">=</span> dp_prev<span class="op">[</span>k<span class="op">]</span> <span class="op">+</span> cost<span class="op">(</span>k<span class="op">,</span> mid<span class="op">);</span></span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;</span> best<span class="op">)</span> <span class="op">{</span></span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a>            best_k <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb129-18"><a href="#cb129-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb129-19"><a href="#cb129-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb129-20"><a href="#cb129-20" aria-hidden="true" tabindex="-1"></a>    dp_cur<span class="op">[</span>mid<span class="op">]</span> <span class="op">=</span> best<span class="op">;</span></span>
<span id="cb129-21"><a href="#cb129-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-22"><a href="#cb129-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recurse with narrowed opt ranges</span></span>
<span id="cb129-23"><a href="#cb129-23" aria-hidden="true" tabindex="-1"></a>    compute<span class="op">(</span>lo<span class="op">,</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> optL<span class="op">,</span> best_k<span class="op">,</span> dp_prev<span class="op">,</span> dp_cur<span class="op">,</span> cost<span class="op">);</span></span>
<span id="cb129-24"><a href="#cb129-24" aria-hidden="true" tabindex="-1"></a>    compute<span class="op">(</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> hi<span class="op">,</span> best_k<span class="op">,</span> optR<span class="op">,</span> dp_prev<span class="op">,</span> dp_cur<span class="op">,</span> cost<span class="op">);</span></span>
<span id="cb129-25"><a href="#cb129-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (clear and compact)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1018</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute(lo, hi, optL, optR, dp_prev, dp_cur, cost):</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> lo <span class="op">&gt;</span> hi:</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (lo <span class="op">+</span> hi) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>    best_val, best_k <span class="op">=</span> INF, <span class="op">-</span><span class="dv">1</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> <span class="bu">min</span>(optR, mid <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(optL, end <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> dp_prev[k] <span class="op">+</span> cost(k, mid)</span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">&lt;</span> best_val:</span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a>            best_val, best_k <span class="op">=</span> v, k</span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a>    dp_cur[mid] <span class="op">=</span> best_val</span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>    compute(lo, mid <span class="op">-</span> <span class="dv">1</span>, optL, best_k, dp_prev, dp_cur, cost)</span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a>    compute(mid <span class="op">+</span> <span class="dv">1</span>, hi, best_k, optR, dp_prev, dp_cur, cost)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>How to use For <span class="math inline">\(i=1..K\)</span>: call <code>compute(1,n,0,n-1, dp_prev, dp_cur, cost)</code> then swap layers. Index ranges depend on your base cases.</p>
</section>
<section id="example-k-partitions-with-convex-segment-cost" class="level4">
<h4 class="anchored" data-anchor-id="example-k-partitions-with-convex-segment-cost">Example: K partitions with convex segment cost</h4>
<p>Given array <span class="math inline">\(a[1..n]\)</span>, let prefix sums <span class="math inline">\(S[j]=\sum_{t=1}^j a[t]\)</span>. Suppose segment cost is <span class="math display">\[
C(k,j)=\big(S[j]-S[k]\big)^2,
\]</span> which is convex and satisfies quadrangle inequality. The DP <span class="math display">\[
dp[i][j]=\min_{k&lt;j}\big(dp[i-1][k]+C(k,j)\big)
\]</span> has monotone argmins, so one layer can be computed with the template. Total roughly <span class="math inline">\(O(K,n\log n)\)</span>.</p>
</section>
<section id="why-it-matters-60" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-60">Why It Matters</h4>
<ul>
<li>Cuts a quadratic DP layer down to near linear</li>
<li>Simple to implement compared to more advanced tricks</li>
<li>Pairs well with prefix sums for <span class="math inline">\(C(k,j)\)</span> evaluation</li>
<li>Core technique in editors line breaking, clustering in 1D, histogram smoothing</li>
</ul>
</section>
<section id="step-by-step-on-a-small-instance" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-on-a-small-instance">Step by Step on a small instance</h4>
<p>Let <span class="math inline">\(a=[1,3,2,4]\)</span>, <span class="math inline">\(K=2\)</span>, <span class="math inline">\(C(k,j)=(S[j]-S[k])^2\)</span>.</p>
<ol type="1">
<li>Initialize <span class="math inline">\(dp[0][0]=0\)</span>, <span class="math inline">\(dp[0][j&gt;0]=+\infty\)</span>.</li>
<li>Layer <span class="math inline">\(i=1\)</span>: compute <span class="math inline">\(dp[1][j]\)</span> by scanning <span class="math inline">\(k&lt;j\)</span>. Argmins are nondecreasing.</li>
<li>Layer <span class="math inline">\(i=2\)</span>: call <code>compute(1,n,0,n-1, ...)</code>. The recursion halves the target interval and narrows candidate <span class="math inline">\(k\)</span> ranges by monotonicity.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-47" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-47">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(opt[j]\)</span> be a minimizer for <span class="math inline">\(dp[j]\)</span>. If <span class="math inline">\(C\)</span> is Monge, then for <span class="math inline">\(x&lt;y\)</span> and <span class="math inline">\(u&lt;v\)</span>: <span class="math display">\[
C(u,x)+C(v,y)\le C(u,y)+C(v,x).
\]</span> Assume by contradiction <span class="math inline">\(opt[x]&gt;opt[y]\)</span>. Using optimality of those indices and the inequality above yields a contradiction. Hence <span class="math inline">\(opt\)</span> is nondecreasing.</p>
<p>The recursion evaluates <span class="math inline">\(dp[mid]\)</span> using candidates in <span class="math inline">\([optL,optR]\)</span>. The found <span class="math inline">\(opt[mid]\)</span> splits feasible candidates:</p>
<ul>
<li>Any optimal index for <span class="math inline">\(j&lt;mid\)</span> is in <span class="math inline">\([optL,opt[mid]]\)</span></li>
<li>Any optimal index for <span class="math inline">\(j&gt;mid\)</span> is in <span class="math inline">\([opt[mid],optR]\)</span> Induct over segments to show each <span class="math inline">\(dp[j]\)</span> is computed with exactly the needed candidate set and no essential candidate is excluded.</li>
</ul>
</section>
<section id="try-it-yourself-60" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-60">Try It Yourself</h4>
<ol type="1">
<li>Replace <span class="math inline">\(C(k,j)\)</span> by <span class="math inline">\(\alpha,(S[j]-S[k])^2+\beta,(j-k)\)</span> and verify monotonicity still holds.</li>
<li>Use the template to speed up line breaking with raggedness penalty.</li>
<li>Benchmark naive <span class="math inline">\(O(n^2)\)</span> vs divide and conquer on random convex costs.</li>
<li>Combine with space optimization by keeping only two layers.</li>
<li>Contrast with Knuth optimization and Convex Hull Trick and decide which applies for your cost.</li>
</ol>
</section>
<section id="test-cases-60" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-60">Test Cases</h4>
<ul>
<li><p>Small convex cost:</p>
<ul>
<li><span class="math inline">\(a=[2,1,3], K=2\)</span>, <span class="math inline">\(C(k,j)=(S[j]-S[k])^2\)</span></li>
<li>Compare naive and D&amp;C outputs, they must match.</li>
</ul></li>
<li><p>Linear plus convex mix:</p>
<ul>
<li><span class="math inline">\(a=[1,1,1,1], K=3\)</span>, <span class="math inline">\(C(k,j)=(S[j]-S[k])^2+(j-k)\)</span></li>
</ul></li>
<li><p>Edge cases:</p>
<ul>
<li><span class="math inline">\(n=1\)</span> any <span class="math inline">\(K\ge1\)</span></li>
<li>All zeros array, any <span class="math inline">\(K\)</span></li>
</ul></li>
</ul>
</section>
<section id="complexity-60" class="level4">
<h4 class="anchored" data-anchor-id="complexity-60">Complexity</h4>
<ul>
<li>One layer with divide and conquer: <span class="math inline">\(O(n\log n)\)</span> evaluations of <span class="math inline">\(C\)</span> in the simple form, often written as <span class="math inline">\(O(n)\)</span> splits with logarithmic recursion depth.</li>
<li>Full DP: <span class="math inline">\(O(K,n\log n)\)</span> time, <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(K,n)\)</span> space depending on whether you store all layers.</li>
</ul>
<p>Divide and conquer DP is your go to when the argmin slides to the right as <span class="math inline">\(j\)</span> grows. It is small code, big speedup.</p>
</section>
</section>
<section id="knuth-optimization" class="level3">
<h3 class="anchored" data-anchor-id="knuth-optimization">462 Knuth Optimization</h3>
<p>Knuth Optimization is a special-case speedup for certain DP transitions where quadrangle inequality and monotonicity of optimal decisions hold. It improves <span class="math inline">\(O(n^2)\)</span> dynamic programs to <span class="math inline">\(O(n)\)</span> per layer, often used in optimal binary search tree, matrix chain, and interval partitioning problems.</p>
<section id="what-problem-are-we-solving-61" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-61">What Problem Are We Solving?</h4>
<p>We want to optimize DP recurrences of the form: <span class="math display">\[
dp[i][j] = \min_{k \in [i, j-1]} \big(dp[i][k] + dp[k+1][j] + C(i, j)\big)
\]</span> for <span class="math inline">\(1 \le i \le j \le n\)</span>, where <span class="math inline">\(C(i,j)\)</span> is a cost function satisfying quadrangle inequality.</p>
<p>Naively, this is <span class="math inline">\(O(n^3)\)</span>. With Knuth optimization, we cut it to <span class="math inline">\(O(n^2)\)</span> by restricting the search range using a monotonic property of the optimal split point.</p>
</section>
<section id="key-condition" class="level4">
<h4 class="anchored" data-anchor-id="key-condition">Key Condition</h4>
<p>Knuth optimization applies when:</p>
<ol type="1">
<li>Quadrangle Inequality: <span class="math display">\[
C(a, c) + C(b, d) \le C(a, d) + C(b, c), \quad \forall a \le b \le c \le d
\]</span></li>
<li>Monotonicity of Argmin: <span class="math display">\[
opt[i][j-1] \le opt[i][j] \le opt[i+1][j]
\]</span> These ensure that the optimal split <span class="math inline">\(k\)</span> for <span class="math inline">\([i,j]\)</span> moves rightward as intervals slide.</li>
</ol>
</section>
<section id="how-does-it-work-plain-language-58" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-58">How Does It Work (Plain Language)</h4>
<p>When computing <span class="math inline">\(dp[i][j]\)</span>, the best partition point <span class="math inline">\(k\)</span> lies between <span class="math inline">\(opt[i][j-1]\)</span> and <span class="math inline">\(opt[i+1][j]\)</span>. So instead of scanning the full <span class="math inline">\([i, j-1]\)</span>, we limit to a narrow window. This reduces work from <span class="math inline">\(O(n^3)\)</span> to <span class="math inline">\(O(n^2)\)</span>.</p>
<p>We fill intervals in increasing length order, maintaining and reusing <code>opt[i][j]</code>.</p>
</section>
<section id="step-by-step-recurrence" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-recurrence">Step-by-Step Recurrence</h4>
<p>For all <span class="math inline">\(i\)</span>: <span class="math display">\[
dp[i][i] = 0
\]</span></p>
<p>Then for lengths <span class="math inline">\(len = 2..n\)</span>:</p>
<pre class="text"><code>for i in 1..n-len+1:
    j = i + len - 1
    dp[i][j] = ∞
    for k in opt[i][j-1]..opt[i+1][j]:
        val = dp[i][k] + dp[k+1][j] + C(i,j)
        if val &lt; dp[i][j]:
            dp[i][j] = val
            opt[i][j] = k</code></pre>
</section>
<section id="tiny-code-easy-versions-56" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-56">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1018</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> knuth_optimization(n, cost):</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    opt <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>        opt[i][i] <span class="op">=</span> i</span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n<span class="op">-</span>length<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> INF</span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>            start <span class="op">=</span> opt[i][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> opt[i<span class="op">+</span><span class="dv">1</span>][j] <span class="cf">if</span> i<span class="op">+</span><span class="dv">1</span> <span class="op">&lt;=</span> j <span class="cf">else</span> j<span class="op">-</span><span class="dv">1</span></span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(start, end<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>                val <span class="op">=</span> dp[i][k] <span class="op">+</span> dp[k<span class="op">+</span><span class="dv">1</span>][j] <span class="op">+</span> cost(i, j)</span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> val <span class="op">&lt;</span> dp[i][j]:</span>
<span id="cb132-19"><a href="#cb132-19" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">=</span> val</span>
<span id="cb132-20"><a href="#cb132-20" aria-hidden="true" tabindex="-1"></a>                    opt[i][j] <span class="op">=</span> k</span>
<span id="cb132-21"><a href="#cb132-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb133"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000000000</span><span class="bu">LL</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">505</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>N<span class="op">][</span>N<span class="op">],</span> opt<span class="op">[</span>N<span class="op">][</span>N<span class="op">];</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> cost<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">);</span> <span class="co">// user-defined cost function</span></span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> knuth<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a>        opt<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb133-17"><a href="#cb133-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb133-18"><a href="#cb133-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb133-19"><a href="#cb133-19" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb133-20"><a href="#cb133-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> start <span class="op">=</span> opt<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb133-21"><a href="#cb133-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> end <span class="op">=</span> opt<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb133-22"><a href="#cb133-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>end <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> end <span class="op">=</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb133-23"><a href="#cb133-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>start <span class="op">&gt;</span> end<span class="op">)</span> <span class="op">{</span> <span class="dt">int</span> tmp <span class="op">=</span> start<span class="op">;</span> start <span class="op">=</span> end<span class="op">;</span> end <span class="op">=</span> tmp<span class="op">;</span> <span class="op">}</span></span>
<span id="cb133-24"><a href="#cb133-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> start<span class="op">;</span> k <span class="op">&lt;=</span> end<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb133-25"><a href="#cb133-25" aria-hidden="true" tabindex="-1"></a>                <span class="dt">long</span> <span class="dt">long</span> val <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>k<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> cost<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb133-26"><a href="#cb133-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb133-27"><a href="#cb133-27" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb133-28"><a href="#cb133-28" aria-hidden="true" tabindex="-1"></a>                    opt<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb133-29"><a href="#cb133-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb133-30"><a href="#cb133-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb133-31"><a href="#cb133-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb133-32"><a href="#cb133-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb133-33"><a href="#cb133-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb133-34"><a href="#cb133-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-61" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-61">Why It Matters</h4>
<p>Knuth Optimization turns a cubic DP into quadratic without approximations. It’s especially useful for:</p>
<ul>
<li>Optimal Binary Search Trees (OBST)</li>
<li>Matrix Chain Multiplication</li>
<li>Merging Stones / File Merging</li>
<li>Bracket Parsing / Partitioning</li>
</ul>
<p>It’s a precise algebraic optimization based on Monge arrays and convexity.</p>
</section>
<section id="step-by-step-example-58" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-58">Step-by-Step Example</h4>
<p>Consider merging files with sizes <span class="math inline">\([10,20,30]\)</span>. <span class="math inline">\(C(i,j)=\text{sum of file sizes from i to j}\)</span>. We fill <span class="math inline">\(dp[i][j]\)</span> with minimal total cost of merging segment <span class="math inline">\([i..j]\)</span>. Argmins move monotonically, so Knuth optimization applies.</p>
</section>
<section id="a-gentle-proof-why-it-works-48" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-48">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(C\)</span> satisfies quadrangle inequality: <span class="math display">\[
C(a, c) + C(b, d) \le C(a, d) + C(b, c),
\]</span> then combining two adjacent subproblems will never cause the optimal cut to move left. Hence, <span class="math inline">\(opt[i][j-1] \le opt[i][j] \le opt[i+1][j]\)</span>. Thus, restricting the search range preserves correctness while cutting redundant checks.</p>
</section>
<section id="try-it-yourself-61" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-61">Try It Yourself</h4>
<ol type="1">
<li>Apply Knuth optimization to Optimal BST: <span class="math display">\[
dp[i][j]=\min_{k\in[i,j]}(dp[i][k-1]+dp[k+1][j]+w[i][j])
\]</span></li>
<li>Use it in Merging Stones (sum-cost merge).</li>
<li>Compare with Divide &amp; Conquer DP, both need monotonicity, but Knuth’s has fixed quadratic structure.</li>
<li>Verify monotonicity by printing <span class="math inline">\(opt[i][j]\)</span>.</li>
<li>Prove <span class="math inline">\(C(i,j)=\text{prefix}[j]-\text{prefix}[i-1]\)</span> satisfies the condition.</li>
</ol>
</section>
<section id="test-cases-61" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-61">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Description</th>
<th>Expected Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>File merging</td>
<td>[10, 20, 30]</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="even">
<td>Optimal BST</td>
<td>Sorted keys, frequencies</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="odd">
<td>Merging Stones</td>
<td>Equal weights</td>
<td>Monotone <span class="math inline">\(opt\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-61" class="level4">
<h4 class="anchored" data-anchor-id="complexity-61">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2)\)</span></li>
<li>Space: <span class="math inline">\(O(n^2)\)</span></li>
</ul>
<p>Knuth Optimization is the elegant midpoint between full DP and convexity tricks, precise, predictable, and optimal whenever cost satisfies Monge structure.</p>
</section>
</section>
<section id="convex-hull-trick-cht" class="level3">
<h3 class="anchored" data-anchor-id="convex-hull-trick-cht">463 Convex Hull Trick (CHT)</h3>
<p>The Convex Hull Trick speeds up DP transitions of the form <span class="math display">\[
dp[i] = \min_{k&lt;i}\big(dp[k] + m_k \cdot x_i + b_k\big)
\]</span> when the slopes <span class="math inline">\(m_k\)</span> are monotonic (increasing or decreasing) and the <span class="math inline">\(x_i\)</span> queries are also monotonic. It replaces <span class="math inline">\(O(n^2)\)</span> scanning with <span class="math inline">\(O(n)\)</span> amortized or <span class="math inline">\(O(\log n)\)</span> query time using a dynamic hull.</p>
<section id="what-problem-are-we-solving-62" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-62">What Problem Are We Solving?</h4>
<p>We have a DP recurrence like: <span class="math display">\[
dp[i] = \min_{k &lt; i}\big(dp[k] + m_k \cdot x_i + b_k\big)
\]</span> where:</p>
<ul>
<li><span class="math inline">\(m_k\)</span> (slope) and <span class="math inline">\(b_k\)</span> (intercept) define lines,</li>
<li><span class="math inline">\(x_i\)</span> is the query coordinate,</li>
<li>we want the minimum (or maximum) value over all <span class="math inline">\(k\)</span>.</li>
</ul>
<p>This appears in:</p>
<ul>
<li>Line DP (e.g.&nbsp;segmented linear costs),</li>
<li>Divide and Conquer DP (convex variant),</li>
<li>Knuth-like DPs with linear penalties,</li>
<li>Aliens trick and Li Chao Trees for non-monotone cases.</li>
</ul>
</section>
<section id="when-it-applies" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies">When It Applies</h4>
<ol type="1">
<li>Transition fits <span class="math inline">\(dp[i] = \min_k(dp[k] + m_k x_i + b_k)\)</span></li>
<li><span class="math inline">\(m_k\)</span>’s are monotonic (non-decreasing or non-increasing)</li>
<li><span class="math inline">\(x_i\)</span> queries are sorted (non-decreasing)</li>
</ol>
<p>Then you can use a deque-based CHT for <span class="math inline">\(O(1)\)</span> amortized per insertion/query.</p>
<p>If slopes or queries are not monotonic, use Li Chao Tree (next algorithm).</p>
</section>
<section id="how-does-it-work-plain-language-59" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-59">How Does It Work (Plain Language)</h4>
<p>Each <span class="math inline">\(k\)</span> defines a line <span class="math inline">\(y = m_k x + b_k\)</span>. The DP asks: for current <span class="math inline">\(x_i\)</span>, which previous line gives the smallest value? All lines together form a lower envelope, a piecewise minimum curve. We maintain this hull incrementally and query the minimum efficiently.</p>
<p>If slopes are sorted, each new line intersects the previous hull at one point, and old lines become useless after their intersection point.</p>
</section>
<section id="tiny-code-easy-versions-57" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-57">Tiny Code (Easy Versions)</h4>
<p>Python (Monotone CHT)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CHT:</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lines <span class="op">=</span> []  <span class="co"># (m, b)</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> bad(<span class="va">self</span>, l1, l2, l3):</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if l2 is unnecessary between l1 and l3</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (l3[<span class="dv">1</span>] <span class="op">-</span> l1[<span class="dv">1</span>]) <span class="op">*</span> (l1[<span class="dv">0</span>] <span class="op">-</span> l2[<span class="dv">0</span>]) <span class="op">&lt;=</span> (l2[<span class="dv">1</span>] <span class="op">-</span> l1[<span class="dv">1</span>]) <span class="op">*</span> (l1[<span class="dv">0</span>] <span class="op">-</span> l3[<span class="dv">0</span>])</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, m, b):</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lines.append((m, b))</span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(<span class="va">self</span>.lines) <span class="op">&gt;=</span> <span class="dv">3</span> <span class="kw">and</span> <span class="va">self</span>.bad(<span class="va">self</span>.lines[<span class="op">-</span><span class="dv">3</span>], <span class="va">self</span>.lines[<span class="op">-</span><span class="dv">2</span>], <span class="va">self</span>.lines[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.lines.pop(<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> query(<span class="va">self</span>, x):</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># queries x in increasing order</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(<span class="va">self</span>.lines) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>              <span class="va">self</span>.lines[<span class="dv">0</span>][<span class="dv">0</span>]<span class="op">*</span>x <span class="op">+</span> <span class="va">self</span>.lines[<span class="dv">0</span>][<span class="dv">1</span>] <span class="op">&gt;=</span> <span class="va">self</span>.lines[<span class="dv">1</span>][<span class="dv">0</span>]<span class="op">*</span>x <span class="op">+</span> <span class="va">self</span>.lines[<span class="dv">1</span>][<span class="dv">1</span>]:</span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.lines.pop(<span class="dv">0</span>)</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>        m, b <span class="op">=</span> <span class="va">self</span>.lines[<span class="dv">0</span>]</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> m<span class="op">*</span>x <span class="op">+</span> b</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: dp[i] = min(dp[k] + m[k]*x[i] + b[k])</span></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span><span class="dv">5</span></span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true" tabindex="-1"></a>cht <span class="op">=</span> CHT()</span>
<span id="cb134-29"><a href="#cb134-29" aria-hidden="true" tabindex="-1"></a>cht.add(m[<span class="dv">0</span>], b[<span class="dv">0</span>])</span>
<span id="cb134-30"><a href="#cb134-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">5</span>):</span>
<span id="cb134-31"><a href="#cb134-31" aria-hidden="true" tabindex="-1"></a>    dp[i] <span class="op">=</span> cht.query(x[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb134-32"><a href="#cb134-32" aria-hidden="true" tabindex="-1"></a>    cht.add(m[i], dp[i] <span class="op">+</span> b[i])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (Deque Implementation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb135"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">long</span> <span class="dt">long</span> m<span class="op">,</span> b<span class="op">;</span> <span class="op">}</span> Line<span class="op">;</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>Line hull<span class="op">[</span><span class="dv">100005</span><span class="op">];</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sz <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> ptr <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> intersect<span class="op">(</span>Line a<span class="op">,</span> Line b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span><span class="dt">double</span><span class="op">)(</span>b<span class="op">.</span>b <span class="op">-</span> a<span class="op">.</span>b<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>a<span class="op">.</span>m <span class="op">-</span> b<span class="op">.</span>m<span class="op">);</span></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> bad<span class="op">(</span>Line a<span class="op">,</span> Line b<span class="op">,</span> Line c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>c<span class="op">.</span>b <span class="op">-</span> a<span class="op">.</span>b<span class="op">)*(</span>a<span class="op">.</span>m <span class="op">-</span> b<span class="op">.</span>m<span class="op">)</span> <span class="op">&lt;=</span> <span class="op">(</span>b<span class="op">.</span>b <span class="op">-</span> a<span class="op">.</span>b<span class="op">)*(</span>a<span class="op">.</span>m <span class="op">-</span> c<span class="op">.</span>m<span class="op">);</span></span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> add_line<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> m<span class="op">,</span> <span class="dt">long</span> <span class="dt">long</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a>    Line L <span class="op">=</span> <span class="op">{</span>m<span class="op">,</span> b<span class="op">};</span></span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>sz <span class="op">&gt;=</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> bad<span class="op">(</span>hull<span class="op">[</span>sz<span class="op">-</span><span class="dv">2</span><span class="op">],</span> hull<span class="op">[</span>sz<span class="op">-</span><span class="dv">1</span><span class="op">],</span> L<span class="op">))</span> sz<span class="op">--;</span></span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true" tabindex="-1"></a>    hull<span class="op">[</span>sz<span class="op">++]</span> <span class="op">=</span> L<span class="op">;</span></span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb135-20"><a href="#cb135-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-21"><a href="#cb135-21" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> query<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-22"><a href="#cb135-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>ptr <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> sz <span class="op">&amp;&amp;</span> hull<span class="op">[</span>ptr<span class="op">+</span><span class="dv">1</span><span class="op">].</span>m <span class="op">*</span> x <span class="op">+</span> hull<span class="op">[</span>ptr<span class="op">+</span><span class="dv">1</span><span class="op">].</span>b <span class="op">&lt;=</span> hull<span class="op">[</span>ptr<span class="op">].</span>m <span class="op">*</span> x <span class="op">+</span> hull<span class="op">[</span>ptr<span class="op">].</span>b<span class="op">)</span></span>
<span id="cb135-23"><a href="#cb135-23" aria-hidden="true" tabindex="-1"></a>        ptr<span class="op">++;</span></span>
<span id="cb135-24"><a href="#cb135-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hull<span class="op">[</span>ptr<span class="op">].</span>m <span class="op">*</span> x <span class="op">+</span> hull<span class="op">[</span>ptr<span class="op">].</span>b<span class="op">;</span></span>
<span id="cb135-25"><a href="#cb135-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-62" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-62">Why It Matters</h4>
<ul>
<li><p>Reduces <span class="math inline">\(O(n^2)\)</span> DP with linear transition to <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(n\log n)\)</span>.</p></li>
<li><p>Extremely common in optimization tasks:</p>
<ul>
<li>Convex cost partitioning</li>
<li>Slope trick extensions</li>
<li>Dynamic programming with linear penalties</li>
</ul></li>
<li><p>Foundation for Li Chao Trees and Slope Trick.</p></li>
</ul>
</section>
<section id="step-by-step-example-59" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-59">Step-by-Step Example</h4>
<p>Suppose <span class="math display">\[
dp[i] = \min_{k&lt;i}\big(dp[k] + a_k \cdot b_i + c_k\big)
\]</span> Given:</p>
<ul>
<li><span class="math inline">\(a = [2,4,6]\)</span></li>
<li><span class="math inline">\(b = [1,2,3]\)</span></li>
<li><span class="math inline">\(c = [5,4,2]\)</span></li>
</ul>
<p>Each step:</p>
<ol type="1">
<li>Add line <span class="math inline">\(y = m_k x + b_k = a_k x + (dp[k] + c_k)\)</span></li>
<li>Query at <span class="math inline">\(x_i = b[i]\)</span> to get min value.</li>
</ol>
<p>CHT keeps only useful lines forming lower envelope.</p>
</section>
<section id="a-gentle-proof-why-it-works-49" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-49">A Gentle Proof (Why It Works)</h4>
<p>For monotonic slopes, intersection points are sorted. Once a line becomes worse than the next at a certain <span class="math inline">\(x\)</span>, it will never be optimal again for larger <span class="math inline">\(x\)</span>. Therefore, we can pop it from the deque — each line enters and leaves once → <span class="math inline">\(O(n)\)</span> amortized.</p>
</section>
<section id="try-it-yourself-62" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-62">Try It Yourself</h4>
<ol type="1">
<li>Adapt for maximum query (flip signs).</li>
<li>Combine with DP: <span class="math inline">\(dp[i] = \min_k(dp[k] + m_k x_i + b_k)\)</span>.</li>
<li>Add Li Chao Tree for unsorted slopes/queries.</li>
<li>Visualize lower envelope intersection points.</li>
<li>Compare with Slope Trick (piecewise-linear potentials).</li>
</ol>
</section>
<section id="test-cases-62" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-62">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>m</th>
<th>b</th>
<th>x</th>
<th>Expected min</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,2,3]</td>
<td>[0,1,3]</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>[2,1]</td>
<td>[5,4]</td>
<td>2</td>
<td>6</td>
</tr>
<tr class="odd">
<td>[1,3,5]</td>
<td>[2,2,2]</td>
<td>4</td>
<td>14</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-62" class="level4">
<h4 class="anchored" data-anchor-id="complexity-62">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> amortized (monotone queries) or <span class="math inline">\(O(n\log n)\)</span> (Li Chao)</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Convex Hull Trick is the bridge between geometry and DP, every line a subproblem, every envelope a minimization frontier.</p>
</section>
</section>
<section id="li-chao-tree" class="level3">
<h3 class="anchored" data-anchor-id="li-chao-tree">464 Li Chao Tree</h3>
<p>The Li Chao Tree is a dynamic data structure for maintaining a set of lines and efficiently querying the minimum (or maximum) value at any given <span class="math inline">\(x\)</span>. Unlike the Convex Hull Trick, it works even when slopes and query points are arbitrary and unordered.</p>
<section id="what-problem-are-we-solving-63" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-63">What Problem Are We Solving?</h4>
<p>We want to handle DP recurrences (or cost functions) of the form:</p>
<p><span class="math display">\[
dp[i] = \min_{j &lt; i} (m_j \cdot x_i + b_j)
\]</span></p>
<p>Each <span class="math inline">\(j\)</span> contributes a line <span class="math inline">\(y = m_jx + b_j\)</span>. We must find the minimum value among all added lines at a given <span class="math inline">\(x_i\)</span>.</p>
<p>Unlike the Convex Hull Trick (which needs monotonic <span class="math inline">\(x\)</span> or <span class="math inline">\(m\)</span>), Li Chao Tree handles any insertion or query order, no sorting required.</p>
</section>
<section id="when-it-applies-1" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies-1">When It Applies</h4>
<p>Li Chao Tree applies when:</p>
<ul>
<li>You need to add arbitrary lines (<span class="math inline">\(m_j, b_j\)</span>) over time</li>
<li>You must query arbitrary <span class="math inline">\(x\)</span> in any order</li>
<li>You want min or max queries efficiently</li>
<li>Slopes and queries are not monotonic</li>
</ul>
<p>This makes it ideal for:</p>
<ul>
<li>DP with arbitrary slopes</li>
<li>Online queries</li>
<li>Geometry problems involving lower envelopes</li>
<li>Line container queries in computational geometry</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-60" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-60">How Does It Work (Plain Language)</h4>
<p>The Li Chao Tree divides the <span class="math inline">\(x\)</span>-axis into segments. Each node represents an interval, storing one line that’s currently optimal over part (or all) of that range.</p>
<p>When a new line is added:</p>
<ul>
<li>Compare it with the current line in the interval</li>
<li>Swap if it’s better at the midpoint</li>
<li>Recursively insert into one child (left/right), narrowing the range</li>
</ul>
<p>When querying:</p>
<ul>
<li>Descend the tree using <span class="math inline">\(x\)</span></li>
<li>Combine values of lines encountered</li>
<li>Return the minimum (or maximum)</li>
</ul>
<p>This yields <span class="math inline">\(O(\log X)\)</span> time per insertion and query, where <span class="math inline">\(X\)</span> is the range of <span class="math inline">\(x\)</span> values (discretized if necessary).</p>
</section>
<section id="tiny-code-easy-version-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-1">Tiny Code (Easy Version)</h4>
<p>Python (Min Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1018</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Line:</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, m, b):</span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.m <span class="op">=</span> m</span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.b <span class="op">=</span> b</span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> value(<span class="va">self</span>, x):</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.m <span class="op">*</span> x <span class="op">+</span> <span class="va">self</span>.b</span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node:</span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, l, r):</span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.l <span class="op">=</span> l</span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.r <span class="op">=</span> r</span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.line <span class="op">=</span> <span class="va">None</span></span>
<span id="cb136-15"><a href="#cb136-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> <span class="va">None</span></span>
<span id="cb136-16"><a href="#cb136-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb136-17"><a href="#cb136-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-18"><a href="#cb136-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LiChaoTree:</span>
<span id="cb136-19"><a href="#cb136-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, l, r):</span>
<span id="cb136-20"><a href="#cb136-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> Node(l, r)</span>
<span id="cb136-21"><a href="#cb136-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb136-22"><a href="#cb136-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _add(<span class="va">self</span>, node, new_line):</span>
<span id="cb136-23"><a href="#cb136-23" aria-hidden="true" tabindex="-1"></a>        l, r <span class="op">=</span> node.l, node.r</span>
<span id="cb136-24"><a href="#cb136-24" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> (l <span class="op">+</span> r) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb136-25"><a href="#cb136-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.line <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb136-26"><a href="#cb136-26" aria-hidden="true" tabindex="-1"></a>            node.line <span class="op">=</span> new_line</span>
<span id="cb136-27"><a href="#cb136-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb136-28"><a href="#cb136-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb136-29"><a href="#cb136-29" aria-hidden="true" tabindex="-1"></a>        left_better <span class="op">=</span> new_line.value(l) <span class="op">&lt;</span> node.line.value(l)</span>
<span id="cb136-30"><a href="#cb136-30" aria-hidden="true" tabindex="-1"></a>        mid_better <span class="op">=</span> new_line.value(m) <span class="op">&lt;</span> node.line.value(m)</span>
<span id="cb136-31"><a href="#cb136-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb136-32"><a href="#cb136-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mid_better:</span>
<span id="cb136-33"><a href="#cb136-33" aria-hidden="true" tabindex="-1"></a>            node.line, new_line <span class="op">=</span> new_line, node.line</span>
<span id="cb136-34"><a href="#cb136-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb136-35"><a href="#cb136-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r <span class="op">-</span> l <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb136-36"><a href="#cb136-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb136-37"><a href="#cb136-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> left_better <span class="op">!=</span> mid_better:</span>
<span id="cb136-38"><a href="#cb136-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> node.left:</span>
<span id="cb136-39"><a href="#cb136-39" aria-hidden="true" tabindex="-1"></a>                node.left <span class="op">=</span> Node(l, m)</span>
<span id="cb136-40"><a href="#cb136-40" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._add(node.left, new_line)</span>
<span id="cb136-41"><a href="#cb136-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb136-42"><a href="#cb136-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> node.right:</span>
<span id="cb136-43"><a href="#cb136-43" aria-hidden="true" tabindex="-1"></a>                node.right <span class="op">=</span> Node(m <span class="op">+</span> <span class="dv">1</span>, r)</span>
<span id="cb136-44"><a href="#cb136-44" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._add(node.right, new_line)</span>
<span id="cb136-45"><a href="#cb136-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb136-46"><a href="#cb136-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_line(<span class="va">self</span>, m, b):</span>
<span id="cb136-47"><a href="#cb136-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._add(<span class="va">self</span>.root, Line(m, b))</span>
<span id="cb136-48"><a href="#cb136-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb136-49"><a href="#cb136-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _query(<span class="va">self</span>, node, x):</span>
<span id="cb136-50"><a href="#cb136-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb136-51"><a href="#cb136-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> INF</span>
<span id="cb136-52"><a href="#cb136-52" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> node.line.value(x) <span class="cf">if</span> node.line <span class="cf">else</span> INF</span>
<span id="cb136-53"><a href="#cb136-53" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> (node.l <span class="op">+</span> node.r) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb136-54"><a href="#cb136-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">&lt;=</span> m:</span>
<span id="cb136-55"><a href="#cb136-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">min</span>(res, <span class="va">self</span>._query(node.left, x))</span>
<span id="cb136-56"><a href="#cb136-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb136-57"><a href="#cb136-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">min</span>(res, <span class="va">self</span>._query(node.right, x))</span>
<span id="cb136-58"><a href="#cb136-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb136-59"><a href="#cb136-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> query(<span class="va">self</span>, x):</span>
<span id="cb136-60"><a href="#cb136-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._query(<span class="va">self</span>.root, x)</span>
<span id="cb136-61"><a href="#cb136-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-62"><a href="#cb136-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb136-63"><a href="#cb136-63" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> LiChaoTree(<span class="dv">0</span>, <span class="dv">100</span>)</span>
<span id="cb136-64"><a href="#cb136-64" aria-hidden="true" tabindex="-1"></a>tree.add_line(<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb136-65"><a href="#cb136-65" aria-hidden="true" tabindex="-1"></a>tree.add_line(<span class="op">-</span><span class="dv">1</span>, <span class="dv">10</span>)</span>
<span id="cb136-66"><a href="#cb136-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tree.query(<span class="dv">5</span>))  <span class="co"># minimum value among all lines at x=5</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-63" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-63">Why It Matters</h4>
<ul>
<li>Handles arbitrary slopes and queries</li>
<li>Efficient for online DP and geometry optimization</li>
<li>Generalizes CHT (works without monotonic constraints)</li>
<li>Can be used for both min and max queries (just flip inequalities)</li>
</ul>
</section>
<section id="step-by-step-example-60" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-60">Step-by-Step Example</h4>
<p>Suppose we insert lines:</p>
<ol type="1">
<li><span class="math inline">\(y = 2x + 3\)</span></li>
<li><span class="math inline">\(y = -x + 10\)</span></li>
</ol>
<p>Then query at <span class="math inline">\(x = 5\)</span>:</p>
<ul>
<li>First line: <span class="math inline">\(2(5) + 3 = 13\)</span></li>
<li>Second line: <span class="math inline">\(-5 + 10 = 5\)</span> → answer = 5</li>
</ul>
<p>The tree ensures each query returns the best line without brute force.</p>
</section>
<section id="a-gentle-proof-why-it-works-50" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-50">A Gentle Proof (Why It Works)</h4>
<p>Each interval stores a line that’s locally optimal at some midpoint. If a new line is better at one endpoint, it must eventually overtake the existing line, so the intersection lies in that half.</p>
<p>By recursing on halves, we ensure the correct line is chosen for every <span class="math inline">\(x\)</span>.</p>
<p>The tree height is <span class="math inline">\(\log X\)</span>, and each insertion affects at most <span class="math inline">\(\log X\)</span> nodes.</p>
<p>Hence: <span class="math display">\[
T(n) = O(n \log X)
\]</span></p>
</section>
<section id="try-it-yourself-63" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-63">Try It Yourself</h4>
<ol type="1">
<li>Implement Li Chao Tree for max queries (invert comparisons).</li>
<li>Add <span class="math inline">\(n\)</span> random lines and query random <span class="math inline">\(x\)</span>.</li>
<li>Apply it to DP with linear cost: <span class="math display">\[
dp[i] = \min_{j &lt; i}(dp[j] + a_jx_i + b_j)
\]</span></li>
<li>Visualize segment splits and stored lines.</li>
<li>Compare with Convex Hull Trick on monotonic test cases.</li>
</ol>
</section>
<section id="test-cases-63" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-63">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Lines</th>
<th>Queries</th>
<th>Range</th>
<th>Time</th>
<th>Works</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>10</td>
<td>[0, 100]</td>
<td>O(n log X)</td>
<td>✓</td>
</tr>
<tr class="even">
<td>1e5</td>
<td>1e5</td>
<td>[0, 1e9]</td>
<td>O(n log X)</td>
<td>✓</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-63" class="level4">
<h4 class="anchored" data-anchor-id="complexity-63">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(\log X)\)</span> per insert/query</li>
<li>Space: <span class="math inline">\(O(\log X)\)</span> per line (tree nodes)</li>
</ul>
<p>The Li Chao Tree is your line oracle, always ready to give the best line, no matter how chaotic your slopes and queries become.</p>
</section>
</section>
<section id="slope-trick" class="level3">
<h3 class="anchored" data-anchor-id="slope-trick">465 Slope Trick</h3>
<p>The Slope Trick is a dynamic programming optimization technique for problems involving piecewise-linear convex functions. It lets you maintain and update the shape of a convex cost function efficiently, especially when transitions involve operations like adding absolute values, shifting minima, or combining convex shapes.</p>
<section id="what-problem-are-we-solving-64" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-64">What Problem Are We Solving?</h4>
<p>Many DP problems involve minimizing a cost function that changes shape over time, such as:</p>
<p><span class="math display">\[
dp[i] = \min_x (dp[i-1](x) + |x - a_i|)
\]</span></p>
<p>Here, <span class="math inline">\(dp[i]\)</span> is not a single value but a function of <span class="math inline">\(x\)</span>. The Slope Trick is how we maintain this function efficiently as a sequence of linear segments.</p>
<p>This comes up when:</p>
<ul>
<li>You need to add |x - a| terms</li>
<li>You need to shift the whole function left or right</li>
<li>You need to add constants or merge minima</li>
</ul>
<p>Rather than storing the full function, we store key “breakpoints” and update in logarithmic time.</p>
</section>
<section id="when-it-applies-2" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies-2">When It Applies</h4>
<p>Slope Trick applies when:</p>
<ul>
<li><p>The cost function is convex and piecewise linear</p></li>
<li><p>Each transition is of the form:</p>
<ul>
<li><span class="math inline">\(f(x) + |x - a|\)</span></li>
<li><span class="math inline">\(f(x + c)\)</span> or <span class="math inline">\(f(x - c)\)</span></li>
<li><span class="math inline">\(\min_x(f(x)) + c\)</span></li>
</ul></li>
<li><p>You need to track minimal cost across shifting choices</p></li>
</ul>
<p>Common in:</p>
<ul>
<li>Median DP</li>
<li>Path alignment</li>
<li>Convex smoothing</li>
<li>Minimizing sum of absolute differences</li>
<li>Cost balancing problems</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-61" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-61">How Does It Work (Plain Language)</h4>
<p>Instead of recomputing the entire cost function each time, we maintain two priority queues (heaps) that track where the slope changes.</p>
<p>Think of the cost function as a mountain made of straight lines:</p>
<ul>
<li>Adding <span class="math inline">\(|x - a|\)</span> means putting a “tent” centered at <span class="math inline">\(a\)</span></li>
<li>Moving <span class="math inline">\(x\)</span> left/right shifts the mountain</li>
<li>The minimum point can move but remains easy to find</li>
</ul>
<p>We track the slope’s left and right breakpoints using heaps:</p>
<ul>
<li>Left heap (max-heap): stores slopes to the left of minimum</li>
<li>Right heap (min-heap): stores slopes to the right</li>
</ul>
<p>Each operation updates these heaps in <span class="math inline">\(O(\log n)\)</span>.</p>
</section>
<section id="example-problem" class="level4">
<h4 class="anchored" data-anchor-id="example-problem">Example Problem</h4>
<p>Minimize: <span class="math display">\[
dp[i] = \min_x(dp[i-1](x) + |x - a_i|)
\]</span></p>
<p>We want the minimal total distance to all <span class="math inline">\(a_1, a_2, ..., a_i\)</span>.</p>
<p>The optimal <span class="math inline">\(x\)</span> is the median of all <span class="math inline">\(a\)</span>’s seen so far.</p>
<p>Slope Trick maintains this function efficiently.</p>
</section>
<section id="tiny-code-easy-version-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-2">Tiny Code (Easy Version)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SlopeTrick:</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> []   <span class="co"># max-heap (store negative values)</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> []  <span class="co"># min-heap</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.min_cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_abs(<span class="va">self</span>, a):</span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.left:</span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(<span class="va">self</span>.left, <span class="op">-</span>a)</span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(<span class="va">self</span>.right, a)</span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">&lt;</span> <span class="op">-</span><span class="va">self</span>.left[<span class="dv">0</span>]:</span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(<span class="va">self</span>.left, <span class="op">-</span>a)</span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a>            val <span class="op">=</span> <span class="op">-</span>heapq.heappop(<span class="va">self</span>.left)</span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(<span class="va">self</span>.right, val)</span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.min_cost <span class="op">+=</span> <span class="op">-</span><span class="va">self</span>.left[<span class="dv">0</span>] <span class="op">-</span> a</span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(<span class="va">self</span>.right, a)</span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>            val <span class="op">=</span> heapq.heappop(<span class="va">self</span>.right)</span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(<span class="va">self</span>.left, <span class="op">-</span>val)</span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.min_cost <span class="op">+=</span> a <span class="op">-</span> val</span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_min(<span class="va">self</span>):</span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.min_cost</span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a>st <span class="op">=</span> SlopeTrick()</span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>]:</span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a>    st.add_abs(a)</span>
<span id="cb137-32"><a href="#cb137-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Minimum cost:"</span>, st.get_min())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This structure efficiently tracks the cost of minimizing the sum of absolute differences.</p>
</section>
<section id="why-it-matters-64" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-64">Why It Matters</h4>
<ul>
<li>Reduces function-based DPs into heap updates</li>
<li>Elegant solution for convex minimization</li>
<li>Handles |x - a|, shift, and constant add in <span class="math inline">\(O(\log n)\)</span></li>
<li>Avoids discretization of continuous <span class="math inline">\(x\)</span></li>
</ul>
</section>
<section id="step-by-step-example-61" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-61">Step-by-Step Example</h4>
<p>Suppose we add points sequentially: <span class="math inline">\(a = [3, 1, 4]\)</span></p>
<ol type="1">
<li>Add <span class="math inline">\(|x - 3|\)</span>: min at <span class="math inline">\(x = 3\)</span></li>
<li>Add <span class="math inline">\(|x - 1|\)</span>: min moves to <span class="math inline">\(x = 2\)</span></li>
<li>Add <span class="math inline">\(|x - 4|\)</span>: min moves to <span class="math inline">\(x = 3\)</span></li>
</ol>
<p>Heaps track these balance points dynamically. Total cost is sum of minimal shifts.</p>
</section>
<section id="a-gentle-proof-why-it-works-51" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-51">A Gentle Proof (Why It Works)</h4>
<p>Adding <span class="math inline">\(|x - a|\)</span> modifies slope:</p>
<ul>
<li>For <span class="math inline">\(x &lt; a\)</span>, slope increases by <span class="math inline">\(-1\)</span></li>
<li>For <span class="math inline">\(x &gt; a\)</span>, slope increases by <span class="math inline">\(+1\)</span></li>
</ul>
<p>Thus, the function stays convex. Heaps store where slope crosses zero (the minimum).</p>
<p>Balancing heaps keeps slopes equalized, ensuring minimum at the median. Each operation maintains convexity and updates cost correctly.</p>
</section>
<section id="try-it-yourself-64" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-64">Try It Yourself</h4>
<ol type="1">
<li>Implement <code>add_shift(c)</code> to shift function horizontally.</li>
<li>Solve: <span class="math display">\[
dp[i] = \min_x(dp[i-1](x) + |x - a_i|)
\]</span> for a list of <span class="math inline">\(a_i\)</span></li>
<li>Add <code>add_constant(c)</code> for vertical shifts.</li>
<li>Track the running median using heaps.</li>
<li>Visualize slope evolution, it should always form a “V” shape.</li>
</ol>
</section>
<section id="test-cases-64" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-64">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>Expected Minimum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3]</td>
<td>0</td>
</tr>
<tr class="even">
<td>[3, 1]</td>
<td>2</td>
</tr>
<tr class="odd">
<td>[3, 1, 4]</td>
<td>3</td>
</tr>
<tr class="even">
<td>[3, 1, 4, 1]</td>
<td>5</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-64" class="level4">
<h4 class="anchored" data-anchor-id="complexity-64">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n\log n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>The Slope Trick is like origami for DP, you fold and shift convex functions to shape the minimal path, one segment at a time.</p>
</section>
</section>
<section id="monotonic-queue-optimization" class="level3">
<h3 class="anchored" data-anchor-id="monotonic-queue-optimization">466 Monotonic Queue Optimization</h3>
<p>Monotonic Queue Optimization is a dynamic programming acceleration technique for recurrences involving sliding windows or range-limited minima. It replaces naive scanning (<span class="math inline">\(O(nk)\)</span>) with a monotonic deque that finds optimal states in <span class="math inline">\(O(n)\)</span>.</p>
<section id="what-problem-are-we-solving-65" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-65">What Problem Are We Solving?</h4>
<p>We want to optimize DP of the form:</p>
<p><span class="math display">\[
dp[i] = \min_{j \in [i-k,, i-1]} (dp[j] + cost(j, i))
\]</span></p>
<p>or simpler, when <span class="math inline">\(cost(j, i)\)</span> is monotonic or separable, like <span class="math inline">\(w_i\)</span> or <span class="math inline">\(c(i-j)\)</span>, we can maintain a window of candidate <span class="math inline">\(j\)</span>’s.</p>
<p>This pattern appears in:</p>
<ul>
<li>Sliding window DPs</li>
<li>Shortest path in DAGs with window constraints</li>
<li>Queue scheduling problems</li>
<li>Constrained subsequence or segment DPs</li>
</ul>
</section>
<section id="when-it-applies-3" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies-3">When It Applies</h4>
<p>You can apply Monotonic Queue Optimization when:</p>
<ul>
<li>The transition uses contiguous ranges of <span class="math inline">\(j\)</span> (like a window)</li>
<li>The cost function is monotonic, allowing pruning of bad states</li>
<li>You want to find <span class="math inline">\(\min\)</span> or <span class="math inline">\(\max\)</span> over a sliding window efficiently</li>
</ul>
<p>Common forms:</p>
<ul>
<li><span class="math inline">\(dp[i] = \min_{j \in [i-k, i]} (dp[j] + c[j])\)</span></li>
<li><span class="math inline">\(dp[i] = \max_{j \in [i-k, i]} (dp[j] + w[i])\)</span></li>
</ul>
<p>This trick does not require convexity, only monotonic ordering in the transition range.</p>
</section>
<section id="how-does-it-work-plain-language-62" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-62">How Does It Work (Plain Language)</h4>
<p>Instead of checking all <span class="math inline">\(k\)</span> previous states for each <span class="math inline">\(i\)</span>, we maintain a deque of indices that are still potentially optimal.</p>
<p>At each step:</p>
<ol type="1">
<li>Remove old indices (outside window)</li>
<li>Pop worse states (whose value is greater than the new one)</li>
<li>Front of deque gives the best <span class="math inline">\(j\)</span> for current <span class="math inline">\(i\)</span></li>
</ol>
<p>This ensures the deque is monotonic (increasing or decreasing depending on min/max).</p>
</section>
<section id="example-recurrence" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence">Example Recurrence</h4>
<p><span class="math display">\[
dp[i] = \min_{j \in [i-k, i-1]} (dp[j] + w_i)
\]</span></p>
<p>Since <span class="math inline">\(w_i\)</span> doesn’t depend on <span class="math inline">\(j\)</span>, we just need <span class="math inline">\(\min dp[j]\)</span> over the last <span class="math inline">\(k\)</span> indices.</p>
</section>
<section id="tiny-code-easy-version-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-3">Tiny Code (Easy Version)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_sliding_window_dp(arr, k):</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>    dq <span class="op">=</span> deque()</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove out-of-window</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> dq <span class="kw">and</span> dq[<span class="dv">0</span>] <span class="op">&lt;</span> i <span class="op">-</span> k:</span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>            dq.popleft()</span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Pop worse elements</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> dq <span class="kw">and</span> dp[dq[<span class="op">-</span><span class="dv">1</span>]] <span class="op">&gt;=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">False</span>:</span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>            dq.pop()</span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Push current</span></span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a>        dq.append(i)</span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute dp</span></span>
<span id="cb138-18"><a href="#cb138-18" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> arr[i] <span class="op">+</span> (dp[dq[<span class="dv">0</span>]] <span class="cf">if</span> dq <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb138-19"><a href="#cb138-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb139"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">100000</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>N<span class="op">],</span> a<span class="op">[</span>N<span class="op">],</span> q<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">,</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> front <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> back <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>    q<span class="op">[</span>back<span class="op">++]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>front <span class="op">&lt;</span> back <span class="op">&amp;&amp;</span> q<span class="op">[</span>front<span class="op">]</span> <span class="op">&lt;</span> i <span class="op">-</span> k<span class="op">)</span> front<span class="op">++;</span></span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>q<span class="op">[</span>front<span class="op">]]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb139-18"><a href="#cb139-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>front <span class="op">&lt;</span> back <span class="op">&amp;&amp;</span> dp<span class="op">[</span>q<span class="op">[</span>back <span class="op">-</span> <span class="dv">1</span><span class="op">]]</span> <span class="op">&gt;=</span> dp<span class="op">[</span>i<span class="op">])</span> back<span class="op">--;</span></span>
<span id="cb139-19"><a href="#cb139-19" aria-hidden="true" tabindex="-1"></a>        q<span class="op">[</span>back<span class="op">++]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb139-20"><a href="#cb139-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb139-21"><a href="#cb139-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-22"><a href="#cb139-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb139-23"><a href="#cb139-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-65" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-65">Why It Matters</h4>
<ul>
<li>Converts range-min DPs from <span class="math inline">\(O(nk)\)</span> → <span class="math inline">\(O(n)\)</span></li>
<li>Essential for problems with window constraints</li>
<li>Avoids heap overhead (constant-time updates)</li>
<li>Extremely simple and robust</li>
</ul>
</section>
<section id="step-by-step-example-62" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-62">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(arr = [3,1,4,1,5]\)</span>, <span class="math inline">\(k = 2\)</span></p>
<p>At <span class="math inline">\(i = 2\)</span>:</p>
<ul>
<li>Candidates: <span class="math inline">\(j \in [0, 1]\)</span></li>
<li>dp[0]=3, dp[1]=4</li>
<li>dq = [1] after pruning worse values</li>
<li>dp[2] = arr[2] + dp[1] = 4 + 4 = 8</li>
</ul>
<p>Deque moves as window slides, always holding potential minima.</p>
</section>
<section id="a-gentle-proof-why-it-works-52" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-52">A Gentle Proof (Why It Works)</h4>
<p>At each <span class="math inline">\(i\)</span>:</p>
<ul>
<li>Remove indices <span class="math inline">\(&lt; i-k\)</span> (out of range)</li>
<li>Maintain monotonic order of dp-values in deque</li>
<li>The front always gives the smallest <span class="math inline">\(dp[j]\)</span> in window</li>
<li>Because each element is pushed and popped once, total operations = <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Thus, overall complexity is linear.</p>
</section>
<section id="try-it-yourself-65" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-65">Try It Yourself</h4>
<ol type="1">
<li>Implement max version by reversing comparisons.</li>
<li>Apply to <span class="math inline">\(dp[i] = \min_{j \in [i-k, i]} (dp[j] + c_i)\)</span></li>
<li>Visualize deque evolution per step.</li>
<li>Solve constrained path problems with limited jump size.</li>
<li>Compare runtime with naive <span class="math inline">\(O(nk)\)</span> approach.</li>
</ol>
</section>
<section id="test-cases-65" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-65">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>k</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3,1,4,1,5]</td>
<td>2</td>
<td>fast min DP</td>
</tr>
<tr class="even">
<td>[10,9,8,7,6]</td>
<td>3</td>
<td>decreasing</td>
</tr>
<tr class="odd">
<td>[1,2,3,4,5]</td>
<td>1</td>
<td>simple</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-65" class="level4">
<h4 class="anchored" data-anchor-id="complexity-65">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(k)\)</span></li>
</ul>
<p>Monotonic Queue Optimization is your sliding window oracle, keeping just the right candidates, and tossing the rest without looking back.</p>
</section>
</section>
<section id="bitset-dp" class="level3">
<h3 class="anchored" data-anchor-id="bitset-dp">467 Bitset DP</h3>
<p>Bitset DP is a performance optimization technique that uses bit-level parallelism to speed up dynamic programming, especially when state transitions involve Boolean operations over large ranges. By representing states as bits, multiple transitions can be processed simultaneously using fast bitwise operators.</p>
<section id="what-problem-are-we-solving-66" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-66">What Problem Are We Solving?</h4>
<p>We want to optimize DPs like:</p>
<p><span class="math display">\[
dp[i] = \text{reachable states after considering first } i \text{ elements}
\]</span></p>
<p>Often in subset sum, knapsack, path existence, or mask propagation, we deal with states where:</p>
<ul>
<li>Each state is true/false</li>
<li>Transition is shifting or combining bits</li>
</ul>
<p>For example, in Subset Sum: <span class="math display">\[
dp[i][s] = dp[i-1][s] \lor dp[i-1][s - a_i]
\]</span> We can compress this into a bitset shift.</p>
</section>
<section id="when-it-applies-4" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies-4">When It Applies</h4>
<p>You can use Bitset DP when:</p>
<ul>
<li>States are Boolean (true/false)</li>
<li>Transition is shift-based or additive</li>
<li>State space is dense and bounded</li>
</ul>
<p>Common use cases:</p>
<ul>
<li>Subset Sum (<span class="math inline">\(O(nS / w)\)</span>)</li>
<li>Bounded Knapsack</li>
<li>Graph reachability</li>
<li>Palindromic substrings DP</li>
<li>Counting with bit masks</li>
</ul>
<p>Here, <span class="math inline">\(w\)</span> is word size (e.g.&nbsp;64), giving up to 64x speedup.</p>
</section>
<section id="how-does-it-work-plain-language-63" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-63">How Does It Work (Plain Language)</h4>
<p>Represent each DP layer as a bitset, each bit indicates whether a state is reachable.</p>
<p>For Subset Sum:</p>
<ul>
<li><p>Initially: <code>dp[0] = 1</code> (sum = 0 reachable)</p></li>
<li><p>For each number <code>a</code>:</p>
<ul>
<li>Shift left by <code>a</code> → new reachable sums</li>
<li>Combine: <code>dp |= dp &lt;&lt; a</code></li>
</ul></li>
</ul>
<p>Example: Adding 3 to {0, 2, 5} means shift left by 3 → {3, 5, 8}.</p>
<p>All in one CPU instruction!</p>
</section>
<section id="example-recurrence-1" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence-1">Example Recurrence</h4>
<p><span class="math display">\[
dp[s] = dp[s] \lor dp[s - a]
\]</span></p>
<p>Bitset form:</p>
<p><span class="math display">\[
dp = dp \lor (dp \ll a)
\]</span></p>
</section>
<section id="tiny-code-easy-version-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-4">Tiny Code (Easy Version)</h4>
<p>Python (using int bitset)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb140"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> subset_sum(nums, target):</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> <span class="dv">1</span>  <span class="co"># bit 0 = reachable sum 0</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> nums:</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">|=</span> dp <span class="op">&lt;&lt;</span> a</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (dp <span class="op">&gt;&gt;</span> target) <span class="op">&amp;</span> <span class="dv">1</span>  <span class="co"># check if bit target is set</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(subset_sum([<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">7</span>], <span class="dv">5</span>))  <span class="co"># True (3+2)</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(subset_sum([<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">7</span>], <span class="dv">6</span>))  <span class="co"># False</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (using bitset)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb141"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXS </span><span class="dv">10000</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define W </span><span class="dv">64</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>MAXS <span class="op">/</span> W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> setbit<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> dp<span class="op">[</span>i <span class="op">/</span> W<span class="op">]</span> <span class="op">|=</span> <span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>i <span class="op">%</span> W<span class="op">);</span> <span class="op">}</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> getbit<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">/</span> W<span class="op">]</span> <span class="op">&gt;&gt;</span> <span class="op">(</span>i <span class="op">%</span> W<span class="op">))</span> <span class="op">&amp;</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>dp<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>dp<span class="op">));</span></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>    setbit<span class="op">(</span><span class="dv">0</span><span class="op">);</span> <span class="co">// sum 0 reachable</span></span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> a<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> MAXS <span class="op">/</span> W<span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> shifted <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">+</span> v <span class="op">/</span> W <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;=</span> MAXS <span class="op">/</span> W<span class="op">)</span></span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j <span class="op">+</span> v <span class="op">/</span> W <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">|=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">&gt;&gt;</span> <span class="op">(</span>W <span class="op">-</span> <span class="op">(</span>v <span class="op">%</span> W<span class="op">));</span></span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">|=</span> shifted<span class="op">;</span></span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Sum 5 reachable? </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> getbit<span class="op">(</span><span class="dv">5</span><span class="op">));</span></span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-66" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-66">Why It Matters</h4>
<ul>
<li>Exploits hardware parallelism</li>
<li>Ideal for dense Boolean DP</li>
<li>Works for subset sums, range transitions, graph masks</li>
<li>Achieves massive speedups with simple operations</li>
</ul>
</section>
<section id="step-by-step-example-63" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-63">Step-by-Step Example</h4>
<p>Suppose <code>nums = [2, 3]</code>, <code>target = 5</code></p>
<p>Start: <code>dp = 1</code> → {0}</p>
<p>After <code>2</code>: <code>dp &lt;&lt; 2</code> = {2} <code>dp |= dp &lt;&lt; 2</code> = {0, 2}</p>
<p>After <code>3</code>: <code>dp &lt;&lt; 3</code> = {3, 5} <code>dp |= dp &lt;&lt; 3</code> = {0, 2, 3, 5}</p>
<p>Bit 5 is set → sum 5 reachable ✅</p>
</section>
<section id="a-gentle-proof-why-it-works-53" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-53">A Gentle Proof (Why It Works)</h4>
<p>Each shift corresponds to adding an element to a subset sum. Bitwise OR merges reachable sums. No overlap conflict, each bit is unique to a sum. After all shifts, all sums formed by subsets are represented.</p>
<p>Each shift-OR runs in <span class="math inline">\(O(S / w)\)</span> time, where <span class="math inline">\(S\)</span> = target sum, <span class="math inline">\(w\)</span> = word size.</p>
</section>
<section id="try-it-yourself-66" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-66">Try It Yourself</h4>
<ol type="1">
<li>Implement bounded knapsack via repeated shift-and-OR.</li>
<li>Count distinct subset sums (popcount of dp).</li>
<li>Apply to palindrome DP: <span class="math inline">\(dp[i][j] = s[i] == s[j] \land dp[i+1][j-1]\)</span>.</li>
<li>Visualize bit patterns after each step.</li>
<li>Benchmark vs normal DP on large <span class="math inline">\(S\)</span>.</li>
</ol>
</section>
<section id="test-cases-66" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-66">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>nums</th>
<th>target</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3, 2, 7]</td>
<td>5</td>
<td>True</td>
</tr>
<tr class="even">
<td>[3, 2, 7]</td>
<td>6</td>
<td>False</td>
</tr>
<tr class="odd">
<td>[1, 2, 3, 4]</td>
<td>10</td>
<td>True</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-66" class="level4">
<h4 class="anchored" data-anchor-id="complexity-66">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(nS / w)\)</span></li>
<li>Space: <span class="math inline">\(O(S / w)\)</span></li>
</ul>
<p>Bitset DP is your Boolean supercharger, turning slow loops into blinding-fast bitwise moves.</p>
</section>
</section>
<section id="offline-dp-queries" class="level3">
<h3 class="anchored" data-anchor-id="offline-dp-queries">468 Offline DP Queries</h3>
<p>Offline DP Queries are a strategy to handle queries on a dynamic programming state space by reordering or batching them for efficient computation. Instead of answering queries as they arrive (online), we process them <em>after sorting or grouping</em>, enabling faster transitions or range updates.</p>
<section id="what-problem-are-we-solving-67" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-67">What Problem Are We Solving?</h4>
<p>You may have a DP or recurrence that evolves over time, and a set of queries asking for values at specific states or intervals, like:</p>
<ul>
<li>“What is <span class="math inline">\(dp[x]\)</span> after all updates?”</li>
<li>“What is the min cost among indices in [L, R]?”</li>
<li>“How many reachable states satisfy condition C?”</li>
</ul>
<p>Naively answering queries as they appear leads to repeated recomputation. By processing them offline, we exploit sorting, prefix accumulation, or data structure reuse.</p>
</section>
<section id="when-it-applies-5" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies-5">When It Applies</h4>
<p>Offline DP Query methods apply when:</p>
<ul>
<li>Queries can be sorted (by time, index, or key)</li>
<li>Transitions or states evolve monotonically</li>
<li>You can batch updates and reuse results</li>
</ul>
<p>Common cases:</p>
<ul>
<li>Range DP queries: <span class="math inline">\(dp[i]\)</span> over [L, R]</li>
<li>Monotonic state DPs (like convex hull or segment DP)</li>
<li>Mo’s algorithm on DP states</li>
<li>Incremental DPs where <span class="math inline">\(dp[i]\)</span> is finalized before querying</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-64" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-64">How Does It Work (Plain Language)</h4>
<p>Instead of answering as we go, we:</p>
<ol type="1">
<li>Collect all queries</li>
<li>Sort them by a relevant dimension (like time or index)</li>
<li>Process DP transitions incrementally</li>
<li>Answer queries once the needed states are available</li>
</ol>
<p>Think of it as “moving forward once” and answering everything you pass.</p>
<p>By decoupling query order from input order, you avoid recomputation and exploit monotonic progression of DP.</p>
</section>
<section id="example-problem-1" class="level4">
<h4 class="anchored" data-anchor-id="example-problem-1">Example Problem</h4>
<p>You’re asked <span class="math inline">\(q\)</span> queries:</p>
<blockquote class="blockquote">
<p>For each <span class="math inline">\(x_i\)</span>, what is the minimum <span class="math inline">\(dp[j] + cost(j, x_i)\)</span> over all <span class="math inline">\(j \le x_i\)</span>?</p>
</blockquote>
<p>Naively, <span class="math inline">\(O(nq)\)</span>. Offline, sort queries by <span class="math inline">\(x_i\)</span>, process <span class="math inline">\(j = 1 \ldots n\)</span>, and maintain current DP structure (like a segment tree or convex hull).</p>
</section>
<section id="tiny-code-easy-version-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-5">Tiny Code (Easy Version)</h4>
<p>Python (sorted queries with running DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> offline_dp(arr, queries):</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># arr defines dp transitions</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># queries = [(x, idx)]</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(queries)</span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a>    queries.sort()  <span class="co"># sort by x</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>    ptr <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> arr[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># process queries with x == i</span></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> ptr <span class="op">&lt;</span> <span class="bu">len</span>(queries) <span class="kw">and</span> queries[ptr][<span class="dv">0</span>] <span class="op">==</span> i:</span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a>            _, idx <span class="op">=</span> queries[ptr]</span>
<span id="cb142-15"><a href="#cb142-15" aria-hidden="true" tabindex="-1"></a>            res[idx] <span class="op">=</span> dp[i]</span>
<span id="cb142-16"><a href="#cb142-16" aria-hidden="true" tabindex="-1"></a>            ptr <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb142-17"><a href="#cb142-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res</span>
<span id="cb142-18"><a href="#cb142-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-19"><a href="#cb142-19" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>]</span>
<span id="cb142-20"><a href="#cb142-20" aria-hidden="true" tabindex="-1"></a>queries <span class="op">=</span> [(<span class="dv">3</span>, <span class="dv">0</span>), (<span class="dv">5</span>, <span class="dv">1</span>)]</span>
<span id="cb142-21"><a href="#cb142-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(offline_dp(arr, queries))  <span class="co"># [sum of first 3, sum of first 5]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (sorted queries)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb143"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> x<span class="op">,</span> idx<span class="op">;</span> <span class="op">}</span> Query<span class="op">;</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmp<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">((</span>Query<span class="op">*)</span>a<span class="op">)-&gt;</span>x <span class="op">-</span> <span class="op">((</span>Query<span class="op">*)</span>b<span class="op">)-&gt;</span>x<span class="op">;</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">},</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a>    Query q<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">5</span><span class="op">,</span><span class="dv">1</span><span class="op">}};</span></span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">},</span> res<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-15"><a href="#cb143-15" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>q<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Query<span class="op">),</span> cmp<span class="op">);</span></span>
<span id="cb143-16"><a href="#cb143-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ptr <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb143-17"><a href="#cb143-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb143-18"><a href="#cb143-18" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb143-19"><a href="#cb143-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>ptr <span class="op">&lt;</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> q<span class="op">[</span>ptr<span class="op">].</span>x <span class="op">==</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb143-20"><a href="#cb143-20" aria-hidden="true" tabindex="-1"></a>            res<span class="op">[</span>q<span class="op">[</span>ptr<span class="op">].</span>idx<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb143-21"><a href="#cb143-21" aria-hidden="true" tabindex="-1"></a>            ptr<span class="op">++;</span></span>
<span id="cb143-22"><a href="#cb143-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb143-23"><a href="#cb143-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb143-24"><a href="#cb143-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-25"><a href="#cb143-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> res<span class="op">[</span><span class="dv">0</span><span class="op">],</span> res<span class="op">[</span><span class="dv">1</span><span class="op">]);</span> <span class="co">// dp[3], dp[5]</span></span>
<span id="cb143-26"><a href="#cb143-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-67" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-67">Why It Matters</h4>
<ul>
<li>Converts repeated query updates into one forward pass</li>
<li>Enables range optimizations (segment trees, CHT, etc.)</li>
<li>Reduces complexity from <span class="math inline">\(O(nq)\)</span> to <span class="math inline">\(O(n + q \log n)\)</span> or better</li>
<li>Essential for problems mixing queries + DP updates</li>
</ul>
</section>
<section id="step-by-step-example-64" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-64">Step-by-Step Example</h4>
<p>Suppose we compute cumulative <span class="math inline">\(dp[i] = dp[i-1] + a[i]\)</span> and queries ask <span class="math inline">\(dp[x]\)</span> for random <span class="math inline">\(x\)</span>:</p>
<p>Naive:</p>
<ul>
<li>Recompute each query: <span class="math inline">\(O(qn)\)</span></li>
</ul>
<p>Offline:</p>
<ul>
<li>Sort queries by <span class="math inline">\(x\)</span></li>
<li>Single pass <span class="math inline">\(O(n + q)\)</span></li>
</ul>
<p>Same principle applies to complex DPs if queries depend on monotone indices.</p>
</section>
<section id="a-gentle-proof-why-it-works-54" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-54">A Gentle Proof (Why It Works)</h4>
<p>If DP states evolve monotonically in one dimension (index or time), then after computing <span class="math inline">\(dp[1]\)</span> to <span class="math inline">\(dp[x]\)</span>, the answer to all queries with bound ≤ <span class="math inline">\(x\)</span> is final.</p>
<p>Sorting ensures we never recompute older states, and every query sees exactly what it needs, no more, no less.</p>
<p>Thus, each DP transition and query is processed once, yielding <span class="math inline">\(O(n + q)\)</span> total complexity.</p>
</section>
<section id="try-it-yourself-67" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-67">Try It Yourself</h4>
<ol type="1">
<li>Implement offline queries for prefix sums</li>
<li>Combine with Convex Hull Trick for sorted <span class="math inline">\(x_i\)</span></li>
<li>Use segment tree for range min DP queries</li>
<li>Implement offline Subset Sum queries (by sum ≤ X)</li>
<li>Compare performance with online queries</li>
</ol>
</section>
<section id="test-cases-67" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-67">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>queries</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3,1,4,1,5]</td>
<td>[3,5]</td>
<td>[8,14]</td>
</tr>
<tr class="even">
<td>[2,2,2]</td>
<td>[1,2,3]</td>
<td>[2,4,6]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-67" class="level4">
<h4 class="anchored" data-anchor-id="complexity-67">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n + q \log q)\)</span></li>
<li>Space: <span class="math inline">\(O(n + q)\)</span></li>
</ul>
<p>Offline DP Queries are your time travelers, answer questions from the future by rearranging them into a single efficient sweep through the past.</p>
</section>
</section>
<section id="dp-segment-tree" class="level3">
<h3 class="anchored" data-anchor-id="dp-segment-tree">469 DP + Segment Tree</h3>
<p>DP + Segment Tree is a hybrid optimization pattern that combines dynamic programming with a segment tree (or Fenwick tree) to handle transitions involving range queries (min, max, sum) efficiently. It’s especially useful when each DP state depends on a range of previous states, rather than a single index.</p>
<section id="what-problem-are-we-solving-68" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-68">What Problem Are We Solving?</h4>
<p>We want to compute:</p>
<p><span class="math display">\[
dp[i] = \min_{l_i \le j \le r_i}(dp[j] + cost[j])
\]</span></p>
<p>or more generally,</p>
<p><span class="math display">\[
dp[i] = \text{aggregate over range [L(i), R(i)] of some function of } dp[j]
\]</span></p>
<p>When transitions span intervals, naive iteration over each range is <span class="math inline">\(O(n^2)\)</span>. A segment tree reduces this to <span class="math inline">\(O(n \log n)\)</span> by supporting range queries and point updates.</p>
</section>
<section id="when-it-applies-6" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies-6">When It Applies</h4>
<p>Use DP + Segment Tree when:</p>
<ul>
<li>Transitions depend on intervals or ranges</li>
<li>The DP recurrence is monotonic in index order</li>
<li>You need fast min, max, or sum over subsets</li>
</ul>
<p>Typical problems:</p>
<ul>
<li>Range-based knapsack variants</li>
<li>Sequence partitioning with range cost</li>
<li>Interval scheduling DP</li>
<li>Increasing subsequences with weight</li>
<li>Pathfinding with segment bounds</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-65" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-65">How Does It Work (Plain Language)</h4>
<p>Instead of looping over all <span class="math inline">\(j\)</span> to find the best previous state:</p>
<ol type="1">
<li>Store <span class="math inline">\(dp[j]\)</span> values in a segment tree</li>
<li>Query for the minimum/maximum over <span class="math inline">\([L(i), R(i)]\)</span></li>
<li>Add transition cost and store <span class="math inline">\(dp[i]\)</span> back</li>
</ol>
<p>This way, every step:</p>
<ul>
<li>Query = <span class="math inline">\(O(\log n)\)</span></li>
<li>Update = <span class="math inline">\(O(\log n)\)</span> Total = <span class="math inline">\(O(n \log n)\)</span></li>
</ul>
</section>
<section id="example-recurrence-2" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence-2">Example Recurrence</h4>
<p><span class="math display">\[
dp[i] = \min_{j &lt; i,, a_j &lt; a_i}(dp[j]) + cost(i)
\]</span></p>
<p>If <span class="math inline">\(a_i\)</span> values can be ordered or compressed, we can query the segment tree for all <span class="math inline">\(a_j &lt; a_i\)</span> efficiently.</p>
</section>
<section id="tiny-code-easy-version-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-6">Tiny Code (Easy Version)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">1018</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SegmentTree:</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.N <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">self</span>.N <span class="op">&lt;</span> n:</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.N <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data <span class="op">=</span> [INF] <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.N)</span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update(<span class="va">self</span>, i, val):</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="va">self</span>.N</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.data[i] <span class="op">=</span> val</span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>            i <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.data[i] <span class="op">=</span> <span class="bu">min</span>(<span class="va">self</span>.data[<span class="dv">2</span><span class="op">*</span>i], <span class="va">self</span>.data[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> query(<span class="va">self</span>, l, r):</span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a>        l <span class="op">+=</span> <span class="va">self</span>.N</span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a>        r <span class="op">+=</span> <span class="va">self</span>.N</span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> INF</span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> l <span class="op">&lt;</span> r:</span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> l <span class="op">%</span> <span class="dv">2</span>:</span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true" tabindex="-1"></a>                res <span class="op">=</span> <span class="bu">min</span>(res, <span class="va">self</span>.data[l])</span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true" tabindex="-1"></a>                l <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> r <span class="op">%</span> <span class="dv">2</span>:</span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true" tabindex="-1"></a>                r <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true" tabindex="-1"></a>                res <span class="op">=</span> <span class="bu">min</span>(res, <span class="va">self</span>.data[r])</span>
<span id="cb144-26"><a href="#cb144-26" aria-hidden="true" tabindex="-1"></a>            l <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb144-27"><a href="#cb144-27" aria-hidden="true" tabindex="-1"></a>            r <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb144-28"><a href="#cb144-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> res</span>
<span id="cb144-29"><a href="#cb144-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-30"><a href="#cb144-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dp_segment_tree(arr):</span>
<span id="cb144-31"><a href="#cb144-31" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb144-32"><a href="#cb144-32" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [INF] <span class="op">*</span> n</span>
<span id="cb144-33"><a href="#cb144-33" aria-hidden="true" tabindex="-1"></a>    seg <span class="op">=</span> SegmentTree(n)</span>
<span id="cb144-34"><a href="#cb144-34" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> arr[<span class="dv">0</span>]</span>
<span id="cb144-35"><a href="#cb144-35" aria-hidden="true" tabindex="-1"></a>    seg.update(<span class="dv">0</span>, dp[<span class="dv">0</span>])</span>
<span id="cb144-36"><a href="#cb144-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb144-37"><a href="#cb144-37" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> seg.query(<span class="bu">max</span>(<span class="dv">0</span>, i <span class="op">-</span> <span class="dv">2</span>), i)  <span class="co"># e.g., range [i-2, i-1]</span></span>
<span id="cb144-38"><a href="#cb144-38" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> arr[i] <span class="op">+</span> best</span>
<span id="cb144-39"><a href="#cb144-39" aria-hidden="true" tabindex="-1"></a>        seg.update(i, dp[i])</span>
<span id="cb144-40"><a href="#cb144-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp</span>
<span id="cb144-41"><a href="#cb144-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-42"><a href="#cb144-42" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>]</span>
<span id="cb144-43"><a href="#cb144-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp_segment_tree(arr))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb145"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">100005</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> seg<span class="op">[</span><span class="dv">4</span><span class="op">*</span>N<span class="op">],</span> dp<span class="op">[</span>N<span class="op">],</span> arr<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">&lt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">(</span><span class="dt">int</span> idx<span class="op">,</span> <span class="dt">int</span> val<span class="op">,</span> <span class="dt">int</span> id<span class="op">,</span> <span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>l <span class="op">==</span> r<span class="op">)</span> <span class="op">{</span> seg<span class="op">[</span>id<span class="op">]</span> <span class="op">=</span> val<span class="op">;</span> <span class="cf">return</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>l <span class="op">+</span> r<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>idx <span class="op">&lt;=</span> mid<span class="op">)</span> update<span class="op">(</span>idx<span class="op">,</span> val<span class="op">,</span> <span class="dv">2</span><span class="op">*</span>id<span class="op">,</span> l<span class="op">,</span> mid<span class="op">);</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> update<span class="op">(</span>idx<span class="op">,</span> val<span class="op">,</span> <span class="dv">2</span><span class="op">*</span>id<span class="op">+</span><span class="dv">1</span><span class="op">,</span> mid<span class="op">+</span><span class="dv">1</span><span class="op">,</span> r<span class="op">);</span></span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a>    seg<span class="op">[</span>id<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>seg<span class="op">[</span><span class="dv">2</span><span class="op">*</span>id<span class="op">],</span> seg<span class="op">[</span><span class="dv">2</span><span class="op">*</span>id<span class="op">+</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-17"><a href="#cb145-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> query<span class="op">(</span><span class="dt">int</span> ql<span class="op">,</span> <span class="dt">int</span> qr<span class="op">,</span> <span class="dt">int</span> id<span class="op">,</span> <span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb145-18"><a href="#cb145-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>qr <span class="op">&lt;</span> l <span class="op">||</span> r <span class="op">&lt;</span> ql<span class="op">)</span> <span class="cf">return</span> INF<span class="op">;</span></span>
<span id="cb145-19"><a href="#cb145-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ql <span class="op">&lt;=</span> l <span class="op">&amp;&amp;</span> r <span class="op">&lt;=</span> qr<span class="op">)</span> <span class="cf">return</span> seg<span class="op">[</span>id<span class="op">];</span></span>
<span id="cb145-20"><a href="#cb145-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>l <span class="op">+</span> r<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb145-21"><a href="#cb145-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min<span class="op">(</span>query<span class="op">(</span>ql<span class="op">,</span> qr<span class="op">,</span> <span class="dv">2</span><span class="op">*</span>id<span class="op">,</span> l<span class="op">,</span> mid<span class="op">),</span></span>
<span id="cb145-22"><a href="#cb145-22" aria-hidden="true" tabindex="-1"></a>               query<span class="op">(</span>ql<span class="op">,</span> qr<span class="op">,</span> <span class="dv">2</span><span class="op">*</span>id<span class="op">+</span><span class="dv">1</span><span class="op">,</span> mid<span class="op">+</span><span class="dv">1</span><span class="op">,</span> r<span class="op">));</span></span>
<span id="cb145-23"><a href="#cb145-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb145-24"><a href="#cb145-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-25"><a href="#cb145-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb145-26"><a href="#cb145-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">5</span><span class="op">},</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb145-27"><a href="#cb145-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">*</span>N<span class="op">;</span> i<span class="op">++)</span> seg<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb145-28"><a href="#cb145-28" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb145-29"><a href="#cb145-29" aria-hidden="true" tabindex="-1"></a>    update<span class="op">(</span><span class="dv">0</span><span class="op">,</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb145-30"><a href="#cb145-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb145-31"><a href="#cb145-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> best <span class="op">=</span> query<span class="op">(</span>i<span class="op">-</span><span class="dv">2</span> <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">?</span> i<span class="op">-</span><span class="dv">2</span> <span class="op">:</span> <span class="dv">0</span><span class="op">,</span> i<span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb145-32"><a href="#cb145-32" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> best<span class="op">;</span></span>
<span id="cb145-33"><a href="#cb145-33" aria-hidden="true" tabindex="-1"></a>        update<span class="op">(</span>i<span class="op">,</span> dp<span class="op">[</span>i<span class="op">],</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb145-34"><a href="#cb145-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb145-35"><a href="#cb145-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb145-36"><a href="#cb145-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-68" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-68">Why It Matters</h4>
<ul>
<li>Handles range transitions efficiently</li>
<li>Reduces quadratic DPs to <span class="math inline">\(O(n \log n)\)</span></li>
<li>Works for both min and max recurrences</li>
<li>Combines with coordinate compression for complex ranges</li>
</ul>
</section>
<section id="step-by-step-example-65" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-65">Step-by-Step Example</h4>
<p>Let <span class="math inline">\(arr = [3, 1, 4, 1, 5]\)</span>, and <span class="math display">\[
dp[i] = arr[i] + \min_{j \in [i-2, i-1]} dp[j]
\]</span></p>
<ul>
<li><span class="math inline">\(i=0\)</span>: <span class="math inline">\(dp[0]=3\)</span></li>
<li><span class="math inline">\(i=1\)</span>: query <span class="math inline">\([0,0]\)</span>, <span class="math inline">\(dp[1]=1+3=4\)</span></li>
<li><span class="math inline">\(i=2\)</span>: query <span class="math inline">\([0,1]\)</span>, <span class="math inline">\(dp[2]=4+1=5\)</span></li>
<li><span class="math inline">\(i=3\)</span>: query <span class="math inline">\([1,2]\)</span>, <span class="math inline">\(dp[3]=1+4=5\)</span></li>
<li><span class="math inline">\(i=4\)</span>: query <span class="math inline">\([2,3]\)</span>, <span class="math inline">\(dp[4]=5+4=9\)</span></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-55" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-55">A Gentle Proof (Why It Works)</h4>
<p>Segment trees store range minima. Each DP state only depends on previously finalized values. As you move <span class="math inline">\(i\)</span> forward, you query and update disjoint ranges. Hence total complexity:</p>
<p><span class="math display">\[
O(n \log n) \text{ (n queries + n updates)}
\]</span></p>
<p>No recomputation, each transition is resolved via the tree in logarithmic time.</p>
</section>
<section id="try-it-yourself-68" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-68">Try It Yourself</h4>
<ol type="1">
<li>Change recurrence to max and adjust segment tree.</li>
<li>Solve weighted LIS: <span class="math inline">\(dp[i] = w_i + \max_{a_j &lt; a_i} dp[j]\)</span>.</li>
<li>Combine with coordinate compression for arbitrary <span class="math inline">\(a_i\)</span>.</li>
<li>Visualize segment tree contents over iterations.</li>
<li>Apply to interval scheduling with overlapping windows.</li>
</ol>
</section>
<section id="test-cases-68" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-68">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>arr</th>
<th>Range</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3,1,4,1,5]</td>
<td>[i-2,i-1]</td>
<td>[3,4,5,5,9]</td>
</tr>
<tr class="even">
<td>[2,2,2,2]</td>
<td>[i-1,i-1]</td>
<td>[2,4,6,8]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-68" class="level4">
<h4 class="anchored" data-anchor-id="complexity-68">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \log n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Segment Tree + DP is your range oracle, answering every interval dependency without scanning the whole past.</p>
</section>
</section>
<section id="divide-conquer-knapsack" class="level3">
<h3 class="anchored" data-anchor-id="divide-conquer-knapsack">470 Divide &amp; Conquer Knapsack</h3>
<p>Divide &amp; Conquer Knapsack is an optimization method that accelerates dynamic programming for large-capacity knapsack problems by recursively splitting the item set and combining results, rather than building a full <span class="math inline">\(O(nW)\)</span> DP table. It is especially powerful when you need to reconstruct solutions or handle queries across subsets.</p>
<section id="what-problem-are-we-solving-69" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-69">What Problem Are We Solving?</h4>
<p>The classic 0/1 Knapsack Problem is:</p>
<p><span class="math display">\[
dp[i][w] = \max(dp[i-1][w],, dp[i-1][w - w_i] + v_i)
\]</span></p>
<p>where <span class="math inline">\(w_i\)</span> is the item’s weight and <span class="math inline">\(v_i\)</span> its value.</p>
<p>This standard DP costs <span class="math inline">\(O(nW)\)</span> in time and space, which becomes infeasible when <span class="math inline">\(n\)</span> or <span class="math inline">\(W\)</span> is large.</p>
<p>Divide &amp; Conquer Knapsack tackles this by splitting items into halves and solving subproblems recursively, a strategy similar to meet-in-the-middle, but adapted to DP.</p>
</section>
<section id="when-it-applies-7" class="level4">
<h4 class="anchored" data-anchor-id="when-it-applies-7">When It Applies</h4>
<p>Use Divide &amp; Conquer Knapsack when:</p>
<ul>
<li>You have many items (<span class="math inline">\(n &gt; 1000\)</span>)</li>
<li>Capacity <span class="math inline">\(W\)</span> is large, but manageable via combinations</li>
<li>You need partial solution reconstruction</li>
<li>You want to handle batch queries (e.g., best value for each capacity range)</li>
</ul>
<p>Common contexts:</p>
<ul>
<li>Large <span class="math inline">\(n\)</span>, moderate <span class="math inline">\(W\)</span> (split across subsets)</li>
<li>Enumerating feasible states</li>
<li>Offline processing of item sets</li>
<li>Recursive solution generation (for decision trees or subset enumeration)</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-66" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-66">How Does It Work (Plain Language)</h4>
<p>Instead of building one giant DP table, we split the item list into halves:</p>
<ul>
<li>Solve left half → get all achievable <span class="math inline">\((weight, value)\)</span> pairs</li>
<li>Solve right half → same</li>
<li>Merge results efficiently (like convolution or sweep)</li>
</ul>
<p>By recursively combining subproblems, you reduce total recomputation and enable parallel merging of feasible subsets.</p>
<p>If <span class="math inline">\(n = 2^k\)</span>, recursion depth = <span class="math inline">\(O(\log n)\)</span>, and each merge costs <span class="math inline">\(O(2^{n/2})\)</span>, much faster than <span class="math inline">\(O(nW)\)</span> when <span class="math inline">\(W\)</span> is large.</p>
</section>
<section id="example-recurrence-3" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence-3">Example Recurrence</h4>
<p>Let <code>solve(l, r)</code> compute all feasible pairs for items <span class="math inline">\([l, r)\)</span>:</p>
<pre class="text"><code>If r - l == 1:
    return {(0,0), (w_l, v_l)}
Else:
    mid = (l + r) / 2
    left = solve(l, mid)
    right = solve(mid, r)
    return combine(left, right)</code></pre>
<p><code>combine</code> merges pairs from left and right (like merging sorted lists, keeping only Pareto-optimal pairs).</p>
</section>
<section id="tiny-code-easy-version-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-7">Tiny Code (Easy Version)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combine(left, right, W):</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w1, v1 <span class="kw">in</span> left:</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w2, v2 <span class="kw">in</span> right:</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> w1 <span class="op">+</span> w2</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="op">&lt;=</span> W:</span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>                res.append((w, v1 <span class="op">+</span> v2))</span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Keep only best value per weight (Pareto frontier)</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>    res.sort()</span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> []</span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>    cur <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w, v <span class="kw">in</span> res:</span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">&gt;</span> cur:</span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a>            best.append((w, v))</span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>            cur <span class="op">=</span> v</span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-18"><a href="#cb147-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve(items, W):</span>
<span id="cb147-19"><a href="#cb147-19" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(items)</span>
<span id="cb147-20"><a href="#cb147-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb147-21"><a href="#cb147-21" aria-hidden="true" tabindex="-1"></a>        w, v <span class="op">=</span> items[<span class="dv">0</span>]</span>
<span id="cb147-22"><a href="#cb147-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [(<span class="dv">0</span>, <span class="dv">0</span>), (w, v)] <span class="cf">if</span> w <span class="op">&lt;=</span> W <span class="cf">else</span> [(<span class="dv">0</span>, <span class="dv">0</span>)]</span>
<span id="cb147-23"><a href="#cb147-23" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb147-24"><a href="#cb147-24" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> solve(items[:mid], W)</span>
<span id="cb147-25"><a href="#cb147-25" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> solve(items[mid:], W)</span>
<span id="cb147-26"><a href="#cb147-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> combine(left, right, W)</span>
<span id="cb147-27"><a href="#cb147-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-28"><a href="#cb147-28" aria-hidden="true" tabindex="-1"></a>items <span class="op">=</span> [(<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">5</span>), (<span class="dv">7</span>, <span class="dv">10</span>), (<span class="dv">8</span>, <span class="dv">11</span>)]</span>
<span id="cb147-29"><a href="#cb147-29" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb147-30"><a href="#cb147-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(solve(items, W))  <span class="co"># [(0,0),(3,4),(4,5),(7,10),(8,11),(10,14)]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-69" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-69">Why It Matters</h4>
<ul>
<li>Avoids full <span class="math inline">\(O(nW)\)</span> DP when <span class="math inline">\(W\)</span> is large</li>
<li>Enables offline merging and solution reconstruction</li>
<li>Useful in meet-in-the-middle optimization</li>
<li>Can handle dynamic constraints by recombining subsets</li>
</ul>
</section>
<section id="step-by-step-example-66" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-66">Step-by-Step Example</h4>
<p>Items: <span class="math inline">\((3,4), (4,5), (7,10), (8,11)\)</span>, <span class="math inline">\(W = 10\)</span></p>
<p>Split:</p>
<ul>
<li>Left half: <span class="math inline">\((3,4), (4,5)\)</span> → feasible = {(0,0),(3,4),(4,5),(7,9)}</li>
<li>Right half: <span class="math inline">\((7,10), (8,11)\)</span> → {(0,0),(7,10),(8,11),(15,21)}</li>
</ul>
<p>Combine all <span class="math inline">\((w_L + w_R, v_L + v_R)\)</span> ≤ 10:</p>
<ul>
<li>(0,0), (3,4), (4,5), (7,9), (7,10), (8,11), (10,14)</li>
</ul>
<p>Pareto-optimal:</p>
<ul>
<li>(0,0), (3,4), (4,5), (7,10), (10,14)</li>
</ul>
<p>Max value for <span class="math inline">\(W=10\)</span>: 14</p>
</section>
<section id="a-gentle-proof-why-it-works-56" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-56">A Gentle Proof (Why It Works)</h4>
<p>By recursively splitting:</p>
<ul>
<li>Each subset’s combinations are enumerated in <span class="math inline">\(O(2^{n/2})\)</span></li>
<li>Merge step ensures only non-dominated states are carried forward</li>
<li>Recursion covers all subsets exactly once</li>
</ul>
<p>Thus, total cost ≈ <span class="math inline">\(O(2^{n/2})\)</span> instead of <span class="math inline">\(O(nW)\)</span>.</p>
<p>For moderate <span class="math inline">\(n\)</span> (≤40), this is dramatically faster.</p>
<p>For large <span class="math inline">\(n\)</span> with constraints (bounded weights), merges reduce to <span class="math inline">\(O(n \log n)\)</span> per layer.</p>
</section>
<section id="try-it-yourself-69" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-69">Try It Yourself</h4>
<ol type="1">
<li>Implement value-only knapsack (max value ≤ W)</li>
<li>Visualize Pareto frontier after each combine</li>
<li>Use recursion tree to print intermediate DP states</li>
<li>Compare against standard <span class="math inline">\(O(nW)\)</span> DP results</li>
<li>Extend to multi-dimensional weights</li>
</ol>
</section>
<section id="test-cases-69" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-69">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Items</th>
<th>W</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[(3,4),(4,5),(7,10),(8,11)]</td>
<td>10</td>
<td>14</td>
</tr>
<tr class="even">
<td>[(1,1),(2,2),(3,3)]</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>[(2,3),(3,4),(4,5)]</td>
<td>5</td>
<td>7</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-69" class="level4">
<h4 class="anchored" data-anchor-id="complexity-69">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(2^{n/2} \cdot n)\)</span> (meet-in-the-middle)</li>
<li>Space: <span class="math inline">\(O(2^{n/2})\)</span></li>
</ul>
<p>Divide &amp; Conquer Knapsack is your recursive craftsman, building optimal subsets by combining halves, not filling tables.</p>
</section>
</section>
</section>
<section id="section-48.-tree-dp-and-rerooting" class="level1">
<h1>Section 48. Tree DP and Rerooting</h1>
<section id="subtree-sum-dp" class="level3">
<h3 class="anchored" data-anchor-id="subtree-sum-dp">471 Subtree Sum DP</h3>
<p>Subtree Sum DP is one of the most fundamental patterns in tree dynamic programming. It computes the sum of values in every node’s subtree using a simple post-order traversal. Once you know how to aggregate over subtrees, you can extend the same idea to handle sizes, depths, counts, or any associative property.</p>
<section id="what-problem-are-we-solving-70" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-70">What Problem Are We Solving?</h4>
<p>Given a rooted tree where each node has a value, compute for every node the sum of values in its subtree (including itself).</p>
<p>For a node <span class="math inline">\(u\)</span> with children <span class="math inline">\(v_1, v_2, \dots, v_k\)</span>, the subtree sum is:</p>
<p><span class="math display">\[
dp[u] = value[u] + \sum_{v \in children(u)} dp[v]
\]</span></p>
<p>This idea generalizes to many forms of aggregation, such as counting nodes, finding subtree size, or computing subtree products.</p>
</section>
<section id="how-does-it-work-plain-language-67" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-67">How Does It Work (Plain Language)</h4>
<p>Think of each node as a small calculator. When a node finishes computing its children’s sums, it adds them all up, plus its own value. This is post-order traversal, compute from leaves upward.</p>
</section>
<section id="step-by-step-example-67" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-67">Step-by-Step Example</h4>
<p>Consider the tree:</p>
<pre><code>       1(5)
      /   \
   2(3)   3(2)
   / \
4(1) 5(4)</code></pre>
<p>Values:</p>
<ul>
<li>Node 1 → 5</li>
<li>Node 2 → 3</li>
<li>Node 3 → 2</li>
<li>Node 4 → 1</li>
<li>Node 5 → 4</li>
</ul>
<p>We compute bottom-up:</p>
<ul>
<li><span class="math inline">\(dp[4] = 1\)</span></li>
<li><span class="math inline">\(dp[5] = 4\)</span></li>
<li><span class="math inline">\(dp[2] = 3 + 1 + 4 = 8\)</span></li>
<li><span class="math inline">\(dp[3] = 2\)</span></li>
<li><span class="math inline">\(dp[1] = 5 + 8 + 2 = 15\)</span></li>
</ul>
<p>So the subtree sums are:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Node</th>
<th>Subtree Sum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>15</td>
</tr>
<tr class="even">
<td>2</td>
<td>8</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2</td>
</tr>
<tr class="even">
<td>4</td>
<td>1</td>
</tr>
<tr class="odd">
<td>5</td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-version-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-8">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb149"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> value<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> parent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> value<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> parent<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb149-15"><a href="#cb149-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb149-16"><a href="#cb149-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb149-17"><a href="#cb149-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb149-18"><a href="#cb149-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-19"><a href="#cb149-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb149-20"><a href="#cb149-20" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb149-21"><a href="#cb149-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">}};</span></span>
<span id="cb149-22"><a href="#cb149-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb149-23"><a href="#cb149-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb149-24"><a href="#cb149-24" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb149-25"><a href="#cb149-25" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb149-26"><a href="#cb149-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb149-27"><a href="#cb149-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vals<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">4</span><span class="op">};</span></span>
<span id="cb149-28"><a href="#cb149-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> value<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> vals<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb149-29"><a href="#cb149-29" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb149-30"><a href="#cb149-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"dp[</span><span class="sc">%d</span><span class="st">] = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb149-31"><a href="#cb149-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>value <span class="op">=</span> {<span class="dv">1</span>:<span class="dv">5</span>, <span class="dv">2</span>:<span class="dv">3</span>, <span class="dv">3</span>:<span class="dv">2</span>, <span class="dv">4</span>:<span class="dv">1</span>, <span class="dv">5</span>:<span class="dv">4</span>}</span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {}</span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>    dp[u] <span class="op">=</span> value[u]</span>
<span id="cb150-15"><a href="#cb150-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb150-16"><a href="#cb150-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb150-17"><a href="#cb150-17" aria-hidden="true" tabindex="-1"></a>        dfs(v, u)</span>
<span id="cb150-18"><a href="#cb150-18" aria-hidden="true" tabindex="-1"></a>        dp[u] <span class="op">+=</span> dp[v]</span>
<span id="cb150-19"><a href="#cb150-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-20"><a href="#cb150-20" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb150-21"><a href="#cb150-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-70" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-70">Why It Matters</h4>
<ul>
<li>A core tree DP pattern: many problems reduce to aggregating over subtrees</li>
<li>Forms the basis of rerooting DP, tree diameter, and centroid decomposition</li>
<li>Used in computing subtree sizes, subtree XOR, sum of depths, subtree counts</li>
</ul>
<p>Once you master subtree DP, you can generalize to:</p>
<ul>
<li>Max/min subtree values</li>
<li>Counting paths through nodes</li>
<li>Dynamic rerooting transitions</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-57" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-57">A Gentle Proof (Why It Works)</h4>
<p>By induction on tree depth:</p>
<ul>
<li>Base Case: For a leaf node <span class="math inline">\(u\)</span>, <span class="math inline">\(dp[u] = value[u]\)</span>, correct by definition.</li>
<li>Inductive Step: Assume all children <span class="math inline">\(v\)</span> have correct <span class="math inline">\(dp[v]\)</span>. Then <span class="math inline">\(dp[u] = value[u] + \sum dp[v]\)</span> correctly accumulates all values in <span class="math inline">\(u\)</span>’s subtree.</li>
</ul>
<p>Since every node is visited once and every edge twice, total cost is <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="try-it-yourself-70" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-70">Try It Yourself</h4>
<ol type="1">
<li>Modify the code to compute subtree size instead of sum</li>
<li>Track maximum value in each subtree</li>
<li>Extend to compute sum of depths per subtree</li>
<li>Add rerooting to compute subtree sum for every root</li>
<li>Use input parser to build arbitrary trees</li>
</ol>
</section>
<section id="test-cases-70" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-70">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Values</th>
<th>Subtree Sums</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2–3</td>
<td>{1:1,2:2,3:3}</td>
<td>{1:6, 2:5, 3:3}</td>
</tr>
<tr class="even">
<td>1–2, 1–3</td>
<td>{1:5,2:2,3:1}</td>
<td>{1:8, 2:2, 3:1}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-70" class="level4">
<h4 class="anchored" data-anchor-id="complexity-70">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> (each node visited once)</li>
<li>Space: <span class="math inline">\(O(n)\)</span> recursion + adjacency</li>
</ul>
<p>Subtree Sum DP is your first brush with tree dynamics, one traversal, full insight.</p>
</section>
</section>
<section id="diameter-dp" class="level3">
<h3 class="anchored" data-anchor-id="diameter-dp">472 Diameter DP</h3>
<p>Diameter DP computes the longest path in a tree, the <em>diameter</em>. Unlike shortest paths, the diameter is measured by the greatest distance between any two nodes, not necessarily passing through the root. Using dynamic programming, we can derive this in a single DFS traversal by combining the two deepest child paths at every node.</p>
<section id="what-problem-are-we-solving-71" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-71">What Problem Are We Solving?</h4>
<p>Given a tree with <span class="math inline">\(n\)</span> nodes (unweighted or weighted), find the diameter, i.e.&nbsp;the length of the longest simple path between any two nodes.</p>
<p>For an unweighted tree, this is measured in edges or nodes; for a weighted tree, in sum of edge weights.</p>
<p>We define a DP recurrence:</p>
<p><span class="math display">\[
dp[u] = \text{length of longest downward path from } u
\]</span></p>
<p>At each node, the diameter candidate is the sum of the two longest child paths:</p>
<p><span class="math display">\[
diameter = \max(diameter, top1 + top2)
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-68" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-68">How Does It Work (Plain Language)</h4>
<p>Think of every node as a hub connecting paths from its children. The longest path passing through a node is formed by picking its two deepest child paths and joining them. We collect this as we perform a post-order DFS.</p>
<p>In the end, the global maximum across all nodes is the tree’s diameter.</p>
</section>
<section id="step-by-step-example-68" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-68">Step-by-Step Example</h4>
<p>Tree:</p>
<pre><code>      1
     / \
    2   3
   / \
  4   5</code></pre>
<p>Each edge has weight 1.</p>
<p>Compute longest downward paths:</p>
<ul>
<li>Leaves (4, 5, 3): <span class="math inline">\(dp=0\)</span></li>
<li>Node 2: <span class="math inline">\(dp[2] = 1 + \max(dp[4], dp[5]) = 1 + 0 = 1\)</span></li>
<li>Node 1: <span class="math inline">\(dp[1] = 1 + \max(dp[2], dp[3]) = 1 + 1 = 2\)</span></li>
</ul>
<p>Now compute diameter:</p>
<ul>
<li>At node 2: top1=0, top2=0 → local diameter=0</li>
<li>At node 1: top1=1 (from 2), top2=1 (from 3) → local diameter=2</li>
</ul>
<p>So the tree diameter = 2 edges (path 4–2–1–3)</p>
</section>
<section id="tiny-code-easy-version-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-9">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb152"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> diameter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-8"><a href="#cb152-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb152-9"><a href="#cb152-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> top2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb152-10"><a href="#cb152-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb152-11"><a href="#cb152-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb152-12"><a href="#cb152-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb152-13"><a href="#cb152-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> depth <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb152-14"><a href="#cb152-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>depth <span class="op">&gt;</span> top1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb152-15"><a href="#cb152-15" aria-hidden="true" tabindex="-1"></a>            top2 <span class="op">=</span> top1<span class="op">;</span></span>
<span id="cb152-16"><a href="#cb152-16" aria-hidden="true" tabindex="-1"></a>            top1 <span class="op">=</span> depth<span class="op">;</span></span>
<span id="cb152-17"><a href="#cb152-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>depth <span class="op">&gt;</span> top2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb152-18"><a href="#cb152-18" aria-hidden="true" tabindex="-1"></a>            top2 <span class="op">=</span> depth<span class="op">;</span></span>
<span id="cb152-19"><a href="#cb152-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb152-20"><a href="#cb152-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb152-21"><a href="#cb152-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>top1 <span class="op">+</span> top2 <span class="op">&gt;</span> diameter<span class="op">)</span> diameter <span class="op">=</span> top1 <span class="op">+</span> top2<span class="op">;</span></span>
<span id="cb152-22"><a href="#cb152-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top1<span class="op">;</span></span>
<span id="cb152-23"><a href="#cb152-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb152-24"><a href="#cb152-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-25"><a href="#cb152-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb152-26"><a href="#cb152-26" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb152-27"><a href="#cb152-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">}};</span></span>
<span id="cb152-28"><a href="#cb152-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb152-29"><a href="#cb152-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb152-30"><a href="#cb152-30" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb152-31"><a href="#cb152-31" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb152-32"><a href="#cb152-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb152-33"><a href="#cb152-33" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb152-34"><a href="#cb152-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Tree diameter: </span><span class="sc">%d</span><span class="st"> edges</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> diameter<span class="op">);</span></span>
<span id="cb152-35"><a href="#cb152-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>diameter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> diameter</span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a>    top1 <span class="op">=</span> top2 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb153-16"><a href="#cb153-16" aria-hidden="true" tabindex="-1"></a>        depth <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dfs(v, u)</span>
<span id="cb153-17"><a href="#cb153-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> depth <span class="op">&gt;</span> top1:</span>
<span id="cb153-18"><a href="#cb153-18" aria-hidden="true" tabindex="-1"></a>            top2 <span class="op">=</span> top1</span>
<span id="cb153-19"><a href="#cb153-19" aria-hidden="true" tabindex="-1"></a>            top1 <span class="op">=</span> depth</span>
<span id="cb153-20"><a href="#cb153-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> depth <span class="op">&gt;</span> top2:</span>
<span id="cb153-21"><a href="#cb153-21" aria-hidden="true" tabindex="-1"></a>            top2 <span class="op">=</span> depth</span>
<span id="cb153-22"><a href="#cb153-22" aria-hidden="true" tabindex="-1"></a>    diameter <span class="op">=</span> <span class="bu">max</span>(diameter, top1 <span class="op">+</span> top2)</span>
<span id="cb153-23"><a href="#cb153-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top1</span>
<span id="cb153-24"><a href="#cb153-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-25"><a href="#cb153-25" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb153-26"><a href="#cb153-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Tree diameter:"</span>, diameter)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-71" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-71">Why It Matters</h4>
<ul>
<li>Central building block for tree analysis, network radius, center finding</li>
<li>Used in problems involving longest paths, tree heights, centroid decomposition</li>
<li>Serves as a key step in rerooting or centroid algorithms</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-58" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-58">A Gentle Proof (Why It Works)</h4>
<p>Let’s prove correctness by induction:</p>
<ul>
<li>Base Case: A leaf node has <span class="math inline">\(dp[u] = 0\)</span>, no contribution beyond itself.</li>
<li>Inductive Step: For each internal node <span class="math inline">\(u\)</span>, if all children <span class="math inline">\(v\)</span> correctly compute their longest downward paths <span class="math inline">\(dp[v]\)</span>, then combining the two largest gives the longest path through <span class="math inline">\(u\)</span>. Since every path in a tree passes through some lowest common ancestor <span class="math inline">\(u\)</span>, our DFS finds the true maximum globally.</li>
</ul>
</section>
<section id="try-it-yourself-71" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-71">Try It Yourself</h4>
<ol type="1">
<li>Modify the code for weighted edges</li>
<li>Return both endpoints of the diameter path</li>
<li>Compare with two-pass BFS method (pick farthest node twice)</li>
<li>Extend to compute height of each subtree alongside</li>
<li>Visualize recursion tree with local diameters</li>
</ol>
</section>
<section id="test-cases-71" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-71">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Diameter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line: 1–2–3–4</td>
<td>3 edges</td>
</tr>
<tr class="even">
<td>Star: 1–{2,3,4,5}</td>
<td>2 edges</td>
</tr>
<tr class="odd">
<td>Balanced binary tree (depth 2)</td>
<td>4 edges</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-71" class="level4">
<h4 class="anchored" data-anchor-id="complexity-71">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span> recursion stack</li>
</ul>
<p>Diameter DP is the lens that reveals the tree’s longest breath, one sweep, full span.</p>
</section>
</section>
<section id="independent-set-dp" class="level3">
<h3 class="anchored" data-anchor-id="independent-set-dp">473 Independent Set DP</h3>
<p>Independent Set DP finds the largest set of nodes in a tree such that no two chosen nodes are adjacent. This is a classic tree dynamic programming problem, showcasing the fundamental trade-off between inclusion and exclusion at each node.</p>
<section id="what-problem-are-we-solving-72" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-72">What Problem Are We Solving?</h4>
<p>Given a tree with <span class="math inline">\(n\)</span> nodes (each possibly having a weight), find the maximum-weight independent set, a subset of nodes such that no two connected nodes are selected.</p>
<p>For each node <span class="math inline">\(u\)</span>, we maintain two DP states:</p>
<ul>
<li><span class="math inline">\(dp[u][0]\)</span>: maximum value in <span class="math inline">\(u\)</span>’s subtree when <span class="math inline">\(u\)</span> is not chosen</li>
<li><span class="math inline">\(dp[u][1]\)</span>: maximum value in <span class="math inline">\(u\)</span>’s subtree when <span class="math inline">\(u\)</span> is chosen</li>
</ul>
<p>The recurrence:</p>
<p><span class="math display">\[
dp[u][0] = \sum_{v \in children(u)} \max(dp[v][0], dp[v][1])
\]</span></p>
<p><span class="math display">\[
dp[u][1] = value[u] + \sum_{v \in children(u)} dp[v][0]
\]</span></p>
<p>The answer is <span class="math inline">\(\max(dp[root][0], dp[root][1])\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-69" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-69">How Does It Work (Plain Language)</h4>
<p>Each node decides:</p>
<ul>
<li>If it includes itself, it excludes its children</li>
<li>If it excludes itself, it can take the best of each child</li>
</ul>
<p>This “take-or-skip” strategy flows bottom-up from leaves to root.</p>
</section>
<section id="step-by-step-example-69" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-69">Step-by-Step Example</h4>
<p>Tree:</p>
<pre><code>      1(3)
     /   \
   2(2)  3(1)
   /
 4(4)</code></pre>
<p>Values in parentheses.</p>
<p>Compute DP from bottom:</p>
<ul>
<li><p>Node 4: <span class="math inline">\(dp[4][0]=0\)</span>, <span class="math inline">\(dp[4][1]=4\)</span></p></li>
<li><p>Node 2: <span class="math inline">\(dp[2][0]=\max(dp[4][0],dp[4][1])=4\)</span> <span class="math inline">\(dp[2][1]=2+dp[4][0]=2+0=2\)</span></p></li>
<li><p>Node 3: <span class="math inline">\(dp[3][0]=0\)</span>, <span class="math inline">\(dp[3][1]=1\)</span></p></li>
<li><p>Node 1: <span class="math inline">\(dp[1][0]=\max(dp[2][0],dp[2][1])+\max(dp[3][0],dp[3][1])=4+1=5\)</span> <span class="math inline">\(dp[1][1]=3+dp[2][0]+dp[3][0]=3+4+0=7\)</span></p></li>
</ul>
<p>Answer: <span class="math inline">\(\max(5,7)=7\)</span></p>
<p>Best set = {1,4}</p>
</section>
<section id="tiny-code-easy-version-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-10">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb155"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> value<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> visited<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> value<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb155-15"><a href="#cb155-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb155-16"><a href="#cb155-16" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb155-17"><a href="#cb155-17" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> <span class="op">(</span>dp<span class="op">[</span>v<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&gt;</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb155-18"><a href="#cb155-18" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb155-19"><a href="#cb155-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb155-20"><a href="#cb155-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb155-21"><a href="#cb155-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-22"><a href="#cb155-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb155-23"><a href="#cb155-23" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb155-24"><a href="#cb155-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">}};</span></span>
<span id="cb155-25"><a href="#cb155-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb155-26"><a href="#cb155-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb155-27"><a href="#cb155-27" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb155-28"><a href="#cb155-28" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb155-29"><a href="#cb155-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb155-30"><a href="#cb155-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vals<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">4</span><span class="op">};</span></span>
<span id="cb155-31"><a href="#cb155-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> value<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> vals<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb155-32"><a href="#cb155-32" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb155-33"><a href="#cb155-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&gt;</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb155-34"><a href="#cb155-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max independent set sum: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb155-35"><a href="#cb155-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>)]</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a>value <span class="op">=</span> {<span class="dv">1</span>:<span class="dv">3</span>, <span class="dv">2</span>:<span class="dv">2</span>, <span class="dv">3</span>:<span class="dv">1</span>, <span class="dv">4</span>:<span class="dv">4</span>}</span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {}</span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb156-13"><a href="#cb156-13" aria-hidden="true" tabindex="-1"></a>    include <span class="op">=</span> value[u]</span>
<span id="cb156-14"><a href="#cb156-14" aria-hidden="true" tabindex="-1"></a>    exclude <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb156-15"><a href="#cb156-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb156-16"><a href="#cb156-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb156-17"><a href="#cb156-17" aria-hidden="true" tabindex="-1"></a>        dfs(v, u)</span>
<span id="cb156-18"><a href="#cb156-18" aria-hidden="true" tabindex="-1"></a>        include <span class="op">+=</span> dp[v][<span class="dv">0</span>]</span>
<span id="cb156-19"><a href="#cb156-19" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">+=</span> <span class="bu">max</span>(dp[v][<span class="dv">0</span>], dp[v][<span class="dv">1</span>])</span>
<span id="cb156-20"><a href="#cb156-20" aria-hidden="true" tabindex="-1"></a>    dp[u] <span class="op">=</span> (exclude, include)</span>
<span id="cb156-21"><a href="#cb156-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-22"><a href="#cb156-22" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb156-23"><a href="#cb156-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max independent set sum:"</span>, <span class="bu">max</span>(dp[<span class="dv">1</span>]))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-72" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-72">Why It Matters</h4>
<ul>
<li>Foundation for tree-based constraint problems</li>
<li>Used in network stability, resource allocation, scheduling</li>
<li>Extensible to weighted graphs, forests, ranged constraints</li>
</ul>
<p>Patterns derived from this:</p>
<ul>
<li>Vertex cover (complement)</li>
<li>House robber on trees</li>
<li>Dynamic inclusion-exclusion states</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-59" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-59">A Gentle Proof (Why It Works)</h4>
<p>We prove by induction:</p>
<ul>
<li>Base case: Leaf node <span class="math inline">\(u\)</span> has <span class="math inline">\(dp[u][1]=value[u]\)</span>, <span class="math inline">\(dp[u][0]=0\)</span>, correct.</li>
<li>Inductive step: For any node <span class="math inline">\(u\)</span>, if all subtrees compute optimal values, including <span class="math inline">\(u\)</span> adds its value and excludes children (<span class="math inline">\(dp[v][0]\)</span>), excluding <span class="math inline">\(u\)</span> allows best child choice (<span class="math inline">\(\max(dp[v][0], dp[v][1])\)</span>). Thus each subtree is optimal, ensuring global optimality.</li>
</ul>
</section>
<section id="try-it-yourself-72" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-72">Try It Yourself</h4>
<ol type="1">
<li>Extend to weighted edges (where cost is per edge)</li>
<li>Modify to reconstruct chosen nodes</li>
<li>Implement for forest (multiple trees)</li>
<li>Compare with vertex cover DP</li>
<li>Apply to House Robber III (Leetcode 337)</li>
</ol>
</section>
<section id="test-cases-72" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-72">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Values</th>
<th>Answer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2–3</td>
<td>{1:3,2:2,3:1}</td>
<td>{1,3} sum=4</td>
</tr>
<tr class="even">
<td>Star 1–{2,3,4}</td>
<td>{1:5, others:3}</td>
<td>{2,3,4} sum=9</td>
</tr>
<tr class="odd">
<td>Chain 1–2–3–4</td>
<td>{1:1,2:4,3:5,4:4}</td>
<td>{2,4} sum=8</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-72" class="level4">
<h4 class="anchored" data-anchor-id="complexity-72">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span> recursion</li>
</ul>
<p>Independent Set DP captures the tree’s quiet balance, every node’s choice echoes through its branches.</p>
</section>
</section>
<section id="vertex-cover-dp" class="level3">
<h3 class="anchored" data-anchor-id="vertex-cover-dp">474 Vertex Cover DP</h3>
<p>Vertex Cover DP solves a classic tree optimization problem: choose the smallest set of nodes such that every edge in the tree has at least one endpoint selected. This complements the Independent Set DP, together they form a dual pair in combinatorial optimization.</p>
<section id="what-problem-are-we-solving-73" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-73">What Problem Are We Solving?</h4>
<p>Given a tree with <span class="math inline">\(n\)</span> nodes, find the minimum vertex cover, i.e.&nbsp;a smallest subset of nodes such that every edge <span class="math inline">\((u,v)\)</span> has <span class="math inline">\(u\)</span> or <span class="math inline">\(v\)</span> in the set.</p>
<p>We define two states for each node <span class="math inline">\(u\)</span>:</p>
<ul>
<li><span class="math inline">\(dp[u][0]\)</span>: minimum size of vertex cover in subtree rooted at <span class="math inline">\(u\)</span>, when <span class="math inline">\(u\)</span> is not included</li>
<li><span class="math inline">\(dp[u][1]\)</span>: minimum size of vertex cover in subtree rooted at <span class="math inline">\(u\)</span>, when <span class="math inline">\(u\)</span> is included</li>
</ul>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[u][0] = \sum_{v \in children(u)} dp[v][1]
\]</span></p>
<p><span class="math display">\[
dp[u][1] = 1 + \sum_{v \in children(u)} \min(dp[v][0], dp[v][1])
\]</span></p>
<p>If <span class="math inline">\(u\)</span> is not in the cover, all its children must be included to cover edges <span class="math inline">\((u,v)\)</span>. If <span class="math inline">\(u\)</span> is included, each child can choose whether or not to join the cover.</p>
<p>Answer: <span class="math inline">\(\min(dp[root][0], dp[root][1])\)</span></p>
</section>
<section id="how-does-it-work-plain-language-70" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-70">How Does It Work (Plain Language)</h4>
<p>Each node decides whether to take responsibility for covering edges or delegate that responsibility to its children. This is a mutual-exclusion constraint:</p>
<ul>
<li>If <span class="math inline">\(u\)</span> is excluded, its children must be included.</li>
<li>If <span class="math inline">\(u\)</span> is included, each child is free to choose.</li>
</ul>
</section>
<section id="step-by-step-example-70" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-70">Step-by-Step Example</h4>
<p>Tree:</p>
<pre><code>    1
   / \
  2   3
 / \
4   5</code></pre>
<p>We compute bottom-up:</p>
<ul>
<li><p>Leaves 4,5: <span class="math inline">\(dp[4][0]=0\)</span>, <span class="math inline">\(dp[4][1]=1\)</span> <span class="math inline">\(dp[5][0]=0\)</span>, <span class="math inline">\(dp[5][1]=1\)</span></p></li>
<li><p>Node 2: <span class="math inline">\(dp[2][0]=dp[4][1]+dp[5][1]=2\)</span> <span class="math inline">\(dp[2][1]=1+\min(dp[4][0],dp[4][1])+\min(dp[5][0],dp[5][1])=1+0+0=1\)</span></p></li>
<li><p>Node 3: <span class="math inline">\(dp[3][0]=0\)</span>, <span class="math inline">\(dp[3][1]=1\)</span></p></li>
<li><p>Node 1: <span class="math inline">\(dp[1][0]=dp[2][1]+dp[3][1]=1+1=2\)</span> <span class="math inline">\(dp[1][1]=1+\min(dp[2][0],dp[2][1])+\min(dp[3][0],dp[3][1])=1+1+0=2\)</span></p></li>
</ul>
<p>Result: <span class="math inline">\(\min(2,2)=2\)</span></p>
<p>Minimum vertex cover size = 2</p>
</section>
<section id="tiny-code-easy-version-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-11">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb158"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> visited<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb158-13"><a href="#cb158-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb158-14"><a href="#cb158-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb158-15"><a href="#cb158-15" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb158-16"><a href="#cb158-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb158-17"><a href="#cb158-17" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">+=</span> <span class="op">(</span>dp<span class="op">[</span>v<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> dp<span class="op">[</span>v<span class="op">][</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb158-18"><a href="#cb158-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb158-19"><a href="#cb158-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb158-20"><a href="#cb158-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-21"><a href="#cb158-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb158-22"><a href="#cb158-22" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb158-23"><a href="#cb158-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">}};</span></span>
<span id="cb158-24"><a href="#cb158-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb158-25"><a href="#cb158-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb158-26"><a href="#cb158-26" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb158-27"><a href="#cb158-27" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb158-28"><a href="#cb158-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb158-29"><a href="#cb158-29" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb158-30"><a href="#cb158-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb158-31"><a href="#cb158-31" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Minimum vertex cover: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb158-32"><a href="#cb158-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb159"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {}</span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a>    include <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a>    exclude <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb159-15"><a href="#cb159-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb159-16"><a href="#cb159-16" aria-hidden="true" tabindex="-1"></a>        dfs(v, u)</span>
<span id="cb159-17"><a href="#cb159-17" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">+=</span> dp[v][<span class="dv">1</span>]</span>
<span id="cb159-18"><a href="#cb159-18" aria-hidden="true" tabindex="-1"></a>        include <span class="op">+=</span> <span class="bu">min</span>(dp[v][<span class="dv">0</span>], dp[v][<span class="dv">1</span>])</span>
<span id="cb159-19"><a href="#cb159-19" aria-hidden="true" tabindex="-1"></a>    dp[u] <span class="op">=</span> (exclude, include)</span>
<span id="cb159-20"><a href="#cb159-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-21"><a href="#cb159-21" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb159-22"><a href="#cb159-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Minimum vertex cover:"</span>, <span class="bu">min</span>(dp[<span class="dv">1</span>]))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-73" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-73">Why It Matters</h4>
<ul>
<li>Fundamental for constraint satisfaction problems on trees</li>
<li>Dual to Independent Set DP (by complement)</li>
<li>Used in network design, task monitoring, sensor placement</li>
</ul>
<p>Many graph algorithms (on trees) rely on this cover-or-skip dichotomy, including:</p>
<ul>
<li>Dominating sets</li>
<li>Guard problems</li>
<li>Minimum cameras in binary tree (Leetcode 968)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-60" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-60">A Gentle Proof (Why It Works)</h4>
<p>By induction:</p>
<ul>
<li><p>Base case: Leaf <span class="math inline">\(u\)</span>: <span class="math inline">\(dp[u][0]=0\)</span> (if not covered, edge must be covered by parent), <span class="math inline">\(dp[u][1]=1\)</span> (include self).</p></li>
<li><p>Inductive step: If all children have optimal covers,</p>
<ul>
<li>Excluding <span class="math inline">\(u\)</span> forces inclusion of all <span class="math inline">\(v\)</span> (ensures edges <span class="math inline">\((u,v)\)</span> covered).</li>
<li>Including <span class="math inline">\(u\)</span> allows flexible optimal choices for children. Each node’s local decision yields global minimality since the tree has no cycles.</li>
</ul></li>
</ul>
</section>
<section id="try-it-yourself-73" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-73">Try It Yourself</h4>
<ol type="1">
<li>Print actual cover set (backtrack from DP)</li>
<li>Extend to weighted vertex cover (replace count with sum of weights)</li>
<li>Compare with Independent Set DP, show complement sizes</li>
<li>Implement iterative version using post-order</li>
<li>Apply to Minimum Cameras in Binary Tree</li>
</ol>
</section>
<section id="test-cases-73" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-73">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Result</th>
<th>Cover</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2–3</td>
<td>1–2–3</td>
<td>{2}</td>
</tr>
<tr class="even">
<td>Star 1–{2,3,4,5}</td>
<td>{1}</td>
<td></td>
</tr>
<tr class="odd">
<td>Chain 1–2–3–4</td>
<td>{2,4} or {1,3}</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-73" class="level4">
<h4 class="anchored" data-anchor-id="complexity-73">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Vertex Cover DP shows how including a node protects its edges, balancing economy and completeness across the tree.</p>
</section>
</section>
<section id="path-counting-dp" class="level3">
<h3 class="anchored" data-anchor-id="path-counting-dp">475 Path Counting DP</h3>
<p>Path Counting DP is a gentle entry point into tree combinatorics, it helps you count how many distinct paths exist under certain conditions, such as from root to leaves, between pairs, or with specific constraints. It builds intuition for counting with structure rather than brute force.</p>
<section id="what-problem-are-we-solving-74" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-74">What Problem Are We Solving?</h4>
<p>Given a tree with <span class="math inline">\(n\)</span> nodes, we want to count paths satisfying some property. The simplest form is counting the number of root-to-leaf paths, but we can generalize to:</p>
<ul>
<li>Total number of paths between all pairs</li>
<li>Paths with weight constraints</li>
<li>Paths with certain node properties</li>
</ul>
<p>We’ll start with the fundamental version, root-to-leaf paths.</p>
<p>Define:</p>
<p><span class="math display">\[
dp[u] = \text{number of paths starting at } u
\]</span></p>
<p>For a rooted tree, each node’s paths equal the sum of paths from its children. If <span class="math inline">\(u\)</span> is a leaf, it contributes <span class="math inline">\(1\)</span> path (just itself):</p>
<p><span class="math display">\[
dp[u] =
\begin{cases}
1, &amp; \text{if } u \text{ is a leaf},\\
\displaystyle\sum_{v \in \text{children}(u)} dp[v], &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>The total number of root-to-leaf paths = <span class="math inline">\(dp[root]\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-71" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-71">How Does It Work (Plain Language)</h4>
<p>Start at the leaves, each leaf is one complete path. Each parent accumulates paths from its children: “Every path from my child forms one from me too.” This propagates upward until the root holds the total count.</p>
</section>
<section id="step-by-step-example-71" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-71">Step-by-Step Example</h4>
<p>Tree:</p>
<pre><code>      1
     / \
    2   3
   / \
  4   5</code></pre>
<p>Compute <span class="math inline">\(dp\)</span> from leaves upward:</p>
<ul>
<li><span class="math inline">\(dp[4] = 1\)</span>, <span class="math inline">\(dp[5] = 1\)</span>, <span class="math inline">\(dp[3] = 1\)</span></li>
<li><span class="math inline">\(dp[2] = dp[4] + dp[5] = 2\)</span></li>
<li><span class="math inline">\(dp[1] = dp[2] + dp[3] = 3\)</span></li>
</ul>
<p>So there are 3 root-to-leaf paths:</p>
<ol type="1">
<li>1–2–4</li>
<li>1–2–5</li>
<li>1–3</li>
</ol>
</section>
<section id="tiny-code-easy-version-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-12">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb161"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> isLeaf <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb161-14"><a href="#cb161-14" aria-hidden="true" tabindex="-1"></a>        isLeaf <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb161-15"><a href="#cb161-15" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb161-16"><a href="#cb161-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb161-17"><a href="#cb161-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>isLeaf<span class="op">)</span> <span class="cf">return</span> dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb161-18"><a href="#cb161-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> count<span class="op">;</span></span>
<span id="cb161-19"><a href="#cb161-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb161-20"><a href="#cb161-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-21"><a href="#cb161-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb161-22"><a href="#cb161-22" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb161-23"><a href="#cb161-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">}};</span></span>
<span id="cb161-24"><a href="#cb161-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb161-25"><a href="#cb161-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb161-26"><a href="#cb161-26" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb161-27"><a href="#cb161-27" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb161-28"><a href="#cb161-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb161-29"><a href="#cb161-29" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb161-30"><a href="#cb161-30" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Root-to-leaf paths: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb161-31"><a href="#cb161-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {}</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a>    is_leaf <span class="op">=</span> <span class="va">True</span></span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb162-15"><a href="#cb162-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb162-16"><a href="#cb162-16" aria-hidden="true" tabindex="-1"></a>        is_leaf <span class="op">=</span> <span class="va">False</span></span>
<span id="cb162-17"><a href="#cb162-17" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> dfs(v, u)</span>
<span id="cb162-18"><a href="#cb162-18" aria-hidden="true" tabindex="-1"></a>    dp[u] <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> is_leaf <span class="cf">else</span> count</span>
<span id="cb162-19"><a href="#cb162-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[u]</span>
<span id="cb162-20"><a href="#cb162-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-21"><a href="#cb162-21" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb162-22"><a href="#cb162-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Root-to-leaf paths:"</span>, dp[<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-74" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-74">Why It Matters</h4>
<ul>
<li>Foundation for counting problems on trees</li>
<li>Forms the basis of path-sum DP, tree DP rerooting, and combinatorial enumeration</li>
<li>Essential in probabilistic models and decision trees</li>
<li>Useful for probability propagation and branching process simulation</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-61" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-61">A Gentle Proof (Why It Works)</h4>
<p>We can prove by induction:</p>
<ul>
<li>Base case: Leaf node <span class="math inline">\(u\)</span> has exactly one path, itself. So <span class="math inline">\(dp[u]=1\)</span>.</li>
<li>Inductive step: Assume all children <span class="math inline">\(v\)</span> compute correct counts <span class="math inline">\(dp[v]\)</span>. Then <span class="math inline">\(dp[u] = \sum dp[v]\)</span> counts all distinct root-to-leaf paths passing through <span class="math inline">\(u\)</span>.</li>
</ul>
<p>Since every path is uniquely identified by its first branching decision, we never double-count.</p>
</section>
<section id="try-it-yourself-74" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-74">Try It Yourself</h4>
<ol type="1">
<li>Modify to count all simple paths (pairs <span class="math inline">\((u,v)\)</span>).</li>
<li>Add edge weights and count paths with total sum <span class="math inline">\(\le K\)</span>.</li>
<li>Track and print all root-to-leaf paths using recursion stack.</li>
<li>Extend to directed acyclic graphs (DAGs).</li>
<li>Combine with rerooting to count paths through each node.</li>
</ol>
</section>
<section id="test-cases-74" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-74">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Paths</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2–3</td>
<td>1 path</td>
</tr>
<tr class="even">
<td>Star (1–{2,3,4})</td>
<td>3 paths</td>
</tr>
<tr class="odd">
<td>Binary tree depth 2</td>
<td>3 paths</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-74" class="level4">
<h4 class="anchored" data-anchor-id="complexity-74">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> (each node visited once)</li>
<li>Space: <span class="math inline">\(O(n)\)</span> recursion</li>
</ul>
<p>Path Counting DP shows how structure transforms into number, one traversal, all paths accounted.</p>
</section>
</section>
<section id="dp-on-rooted-tree" class="level3">
<h3 class="anchored" data-anchor-id="dp-on-rooted-tree">476 DP on Rooted Tree</h3>
<p>DP on Rooted Tree is the most general pattern of tree dynamic programming, it teaches you to reason about <em>states</em> on hierarchical structures. Every subtree contributes partial answers, and a parent combines them. This is the building block for almost every tree-based DP: sums, counts, distances, constraints, and beyond.</p>
<section id="what-problem-are-we-solving-75" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-75">What Problem Are We Solving?</h4>
<p>We want to compute a property for each node based on its subtree, things like:</p>
<ul>
<li>Subtree sum</li>
<li>Subtree size</li>
<li>Maximum depth</li>
<li>Path counts</li>
<li>Modular products</li>
<li>Combinatorial counts</li>
</ul>
<p>Given a rooted tree, we define a DP function that recursively collects results from each child and aggregates them.</p>
<p>Generic form:</p>
<p><span class="math display">\[
dp[u] = f(u, {dp[v] : v \in children(u)})
\]</span></p>
<p>You define:</p>
<ul>
<li>Base case (usually for leaves)</li>
<li>Transition function (combine children’s results)</li>
<li>Merge operation (sum, max, min, multiply, etc.)</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-72" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-72">How Does It Work (Plain Language)</h4>
<p>You think from the leaves upward. Each node:</p>
<ol type="1">
<li>Collects results from its children.</li>
<li>Applies a combining function.</li>
<li>Stores a final value.</li>
</ol>
<p>This bottom-up reasoning mirrors <em>post-order traversal</em>, solve children first, then parent.</p>
<p>The power is that <span class="math inline">\(f\)</span> can represent <em>any operation</em>: sum, min, max, or even bitmask merge.</p>
</section>
<section id="step-by-step-example-72" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-72">Step-by-Step Example</h4>
<p>Let’s compute subtree size for every node (number of nodes in its subtree):</p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[u] = 1 + \sum_{v \in children(u)} dp[v]
\]</span></p>
<p>Tree:</p>
<pre><code>      1
     / \
    2   3
   / \
  4   5</code></pre>
<p>Compute bottom-up:</p>
<ul>
<li><span class="math inline">\(dp[4]=1\)</span>, <span class="math inline">\(dp[5]=1\)</span></li>
<li><span class="math inline">\(dp[2]=1+1+1=3\)</span></li>
<li><span class="math inline">\(dp[3]=1\)</span></li>
<li><span class="math inline">\(dp[1]=1+3+1=5\)</span></li>
</ul>
<p>So:</p>
<ul>
<li><span class="math inline">\(dp[1]=5\)</span></li>
<li><span class="math inline">\(dp[2]=3\)</span></li>
<li><span class="math inline">\(dp[3]=1\)</span></li>
<li><span class="math inline">\(dp[4]=1\)</span></li>
<li><span class="math inline">\(dp[5]=1\)</span></li>
</ul>
</section>
<section id="tiny-code-easy-version-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-13">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb164"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// count itself</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb164-19"><a href="#cb164-19" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb164-20"><a href="#cb164-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">}};</span></span>
<span id="cb164-21"><a href="#cb164-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb164-22"><a href="#cb164-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb164-23"><a href="#cb164-23" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb164-24"><a href="#cb164-24" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb164-25"><a href="#cb164-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb164-26"><a href="#cb164-26" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb164-27"><a href="#cb164-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb164-28"><a href="#cb164-28" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"dp[</span><span class="sc">%d</span><span class="st">] = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb164-29"><a href="#cb164-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {}</span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb165-12"><a href="#cb165-12" aria-hidden="true" tabindex="-1"></a>    dp[u] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb165-13"><a href="#cb165-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb165-14"><a href="#cb165-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb165-15"><a href="#cb165-15" aria-hidden="true" tabindex="-1"></a>        dp[u] <span class="op">+=</span> dfs(v, u)</span>
<span id="cb165-16"><a href="#cb165-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[u]</span>
<span id="cb165-17"><a href="#cb165-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-18"><a href="#cb165-18" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb165-19"><a href="#cb165-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-75" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-75">Why It Matters</h4>
<ul>
<li>Core template for any tree DP problem</li>
<li>Powers algorithms like subtree sum, depth counting, modular product aggregation, path count, and rerooting</li>
<li>Foundation for advanced rerooting DP, where answers depend on parent and sibling states</li>
</ul>
<p>Once you master this pattern, you can:</p>
<ul>
<li>Change the recurrence → change the problem</li>
<li>Add constraints → introduce multiple DP states</li>
<li>Extend to graphs with DAG structure</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-62" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-62">A Gentle Proof (Why It Works)</h4>
<p>Induction on tree height:</p>
<ul>
<li>Base case: Leaf <span class="math inline">\(u\)</span> → <span class="math inline">\(dp[u]\)</span> initialized to base (e.g.&nbsp;1 or value[u]).</li>
<li>Inductive step: Suppose all children <span class="math inline">\(v\)</span> compute correct <span class="math inline">\(dp[v]\)</span>. Then <span class="math inline">\(f(u, {dp[v]})\)</span> aggregates subtree results correctly.</li>
</ul>
<p>Since trees are acyclic, post-order guarantees children are processed first, correctness follows.</p>
</section>
<section id="try-it-yourself-75" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-75">Try It Yourself</h4>
<ol type="1">
<li>Change recurrence to compute sum of subtree values.</li>
<li>Compute maximum subtree depth.</li>
<li>Track count of leaves in each subtree.</li>
<li>Extend to two-state DP, e.g.&nbsp;include/exclude logic.</li>
<li>Combine with rerooting to compute value for every root.</li>
</ol>
</section>
<section id="test-cases-75" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-75">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Subtree Sizes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2–3</td>
<td>{1:3, 2:2, 3:1}</td>
</tr>
<tr class="even">
<td>Star 1–{2,3,4,5}</td>
<td>{1:5, others:1}</td>
</tr>
<tr class="odd">
<td>Chain 1–2–3–4</td>
<td>{1:4,2:3,3:2,4:1}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-75" class="level4">
<h4 class="anchored" data-anchor-id="complexity-75">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span> recursion</li>
</ul>
<p>DP on Rooted Tree is your <em>canvas</em>, define <span class="math inline">\(f\)</span>, and paint the structure’s logic across its branches.</p>
</section>
</section>
<section id="rerooting-technique" class="level3">
<h3 class="anchored" data-anchor-id="rerooting-technique">477 Rerooting Technique</h3>
<p>The Rerooting Technique is a powerful pattern in tree dynamic programming that allows you to compute results for every node as root, in linear time. Instead of recalculating from scratch for each root, we “reroot” efficiently by reusing already computed subtree results.</p>
<section id="what-problem-are-we-solving-76" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-76">What Problem Are We Solving?</h4>
<p>Suppose we’ve computed a property (like subtree sum, subtree size, distance sum) rooted at a fixed node, say node <span class="math inline">\(1\)</span>. Now we want to compute the same property for all nodes as root, for example:</p>
<ul>
<li>Sum of distances from each node to all others</li>
<li>Size or cost of each subtree when rooted differently</li>
<li>Count of paths or contributions that depend on root position</li>
</ul>
<p>We define:</p>
<p><span class="math display">\[
dp[u] = f({dp[v]}_{v \in children(u)})
\]</span></p>
<p>But we also want <span class="math inline">\(res[u]\)</span>, the answer when the tree is rooted at <span class="math inline">\(u\)</span>.</p>
<p>By rerooting, we can transfer results along edges, moving the root and updating only local contributions.</p>
</section>
<section id="how-does-it-work-plain-language-73" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-73">How Does It Work (Plain Language)</h4>
<p>We first perform a post-order DFS to compute <span class="math inline">\(dp[u]\)</span> for every node as if the root were fixed (e.g.&nbsp;node 1).</p>
<p>Then, a second pre-order DFS “pushes” results outward — when moving root from parent <span class="math inline">\(u\)</span> to child <span class="math inline">\(v\)</span>, we adjust contributions:</p>
<ul>
<li>Remove child’s part from parent</li>
<li>Add parent’s part to child</li>
</ul>
<p>Each rerooting step updates <span class="math inline">\(res[v]\)</span> from <span class="math inline">\(res[u]\)</span> in constant or small time.</p>
<p>This two-pass structure is the hallmark of rerooting DP:</p>
<ol type="1">
<li>Downward pass: gather subtree results</li>
<li>Upward pass: propagate parent contributions</li>
</ol>
</section>
<section id="step-by-step-example-sum-of-distances" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-sum-of-distances">Step-by-Step Example: Sum of Distances</h4>
<p>Goal: for each node, compute sum of distances to all other nodes.</p>
<p>Tree:</p>
<pre><code>      1
     / \
    2   3
   / \
  4   5</code></pre>
<p>Step 1: Post-order (subtree sums + sizes)</p>
<p>For each node:</p>
<ul>
<li><span class="math inline">\(subtree_size[u]\)</span> = number of nodes in subtree of <span class="math inline">\(u\)</span></li>
<li><span class="math inline">\(dp[u]\)</span> = sum of distances from <span class="math inline">\(u\)</span> to nodes in its subtree</li>
</ul>
<p>Recurrence:</p>
<p><span class="math display">\[
subtree_size[u] = 1 + \sum subtree_size[v]
\]</span></p>
<p><span class="math display">\[
dp[u] = \sum (dp[v] + subtree_size[v])
\]</span></p>
<p>At root (1), <span class="math inline">\(dp[1]=8\)</span> (sum of distances from 1 to all nodes).</p>
<p>Step 2: Pre-order (rerooting)</p>
<p>When rerooting from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>:</p>
<ul>
<li>Moving root away from <span class="math inline">\(v\)</span> adds <span class="math inline">\((n - subtree_size[v])\)</span></li>
<li>Moving root toward <span class="math inline">\(v\)</span> subtracts <span class="math inline">\(subtree_size[v]\)</span></li>
</ul>
<p>So: <span class="math display">\[
dp[v] = dp[u] + (n - 2 \times subtree_size[v])
\]</span></p>
<p>Now every node has its distance sum in <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="tiny-code-sum-of-distances" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-sum-of-distances">Tiny Code (Sum of Distances)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb167"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">],</span> subtree<span class="op">[</span>MAXN<span class="op">],</span> res<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>    subtree<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>        dfs1<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb167-15"><a href="#cb167-15" aria-hidden="true" tabindex="-1"></a>        subtree<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> subtree<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb167-16"><a href="#cb167-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>v<span class="op">]</span> <span class="op">+</span> subtree<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb167-17"><a href="#cb167-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb167-18"><a href="#cb167-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb167-19"><a href="#cb167-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-20"><a href="#cb167-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb167-21"><a href="#cb167-21" aria-hidden="true" tabindex="-1"></a>    res<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb167-22"><a href="#cb167-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb167-23"><a href="#cb167-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb167-24"><a href="#cb167-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb167-25"><a href="#cb167-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pu <span class="op">=</span> dp<span class="op">[</span>u<span class="op">],</span> pv <span class="op">=</span> dp<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb167-26"><a href="#cb167-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> su <span class="op">=</span> subtree<span class="op">[</span>u<span class="op">],</span> sv <span class="op">=</span> subtree<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb167-27"><a href="#cb167-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-28"><a href="#cb167-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// move root u -&gt; v</span></span>
<span id="cb167-29"><a href="#cb167-29" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">-=</span> dp<span class="op">[</span>v<span class="op">]</span> <span class="op">+</span> subtree<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb167-30"><a href="#cb167-30" aria-hidden="true" tabindex="-1"></a>        subtree<span class="op">[</span>u<span class="op">]</span> <span class="op">-=</span> subtree<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb167-31"><a href="#cb167-31" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>v<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> subtree<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb167-32"><a href="#cb167-32" aria-hidden="true" tabindex="-1"></a>        subtree<span class="op">[</span>v<span class="op">]</span> <span class="op">+=</span> subtree<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb167-33"><a href="#cb167-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-34"><a href="#cb167-34" aria-hidden="true" tabindex="-1"></a>        dfs2<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb167-35"><a href="#cb167-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-36"><a href="#cb167-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// restore</span></span>
<span id="cb167-37"><a href="#cb167-37" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> pv<span class="op">;</span></span>
<span id="cb167-38"><a href="#cb167-38" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> pu<span class="op">;</span></span>
<span id="cb167-39"><a href="#cb167-39" aria-hidden="true" tabindex="-1"></a>        subtree<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> sv<span class="op">;</span></span>
<span id="cb167-40"><a href="#cb167-40" aria-hidden="true" tabindex="-1"></a>        subtree<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> su<span class="op">;</span></span>
<span id="cb167-41"><a href="#cb167-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb167-42"><a href="#cb167-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb167-43"><a href="#cb167-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-44"><a href="#cb167-44" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb167-45"><a href="#cb167-45" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb167-46"><a href="#cb167-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">}};</span></span>
<span id="cb167-47"><a href="#cb167-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb167-48"><a href="#cb167-48" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb167-49"><a href="#cb167-49" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb167-50"><a href="#cb167-50" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb167-51"><a href="#cb167-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb167-52"><a href="#cb167-52" aria-hidden="true" tabindex="-1"></a>    dfs1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb167-53"><a href="#cb167-53" aria-hidden="true" tabindex="-1"></a>    dfs2<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb167-54"><a href="#cb167-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb167-55"><a href="#cb167-55" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"res[</span><span class="sc">%d</span><span class="st">] = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> res<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb167-56"><a href="#cb167-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {i:<span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)}</span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a>sub <span class="op">=</span> {i:<span class="dv">1</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)}</span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> {}</span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs1(u,p):</span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true" tabindex="-1"></a>    sub[u]<span class="op">=</span><span class="dv">1</span></span>
<span id="cb168-15"><a href="#cb168-15" aria-hidden="true" tabindex="-1"></a>    dp[u]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb168-16"><a href="#cb168-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb168-17"><a href="#cb168-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v<span class="op">==</span>p: <span class="cf">continue</span></span>
<span id="cb168-18"><a href="#cb168-18" aria-hidden="true" tabindex="-1"></a>        dfs1(v,u)</span>
<span id="cb168-19"><a href="#cb168-19" aria-hidden="true" tabindex="-1"></a>        sub[u]<span class="op">+=</span>sub[v]</span>
<span id="cb168-20"><a href="#cb168-20" aria-hidden="true" tabindex="-1"></a>        dp[u]<span class="op">+=</span>dp[v]<span class="op">+</span>sub[v]</span>
<span id="cb168-21"><a href="#cb168-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-22"><a href="#cb168-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs2(u,p):</span>
<span id="cb168-23"><a href="#cb168-23" aria-hidden="true" tabindex="-1"></a>    res[u]<span class="op">=</span>dp[u]</span>
<span id="cb168-24"><a href="#cb168-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb168-25"><a href="#cb168-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v<span class="op">==</span>p: <span class="cf">continue</span></span>
<span id="cb168-26"><a href="#cb168-26" aria-hidden="true" tabindex="-1"></a>        pu,pv<span class="op">=</span>dp[u],dp[v]</span>
<span id="cb168-27"><a href="#cb168-27" aria-hidden="true" tabindex="-1"></a>        su,sv<span class="op">=</span>sub[u],sub[v]</span>
<span id="cb168-28"><a href="#cb168-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-29"><a href="#cb168-29" aria-hidden="true" tabindex="-1"></a>        dp[u]<span class="op">-=</span>dp[v]<span class="op">+</span>sub[v]</span>
<span id="cb168-30"><a href="#cb168-30" aria-hidden="true" tabindex="-1"></a>        sub[u]<span class="op">-=</span>sub[v]</span>
<span id="cb168-31"><a href="#cb168-31" aria-hidden="true" tabindex="-1"></a>        dp[v]<span class="op">+=</span>dp[u]<span class="op">+</span>sub[u]</span>
<span id="cb168-32"><a href="#cb168-32" aria-hidden="true" tabindex="-1"></a>        sub[v]<span class="op">+=</span>sub[u]</span>
<span id="cb168-33"><a href="#cb168-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-34"><a href="#cb168-34" aria-hidden="true" tabindex="-1"></a>        dfs2(v,u)</span>
<span id="cb168-35"><a href="#cb168-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-36"><a href="#cb168-36" aria-hidden="true" tabindex="-1"></a>        dp[u],dp[v]<span class="op">=</span>pu,pv</span>
<span id="cb168-37"><a href="#cb168-37" aria-hidden="true" tabindex="-1"></a>        sub[u],sub[v]<span class="op">=</span>su,sv</span>
<span id="cb168-38"><a href="#cb168-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-39"><a href="#cb168-39" aria-hidden="true" tabindex="-1"></a>dfs1(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb168-40"><a href="#cb168-40" aria-hidden="true" tabindex="-1"></a>dfs2(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb168-41"><a href="#cb168-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-76" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-76">Why It Matters</h4>
<ul>
<li>Compute answers for all nodes in <span class="math inline">\(O(n)\)</span></li>
<li>Essential in distance sums, rerooted subtree queries, centroid-based algorithms</li>
<li>Core pattern in Tree Rerooting DP problems on AtCoder, Codeforces, Leetcode</li>
</ul>
<p>Rerooting transforms one-root logic into every-root knowledge.</p>
</section>
<section id="a-gentle-proof-why-it-works-63" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-63">A Gentle Proof (Why It Works)</h4>
<ol type="1">
<li><p>First pass ensures each node knows its subtree contribution.</p></li>
<li><p>Second pass applies a constant-time update to shift the root:</p>
<ul>
<li>Remove child’s contribution</li>
<li>Add parent’s complement</li>
</ul></li>
</ol>
<p>Since each edge is traversed twice, total cost is linear.</p>
</section>
<section id="try-it-yourself-76" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-76">Try It Yourself</h4>
<ol type="1">
<li>Count number of nodes in subtree for every possible root.</li>
<li>Compute sum of depths for every root.</li>
<li>Modify recurrence for product of subtree values.</li>
<li>Apply to tree balancing: minimize total distance.</li>
<li>Extend to weighted trees.</li>
</ol>
</section>
<section id="test-cases-76" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-76">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Root</th>
<th>Distance Sum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2–3</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>1–2–3</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>1–2–3</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-76" class="level4">
<h4 class="anchored" data-anchor-id="complexity-76">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Rerooting DP is your algorithmic kaleidoscope, spin the root, and watch all perspectives appear.</p>
</section>
</section>
<section id="distance-sum-rerooting" class="level3">
<h3 class="anchored" data-anchor-id="distance-sum-rerooting">478 Distance Sum Rerooting</h3>
<p>Distance Sum Rerooting is a classic and elegant application of the rerooting technique. It computes, for every node, the sum of distances to all other nodes in a tree, in just O(n) time. It’s one of the cleanest examples showing how rerooting transforms local subtree data into global insight.</p>
<section id="what-problem-are-we-solving-77" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-77">What Problem Are We Solving?</h4>
<p>Given a tree with <span class="math inline">\(n\)</span> nodes, for every node <span class="math inline">\(u\)</span>, compute:</p>
<p><span class="math display">\[
res[u] = \sum_{v=1}^{n} \text{dist}(u, v)
\]</span></p>
<p>A naïve approach (running BFS from every node) takes <span class="math inline">\(O(n^2)\)</span>. We’ll do it in two DFS passes using rerooting DP.</p>
</section>
<section id="how-does-it-work-plain-language-74" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-74">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>First pass (post-order): Root the tree at an arbitrary node (say, 1). Compute:</p>
<ul>
<li><span class="math inline">\(subtree[u]\)</span>: size of subtree rooted at <span class="math inline">\(u\)</span></li>
<li><span class="math inline">\(dp[u]\)</span>: sum of distances from <span class="math inline">\(u\)</span> to all nodes in its subtree</li>
</ul>
<p>Recurrence:</p>
<p><span class="math display">\[
subtree[u] = 1 + \sum_{v \in children(u)} subtree[v]
\]</span></p>
<p><span class="math display">\[
dp[u] = \sum_{v \in children(u)} (dp[v] + subtree[v])
\]</span></p></li>
<li><p>Second pass (pre-order): Use rerooting to compute <span class="math inline">\(res[v]\)</span> from <span class="math inline">\(res[u]\)</span>:</p>
<p><span class="math display">\[
res[v] = res[u] + (n - 2 \times subtree[v])
\]</span></p>
<ul>
<li><p>Moving root from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>:</p>
<ul>
<li>Nodes inside <span class="math inline">\(v\)</span>’s subtree get 1 closer</li>
<li>Nodes outside get 1 farther</li>
</ul></li>
<li><p>So net change = <span class="math inline">\(-subtree[v] + (n - subtree[v]) = n - 2 \times subtree[v]\)</span></p></li>
</ul></li>
<li><p><span class="math inline">\(res[1] = dp[1]\)</span> (initial result for root)</p></li>
</ol>
<p>After this, each node has its sum of distances, all in linear time.</p>
</section>
<section id="step-by-step-example-73" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-73">Step-by-Step Example</h4>
<p>Tree:</p>
<pre><code>      1
     / \
    2   3
   / \
  4   5</code></pre>
<p>Step 1 (Post-order)</p>
<ul>
<li><span class="math inline">\(dp[4]=0,\ dp[5]=0,\ dp[3]=0\)</span></li>
<li><span class="math inline">\(subtree[4]=1,\ subtree[5]=1,\ subtree[3]=1\)</span></li>
<li><span class="math inline">\(subtree[2]=1+1+1=3,\ dp[2]=dp[4]+dp[5]+subtree[4]+subtree[5]=0+0+1+1=2\)</span></li>
<li><span class="math inline">\(subtree[1]=1+3+1=5,\ dp[1]=dp[2]+dp[3]+subtree[2]+subtree[3]=2+0+3+1=6\)</span></li>
</ul>
<p>So <span class="math inline">\(res[1]=6\)</span>.</p>
<p>Step 2 (Reroot)</p>
<ul>
<li><span class="math inline">\(res[2]=res[1]+(5-2\times3)=6-1=5\)</span></li>
<li><span class="math inline">\(res[3]=res[1]+(5-2\times1)=6+3=9\)</span></li>
<li><span class="math inline">\(res[4]=res[2]+(5-2\times1)=5+3=8\)</span></li>
<li><span class="math inline">\(res[5]=res[2]+(5-2\times1)=5+3=8\)</span></li>
</ul>
<p>✅ Final:</p>
<ul>
<li><span class="math inline">\(res[1]=6\)</span>, <span class="math inline">\(res[2]=5\)</span>, <span class="math inline">\(res[3]=9\)</span>, <span class="math inline">\(res[4]=8\)</span>, <span class="math inline">\(res[5]=8\)</span></li>
</ul>
</section>
<section id="tiny-code-easy-version-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-14">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb170"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> subtree<span class="op">[</span>MAXN<span class="op">],</span> dp<span class="op">[</span>MAXN<span class="op">],</span> res<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>    subtree<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>        dfs1<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb170-15"><a href="#cb170-15" aria-hidden="true" tabindex="-1"></a>        subtree<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> subtree<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb170-16"><a href="#cb170-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>v<span class="op">]</span> <span class="op">+</span> subtree<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb170-17"><a href="#cb170-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-18"><a href="#cb170-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb170-19"><a href="#cb170-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-20"><a href="#cb170-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb170-21"><a href="#cb170-21" aria-hidden="true" tabindex="-1"></a>    res<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb170-22"><a href="#cb170-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb170-23"><a href="#cb170-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb170-24"><a href="#cb170-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb170-25"><a href="#cb170-25" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> subtree<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb170-26"><a href="#cb170-26" aria-hidden="true" tabindex="-1"></a>        dfs2<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb170-27"><a href="#cb170-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-28"><a href="#cb170-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb170-29"><a href="#cb170-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-30"><a href="#cb170-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb170-31"><a href="#cb170-31" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb170-32"><a href="#cb170-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">}};</span></span>
<span id="cb170-33"><a href="#cb170-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb170-34"><a href="#cb170-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb170-35"><a href="#cb170-35" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb170-36"><a href="#cb170-36" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb170-37"><a href="#cb170-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-38"><a href="#cb170-38" aria-hidden="true" tabindex="-1"></a>    dfs1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb170-39"><a href="#cb170-39" aria-hidden="true" tabindex="-1"></a>    dfs2<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb170-40"><a href="#cb170-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb170-41"><a href="#cb170-41" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Sum of distances from </span><span class="sc">%d</span><span class="st"> = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> res<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb170-42"><a href="#cb170-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb171-10"><a href="#cb171-10" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {i:<span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)}</span>
<span id="cb171-11"><a href="#cb171-11" aria-hidden="true" tabindex="-1"></a>sub <span class="op">=</span> {i:<span class="dv">1</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)}</span>
<span id="cb171-12"><a href="#cb171-12" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> {}</span>
<span id="cb171-13"><a href="#cb171-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-14"><a href="#cb171-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs1(u,p):</span>
<span id="cb171-15"><a href="#cb171-15" aria-hidden="true" tabindex="-1"></a>    sub[u]<span class="op">=</span><span class="dv">1</span></span>
<span id="cb171-16"><a href="#cb171-16" aria-hidden="true" tabindex="-1"></a>    dp[u]<span class="op">=</span><span class="dv">0</span></span>
<span id="cb171-17"><a href="#cb171-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb171-18"><a href="#cb171-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v<span class="op">==</span>p: <span class="cf">continue</span></span>
<span id="cb171-19"><a href="#cb171-19" aria-hidden="true" tabindex="-1"></a>        dfs1(v,u)</span>
<span id="cb171-20"><a href="#cb171-20" aria-hidden="true" tabindex="-1"></a>        sub[u]<span class="op">+=</span>sub[v]</span>
<span id="cb171-21"><a href="#cb171-21" aria-hidden="true" tabindex="-1"></a>        dp[u]<span class="op">+=</span>dp[v]<span class="op">+</span>sub[v]</span>
<span id="cb171-22"><a href="#cb171-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-23"><a href="#cb171-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs2(u,p):</span>
<span id="cb171-24"><a href="#cb171-24" aria-hidden="true" tabindex="-1"></a>    res[u]<span class="op">=</span>dp[u]</span>
<span id="cb171-25"><a href="#cb171-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb171-26"><a href="#cb171-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v<span class="op">==</span>p: <span class="cf">continue</span></span>
<span id="cb171-27"><a href="#cb171-27" aria-hidden="true" tabindex="-1"></a>        dp[v]<span class="op">=</span>dp[u]<span class="op">+</span>(n<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sub[v])</span>
<span id="cb171-28"><a href="#cb171-28" aria-hidden="true" tabindex="-1"></a>        dfs2(v,u)</span>
<span id="cb171-29"><a href="#cb171-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-30"><a href="#cb171-30" aria-hidden="true" tabindex="-1"></a>dfs1(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb171-31"><a href="#cb171-31" aria-hidden="true" tabindex="-1"></a>dfs2(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb171-32"><a href="#cb171-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-77" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-77">Why It Matters</h4>
<ul>
<li>Computes sum of distances for every node in linear time</li>
<li>A foundational rerooting example, applies to many other metrics (sums, products, min/max)</li>
<li>Extensible to weighted edges, directed trees, and centroid decomposition</li>
<li>Useful in graph analysis, network latency, tree balancing, dynamic centers</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-64" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-64">A Gentle Proof (Why It Works)</h4>
<p>Each reroot step adjusts the sum of distances by accounting for nodes that become closer or farther:</p>
<ul>
<li>Nodes in the new root’s subtree (<span class="math inline">\(subtree[v]\)</span>): distances decrease by 1</li>
<li>Others (<span class="math inline">\(n - subtree[v]\)</span>): distances increase by 1</li>
</ul>
<p>So:</p>
<p><span class="math display">\[
res[v] = res[u] + (n - 2 \times subtree[v])
\]</span></p>
<p>By induction across edges, each node gets correct total distance.</p>
</section>
<section id="try-it-yourself-77" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-77">Try It Yourself</h4>
<ol type="1">
<li>Extend to weighted edges.</li>
<li>Compute average distance per node.</li>
<li>Combine with centroid finding (node minimizing <span class="math inline">\(res[u]\)</span>).</li>
<li>Visualize change in <span class="math inline">\(res\)</span> as root slides.</li>
<li>Adapt for directed rooted trees.</li>
</ol>
</section>
<section id="test-cases-77" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-77">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Node</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2–3</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>1–2–3</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>1–2–3</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-77" class="level4">
<h4 class="anchored" data-anchor-id="complexity-77">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Distance Sum Rerooting shows the beauty of symmetry in trees, move the root, update the world, keep it all in balance.</p>
</section>
</section>
<section id="tree-coloring-dp" class="level3">
<h3 class="anchored" data-anchor-id="tree-coloring-dp">479 Tree Coloring DP</h3>
<p>Tree Coloring DP is a versatile pattern for solving coloring and labeling problems on trees under local constraints, for example, counting how many valid colorings exist when adjacent nodes cannot share a color, or minimizing cost under adjacency restrictions. It combines state definition with child aggregation, forming one of the most common templates in competitive programming.</p>
<section id="what-problem-are-we-solving-78" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-78">What Problem Are We Solving?</h4>
<p>Given a tree with <span class="math inline">\(n\)</span> nodes, we want to color each node with one of <span class="math inline">\(k\)</span> colors so that no two adjacent nodes share the same color, and count the number of valid colorings.</p>
<p>Formally, find the number of ways to assign <span class="math inline">\(color[u] \in {1,2,\dots,k}\)</span> such that for every edge <span class="math inline">\((u,v)\)</span>, <span class="math inline">\(color[u] \ne color[v]\)</span>.</p>
<p>We can also generalize:</p>
<ul>
<li>Weighted versions (cost per color)</li>
<li>Restricted versions (pre-colored nodes)</li>
<li>Modular counting (<span class="math inline">\(\bmod\ 10^9+7\)</span>)</li>
</ul>
<p>Here, we’ll solve the basic unweighted counting version.</p>
</section>
<section id="how-does-it-work-plain-language-75" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-75">How Does It Work (Plain Language)</h4>
<p>We do a rooted DP where each node decides its color and multiplies the valid combinations from its children.</p>
<p>If a node <span class="math inline">\(u\)</span> is colored <span class="math inline">\(c\)</span>, then each child <span class="math inline">\(v\)</span> can take any color except <span class="math inline">\(c\)</span>.</p>
<p>So for each node:</p>
<p><span class="math display">\[
dp[u][c] = \prod_{v \in children(u)} \sum_{\substack{c' = 1 \ c' \ne c}}^{k} dp[v][c']
\]</span></p>
<p>Finally, the total count is:</p>
<p><span class="math display">\[
\text{Answer} = \sum_{c=1}^{k} dp[root][c]
\]</span></p>
<p>Because the tree is acyclic, we can safely combine subtrees without overcounting.</p>
</section>
<section id="step-by-step-example-74" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-74">Step-by-Step Example</h4>
<p>Tree:</p>
<pre><code>    1
   / \
  2   3</code></pre>
<p><span class="math inline">\(k=3\)</span> colors (1,2,3)</p>
<p>Start from leaves:</p>
<ul>
<li>For leaf node <span class="math inline">\(v\)</span>, <span class="math inline">\(dp[v][c] = 1\)</span> for all <span class="math inline">\(c \in {1,2,3}\)</span> (any color works)</li>
</ul>
<p>Now node 2 and 3:</p>
<ul>
<li><span class="math inline">\(dp[2] = dp[3] = [1,1,1]\)</span></li>
</ul>
<p>At node 1:</p>
<ul>
<li><span class="math inline">\(dp[1][1] = \prod_{child} \sum_{c' \ne 1} dp[child][c'] = (1+1)*(1+1)=4\)</span></li>
<li><span class="math inline">\(dp[1][2] = (1+1)*(1+1)=4\)</span></li>
<li><span class="math inline">\(dp[1][3] = (1+1)*(1+1)=4\)</span></li>
</ul>
<p>Total = <span class="math inline">\(4+4+4 = 12\)</span> valid colorings</p>
<p>Manual check: each of 3 colors for node 1 × 2 choices per child × 2 children = 12 ✅</p>
</section>
<section id="tiny-code-easy-version-15" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-15">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb173"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXK </span><span class="dv">10</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MOD </span><span class="dv">1000000007</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> k<span class="op">;</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>MAXN<span class="op">][</span>MAXK<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> c <span class="op">&lt;=</span> k<span class="op">;</span> c<span class="op">++)</span> dp<span class="op">[</span>u<span class="op">][</span>c<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb173-12"><a href="#cb173-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb173-13"><a href="#cb173-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb173-14"><a href="#cb173-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb173-15"><a href="#cb173-15" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb173-16"><a href="#cb173-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> c <span class="op">&lt;=</span> k<span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb173-17"><a href="#cb173-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">long</span> <span class="dt">long</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb173-18"><a href="#cb173-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c2 <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> c2 <span class="op">&lt;=</span> k<span class="op">;</span> c2<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb173-19"><a href="#cb173-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>c2 <span class="op">==</span> c<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb173-20"><a href="#cb173-20" aria-hidden="true" tabindex="-1"></a>                sum <span class="op">=</span> <span class="op">(</span>sum <span class="op">+</span> dp<span class="op">[</span>v<span class="op">][</span>c2<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb173-21"><a href="#cb173-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb173-22"><a href="#cb173-22" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>u<span class="op">][</span>c<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>u<span class="op">][</span>c<span class="op">]</span> <span class="op">*</span> sum<span class="op">)</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb173-23"><a href="#cb173-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb173-24"><a href="#cb173-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb173-25"><a href="#cb173-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb173-26"><a href="#cb173-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-27"><a href="#cb173-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb173-28"><a href="#cb173-28" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> k <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb173-29"><a href="#cb173-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">}};</span></span>
<span id="cb173-30"><a href="#cb173-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb173-31"><a href="#cb173-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b <span class="op">=</span> edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb173-32"><a href="#cb173-32" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]++]</span> <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb173-33"><a href="#cb173-33" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]++]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb173-34"><a href="#cb173-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb173-35"><a href="#cb173-35" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb173-36"><a href="#cb173-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb173-37"><a href="#cb173-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> c <span class="op">&lt;=</span> k<span class="op">;</span> c<span class="op">++)</span> ans <span class="op">=</span> <span class="op">(</span>ans <span class="op">+</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span>c<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb173-38"><a href="#cb173-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Total colorings: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb173-39"><a href="#cb173-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>MOD <span class="op">=</span> <span class="dv">109</span> <span class="op">+</span> <span class="dv">7</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>n, k <span class="op">=</span> <span class="dv">3</span>, <span class="dv">3</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>)]</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a>    g[u].append(v)</span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a>    g[v].append(u)</span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-12"><a href="#cb174-12" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> {}</span>
<span id="cb174-13"><a href="#cb174-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-14"><a href="#cb174-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb174-15"><a href="#cb174-15" aria-hidden="true" tabindex="-1"></a>    dp[u] <span class="op">=</span> [<span class="dv">1</span>]<span class="op">*</span>(k<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb174-16"><a href="#cb174-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb174-17"><a href="#cb174-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb174-18"><a href="#cb174-18" aria-hidden="true" tabindex="-1"></a>        dfs(v, u)</span>
<span id="cb174-19"><a href="#cb174-19" aria-hidden="true" tabindex="-1"></a>        new <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(k<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb174-20"><a href="#cb174-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb174-21"><a href="#cb174-21" aria-hidden="true" tabindex="-1"></a>            total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb174-22"><a href="#cb174-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> c2 <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb174-23"><a href="#cb174-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> c2 <span class="op">==</span> c: <span class="cf">continue</span></span>
<span id="cb174-24"><a href="#cb174-24" aria-hidden="true" tabindex="-1"></a>                total <span class="op">=</span> (total <span class="op">+</span> dp[v][c2]) <span class="op">%</span> MOD</span>
<span id="cb174-25"><a href="#cb174-25" aria-hidden="true" tabindex="-1"></a>            new[c] <span class="op">=</span> (dp[u][c] <span class="op">*</span> total) <span class="op">%</span> MOD</span>
<span id="cb174-26"><a href="#cb174-26" aria-hidden="true" tabindex="-1"></a>        dp[u] <span class="op">=</span> new</span>
<span id="cb174-27"><a href="#cb174-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-28"><a href="#cb174-28" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb174-29"><a href="#cb174-29" aria-hidden="true" tabindex="-1"></a>ans <span class="op">=</span> <span class="bu">sum</span>(dp[<span class="dv">1</span>][<span class="dv">1</span>:]) <span class="op">%</span> MOD</span>
<span id="cb174-30"><a href="#cb174-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Total colorings:"</span>, ans)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-78" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-78">Why It Matters</h4>
<ul>
<li>Solves coloring, labeling, and assignment problems on trees</li>
<li>Foundation for constraint satisfaction DPs</li>
<li>Extensible to weighted, modular, and partial pre-colored versions</li>
<li>Appears in graph theory, combinatorics, and tree-structured probabilistic models</li>
</ul>
<p>With small tweaks, it becomes:</p>
<ul>
<li>Minimum-cost coloring (replace <code>+</code> with <code>min</code>)</li>
<li>Constraint coloring (prune invalid colors)</li>
<li>Modular counting (for combinatorics)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-65" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-65">A Gentle Proof (Why It Works)</h4>
<p>By induction on tree height:</p>
<ul>
<li>Base case: Leaf node <span class="math inline">\(u\)</span>: <span class="math inline">\(dp[u][c]=1\)</span> (can take any color)</li>
<li>Inductive step: Suppose each child <span class="math inline">\(v\)</span> has computed correct <span class="math inline">\(dp[v][c']\)</span>. For node <span class="math inline">\(u\)</span> colored <span class="math inline">\(c\)</span>, all children <span class="math inline">\(v\)</span> must choose colors <span class="math inline">\(c' \ne c\)</span>. Summing and multiplying ensures we count all valid combinations.</li>
</ul>
<p>No overlap or omission occurs because trees have no cycles.</p>
</section>
<section id="try-it-yourself-78" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-78">Try It Yourself</h4>
<ol type="1">
<li>Add modular constraint (e.g.&nbsp;<span class="math inline">\(k=10^5\)</span>).</li>
<li>Extend to pre-colored nodes: fix certain <span class="math inline">\(dp[u][c] = 0/1\)</span>.</li>
<li>Modify recurrence for weighted coloring (cost per color).</li>
<li>Optimize with prefix-suffix products for large <span class="math inline">\(k\)</span>.</li>
<li>Apply to binary tree coloring with parity constraints.</li>
</ol>
</section>
<section id="test-cases-78" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-78">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>n</th>
<th>k</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>1–2–3</td>
<td>3</td>
<td>3</td>
<td>12</td>
</tr>
<tr class="odd">
<td>Star 1–{2,3,4}</td>
<td>4</td>
<td>3</td>
<td>24</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-78" class="level4">
<h4 class="anchored" data-anchor-id="complexity-78">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \times k^2)\)</span></li>
<li>Space: <span class="math inline">\(O(n \times k)\)</span></li>
</ul>
<p>Tree Coloring DP is your combinatorial paintbrush, define local rules, traverse once, and color the whole forest with logic.</p>
</section>
</section>
<section id="binary-search-on-tree-dp" class="level3">
<h3 class="anchored" data-anchor-id="binary-search-on-tree-dp">480 Binary Search on Tree DP</h3>
<p>Binary Search on Tree DP is a hybrid strategy combining tree dynamic programming with binary search over an answer space. It’s especially useful when the feasibility of a condition is monotonic, for example, when asking “is there a subtree/path satisfying constraint X under threshold T?” and the answer changes from false → true as T increases.</p>
<section id="what-problem-are-we-solving-79" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-79">What Problem Are We Solving?</h4>
<p>Given a tree with weights or values on nodes or edges, we want to find a minimum (or maximum) threshold <span class="math inline">\(T\)</span> such that a property holds, e.g.:</p>
<ul>
<li>Longest path with all edge weights ≤ <span class="math inline">\(T\)</span></li>
<li>Smallest <span class="math inline">\(T\)</span> such that there exists a subtree of sum ≥ <span class="math inline">\(S\)</span></li>
<li>Minimal limit where a valid DP state becomes achievable</li>
</ul>
<p>We binary search over <span class="math inline">\(T\)</span>, and for each guess, we run a DP on the tree to check if the condition is satisfied.</p>
</section>
<section id="how-does-it-work-plain-language-76" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-76">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>Identify a monotonic property, one that, once true, stays true (or once false, stays false).</li>
<li>Define a check(T) function using Tree DP that returns whether the property holds.</li>
<li>Apply binary search over <span class="math inline">\(T\)</span> to find the smallest (or largest) value satisfying the condition.</li>
</ol>
</section>
<section id="example-longest-path-under-limit" class="level4">
<h4 class="anchored" data-anchor-id="example-longest-path-under-limit">Example: Longest Path Under Limit</h4>
<p>We’re given a weighted tree with edge weights <span class="math inline">\(w(u,v)\)</span>. Find the maximum path length such that all edges ≤ T. We want the minimum T for which path length ≥ L.</p>
<p>Steps:</p>
<ol type="1">
<li>Binary search over <span class="math inline">\(T\)</span></li>
<li>For each <span class="math inline">\(T\)</span>, build a subgraph of edges ≤ <span class="math inline">\(T\)</span></li>
<li>Run DP on tree (e.g.&nbsp;diameter DP) to check if a path of length ≥ L exists</li>
</ol>
</section>
<section id="dp-design" class="level4">
<h4 class="anchored" data-anchor-id="dp-design">DP Design</h4>
<p>We use a DFS-based DP that computes, for each node:</p>
<p><span class="math display">\[
dp[u] = \text{length of longest downward path under } T
\]</span></p>
<p>and combine two best child paths to check if the diameter ≥ L.</p>
</section>
<section id="tiny-code-feasibility-check" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-feasibility-check">Tiny Code (Feasibility Check)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb175"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> L<span class="op">;</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> adj<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> w<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> deg<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> best<span class="op">;</span></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">,</span> <span class="dt">int</span> T<span class="op">)</span> <span class="op">{</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> top2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> p <span class="op">||</span> w<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">&gt;</span> T<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> len <span class="op">=</span> dfs<span class="op">(</span>v<span class="op">,</span> u<span class="op">,</span> T<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>len <span class="op">&gt;</span> top1<span class="op">)</span> <span class="op">{</span> top2 <span class="op">=</span> top1<span class="op">;</span> top1 <span class="op">=</span> len<span class="op">;</span> <span class="op">}</span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>len <span class="op">&gt;</span> top2<span class="op">)</span> top2 <span class="op">=</span> len<span class="op">;</span></span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>top1 <span class="op">+</span> top2 <span class="op">&gt;=</span> L<span class="op">)</span> best <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top1<span class="op">;</span></span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> check<span class="op">(</span><span class="dt">int</span> T<span class="op">)</span> <span class="op">{</span></span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> T<span class="op">);</span></span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best<span class="op">;</span></span>
<span id="cb175-27"><a href="#cb175-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb175-28"><a href="#cb175-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-29"><a href="#cb175-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb175-30"><a href="#cb175-30" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> L <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb175-31"><a href="#cb175-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> edges<span class="op">[</span><span class="dv">3</span><span class="op">][</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">5</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">7</span><span class="op">}};</span></span>
<span id="cb175-32"><a href="#cb175-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb175-33"><a href="#cb175-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">=</span>edges<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> b<span class="op">=</span>edges<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">],</span> c<span class="op">=</span>edges<span class="op">[</span>i<span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb175-34"><a href="#cb175-34" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>a<span class="op">][</span>deg<span class="op">[</span>a<span class="op">]]</span> <span class="op">=</span> b<span class="op">;</span> w<span class="op">[</span>a<span class="op">][</span>b<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span> deg<span class="op">[</span>a<span class="op">]++;</span></span>
<span id="cb175-35"><a href="#cb175-35" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>b<span class="op">][</span>deg<span class="op">[</span>b<span class="op">]]</span> <span class="op">=</span> a<span class="op">;</span> w<span class="op">[</span>b<span class="op">][</span>a<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span> deg<span class="op">[</span>b<span class="op">]++;</span></span>
<span id="cb175-36"><a href="#cb175-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-37"><a href="#cb175-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lo <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> hi <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> ans <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb175-38"><a href="#cb175-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>lo <span class="op">&lt;=</span> hi<span class="op">)</span> <span class="op">{</span></span>
<span id="cb175-39"><a href="#cb175-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>lo <span class="op">+</span> hi<span class="op">)/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb175-40"><a href="#cb175-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>check<span class="op">(</span>mid<span class="op">))</span> <span class="op">{</span> ans <span class="op">=</span> mid<span class="op">;</span> hi <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb175-41"><a href="#cb175-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> lo <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb175-42"><a href="#cb175-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-43"><a href="#cb175-43" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Minimum T: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> ans<span class="op">);</span></span>
<span id="cb175-44"><a href="#cb175-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">7</span>)]</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>n, L <span class="op">=</span> <span class="dv">4</span>, <span class="dv">3</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v,w <span class="kw">in</span> edges:</span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>    g[u].append((v,w))</span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a>    g[v].append((u,w))</span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p, T):</span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a>    top1 <span class="op">=</span> top2 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> ok</span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v,w <span class="kw">in</span> g[u]:</span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p <span class="kw">or</span> w <span class="op">&gt;</span> T: <span class="cf">continue</span></span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a>        length <span class="op">=</span> dfs(v, u, T) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb176-16"><a href="#cb176-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> length <span class="op">&gt;</span> top1:</span>
<span id="cb176-17"><a href="#cb176-17" aria-hidden="true" tabindex="-1"></a>            top2 <span class="op">=</span> top1</span>
<span id="cb176-18"><a href="#cb176-18" aria-hidden="true" tabindex="-1"></a>            top1 <span class="op">=</span> length</span>
<span id="cb176-19"><a href="#cb176-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> length <span class="op">&gt;</span> top2:</span>
<span id="cb176-20"><a href="#cb176-20" aria-hidden="true" tabindex="-1"></a>            top2 <span class="op">=</span> length</span>
<span id="cb176-21"><a href="#cb176-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> top1 <span class="op">+</span> top2 <span class="op">&gt;=</span> L:</span>
<span id="cb176-22"><a href="#cb176-22" aria-hidden="true" tabindex="-1"></a>        ok <span class="op">=</span> <span class="va">True</span></span>
<span id="cb176-23"><a href="#cb176-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top1</span>
<span id="cb176-24"><a href="#cb176-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-25"><a href="#cb176-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check(T):</span>
<span id="cb176-26"><a href="#cb176-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> ok</span>
<span id="cb176-27"><a href="#cb176-27" aria-hidden="true" tabindex="-1"></a>    ok <span class="op">=</span> <span class="va">False</span></span>
<span id="cb176-28"><a href="#cb176-28" aria-hidden="true" tabindex="-1"></a>    dfs(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, T)</span>
<span id="cb176-29"><a href="#cb176-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ok</span>
<span id="cb176-30"><a href="#cb176-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-31"><a href="#cb176-31" aria-hidden="true" tabindex="-1"></a>lo, hi <span class="op">=</span> <span class="dv">0</span>, <span class="dv">10</span></span>
<span id="cb176-32"><a href="#cb176-32" aria-hidden="true" tabindex="-1"></a>ans <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb176-33"><a href="#cb176-33" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> lo <span class="op">&lt;=</span> hi:</span>
<span id="cb176-34"><a href="#cb176-34" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (lo <span class="op">+</span> hi)<span class="op">//</span><span class="dv">2</span></span>
<span id="cb176-35"><a href="#cb176-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> check(mid):</span>
<span id="cb176-36"><a href="#cb176-36" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> mid</span>
<span id="cb176-37"><a href="#cb176-37" aria-hidden="true" tabindex="-1"></a>        hi <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb176-38"><a href="#cb176-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb176-39"><a href="#cb176-39" aria-hidden="true" tabindex="-1"></a>        lo <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb176-40"><a href="#cb176-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Minimum T:"</span>, ans)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-79" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-79">Why It Matters</h4>
<ul>
<li>Many threshold optimization problems rely on binary search + DP</li>
<li>Ideal when cost / limit interacts with tree-based structure</li>
<li>Useful in network design, path constraints, tree queries, game theory</li>
</ul>
<p>Examples:</p>
<ul>
<li>Smallest edge weight for connectivity</li>
<li>Minimal node cost for subtree property</li>
<li>Path feasibility under resource constraint</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-66" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-66">A Gentle Proof (Why It Works)</h4>
<p>If the property is monotonic, binary search guarantees correctness:</p>
<ul>
<li>If a condition holds at <span class="math inline">\(T\)</span>, it holds at all <span class="math inline">\(T' &gt; T\)</span></li>
<li>So, we can search for the smallest satisfying <span class="math inline">\(T\)</span></li>
</ul>
<p>Tree DP correctly checks feasibility because it enumerates all root-to-leaf and child-to-child paths under threshold <span class="math inline">\(T\)</span>.</p>
</section>
<section id="try-it-yourself-79" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-79">Try It Yourself</h4>
<ol type="1">
<li>Modify to maximize value (reverse monotonicity).</li>
<li>Replace edge constraint with node value ≤ T.</li>
<li>Use DP to count paths, not just check existence.</li>
<li>Apply to maximum subtree sum under bound.</li>
<li>Extend to k-colored constraints (binary search over cost).</li>
</ol>
</section>
<section id="test-cases-79" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-79">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>n</th>
<th>L</th>
<th>Edges</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4</td>
<td>3</td>
<td>(1-2:3, 2-3:5, 3-4:7)</td>
<td>5</td>
</tr>
<tr class="even">
<td>3</td>
<td>2</td>
<td>(1-2:1, 2-3:2)</td>
<td>2</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-79" class="level4">
<h4 class="anchored" data-anchor-id="complexity-79">Complexity</h4>
<ul>
<li>DP per check: <span class="math inline">\(O(n)\)</span></li>
<li>Binary search: <span class="math inline">\(\log(\text{range})\)</span></li>
<li>Total: <span class="math inline">\(O(n\log C)\)</span> where <span class="math inline">\(C\)</span> is max edge weight</li>
</ul>
<p>Binary Search on Tree DP bridges feasibility logic and optimization, use it whenever monotonic thresholds and tree states meet.</p>
</section>
</section>
</section>
<section id="section-49.-dp-reconstruction-and-traceback" class="level1">
<h1>Section 49. DP Reconstruction and Traceback</h1>
<section id="reconstruct-lcs" class="level3">
<h3 class="anchored" data-anchor-id="reconstruct-lcs">481 Reconstruct LCS</h3>
<p>Reconstructing the Longest Common Subsequence (LCS) means not just computing its length, but tracing back the actual sequence that two strings share in order. This step turns abstract DP tables into tangible answers, a common need in bioinformatics, text diffing, and alignment tasks.</p>
<section id="what-problem-are-we-solving-80" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-80">What Problem Are We Solving?</h4>
<p>Given two sequences <span class="math inline">\(A\)</span> (length <span class="math inline">\(n\)</span>) and <span class="math inline">\(B\)</span> (length <span class="math inline">\(m\)</span>), find the longest subsequence common to both (not necessarily contiguous).</p>
<p>We first build a DP table for LCS length:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
0, &amp; \text{if } i = 0 \text{ or } j = 0,\\
dp[i-1][j-1] + 1, &amp; \text{if } A[i-1] = B[j-1],\\
\max(dp[i-1][j],\ dp[i][j-1]), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Then we trace back from <span class="math inline">\(dp[n][m]\)</span> to reconstruct the sequence.</p>
</section>
<section id="how-does-it-work-plain-language-77" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-77">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Compute the LCS length table using standard DP.</p></li>
<li><p>Start from the bottom-right corner (<span class="math inline">\(dp[n][m]\)</span>).</p></li>
<li><p>Trace back:</p>
<ul>
<li>If <span class="math inline">\(A[i-1] == B[j-1]\)</span>: add that character and move diagonally (<span class="math inline">\(i-1, j-1\)</span>)</li>
<li>Else move to the direction with larger dp value</li>
</ul></li>
<li><p>Reverse the collected sequence.</p></li>
</ol>
</section>
<section id="example-1" class="level4">
<h4 class="anchored" data-anchor-id="example-1">Example</h4>
<p>Let <span class="math inline">\(A = \text{"ABCBDAB"}\)</span>, <span class="math inline">\(B = \text{"BDCABA"}\)</span></p>
<p>DP length table leads to result “BCBA”.</p>
</section>
<section id="tiny-code-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-1">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb177"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> A<span class="op">[</span>MAX<span class="op">],</span> B<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> lcs<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> A<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>A<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb177-14"><a href="#cb177-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb177-15"><a href="#cb177-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb177-16"><a href="#cb177-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb177-17"><a href="#cb177-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb177-18"><a href="#cb177-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">&gt;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">:</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb177-19"><a href="#cb177-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-20"><a href="#cb177-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reconstruct</span></span>
<span id="cb177-21"><a href="#cb177-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> n<span class="op">,</span> j <span class="op">=</span> m<span class="op">,</span> k <span class="op">=</span> dp<span class="op">[</span>n<span class="op">][</span>m<span class="op">];</span></span>
<span id="cb177-22"><a href="#cb177-22" aria-hidden="true" tabindex="-1"></a>    lcs<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb177-23"><a href="#cb177-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb177-24"><a href="#cb177-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb177-25"><a href="#cb177-25" aria-hidden="true" tabindex="-1"></a>            lcs<span class="op">[--</span>k<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb177-26"><a href="#cb177-26" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span> j<span class="op">--;</span></span>
<span id="cb177-27"><a href="#cb177-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">&gt;=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb177-28"><a href="#cb177-28" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span></span>
<span id="cb177-29"><a href="#cb177-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb177-30"><a href="#cb177-30" aria-hidden="true" tabindex="-1"></a>            j<span class="op">--;</span></span>
<span id="cb177-31"><a href="#cb177-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb177-32"><a href="#cb177-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LCS: </span><span class="sc">%s\n</span><span class="st">"</span><span class="op">,</span> lcs<span class="op">);</span></span>
<span id="cb177-33"><a href="#cb177-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb178"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reconstruct_lcs(A, B):</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(A), <span class="bu">len</span>(B)</span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(m<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> A[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> B[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb178-10"><a href="#cb178-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-11"><a href="#cb178-11" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> n, m</span>
<span id="cb178-12"><a href="#cb178-12" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb178-13"><a href="#cb178-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb178-14"><a href="#cb178-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> A[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> B[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb178-15"><a href="#cb178-15" aria-hidden="true" tabindex="-1"></a>            res.append(A[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb178-16"><a href="#cb178-16" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb178-17"><a href="#cb178-17" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb178-18"><a href="#cb178-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">&gt;=</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb178-19"><a href="#cb178-19" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb178-20"><a href="#cb178-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb178-21"><a href="#cb178-21" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb178-22"><a href="#cb178-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(<span class="bu">reversed</span>(res))</span>
<span id="cb178-23"><a href="#cb178-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-24"><a href="#cb178-24" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="bu">input</span>(<span class="st">"A: "</span>)</span>
<span id="cb178-25"><a href="#cb178-25" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="bu">input</span>(<span class="st">"B: "</span>)</span>
<span id="cb178-26"><a href="#cb178-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LCS:"</span>, reconstruct_lcs(A, B))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-80" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-80">Why It Matters</h4>
<ul>
<li>Core of diff, merge, and DNA alignment tools</li>
<li>Demonstrates how DP solutions can reconstruct actual solutions, not just counts</li>
<li>Foundation for traceback techniques in many DP problems</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-67" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-67">A Gentle Proof (Why It Works)</h4>
<p>At each step:</p>
<ul>
<li>If <span class="math inline">\(A[i-1] = B[j-1]\)</span>, the character must belong to the LCS, so we include it and move diagonally.</li>
<li>Otherwise, the longer LCS lies in the direction of the greater dp value, hence we follow that path. By starting from <span class="math inline">\(dp[n][m]\)</span> and moving backward, we guarantee each included character is part of at least one optimal solution.</li>
</ul>
<p>Since we collect in reverse order, reversing yields the correct sequence.</p>
</section>
<section id="try-it-yourself-80" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-80">Try It Yourself</h4>
<ol type="1">
<li>Trace the LCS of “ABCBDAB” and “BDCABA” by hand.</li>
<li>Modify to find one of all possible LCSs (handle ties).</li>
<li>Extend for case-insensitive comparison.</li>
<li>Adapt code to return indices of matching characters.</li>
<li>Visualize path arrows in DP table.</li>
</ol>
</section>
<section id="test-cases-80" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-80">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>LCS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“ABCBDAB”</td>
<td>“BDCABA”</td>
<td>“BCBA”</td>
</tr>
<tr class="even">
<td>“AGGTAB”</td>
<td>“GXTXAYB”</td>
<td>“GTAB”</td>
</tr>
<tr class="odd">
<td>“AXYT”</td>
<td>“AYZX”</td>
<td>“AY”</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-80" class="level4">
<h4 class="anchored" data-anchor-id="complexity-80">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(nm)\)</span></li>
<li>Space: <span class="math inline">\(O(nm)\)</span> (can optimize to <span class="math inline">\(O(\min(n,m))\)</span> for length only)</li>
</ul>
<p>Reconstruct LCS is your first step from number tables to actual solutions, bridging reasoning and reality.</p>
</section>
</section>
<section id="reconstruct-lis" class="level3">
<h3 class="anchored" data-anchor-id="reconstruct-lis">482 Reconstruct LIS</h3>
<p>Reconstructing the Longest Increasing Subsequence (LIS) means finding not just the length of the longest increasing sequence, but the actual subsequence. This is a classic step beyond computing DP values, it’s about tracing <em>how</em> we got there.</p>
<section id="what-problem-are-we-solving-81" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-81">What Problem Are We Solving?</h4>
<p>Given a sequence of numbers <span class="math inline">\(A = [a_1, a_2, \dots, a_n]\)</span>, we want to find the longest strictly increasing subsequence. The DP version computes LIS length in <span class="math inline">\(O(n^2)\)</span>, but here we focus on reconstruction.</p>
<p>We define:</p>
<p><span class="math display">\[
dp[i] = \text{length of LIS ending at } i
\]</span></p>
<p>and a parent array to track predecessors:</p>
<p><span class="math display">\[
parent[i] = \text{index of previous element in LIS ending at } i
\]</span></p>
<p>Finally, we backtrack from the index of the maximum <span class="math inline">\(dp[i]\)</span> to recover the sequence.</p>
</section>
<section id="how-does-it-work-plain-language-78" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-78">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>Compute dp[i]: longest LIS ending at <span class="math inline">\(A[i]\)</span>.</li>
<li>Track parent[i]: where this sequence came from.</li>
<li>Find max length index, call it <code>best</code>.</li>
<li>Backtrack using <code>parent</code> array.</li>
<li>Reverse the reconstructed list.</li>
</ol>
</section>
<section id="example-2" class="level4">
<h4 class="anchored" data-anchor-id="example-2">Example</h4>
<p>For <span class="math inline">\(A = [10, 22, 9, 33, 21, 50, 41, 60]\)</span></p>
<p>We get:</p>
<ul>
<li><code>dp = [1, 2, 1, 3, 2, 4, 4, 5]</code></li>
<li>LIS length = 5</li>
<li>Sequence = <code>[10, 22, 33, 50, 60]</code></li>
</ul>
</section>
<section id="tiny-code-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-2">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb179"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> A<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">21</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">41</span><span class="op">,</span> <span class="dv">60</span><span class="op">};</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n<span class="op">],</span> parent<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a>        parent<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> dp<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb179-14"><a href="#cb179-14" aria-hidden="true" tabindex="-1"></a>                parent<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb179-15"><a href="#cb179-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb179-16"><a href="#cb179-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb179-17"><a href="#cb179-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb179-18"><a href="#cb179-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-19"><a href="#cb179-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Find index of LIS</span></span>
<span id="cb179-20"><a href="#cb179-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb179-21"><a href="#cb179-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb179-22"><a href="#cb179-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> dp<span class="op">[</span>best<span class="op">])</span> best <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb179-23"><a href="#cb179-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-24"><a href="#cb179-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reconstruct LIS</span></span>
<span id="cb179-25"><a href="#cb179-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lis<span class="op">[</span><span class="dv">100</span><span class="op">],</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb179-26"><a href="#cb179-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> best<span class="op">;</span> i <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">=</span> parent<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb179-27"><a href="#cb179-27" aria-hidden="true" tabindex="-1"></a>        lis<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb179-28"><a href="#cb179-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-29"><a href="#cb179-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LIS: "</span><span class="op">);</span></span>
<span id="cb179-30"><a href="#cb179-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="cb179-31"><a href="#cb179-31" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> lis<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb179-32"><a href="#cb179-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb179-33"><a href="#cb179-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb180"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reconstruct_lis(A):</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>]<span class="op">*</span>n</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>n</span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> A[j] <span class="op">&lt;</span> A[i] <span class="kw">and</span> dp[j] <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> dp[i]:</span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> dp[j] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a>                parent[i] <span class="op">=</span> j</span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="bu">max</span>(<span class="bu">range</span>(n), key<span class="op">=</span><span class="kw">lambda</span> i: dp[i])</span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> []</span>
<span id="cb180-15"><a href="#cb180-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> best <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb180-16"><a href="#cb180-16" aria-hidden="true" tabindex="-1"></a>        res.append(A[best])</span>
<span id="cb180-17"><a href="#cb180-17" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> parent[best]</span>
<span id="cb180-18"><a href="#cb180-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb180-19"><a href="#cb180-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-20"><a href="#cb180-20" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">22</span>, <span class="dv">9</span>, <span class="dv">33</span>, <span class="dv">21</span>, <span class="dv">50</span>, <span class="dv">41</span>, <span class="dv">60</span>]</span>
<span id="cb180-21"><a href="#cb180-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LIS:"</span>, reconstruct_lis(A))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-81" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-81">Why It Matters</h4>
<ul>
<li>Transforms abstract DP into real sequence output</li>
<li>Useful in scheduling, stock analysis, subsequence pattern recognition</li>
<li>Teaches traceback technique with parent tracking, reused across many problems</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-68" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-68">A Gentle Proof (Why It Works)</h4>
<p>By definition, <span class="math inline">\(dp[i]\)</span> records the LIS length ending at <span class="math inline">\(i\)</span>. Whenever we update <span class="math inline">\(dp[i] = dp[j] + 1\)</span>, we’ve extended the best LIS ending at <span class="math inline">\(j\)</span>. Recording <code>parent[i] = j</code> lets us reconstruct that path.</p>
<p>The element with the maximum <span class="math inline">\(dp[i]\)</span> must end one LIS, and by backtracking through parents, we trace exactly one valid increasing subsequence achieving the max length.</p>
</section>
<section id="try-it-yourself-81" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-81">Try It Yourself</h4>
<ol type="1">
<li>Trace LIS reconstruction for <span class="math inline">\([3, 10, 2, 1, 20]\)</span></li>
<li>Modify to return all LIS sequences (handle equal-length ties).</li>
<li>Adapt code for non-decreasing LIS.</li>
<li>Combine with binary search LIS for <span class="math inline">\(O(n \log n)\)</span> + parent tracking.</li>
<li>Visualize <code>parent</code> links as arrows between indices.</li>
</ol>
</section>
<section id="test-cases-81" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-81">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>LIS</th>
<th>Length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[10, 22, 9, 33, 21, 50, 41, 60]</td>
<td>[10, 22, 33, 50, 60]</td>
<td>5</td>
</tr>
<tr class="even">
<td>[3, 10, 2, 1, 20]</td>
<td>[3, 10, 20]</td>
<td>3</td>
</tr>
<tr class="odd">
<td>[50, 3, 10, 7, 40, 80]</td>
<td>[3, 7, 40, 80]</td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-81" class="level4">
<h4 class="anchored" data-anchor-id="complexity-81">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Reconstruct LIS is a gentle bridge from computing a number to seeing the story behind it, each element tracing its lineage through the DP table.</p>
</section>
</section>
<section id="reconstruct-knapsack" class="level3">
<h3 class="anchored" data-anchor-id="reconstruct-knapsack">483 Reconstruct Knapsack</h3>
<p>Reconstructing the Knapsack solution means identifying which items form the optimal value, not just knowing the maximum value. This is the difference between understanding <em>what’s possible</em> and <em>what to choose</em>.</p>
<section id="what-problem-are-we-solving-82" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-82">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li><span class="math inline">\(n\)</span> items with values <span class="math inline">\(v[i]\)</span> and weights <span class="math inline">\(w[i]\)</span></li>
<li>Capacity <span class="math inline">\(W\)</span></li>
</ul>
<p>We want:</p>
<ul>
<li>Maximize total value without exceeding <span class="math inline">\(W\)</span></li>
<li>Recover the chosen items</li>
</ul>
<p>The 0/1 knapsack DP table is defined as:</p>
<p><span class="math display">\[
dp[i][w] =
\begin{cases}
0, &amp; \text{if } i = 0 \text{ or } w = 0,\\
dp[i-1][w], &amp; \text{if } w_i &gt; w,\\
\max(dp[i-1][w],\ dp[i-1][w - w_i] + v_i), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>To reconstruct, we backtrack from <span class="math inline">\(dp[n][W]\)</span>:</p>
<ul>
<li>If <span class="math inline">\(dp[i][w] \neq dp[i-1][w]\)</span>, then item <span class="math inline">\(i\)</span> was included</li>
<li>Subtract its weight, move to <span class="math inline">\(i-1\)</span></li>
</ul>
</section>
<section id="how-does-it-work-plain-language-79" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-79">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Build the standard 0/1 knapsack DP table.</p></li>
<li><p>Start from bottom-right corner <span class="math inline">\((n, W)\)</span>.</p></li>
<li><p>Compare <span class="math inline">\(dp[i][w]\)</span> vs <span class="math inline">\(dp[i-1][w]\)</span>:</p>
<ul>
<li>If different, include item <span class="math inline">\(i\)</span>, update <span class="math inline">\(w -= w_i\)</span>.</li>
</ul></li>
<li><p>Continue until <span class="math inline">\(i=0\)</span>.</p></li>
<li><p>Reverse selected items for correct order.</p></li>
</ol>
</section>
<section id="example-3" class="level4">
<h4 class="anchored" data-anchor-id="example-3">Example</h4>
<p>Let:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>Value</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>60</td>
<td>10</td>
</tr>
<tr class="even">
<td>2</td>
<td>100</td>
<td>20</td>
</tr>
<tr class="odd">
<td>3</td>
<td>120</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>Capacity <span class="math inline">\(W = 50\)</span></p>
<p>Optimal value = 220 Chosen items = {2, 3}</p>
</section>
<section id="tiny-code-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-3">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb181"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">4</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define W </span><span class="dv">50</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">60</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">120</span><span class="op">};</span></span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">};</span></span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>N<span class="op">][</span>W<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-11"><a href="#cb181-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb181-12"><a href="#cb181-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span></span>
<span id="cb181-13"><a href="#cb181-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb181-14"><a href="#cb181-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-15"><a href="#cb181-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb181-16"><a href="#cb181-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb181-17"><a href="#cb181-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>wt<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;=</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb181-18"><a href="#cb181-18" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> include <span class="op">=</span> val<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">-</span>wt<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb181-19"><a href="#cb181-19" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> exclude <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">];</span></span>
<span id="cb181-20"><a href="#cb181-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> include <span class="op">&gt;</span> exclude <span class="op">?</span> include <span class="op">:</span> exclude<span class="op">;</span></span>
<span id="cb181-21"><a href="#cb181-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">];</span></span>
<span id="cb181-22"><a href="#cb181-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb181-23"><a href="#cb181-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb181-24"><a href="#cb181-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-25"><a href="#cb181-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max Value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>N<span class="op">-</span><span class="dv">1</span><span class="op">][</span>W<span class="op">]);</span></span>
<span id="cb181-26"><a href="#cb181-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Items Taken: "</span><span class="op">);</span></span>
<span id="cb181-27"><a href="#cb181-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-28"><a href="#cb181-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> w <span class="op">=</span> W<span class="op">;</span></span>
<span id="cb181-29"><a href="#cb181-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> N<span class="op">-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb181-30"><a href="#cb181-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">!=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">])</span> <span class="op">{</span></span>
<span id="cb181-31"><a href="#cb181-31" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb181-32"><a href="#cb181-32" aria-hidden="true" tabindex="-1"></a>            w <span class="op">-=</span> wt<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb181-33"><a href="#cb181-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb181-34"><a href="#cb181-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb181-35"><a href="#cb181-35" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb181-36"><a href="#cb181-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb182"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reconstruct_knapsack(values, weights, W):</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(values)</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(W<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(W<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weights[i<span class="op">-</span><span class="dv">1</span>] <span class="op">&lt;=</span> w:</span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>                dp[i][w] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>][w],</span>
<span id="cb182-9"><a href="#cb182-9" aria-hidden="true" tabindex="-1"></a>                               values[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">1</span>][w <span class="op">-</span> weights[i<span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb182-10"><a href="#cb182-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb182-11"><a href="#cb182-11" aria-hidden="true" tabindex="-1"></a>                dp[i][w] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][w]</span>
<span id="cb182-12"><a href="#cb182-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-13"><a href="#cb182-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruction</span></span>
<span id="cb182-14"><a href="#cb182-14" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> W</span>
<span id="cb182-15"><a href="#cb182-15" aria-hidden="true" tabindex="-1"></a>    chosen <span class="op">=</span> []</span>
<span id="cb182-16"><a href="#cb182-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb182-17"><a href="#cb182-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dp[i][w] <span class="op">!=</span> dp[i<span class="op">-</span><span class="dv">1</span>][w]:</span>
<span id="cb182-18"><a href="#cb182-18" aria-hidden="true" tabindex="-1"></a>            chosen.append(i<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb182-19"><a href="#cb182-19" aria-hidden="true" tabindex="-1"></a>            w <span class="op">-=</span> weights[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb182-20"><a href="#cb182-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-21"><a href="#cb182-21" aria-hidden="true" tabindex="-1"></a>    chosen.reverse()</span>
<span id="cb182-22"><a href="#cb182-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][W], chosen</span>
<span id="cb182-23"><a href="#cb182-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-24"><a href="#cb182-24" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> [<span class="dv">60</span>, <span class="dv">100</span>, <span class="dv">120</span>]</span>
<span id="cb182-25"><a href="#cb182-25" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>]</span>
<span id="cb182-26"><a href="#cb182-26" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb182-27"><a href="#cb182-27" aria-hidden="true" tabindex="-1"></a>value, items <span class="op">=</span> reconstruct_knapsack(values, weights, W)</span>
<span id="cb182-28"><a href="#cb182-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, value)</span>
<span id="cb182-29"><a href="#cb182-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Items:"</span>, items)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-82" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-82">Why It Matters</h4>
<ul>
<li>Turns value tables into actionable decisions</li>
<li>Essential in optimization problems (resource allocation, budgeting)</li>
<li>Demonstrates traceback logic from DP matrix</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-69" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-69">A Gentle Proof (Why It Works)</h4>
<p>Every <span class="math inline">\(dp[i][w]\)</span> represents the best value using the first <span class="math inline">\(i\)</span> items under capacity <span class="math inline">\(w\)</span>. If <span class="math inline">\(dp[i][w] \neq dp[i-1][w]\)</span>, item <span class="math inline">\(i\)</span> was critical in improving value, so it must be included. Reducing <span class="math inline">\(w\)</span> by its weight and moving up repeats the same logic, tracing one optimal solution.</p>
</section>
<section id="try-it-yourself-82" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-82">Try It Yourself</h4>
<ol type="1">
<li>Modify for multiple optimal solutions (store parent paths).</li>
<li>Implement space-optimized DP and reconstruct with backtracking info.</li>
<li>Adapt for unbounded knapsack (reuse items).</li>
<li>Add total weight output.</li>
<li>Visualize reconstruction arrows from <span class="math inline">\(dp[n][W]\)</span>.</li>
</ol>
</section>
<section id="test-cases-82" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-82">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Values</th>
<th>Weights</th>
<th>W</th>
<th>Max Value</th>
<th>Items</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[60, 100, 120]</td>
<td>[10, 20, 30]</td>
<td>50</td>
<td>220</td>
<td>[1, 2]</td>
</tr>
<tr class="even">
<td>[10, 20, 30]</td>
<td>[1, 1, 1]</td>
<td>2</td>
<td>50</td>
<td>[1, 2]</td>
</tr>
<tr class="odd">
<td>[5, 4, 6, 3]</td>
<td>[2, 3, 4, 5]</td>
<td>5</td>
<td>7</td>
<td>[0, 1]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-82" class="level4">
<h4 class="anchored" data-anchor-id="complexity-82">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(nW)\)</span></li>
<li>Space: <span class="math inline">\(O(nW)\)</span> (can reduce to <span class="math inline">\(O(W)\)</span> for value-only)</li>
</ul>
<p>Reconstruction transforms knapsack from a math result to a real-world selection list, revealing <em>which</em> items make the optimum possible.</p>
</section>
</section>
<section id="edit-distance-alignment" class="level3">
<h3 class="anchored" data-anchor-id="edit-distance-alignment">484 Edit Distance Alignment</h3>
<p>Edit Distance tells us <em>how different</em> two strings are, alignment reconstruction shows <em>exactly where</em> they differ. By tracing the path of operations (insert, delete, substitute), we can visualize the full transformation.</p>
<section id="what-problem-are-we-solving-83" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-83">What Problem Are We Solving?</h4>
<p>Given two strings <span class="math inline">\(A\)</span> (length <span class="math inline">\(n\)</span>) and <span class="math inline">\(B\)</span> (length <span class="math inline">\(m\)</span>), compute not only the edit distance but also the alignment that transforms <span class="math inline">\(A\)</span> into <span class="math inline">\(B\)</span> using the minimum number of operations.</p>
<p>We define:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
0, &amp; \text{if } i = 0 \text{ and } j = 0,\\
i, &amp; \text{if } j = 0,\\
j, &amp; \text{if } i = 0,\\[6pt]
\displaystyle
\min\!\begin{cases}
dp[i-1][j] + 1, &amp; \text{deletion},\\
dp[i][j-1] + 1, &amp; \text{insertion},\\
dp[i-1][j-1] + \text{cost}(A[i-1], B[j-1]), &amp; \text{replace or match.}
\end{cases}
\end{cases}
\]</span></p>
<p>Then, we trace back from <span class="math inline">\(dp[n][m]\)</span> to list operations in reverse.</p>
</section>
<section id="how-does-it-work-plain-language-80" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-80">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Build standard Levenshtein DP table.</p></li>
<li><p>Start from <span class="math inline">\(dp[n][m]\)</span>.</p></li>
<li><p>Move:</p>
<ul>
<li>Diagonal: match or replace</li>
<li>Up: delete</li>
<li>Left: insert</li>
</ul></li>
<li><p>Record operation at each move.</p></li>
<li><p>Reverse the sequence for final alignment.</p></li>
</ol>
</section>
<section id="example-4" class="level4">
<h4 class="anchored" data-anchor-id="example-4">Example</h4>
<p>Let <span class="math inline">\(A=\text{"kitten"}\)</span>, <span class="math inline">\(B=\text{"sitting"}\)</span>.</p>
<p>Operations:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k → k</td>
<td>match</td>
<td>kitten / sitting</td>
</tr>
<tr class="even">
<td>i → i</td>
<td>match</td>
<td>kitten / sitting</td>
</tr>
<tr class="odd">
<td>t → t</td>
<td>match</td>
<td>kitten / sitting</td>
</tr>
<tr class="even">
<td>t → t</td>
<td>match</td>
<td>kitten / sitting</td>
</tr>
<tr class="odd">
<td>e → i</td>
<td>replace</td>
<td>kitti n</td>
</tr>
<tr class="even">
<td>insert g</td>
<td>insertion</td>
<td>kitting</td>
</tr>
</tbody>
</table>
<p>Edit distance = 3 (replace e→i, insert g, insert n)</p>
</section>
<section id="tiny-code-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-4">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb183"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min3<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&lt;</span> b <span class="op">?</span> <span class="op">(</span>a <span class="op">&lt;</span> c <span class="op">?</span> a <span class="op">:</span> c<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>b <span class="op">&lt;</span> c <span class="op">?</span> b <span class="op">:</span> c<span class="op">);</span></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> A<span class="op">[</span>MAX<span class="op">],</span> B<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> A<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>A<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-17"><a href="#cb183-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb183-18"><a href="#cb183-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> m<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb183-19"><a href="#cb183-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-20"><a href="#cb183-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb183-21"><a href="#cb183-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> m<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb183-22"><a href="#cb183-22" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> cost <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb183-23"><a href="#cb183-23" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> min3<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb183-24"><a href="#cb183-24" aria-hidden="true" tabindex="-1"></a>                            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb183-25"><a href="#cb183-25" aria-hidden="true" tabindex="-1"></a>                            dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> cost<span class="op">);</span></span>
<span id="cb183-26"><a href="#cb183-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb183-27"><a href="#cb183-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb183-28"><a href="#cb183-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-29"><a href="#cb183-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Edit Distance: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>m<span class="op">]);</span></span>
<span id="cb183-30"><a href="#cb183-30" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Operations:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb183-31"><a href="#cb183-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-32"><a href="#cb183-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> n<span class="op">,</span> j <span class="op">=</span> m<span class="op">;</span></span>
<span id="cb183-33"><a href="#cb183-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">||</span> j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-34"><a href="#cb183-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb183-35"><a href="#cb183-35" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match </span><span class="sc">%c\n</span><span class="st">"</span><span class="op">,</span> A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb183-36"><a href="#cb183-36" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span> j<span class="op">--;</span></span>
<span id="cb183-37"><a href="#cb183-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb183-38"><a href="#cb183-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-39"><a href="#cb183-39" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Replace </span><span class="sc">%c</span><span class="st"> -&gt; </span><span class="sc">%c\n</span><span class="st">"</span><span class="op">,</span> A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">],</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb183-40"><a href="#cb183-40" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span> j<span class="op">--;</span></span>
<span id="cb183-41"><a href="#cb183-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb183-42"><a href="#cb183-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-43"><a href="#cb183-43" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Delete </span><span class="sc">%c\n</span><span class="st">"</span><span class="op">,</span> A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb183-44"><a href="#cb183-44" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span></span>
<span id="cb183-45"><a href="#cb183-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb183-46"><a href="#cb183-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb183-47"><a href="#cb183-47" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Insert </span><span class="sc">%c\n</span><span class="st">"</span><span class="op">,</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb183-48"><a href="#cb183-48" aria-hidden="true" tabindex="-1"></a>            j<span class="op">--;</span></span>
<span id="cb183-49"><a href="#cb183-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb183-50"><a href="#cb183-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb183-51"><a href="#cb183-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edit_distance_alignment(A, B):</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(A), <span class="bu">len</span>(B)</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(m<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> A[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> B[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>                           dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a>                           dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> cost)</span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> n, m</span>
<span id="cb184-18"><a href="#cb184-18" aria-hidden="true" tabindex="-1"></a>    ops <span class="op">=</span> []</span>
<span id="cb184-19"><a href="#cb184-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb184-20"><a href="#cb184-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> A[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> B[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb184-21"><a href="#cb184-21" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="ss">f"Match </span><span class="sc">{</span>A[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb184-22"><a href="#cb184-22" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb184-23"><a href="#cb184-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[i][j] <span class="op">==</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb184-24"><a href="#cb184-24" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="ss">f"Replace </span><span class="sc">{</span>A[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss"> -&gt; </span><span class="sc">{</span>B[j<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb184-25"><a href="#cb184-25" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb184-26"><a href="#cb184-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[i][j] <span class="op">==</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb184-27"><a href="#cb184-27" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="ss">f"Delete </span><span class="sc">{</span>A[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb184-28"><a href="#cb184-28" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb184-29"><a href="#cb184-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb184-30"><a href="#cb184-30" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="ss">f"Insert </span><span class="sc">{</span>B[j<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb184-31"><a href="#cb184-31" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb184-32"><a href="#cb184-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-33"><a href="#cb184-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][m], <span class="bu">list</span>(<span class="bu">reversed</span>(ops))</span>
<span id="cb184-34"><a href="#cb184-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-35"><a href="#cb184-35" aria-hidden="true" tabindex="-1"></a>dist, ops <span class="op">=</span> edit_distance_alignment(<span class="st">"kitten"</span>, <span class="st">"sitting"</span>)</span>
<span id="cb184-36"><a href="#cb184-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edit Distance:"</span>, dist)</span>
<span id="cb184-37"><a href="#cb184-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Alignment:"</span>)</span>
<span id="cb184-38"><a href="#cb184-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> op <span class="kw">in</span> ops:</span>
<span id="cb184-39"><a href="#cb184-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(op)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-83" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-83">Why It Matters</h4>
<ul>
<li>Powers diff, spell checkers, and DNA sequence alignment</li>
<li>Essential for text transformation visualization</li>
<li>Reinforces traceback logic from DP tables</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-70" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-70">A Gentle Proof (Why It Works)</h4>
<p>Each <span class="math inline">\(dp[i][j]\)</span> is minimal over three possibilities:</p>
<ul>
<li>Insertion: adding <span class="math inline">\(B[j-1]\)</span></li>
<li>Deletion: removing <span class="math inline">\(A[i-1]\)</span></li>
<li>Replacement: changing <span class="math inline">\(A[i-1]\)</span> to <span class="math inline">\(B[j-1]\)</span></li>
</ul>
<p>The optimal path through the DP grid, via moves left, up, or diagonal, exactly records the sequence of minimal edits. Reversing the trace yields the transformation.</p>
</section>
<section id="try-it-yourself-83" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-83">Try It Yourself</h4>
<ol type="1">
<li>Compute alignment for “intention” → “execution”</li>
<li>Add operation count summary (insertions, deletions, replacements)</li>
<li>Visualize grid with arrows (↑, ←, ↖)</li>
<li>Modify cost: substitution = 2, insertion/deletion = 1</li>
<li>Return both alignment string and operation list</li>
</ol>
</section>
<section id="test-cases-83" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-83">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>Distance</th>
<th>Alignment (Ops)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>kitten</td>
<td>sitting</td>
<td>3</td>
<td>Replace e→i, Insert n, Insert g</td>
</tr>
<tr class="even">
<td>sunday</td>
<td>saturday</td>
<td>3</td>
<td>Insert a, Insert t, Replace n→r</td>
</tr>
<tr class="odd">
<td>horse</td>
<td>ros</td>
<td>3</td>
<td>Delete h, Replace o→r, Delete e</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-83" class="level4">
<h4 class="anchored" data-anchor-id="complexity-83">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(nm)\)</span></li>
<li>Space: <span class="math inline">\(O(nm)\)</span> (can reduce to <span class="math inline">\(O(\min(n,m))\)</span> without reconstruction)</li>
</ul>
<p>Edit Distance Alignment transforms a distance metric into a step-by-step story, showing exactly how one word becomes another.</p>
</section>
</section>
<section id="matrix-chain-parentheses" class="level3">
<h3 class="anchored" data-anchor-id="matrix-chain-parentheses">485 Matrix Chain Parentheses</h3>
<p>Matrix Chain Multiplication gives us the minimum number of multiplications, but reconstruction tells us how to parenthesize, the <em>order</em> of multiplication that achieves that cost. Without this step, we know the cost, but not the recipe.</p>
<section id="what-problem-are-we-solving-84" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-84">What Problem Are We Solving?</h4>
<p>Given a sequence of matrices <span class="math inline">\(A_1, A_2, \dots, A_n\)</span> with dimensions <span class="math inline">\(p_0 \times p_1, p_1 \times p_2, \dots, p_{n-1} \times p_n\)</span>, we want to determine the optimal parenthesization that minimizes scalar multiplications.</p>
<p>The cost DP is:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
0 &amp; \text{if } i = j \
\min_{i \le k &lt; j} (dp[i][k] + dp[k+1][j] + p_{i-1} \cdot p_k \cdot p_j)
\end{cases}
\]</span></p>
<p>To reconstruct the solution, we maintain a split table <span class="math inline">\(split[i][j]\)</span> indicating the index <span class="math inline">\(k\)</span> where the optimal split occurs.</p>
</section>
<section id="how-does-it-work-plain-language-81" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-81">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Compute cost table using bottom-up DP.</p></li>
<li><p>Track split point <span class="math inline">\(k\)</span> at each subproblem.</p></li>
<li><p>Recurse:</p>
<ul>
<li>Base: if <span class="math inline">\(i==j\)</span>, return <span class="math inline">\(A_i\)</span></li>
<li>Otherwise: <code>(</code> + solve(<span class="math inline">\(i\)</span>, <span class="math inline">\(k\)</span>) + solve(<span class="math inline">\(k+1\)</span>, <span class="math inline">\(j\)</span>) + <code>)</code></li>
</ul></li>
</ol>
<p>This yields the exact parenthesization.</p>
</section>
<section id="example-5" class="level4">
<h4 class="anchored" data-anchor-id="example-5">Example</h4>
<p>Matrix dimensions: <span class="math inline">\([40, 20, 30, 10, 30]\)</span></p>
<p>There are 4 matrices:</p>
<ul>
<li><span class="math inline">\(A_1: 40\times20\)</span></li>
<li><span class="math inline">\(A_2: 20\times30\)</span></li>
<li><span class="math inline">\(A_3: 30\times10\)</span></li>
<li><span class="math inline">\(A_4: 10\times30\)</span></li>
</ul>
<p>Optimal order: <span class="math inline">\(((A_1(A_2A_3))A_4)\)</span> Minimal cost: 26000</p>
</section>
<section id="tiny-code-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-5">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb185"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">5</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>N<span class="op">][</span>N<span class="op">];</span></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> split<span class="op">[</span>N<span class="op">][</span>N<span class="op">];</span></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">&lt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_paren<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"A</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"("</span><span class="op">);</span></span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>    print_paren<span class="op">(</span>i<span class="op">,</span> split<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a>    print_paren<span class="op">(</span>split<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">")"</span><span class="op">);</span></span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb185-21"><a href="#cb185-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-22"><a href="#cb185-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb185-23"><a href="#cb185-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> p<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">40</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">30</span><span class="op">};</span></span>
<span id="cb185-24"><a href="#cb185-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb185-25"><a href="#cb185-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-26"><a href="#cb185-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb185-27"><a href="#cb185-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-28"><a href="#cb185-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb185-29"><a href="#cb185-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> len <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb185-30"><a href="#cb185-30" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb185-31"><a href="#cb185-31" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> INT_MAX<span class="op">;</span></span>
<span id="cb185-32"><a href="#cb185-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i<span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb185-33"><a href="#cb185-33" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> cost <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>k<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> p<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]*</span>p<span class="op">[</span>k<span class="op">]*</span>p<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb185-34"><a href="#cb185-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>cost <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb185-35"><a href="#cb185-35" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> cost<span class="op">;</span></span>
<span id="cb185-36"><a href="#cb185-36" aria-hidden="true" tabindex="-1"></a>                    split<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb185-37"><a href="#cb185-37" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb185-38"><a href="#cb185-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb185-39"><a href="#cb185-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb185-40"><a href="#cb185-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb185-41"><a href="#cb185-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-42"><a href="#cb185-42" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Minimum cost: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb185-43"><a href="#cb185-43" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Optimal order: "</span><span class="op">);</span></span>
<span id="cb185-44"><a href="#cb185-44" aria-hidden="true" tabindex="-1"></a>    print_paren<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb185-45"><a href="#cb185-45" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb185-46"><a href="#cb185-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb186"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> matrix_chain_order(p):</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(p) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span> (n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>    split <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span> (n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">-</span>l<span class="op">+</span><span class="dv">2</span>):</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> l <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i, j):</span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>                cost <span class="op">=</span> dp[i][k] <span class="op">+</span> dp[k<span class="op">+</span><span class="dv">1</span>][j] <span class="op">+</span> p[i<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>p[k]<span class="op">*</span>p[j]</span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cost <span class="op">&lt;</span> dp[i][j]:</span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">=</span> cost</span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>                    split[i][j] <span class="op">=</span> k</span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-16"><a href="#cb186-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build(i, j):</span>
<span id="cb186-17"><a href="#cb186-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> j: <span class="cf">return</span> <span class="ss">f"A</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb186-18"><a href="#cb186-18" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> split[i][j]</span>
<span id="cb186-19"><a href="#cb186-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ss">f"(</span><span class="sc">{</span>build(i, k)<span class="sc">}{</span>build(k<span class="op">+</span><span class="dv">1</span>, j)<span class="sc">}</span><span class="ss">)"</span></span>
<span id="cb186-20"><a href="#cb186-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-21"><a href="#cb186-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">1</span>][n], build(<span class="dv">1</span>, n)</span>
<span id="cb186-22"><a href="#cb186-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-23"><a href="#cb186-23" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> [<span class="dv">40</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">10</span>, <span class="dv">30</span>]</span>
<span id="cb186-24"><a href="#cb186-24" aria-hidden="true" tabindex="-1"></a>cost, order <span class="op">=</span> matrix_chain_order(p)</span>
<span id="cb186-25"><a href="#cb186-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min Cost:"</span>, cost)</span>
<span id="cb186-26"><a href="#cb186-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Order:"</span>, order)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-84" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-84">Why It Matters</h4>
<ul>
<li>Converts abstract cost table into concrete plan</li>
<li>Foundation of query optimization, compiler expression parsing</li>
<li>Shows how split tracking yields human-readable structure</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-71" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-71">A Gentle Proof (Why It Works)</h4>
<p>At each subchain <span class="math inline">\((i, j)\)</span>, DP tries all <span class="math inline">\(k\)</span> splits. The chosen <span class="math inline">\(k\)</span> minimizing cost is stored in <code>split[i][j]</code>. By recursively applying these stored splits, we follow the same decision tree that generated the minimal cost. Thus reconstruction yields the exact sequence of multiplications.</p>
</section>
<section id="try-it-yourself-84" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-84">Try It Yourself</h4>
<ol type="1">
<li>Try <span class="math inline">\(p=[10, 20, 30, 40, 30]\)</span> and verify order.</li>
<li>Add printing of subproblem cost for each pair <span class="math inline">\((i,j)\)</span>.</li>
<li>Modify to return tree structure instead of string.</li>
<li>Visualize with nested parentheses tree.</li>
<li>Extend to show intermediate matrix dimensions at each step.</li>
</ol>
</section>
<section id="test-cases-84" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-84">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Dimensions</th>
<th>Cost</th>
<th>Parenthesization</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[40,20,30,10,30]</td>
<td>26000</td>
<td>((A1(A2A3))A4)</td>
</tr>
<tr class="even">
<td>[10,20,30]</td>
<td>6000</td>
<td>(A1A2A3)</td>
</tr>
<tr class="odd">
<td>[10,20,30,40,30]</td>
<td>30000</td>
<td>((A1A2)(A3A4))</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-84" class="level4">
<h4 class="anchored" data-anchor-id="complexity-84">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^3)\)</span></li>
<li>Space: <span class="math inline">\(O(n^2)\)</span></li>
</ul>
<p>Matrix Chain Parentheses turns cost minimization into concrete strategy, showing <em>not just how much</em>, but <em>how exactly</em>.</p>
</section>
</section>
<section id="coin-change-reconstruction" class="level3">
<h3 class="anchored" data-anchor-id="coin-change-reconstruction">486 Coin Change Reconstruction</h3>
<p>In the Coin Change problem, we usually count the minimum coins or total ways. Reconstruction, however, asks: <em>which exact coins make up the solution?</em> This bridges the gap between number answers and actual combinations.</p>
<section id="what-problem-are-we-solving-85" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-85">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A set of coin denominations <span class="math inline">\(coins = [c_1, c_2, \dots, c_n]\)</span></li>
<li>A target sum <span class="math inline">\(S\)</span></li>
</ul>
<p>We want to:</p>
<ol type="1">
<li>Compute the minimum number of coins needed (classic DP)</li>
<li>Reconstruct one optimal combination of coins that achieves <span class="math inline">\(S\)</span></li>
</ol>
<p>We define:</p>
<p><span class="math display">\[
dp[x] =
\begin{cases}
0, &amp; \text{if } x = 0,\\
1 + \displaystyle\min_{c \le x}\bigl(dp[x - c]\bigr), &amp; \text{if } x &gt; 0.
\end{cases}
\]</span></p>
<p>And record which coin gave the best solution:</p>
<p><span class="math display">\[
choice[x] = c \text{ that minimizes } dp[x-c]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-82" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-82">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Build DP array from <span class="math inline">\(0\)</span> to <span class="math inline">\(S\)</span>.</p></li>
<li><p>For each amount <span class="math inline">\(x\)</span>, try every coin <span class="math inline">\(c\)</span>.</p></li>
<li><p>Keep track of:</p>
<ul>
<li>The minimum coin count (<code>dp[x]</code>)</li>
<li>The coin used (<code>choice[x]</code>)</li>
</ul></li>
<li><p>After filling, trace back from <span class="math inline">\(S\)</span>: repeatedly subtract <code>choice[x]</code> until reaching 0.</p></li>
</ol>
</section>
<section id="example-6" class="level4">
<h4 class="anchored" data-anchor-id="example-6">Example</h4>
<p>Coins = [1, 3, 4], Target <span class="math inline">\(S = 6\)</span></p>
<p>DP steps:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>x</th>
<th>dp[x]</th>
<th>choice[x]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>4</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>5</td>
<td>2</td>
<td>1</td>
</tr>
<tr class="odd">
<td>6</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Optimal combination: [3, 3]</p>
</section>
<section id="tiny-code-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-6">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb187"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> coins<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> S <span class="op">=</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>MAX<span class="op">],</span> choice<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-12"><a href="#cb187-12" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb187-13"><a href="#cb187-13" aria-hidden="true" tabindex="-1"></a>    choice<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb187-14"><a href="#cb187-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-15"><a href="#cb187-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> S<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb187-16"><a href="#cb187-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INT_MAX<span class="op">;</span></span>
<span id="cb187-17"><a href="#cb187-17" aria-hidden="true" tabindex="-1"></a>        choice<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb187-18"><a href="#cb187-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb187-19"><a href="#cb187-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> c <span class="op">=</span> coins<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb187-20"><a href="#cb187-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>c <span class="op">&lt;=</span> i <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i<span class="op">-</span>c<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb187-21"><a href="#cb187-21" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span>c<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb187-22"><a href="#cb187-22" aria-hidden="true" tabindex="-1"></a>                choice<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb187-23"><a href="#cb187-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb187-24"><a href="#cb187-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb187-25"><a href="#cb187-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb187-26"><a href="#cb187-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-27"><a href="#cb187-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Min coins: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>S<span class="op">]);</span></span>
<span id="cb187-28"><a href="#cb187-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Combination: "</span><span class="op">);</span></span>
<span id="cb187-29"><a href="#cb187-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> S<span class="op">;</span></span>
<span id="cb187-30"><a href="#cb187-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb187-31"><a href="#cb187-31" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> choice<span class="op">[</span>x<span class="op">]);</span></span>
<span id="cb187-32"><a href="#cb187-32" aria-hidden="true" tabindex="-1"></a>        x <span class="op">-=</span> choice<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb187-33"><a href="#cb187-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb187-34"><a href="#cb187-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb187-35"><a href="#cb187-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb188"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coin_change_reconstruct(coins, S):</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> (S <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    choice <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> (S <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, S <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> coins:</span>
<span id="cb188-8"><a href="#cb188-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> c <span class="op">&lt;=</span> x <span class="kw">and</span> dp[x <span class="op">-</span> c] <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> dp[x]:</span>
<span id="cb188-9"><a href="#cb188-9" aria-hidden="true" tabindex="-1"></a>                dp[x] <span class="op">=</span> dp[x <span class="op">-</span> c] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb188-10"><a href="#cb188-10" aria-hidden="true" tabindex="-1"></a>                choice[x] <span class="op">=</span> c</span>
<span id="cb188-11"><a href="#cb188-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-12"><a href="#cb188-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dp[S] <span class="op">==</span> <span class="bu">float</span>(<span class="st">'inf'</span>):</span>
<span id="cb188-13"><a href="#cb188-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span>, []</span>
<span id="cb188-14"><a href="#cb188-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-15"><a href="#cb188-15" aria-hidden="true" tabindex="-1"></a>    comb <span class="op">=</span> []</span>
<span id="cb188-16"><a href="#cb188-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> S <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb188-17"><a href="#cb188-17" aria-hidden="true" tabindex="-1"></a>        comb.append(choice[S])</span>
<span id="cb188-18"><a href="#cb188-18" aria-hidden="true" tabindex="-1"></a>        S <span class="op">-=</span> choice[S]</span>
<span id="cb188-19"><a href="#cb188-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-20"><a href="#cb188-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>], comb</span>
<span id="cb188-21"><a href="#cb188-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-22"><a href="#cb188-22" aria-hidden="true" tabindex="-1"></a>coins <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb188-23"><a href="#cb188-23" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb188-24"><a href="#cb188-24" aria-hidden="true" tabindex="-1"></a>count, comb <span class="op">=</span> coin_change_reconstruct(coins, S)</span>
<span id="cb188-25"><a href="#cb188-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min coins:"</span>, count)</span>
<span id="cb188-26"><a href="#cb188-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Combination:"</span>, comb)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-85" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-85">Why It Matters</h4>
<ul>
<li>Converts abstract DP result into practical plan</li>
<li>Critical in finance, vending systems, resource allocation</li>
<li>Reinforces traceback technique for linear DP problems</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-72" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-72">A Gentle Proof (Why It Works)</h4>
<p>By definition, <span class="math inline">\(dp[x] = 1 + dp[x-c]\)</span> for optimal <span class="math inline">\(c\)</span>. Thus the optimal last step for <span class="math inline">\(x\)</span> must use coin <span class="math inline">\(choice[x] = c\)</span>. Repeatedly subtracting this <span class="math inline">\(c\)</span> gives a valid sequence ending at <span class="math inline">\(0\)</span>. Each step reduces the problem size while preserving optimality (greedy by DP).</p>
</section>
<section id="try-it-yourself-85" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-85">Try It Yourself</h4>
<ol type="1">
<li>Try <span class="math inline">\(coins=[1,3,4]\)</span>, <span class="math inline">\(S=10\)</span></li>
<li>Modify to return all optimal combinations (if multiple)</li>
<li>Extend for limited coin counts</li>
<li>Visualize table <span class="math inline">\((x, dp[x], choice[x])\)</span></li>
<li>Adapt for non-canonical systems (like [1, 3, 5, 7])</li>
</ol>
</section>
<section id="test-cases-85" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-85">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Coins</th>
<th>S</th>
<th>Min Coins</th>
<th>Combination</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1, 3, 4]</td>
<td>6</td>
<td>2</td>
<td>[3, 3]</td>
</tr>
<tr class="even">
<td>[1, 2, 5]</td>
<td>11</td>
<td>3</td>
<td>[5, 5, 1]</td>
</tr>
<tr class="odd">
<td>[2, 5, 10]</td>
<td>7</td>
<td>∞</td>
<td>[]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-85" class="level4">
<h4 class="anchored" data-anchor-id="complexity-85">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(S \times n)\)</span></li>
<li>Space: <span class="math inline">\(O(S)\)</span></li>
</ul>
<p>Coin Change Reconstruction transforms “how many” into “which ones”, building not just an answer, but a clear path to it.</p>
</section>
</section>
<section id="path-reconstruction-dp" class="level3">
<h3 class="anchored" data-anchor-id="path-reconstruction-dp">487 Path Reconstruction DP</h3>
<p>Path reconstruction in DP is the art of retracing your steps through a cost or distance table to find the <em>exact route</em> that led to the optimal answer. It’s not enough to know <em>how far</em>, you want to know <em>how you got there</em>.</p>
<section id="what-problem-are-we-solving-86" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-86">What Problem Are We Solving?</h4>
<p>Given a grid (or graph) where each cell has a cost, we compute the minimum path cost from a start cell <span class="math inline">\((0,0)\)</span> to a destination <span class="math inline">\((n-1, m-1)\)</span> using only right or down moves. Now, instead of just reporting the minimal cost, we’ll reconstruct the path.</p>
<p>We define:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
grid[0][0], &amp; \text{if } i = 0 \text{ and } j = 0,\\
grid[i][j] + \min\bigl(dp[i-1][j],\ dp[i][j-1]\bigr), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>We also maintain a parent table <code>parent[i][j]</code> to remember whether we came from top or left.</p>
</section>
<section id="how-does-it-work-plain-language-83" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-83">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Fill dp[i][j] with the minimum cost to reach each cell.</p></li>
<li><p>Track the move that led to this cost:</p>
<ul>
<li>If <span class="math inline">\(dp[i][j]\)</span> came from <span class="math inline">\(dp[i-1][j]\)</span>, parent = “up”</li>
<li>Else parent = “left”</li>
</ul></li>
<li><p>Start from destination <span class="math inline">\((n-1,m-1)\)</span> and backtrack using <code>parent</code>.</p></li>
<li><p>Reverse the reconstructed list for the correct order.</p></li>
</ol>
</section>
<section id="example-7" class="level4">
<h4 class="anchored" data-anchor-id="example-7">Example</h4>
<p>Grid:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>1</th>
<th>3</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>5</td>
<td>1</td>
</tr>
<tr class="even">
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Minimal path sum: 7 Path: <span class="math inline">\((0,0)\rightarrow(0,1)\rightarrow(0,2)\rightarrow(1,2)\rightarrow(2,2)\)</span></p>
</section>
<section id="tiny-code-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-7">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb189"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">3</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define M </span><span class="dv">3</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> grid<span class="op">[</span>N<span class="op">][</span>M<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>N<span class="op">][</span>M<span class="op">];</span></span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> parent<span class="op">[</span>N<span class="op">][</span>M<span class="op">];</span> <span class="co">// 'U' = up, 'L' = left</span></span>
<span id="cb189-15"><a href="#cb189-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-16"><a href="#cb189-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">&lt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb189-17"><a href="#cb189-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-18"><a href="#cb189-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb189-19"><a href="#cb189-19" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb189-20"><a href="#cb189-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-21"><a href="#cb189-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// First row</span></span>
<span id="cb189-22"><a href="#cb189-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> M<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb189-23"><a href="#cb189-23" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb189-24"><a href="#cb189-24" aria-hidden="true" tabindex="-1"></a>        parent<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="ch">'L'</span><span class="op">;</span></span>
<span id="cb189-25"><a href="#cb189-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb189-26"><a href="#cb189-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// First column</span></span>
<span id="cb189-27"><a href="#cb189-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb189-28"><a href="#cb189-28" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb189-29"><a href="#cb189-29" aria-hidden="true" tabindex="-1"></a>        parent<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="ch">'U'</span><span class="op">;</span></span>
<span id="cb189-30"><a href="#cb189-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb189-31"><a href="#cb189-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-32"><a href="#cb189-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill rest</span></span>
<span id="cb189-33"><a href="#cb189-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb189-34"><a href="#cb189-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> M<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb189-35"><a href="#cb189-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb189-36"><a href="#cb189-36" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb189-37"><a href="#cb189-37" aria-hidden="true" tabindex="-1"></a>                parent<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="ch">'U'</span><span class="op">;</span></span>
<span id="cb189-38"><a href="#cb189-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb189-39"><a href="#cb189-39" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb189-40"><a href="#cb189-40" aria-hidden="true" tabindex="-1"></a>                parent<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="ch">'L'</span><span class="op">;</span></span>
<span id="cb189-41"><a href="#cb189-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb189-42"><a href="#cb189-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb189-43"><a href="#cb189-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb189-44"><a href="#cb189-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-45"><a href="#cb189-45" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Min path sum: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>N<span class="op">-</span><span class="dv">1</span><span class="op">][</span>M<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb189-46"><a href="#cb189-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-47"><a href="#cb189-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Backtrack</span></span>
<span id="cb189-48"><a href="#cb189-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> N <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> j <span class="op">=</span> M <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb189-49"><a href="#cb189-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> path<span class="op">[</span><span class="dv">100</span><span class="op">][</span><span class="dv">2</span><span class="op">],</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb189-50"><a href="#cb189-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">==</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb189-51"><a href="#cb189-51" aria-hidden="true" tabindex="-1"></a>        path<span class="op">[</span>len<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb189-52"><a href="#cb189-52" aria-hidden="true" tabindex="-1"></a>        path<span class="op">[</span>len<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb189-53"><a href="#cb189-53" aria-hidden="true" tabindex="-1"></a>        len<span class="op">++;</span></span>
<span id="cb189-54"><a href="#cb189-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>parent<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="ch">'U'</span><span class="op">)</span> i<span class="op">--;</span></span>
<span id="cb189-55"><a href="#cb189-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> j<span class="op">--;</span></span>
<span id="cb189-56"><a href="#cb189-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb189-57"><a href="#cb189-57" aria-hidden="true" tabindex="-1"></a>    path<span class="op">[</span>len<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> path<span class="op">[</span>len<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb189-58"><a href="#cb189-58" aria-hidden="true" tabindex="-1"></a>    len<span class="op">++;</span></span>
<span id="cb189-59"><a href="#cb189-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-60"><a href="#cb189-60" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Path: "</span><span class="op">);</span></span>
<span id="cb189-61"><a href="#cb189-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> k<span class="op">--)</span></span>
<span id="cb189-62"><a href="#cb189-62" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) "</span><span class="op">,</span> path<span class="op">[</span>k<span class="op">][</span><span class="dv">0</span><span class="op">],</span> path<span class="op">[</span>k<span class="op">][</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb189-63"><a href="#cb189-63" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb189-64"><a href="#cb189-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb190"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_path_sum_path(grid):</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>m <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [[<span class="st">''</span>]<span class="op">*</span>m <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>        parent[<span class="dv">0</span>][j] <span class="op">=</span> <span class="st">'L'</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a>        parent[i][<span class="dv">0</span>] <span class="op">=</span> <span class="st">'U'</span></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb190-16"><a href="#cb190-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb190-17"><a href="#cb190-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">&lt;</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb190-18"><a href="#cb190-18" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> grid[i][j]</span>
<span id="cb190-19"><a href="#cb190-19" aria-hidden="true" tabindex="-1"></a>                parent[i][j] <span class="op">=</span> <span class="st">'U'</span></span>
<span id="cb190-20"><a href="#cb190-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb190-21"><a href="#cb190-21" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> grid[i][j]</span>
<span id="cb190-22"><a href="#cb190-22" aria-hidden="true" tabindex="-1"></a>                parent[i][j] <span class="op">=</span> <span class="st">'L'</span></span>
<span id="cb190-23"><a href="#cb190-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-24"><a href="#cb190-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Backtrack</span></span>
<span id="cb190-25"><a href="#cb190-25" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> []</span>
<span id="cb190-26"><a href="#cb190-26" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> n<span class="op">-</span><span class="dv">1</span>, m<span class="op">-</span><span class="dv">1</span></span>
<span id="cb190-27"><a href="#cb190-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="kw">not</span> (i <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb190-28"><a href="#cb190-28" aria-hidden="true" tabindex="-1"></a>        path.append((i, j))</span>
<span id="cb190-29"><a href="#cb190-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parent[i][j] <span class="op">==</span> <span class="st">'U'</span>:</span>
<span id="cb190-30"><a href="#cb190-30" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb190-31"><a href="#cb190-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb190-32"><a href="#cb190-32" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb190-33"><a href="#cb190-33" aria-hidden="true" tabindex="-1"></a>    path.append((<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb190-34"><a href="#cb190-34" aria-hidden="true" tabindex="-1"></a>    path.reverse()</span>
<span id="cb190-35"><a href="#cb190-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-36"><a href="#cb190-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>], path</span>
<span id="cb190-37"><a href="#cb190-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-38"><a href="#cb190-38" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">1</span>],[<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>]]</span>
<span id="cb190-39"><a href="#cb190-39" aria-hidden="true" tabindex="-1"></a>cost, path <span class="op">=</span> min_path_sum_path(grid)</span>
<span id="cb190-40"><a href="#cb190-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Min cost:"</span>, cost)</span>
<span id="cb190-41"><a href="#cb190-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Path:"</span>, path)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-86" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-86">Why It Matters</h4>
<ul>
<li>Translates numerical DP into navigable routes</li>
<li>Key in pathfinding, robot navigation, route planning</li>
<li>Demonstrates parent-pointer technique for 2D grids</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-73" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-73">A Gentle Proof (Why It Works)</h4>
<p>By construction, <span class="math inline">\(dp[i][j]\)</span> stores the minimal cost to reach <span class="math inline">\((i,j)\)</span>. Since each cell depends only on top and left, storing the better source as <code>parent[i][j]</code> ensures each step back leads to a valid prefix of an optimal path. Following parents reconstructs one such optimal path.</p>
</section>
<section id="try-it-yourself-86" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-86">Try It Yourself</h4>
<ol type="1">
<li>Try on a <span class="math inline">\(4\times4\)</span> grid with random costs.</li>
<li>Modify to allow diagonal moves.</li>
<li>Extend for maximum path sum (change min→max).</li>
<li>Visualize path arrows (↑, ←).</li>
<li>Adapt for graph shortest path with adjacency matrix.</li>
</ol>
</section>
<section id="test-cases-86" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-86">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Grid</th>
<th>Result</th>
<th>Path</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[1,3,1],[1,5,1],[4,2,1]]</td>
<td>7</td>
<td>[(0,0),(0,1),(0,2),(1,2),(2,2)]</td>
</tr>
<tr class="even">
<td>[[1,2,3],[4,5,6]]</td>
<td>12</td>
<td>[(0,0),(0,1),(0,2),(1,2)]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-86" class="level4">
<h4 class="anchored" data-anchor-id="complexity-86">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(nm)\)</span></li>
<li>Space: <span class="math inline">\(O(nm)\)</span></li>
</ul>
<p>Path Reconstruction DP turns shortest paths into visible journeys, showing every choice that built the optimum.</p>
</section>
</section>
<section id="sequence-reconstruction" class="level3">
<h3 class="anchored" data-anchor-id="sequence-reconstruction">488 Sequence Reconstruction</h3>
<p>Sequence Reconstruction is the process of recovering an entire sequence from partial or implicit information, typically from DP tables, prefix relations, or pairwise constraints. It is a bridge between solving a problem and interpreting its answer as a sequence.</p>
<section id="what-problem-are-we-solving-87" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-87">What Problem Are We Solving?</h4>
<p>You often solve DP problems that count or score possible sequences, but what if you need to recover one valid sequence (or even all)? For example:</p>
<ol type="1">
<li>Given the LIS length, reconstruct one LIS.</li>
<li>Given partial orders, reconstruct a sequence that satisfies them.</li>
<li>Given prefix sums, rebuild the original array.</li>
</ol>
<p>Here, we’ll explore a general pattern: rebuild the sequence using parent or predecessor states tracked during DP.</p>
</section>
<section id="example-reconstruct-longest-increasing-subsequence" class="level4">
<h4 class="anchored" data-anchor-id="example-reconstruct-longest-increasing-subsequence">Example: Reconstruct Longest Increasing Subsequence</h4>
<p>Given an array <code>arr</code>, we first compute <code>dp[i]</code> = length of LIS ending at <code>i</code>. We then track predecessors using <code>parent[i]</code> to rebuild the actual subsequence.</p>
</section>
<section id="recurrence-3" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-3">Recurrence</h4>
<p><span class="math display">\[
dp[i] = 1 + \max_{j&lt;i,\ arr[j]&lt;arr[i]} dp[j]
\]</span></p>
<p>with <span class="math display">\[
parent[i] = \arg\max_{j&lt;i,\ arr[j]&lt;arr[i]} dp[j]
\]</span></p>
<p>After computing <code>dp</code>, we find the index of max(dp), then backtrack using <code>parent</code>.</p>
</section>
<section id="how-does-it-work-plain-language-84" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-84">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>Run the LIS DP as usual.</li>
<li>Whenever we update <code>dp[i]</code>, store which previous index gave that improvement.</li>
<li>After finishing, find the end index of the best LIS.</li>
<li>Walk backward using <code>parent</code> until <code>-1</code>.</li>
<li>Reverse the collected indices, that’s your LIS.</li>
</ol>
</section>
<section id="tiny-code-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-8">Tiny Code</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb191"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reconstruct_lis(arr):</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[j] <span class="op">&lt;</span> arr[i] <span class="kw">and</span> dp[j] <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> dp[i]:</span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> dp[j] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>                parent[i] <span class="op">=</span> j</span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">max</span>(dp)</span>
<span id="cb191-13"><a href="#cb191-13" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> dp.index(length)</span>
<span id="cb191-14"><a href="#cb191-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-15"><a href="#cb191-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Backtrack</span></span>
<span id="cb191-16"><a href="#cb191-16" aria-hidden="true" tabindex="-1"></a>    lis <span class="op">=</span> []</span>
<span id="cb191-17"><a href="#cb191-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> idx <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb191-18"><a href="#cb191-18" aria-hidden="true" tabindex="-1"></a>        lis.append(arr[idx])</span>
<span id="cb191-19"><a href="#cb191-19" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> parent[idx]</span>
<span id="cb191-20"><a href="#cb191-20" aria-hidden="true" tabindex="-1"></a>    lis.reverse()</span>
<span id="cb191-21"><a href="#cb191-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lis</span>
<span id="cb191-22"><a href="#cb191-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-23"><a href="#cb191-23" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">101</span>, <span class="dv">18</span>]</span>
<span id="cb191-24"><a href="#cb191-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(reconstruct_lis(arr))  <span class="co"># [2, 3, 7, 18]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="c-version" class="level4">
<h4 class="anchored" data-anchor-id="c-version">C Version</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb192"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">101</span><span class="op">,</span> <span class="dv">18</span><span class="op">};</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>arr<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n<span class="op">],</span> parent<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>        parent<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-12"><a href="#cb192-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb192-13"><a href="#cb192-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb192-14"><a href="#cb192-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> dp<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb192-15"><a href="#cb192-15" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb192-16"><a href="#cb192-16" aria-hidden="true" tabindex="-1"></a>                parent<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb192-17"><a href="#cb192-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb192-18"><a href="#cb192-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb192-19"><a href="#cb192-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb192-20"><a href="#cb192-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-21"><a href="#cb192-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// find max index</span></span>
<span id="cb192-22"><a href="#cb192-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_len <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> idx <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb192-23"><a href="#cb192-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb192-24"><a href="#cb192-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> max_len<span class="op">)</span> <span class="op">{</span></span>
<span id="cb192-25"><a href="#cb192-25" aria-hidden="true" tabindex="-1"></a>            max_len <span class="op">=</span> dp<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb192-26"><a href="#cb192-26" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb192-27"><a href="#cb192-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb192-28"><a href="#cb192-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb192-29"><a href="#cb192-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-30"><a href="#cb192-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// reconstruct</span></span>
<span id="cb192-31"><a href="#cb192-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lis<span class="op">[</span>n<span class="op">],</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb192-32"><a href="#cb192-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>idx <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb192-33"><a href="#cb192-33" aria-hidden="true" tabindex="-1"></a>        lis<span class="op">[</span>len<span class="op">++]</span> <span class="op">=</span> arr<span class="op">[</span>idx<span class="op">];</span></span>
<span id="cb192-34"><a href="#cb192-34" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> parent<span class="op">[</span>idx<span class="op">];</span></span>
<span id="cb192-35"><a href="#cb192-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb192-36"><a href="#cb192-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-37"><a href="#cb192-37" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"LIS: "</span><span class="op">);</span></span>
<span id="cb192-38"><a href="#cb192-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> lis<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb192-39"><a href="#cb192-39" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb192-40"><a href="#cb192-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-87" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-87">Why It Matters</h4>
<ul>
<li>Shows how DP tables contain full structure, not just values</li>
<li>Useful in bioinformatics, diff tools, edit tracing, sequence alignment</li>
<li>Forms the foundation for traceback algorithms</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-74" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-74">A Gentle Proof (Why It Works)</h4>
<p>By induction on index <code>i</code>:</p>
<ul>
<li>Base case: first element, LIS = <code>[arr[i]]</code></li>
<li>Inductive step: each <code>parent[i]</code> points to the previous LIS endpoint giving max length Thus, following parent pointers from the max element recreates a valid LIS, and reversing yields forward order.</li>
</ul>
</section>
<section id="try-it-yourself-87" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-87">Try It Yourself</h4>
<ol type="1">
<li>Change condition to <code>arr[j] &gt; arr[i]</code> → Longest Decreasing Subsequence.</li>
<li>Modify to track all LIS sequences.</li>
<li>Print indices instead of values.</li>
<li>Extend to two dimensions (nested envelopes).</li>
<li>Combine with binary search LIS to get <span class="math inline">\(O(n \log n)\)</span> reconstruction.</li>
</ol>
</section>
<section id="test-cases-87" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-87">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>LIS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[10,9,2,5,3,7,101,18]</td>
<td>[2,3,7,18]</td>
</tr>
<tr class="even">
<td>[3,10,2,1,20]</td>
<td>[3,10,20]</td>
</tr>
<tr class="odd">
<td>[50,3,10,7,40,80]</td>
<td>[3,7,40,80]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-87" class="level4">
<h4 class="anchored" data-anchor-id="complexity-87">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Sequence Reconstruction turns numerical answers into narrative sequences, revealing how each element fits into the optimal story.</p>
</section>
</section>
<section id="multi-choice-reconstruction" class="level3">
<h3 class="anchored" data-anchor-id="multi-choice-reconstruction">489 Multi-Choice Reconstruction</h3>
<p>Multi-Choice Reconstruction is about retracing selections when a DP problem allows multiple choices per state, such as picking from categories, groups, or configurations. It extends simple parent tracking into multi-dimensional or multi-decision DP, reconstructing a full combination of choices that led to the optimal answer.</p>
<section id="what-problem-are-we-solving-88" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-88">What Problem Are We Solving?</h4>
<p>Some DP problems involve choosing one option from several categories, such as:</p>
<ol type="1">
<li>Multi-choice Knapsack, each group has several items; you can pick at most one.</li>
<li>Course Scheduling, pick one time slot per subject to maximize free time.</li>
<li>Machine Assignment, choose one machine per job for minimal cost.</li>
</ol>
<p>We need to not only compute the optimal value, but also reconstruct which choices were made across categories.</p>
</section>
<section id="example-multi-choice-knapsack" class="level4">
<h4 class="anchored" data-anchor-id="example-multi-choice-knapsack">Example: Multi-Choice Knapsack</h4>
<p>Given <code>G</code> groups, each containing several items <code>(weight, value)</code>, select one item per group such that the total weight ≤ W and value is maximized.</p>
</section>
<section id="state-definition" class="level4">
<h4 class="anchored" data-anchor-id="state-definition">State Definition</h4>
<p>Let <span class="math inline">\(dp[g][w]\)</span> = max value using first <span class="math inline">\(g\)</span> groups with total weight <span class="math inline">\(w\)</span>. We will track which item in each group contributed to this value.</p>
</section>
<section id="recurrence-4" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-4">Recurrence</h4>
<p><span class="math display">\[
dp[g][w] = \max_{(w_i, v_i) \in group[g]} \big(dp[g-1][w - w_i] + v_i\big)
\]</span></p>
<p>To reconstruct, we store:</p>
<p><span class="math display">\[
choice[g][w] = i \text{ such that } dp[g][w] \text{ achieved by item } i
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-85" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-85">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>For each group, for each capacity, try every item in the group.</li>
<li>Pick the one that gives the highest value.</li>
<li>Store which item index gave that best value in <code>choice</code>.</li>
<li>After filling the table, backtrack from <code>(G, W)</code> using <code>choice</code> to rebuild selected items.</li>
</ol>
</section>
<section id="tiny-code-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-9">Tiny Code</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb193"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_choice_knapsack(groups, W):</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> <span class="bu">len</span>(groups)</span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(G <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>    choice <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(G <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> g <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, G <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(W <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> idx, (wt, val) <span class="kw">in</span> <span class="bu">enumerate</span>(groups[g <span class="op">-</span> <span class="dv">1</span>]):</span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> wt <span class="op">&lt;=</span> w <span class="kw">and</span> dp[g <span class="op">-</span> <span class="dv">1</span>][w <span class="op">-</span> wt] <span class="op">+</span> val <span class="op">&gt;</span> dp[g][w]:</span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>                    dp[g][w] <span class="op">=</span> dp[g <span class="op">-</span> <span class="dv">1</span>][w <span class="op">-</span> wt] <span class="op">+</span> val</span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>                    choice[g][w] <span class="op">=</span> idx</span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Backtrack</span></span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> W</span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a>    selected <span class="op">=</span> []</span>
<span id="cb193-16"><a href="#cb193-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> g <span class="kw">in</span> <span class="bu">range</span>(G, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb193-17"><a href="#cb193-17" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> choice[g][w]</span>
<span id="cb193-18"><a href="#cb193-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> idx <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb193-19"><a href="#cb193-19" aria-hidden="true" tabindex="-1"></a>            wt, val <span class="op">=</span> groups[g <span class="op">-</span> <span class="dv">1</span>][idx]</span>
<span id="cb193-20"><a href="#cb193-20" aria-hidden="true" tabindex="-1"></a>            selected.append((g <span class="op">-</span> <span class="dv">1</span>, idx, wt, val))</span>
<span id="cb193-21"><a href="#cb193-21" aria-hidden="true" tabindex="-1"></a>            w <span class="op">-=</span> wt</span>
<span id="cb193-22"><a href="#cb193-22" aria-hidden="true" tabindex="-1"></a>    selected.reverse()</span>
<span id="cb193-23"><a href="#cb193-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[G][W], selected</span>
<span id="cb193-24"><a href="#cb193-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-25"><a href="#cb193-25" aria-hidden="true" tabindex="-1"></a>groups <span class="op">=</span> [</span>
<span id="cb193-26"><a href="#cb193-26" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">3</span>, <span class="dv">5</span>), (<span class="dv">2</span>, <span class="dv">3</span>)], </span>
<span id="cb193-27"><a href="#cb193-27" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">4</span>, <span class="dv">6</span>), (<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>)], </span>
<span id="cb193-28"><a href="#cb193-28" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">1</span>, <span class="dv">1</span>)]</span>
<span id="cb193-29"><a href="#cb193-29" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb193-30"><a href="#cb193-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(multi_choice_knapsack(groups, <span class="dv">7</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(13, [(0, 0, 3, 5), (1, 1, 1, 2), (2, 0, 2, 4)])</code></pre>
</section>
<section id="why-it-matters-88" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-88">Why It Matters</h4>
<ul>
<li>Many optimization problems involve multiple nested decisions.</li>
<li>Useful in resource allocation, scheduling, and multi-constraint planning.</li>
<li>Reconstruction helps explain why the DP made each choice, crucial for debugging and interpretation.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-75" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-75">A Gentle Proof (Why It Works)</h4>
<p>We proceed by induction on <code>g</code> (group count):</p>
<ul>
<li>Base Case: <span class="math inline">\(g=1\)</span>, choose the best item under capacity <span class="math inline">\(w\)</span>.</li>
<li>Inductive Step: assume all optimal choices up to group <span class="math inline">\(g-1\)</span> are correct. For group <span class="math inline">\(g\)</span>, each <code>dp[g][w]</code> is built from <code>dp[g-1][w-w_i] + v_i</code>, and storing the index <code>i</code> ensures reconstructing one valid optimal chain backward from <span class="math inline">\((G,W)\)</span>.</li>
</ul>
<p>Thus, each backtracked choice sequence corresponds to one optimal solution.</p>
</section>
<section id="try-it-yourself-88" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-88">Try It Yourself</h4>
<ol type="1">
<li>Add a limit on total number of groups selected.</li>
<li>Modify for multiple item selections per group.</li>
<li>Print group name instead of index.</li>
<li>Extend to 3D DP (group × capacity × budget).</li>
<li>Reconstruct second-best solution by skipping one choice.</li>
</ol>
</section>
<section id="test-cases-88" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-88">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 60%">
<col style="width: 1%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Groups</th>
<th>W</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[[(3,5),(2,3)], [(4,6),(1,2),(3,4)], [(2,4),(1,1)]]</code></td>
<td>7</td>
<td>Value=13, picks=(3,5),(1,2),(2,4)</td>
</tr>
<tr class="even">
<td><code>[[(2,3)], [(2,2),(3,5)]]</code></td>
<td>5</td>
<td>Value=8</td>
</tr>
<tr class="odd">
<td><code>[[(1,1),(2,4)], [(2,2),(3,5)]]</code></td>
<td>4</td>
<td>Value=6</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-88" class="level4">
<h4 class="anchored" data-anchor-id="complexity-88">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(G \cdot W \cdot K)\)</span> where <span class="math inline">\(K\)</span> = max group size</li>
<li>Space: <span class="math inline">\(O(G \cdot W)\)</span></li>
</ul>
<p>Multi-Choice Reconstruction turns layered decision DPs into understandable sequences, revealing exactly what was chosen and why.</p>
</section>
</section>
<section id="traceback-visualization" class="level3">
<h3 class="anchored" data-anchor-id="traceback-visualization">490 Traceback Visualization</h3>
<p>Traceback Visualization is about seeing how a DP algorithm reconstructs its answer, turning invisible state transitions into a clear path of decisions. It converts a DP table into a narrative of moves, showing how each optimal solution is formed step by step.</p>
<section id="what-problem-are-we-solving-89" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-89">What Problem Are We Solving?</h4>
<p>Most DP problems compute optimal values but hide how those values were reached. Traceback visualization helps us answer:</p>
<ul>
<li>Which transitions were taken?</li>
<li>How do we get from the base case to the solution?</li>
<li>What pattern does the DP follow through its table?</li>
</ul>
<p>You’re not changing the algorithm, you’re revealing its story.</p>
<p>Common examples:</p>
<ul>
<li>Longest Common Subsequence (LCS): arrows tracing matches.</li>
<li>Edit Distance: diagonal for match, up for delete, left for insert.</li>
<li>Matrix Path Problems: arrows showing minimal path sum.</li>
<li>Knapsack: table highlights selected cells.</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-86" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-86">How Does It Work (Plain Language)</h4>
<p>We reconstruct the DP solution visually:</p>
<ol type="1">
<li>Compute <code>dp</code> table as usual.</li>
<li>Start from the final state (e.g.&nbsp;<code>dp[n][m]</code>).</li>
<li>Move backward following transitions that created the optimal value.</li>
<li>Record each step (arrow, direction, or explanation).</li>
<li>Draw path or print trace.</li>
</ol>
<p>Each cell’s transition reveals why it was chosen, minimal, maximal, or matching condition.</p>
</section>
<section id="example-edit-distance-visualization" class="level4">
<h4 class="anchored" data-anchor-id="example-edit-distance-visualization">Example: Edit Distance Visualization</h4>
<p>Given strings <code>A = "kitten"</code>, <code>B = "sitting"</code>, we compute <span class="math inline">\(dp[i][j]\)</span> = min edit distance between prefixes <span class="math inline">\(A[0..i)\)</span> and <span class="math inline">\(B[0..j)\)</span>.</p>
<p>We then trace back:</p>
<ul>
<li><p>If <span class="math inline">\(A[i-1] = B[j-1]\)</span>: diagonal (match)</p></li>
<li><p>Else:</p>
<ul>
<li>if <span class="math inline">\(dp[i][j] = dp[i-1][j-1] + 1\)</span>: substitution</li>
<li>if <span class="math inline">\(dp[i][j] = dp[i-1][j] + 1\)</span>: deletion</li>
<li>if <span class="math inline">\(dp[i][j] = dp[i][j-1] + 1\)</span>: insertion</li>
</ul></li>
</ul>
<p>Trace path: bottom-right → top-left</p>
</section>
<section id="tiny-code-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-10">Tiny Code</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb195"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edit_distance_trace(a, b):</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(m<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> b[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb195-13"><a href="#cb195-13" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb195-14"><a href="#cb195-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb195-15"><a href="#cb195-15" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb195-16"><a href="#cb195-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-17"><a href="#cb195-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Traceback</span></span>
<span id="cb195-18"><a href="#cb195-18" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> n, m</span>
<span id="cb195-19"><a href="#cb195-19" aria-hidden="true" tabindex="-1"></a>    trace <span class="op">=</span> []</span>
<span id="cb195-20"><a href="#cb195-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb195-21"><a href="#cb195-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> a[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> b[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb195-22"><a href="#cb195-22" aria-hidden="true" tabindex="-1"></a>            trace.append(<span class="ss">f"Match </span><span class="sc">{</span>a[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb195-23"><a href="#cb195-23" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb195-24"><a href="#cb195-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[i][j] <span class="op">==</span> dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb195-25"><a href="#cb195-25" aria-hidden="true" tabindex="-1"></a>            trace.append(<span class="ss">f"Substitute </span><span class="sc">{</span>a[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss"> -&gt; </span><span class="sc">{</span>b[j<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb195-26"><a href="#cb195-26" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb195-27"><a href="#cb195-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[i][j] <span class="op">==</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb195-28"><a href="#cb195-28" aria-hidden="true" tabindex="-1"></a>            trace.append(<span class="ss">f"Delete </span><span class="sc">{</span>a[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb195-29"><a href="#cb195-29" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb195-30"><a href="#cb195-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb195-31"><a href="#cb195-31" aria-hidden="true" tabindex="-1"></a>            trace.append(<span class="ss">f"Insert </span><span class="sc">{</span>b[j<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb195-32"><a href="#cb195-32" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb195-33"><a href="#cb195-33" aria-hidden="true" tabindex="-1"></a>    trace.reverse()</span>
<span id="cb195-34"><a href="#cb195-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][m], trace</span>
<span id="cb195-35"><a href="#cb195-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-36"><a href="#cb195-36" aria-hidden="true" tabindex="-1"></a>dist, steps <span class="op">=</span> edit_distance_trace(<span class="st">"kitten"</span>, <span class="st">"sitting"</span>)</span>
<span id="cb195-37"><a href="#cb195-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Distance:"</span>, dist)</span>
<span id="cb195-38"><a href="#cb195-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join(steps))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Distance: 3
Substitute k -&gt; s
Match i
Match t
Match t
Substitute e -&gt; i
Match n
Insert g</code></pre>
</section>
<section id="why-it-matters-89" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-89">Why It Matters</h4>
<ul>
<li>Turns abstract numbers into concrete reasoning.</li>
<li>Great for teaching and debugging DPs.</li>
<li>Bridges computation and human understanding.</li>
<li>Helps verify optimal path or detect incorrect transitions.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-76" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-76">A Gentle Proof (Why It Works)</h4>
<p>By construction, each <span class="math inline">\(dp[i][j]\)</span> is the minimal cost achievable. At reconstruction, we select any predecessor <span class="math inline">\((i', j')\)</span> satisfying the recurrence equality:</p>
<p><span class="math display">\[
dp[i][j] = f(dp[i'][j']) + cost
\]</span></p>
<p>Thus, following these equalities in reverse forms a valid optimal path. Since all <span class="math inline">\(dp\)</span> states are filled bottom-up, each predecessor was computed earlier, ensuring consistency.</p>
</section>
<section id="try-it-yourself-89" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-89">Try It Yourself</h4>
<ol type="1">
<li>Visualize LCS: arrows for match and direction.</li>
<li>Visualize min path sum in a grid: print arrows or coordinates.</li>
<li>Add ASCII arrows (↖ ↑ ←) to the traceback.</li>
<li>Generate a heatmap with colored path.</li>
<li>Show decision explanation (e.g.&nbsp;“Insert g at pos 6”).</li>
</ol>
</section>
<section id="test-cases-89" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-89">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>Output Trace</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(“abc”, “abc”)</td>
<td>Matches only</td>
</tr>
<tr class="even">
<td>(“kitten”, “sitting”)</td>
<td>Substitute, Insert steps</td>
</tr>
<tr class="odd">
<td>(“intention”, “execution”)</td>
<td>Mixed edits</td>
</tr>
<tr class="even">
<td>(“horse”, “ros”)</td>
<td>Delete + Substitute path</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-89" class="level4">
<h4 class="anchored" data-anchor-id="complexity-89">Complexity</h4>
<ul>
<li>Time: same as DP, <span class="math inline">\(O(nm)\)</span></li>
<li>Space: <span class="math inline">\(O(nm)\)</span> for table + path</li>
</ul>
<p>Traceback visualization transforms the final DP value into a living path, so learners see how the algorithm’s reasoning unfolds across the grid.</p>
</section>
</section>
</section>
<section id="section-50.-meta-dp-and-optimization-templates" class="level1">
<h1>Section 50. Meta-DP and Optimization Templates</h1>
<section id="state-compression-template" class="level3">
<h3 class="anchored" data-anchor-id="state-compression-template">491 State Compression Template</h3>
<p>State Compression is a powerful technique for reducing the dimensionality of dynamic programming problems by encoding multiple substate variables into a single integer mask. This allows us to handle problems that depend on subsets, visited states, or boolean configurations efficiently using bitwise operations.</p>
<section id="what-problem-are-we-solving-90" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-90">What Problem Are We Solving?</h4>
<p>Many DP problems depend on a combination of states:</p>
<ul>
<li>Which elements have been used?</li>
<li>Which nodes have been visited?</li>
<li>What subset is currently active?</li>
</ul>
<p>Representing these directly can explode in complexity. Instead, we compress the state into an integer bitmask, where each bit indicates the inclusion or status of an element.</p>
<p>For example:</p>
<ul>
<li>Traveling Salesman: mask tracks visited cities.</li>
<li>Subset Sum: mask tracks sums possible with subsets.</li>
<li>Graph DP: mask encodes chosen vertices.</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-87" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-87">How Does It Work (Plain Language)</h4>
<p>We represent subsets or multi-variable states with bitmasks:</p>
<ul>
<li><span class="math inline">\(1\)</span> bit → included, <span class="math inline">\(0\)</span> bit → excluded.</li>
<li>For <span class="math inline">\(n\)</span> elements, we have <span class="math inline">\(2^n\)</span> possible masks.</li>
</ul>
<p>Each DP state looks like:</p>
<p><span class="math display">\[
dp[mask] = \text{best result for subset represented by } mask
\]</span></p>
<p>Transitions iterate over bits set/unset in the mask, updating dependent states.</p>
<p>Key operations:</p>
<ul>
<li><code>mask | (1 &lt;&lt; i)</code> → include element i</li>
<li><code>mask &amp; (1 &lt;&lt; i)</code> → check if i included</li>
<li><code>mask ^ (1 &lt;&lt; i)</code> → toggle inclusion</li>
<li><code>mask &amp; -mask</code> → extract lowest set bit</li>
</ul>
</section>
<section id="example-subset-dp-template" class="level4">
<h4 class="anchored" data-anchor-id="example-subset-dp-template">Example: Subset DP Template</h4>
<p><span class="math display">\[
dp[mask] = \min_{i \in mask} \big( dp[mask \setminus {i}] + cost[i] \big)
\]</span></p>
<p>Here, each <code>mask</code> represents a combination of items, and we build solutions incrementally by adding one element at a time.</p>
</section>
<section id="tiny-code-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-11">Tiny Code</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb197"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">&lt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cost<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">3</span><span class="op">];</span></span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">);</span> mask<span class="op">++)</span></span>
<span id="cb197-12"><a href="#cb197-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>mask<span class="op">]</span> <span class="op">=</span> INT_MAX <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb197-13"><a href="#cb197-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-14"><a href="#cb197-14" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb197-15"><a href="#cb197-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-16"><a href="#cb197-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">);</span> mask<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb197-17"><a href="#cb197-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb197-18"><a href="#cb197-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">))</span> <span class="op">{</span></span>
<span id="cb197-19"><a href="#cb197-19" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> prev <span class="op">=</span> mask <span class="op">^</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> i<span class="op">);</span></span>
<span id="cb197-20"><a href="#cb197-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>mask<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>mask<span class="op">],</span> dp<span class="op">[</span>prev<span class="op">]</span> <span class="op">+</span> cost<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb197-21"><a href="#cb197-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb197-22"><a href="#cb197-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb197-23"><a href="#cb197-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb197-24"><a href="#cb197-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-25"><a href="#cb197-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Minimum total cost: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb197-26"><a href="#cb197-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb198"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> inf</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>cost <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [inf] <span class="op">*</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> n)</span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">1</span> <span class="op">&lt;&lt;</span> n):</span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mask <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i):</span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>            dp[mask] <span class="op">=</span> <span class="bu">min</span>(dp[mask], dp[mask <span class="op">^</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)] <span class="op">+</span> cost[i])</span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Minimum total cost:"</span>, dp[(<span class="dv">1</span> <span class="op">&lt;&lt;</span> n) <span class="op">-</span> <span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-90" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-90">Why It Matters</h4>
<ul>
<li>Compresses exponential states into manageable integer masks.</li>
<li>Enables elegant solutions for combinatorial problems.</li>
<li>Essential for TSP, Assignment, Subset DP, and Bitmask Knapsack.</li>
<li>Fits perfectly with iterative DP loops.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-77" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-77">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(dp[S]\)</span> stores the optimal result for subset <span class="math inline">\(S\)</span>, and every transition moves from smaller to larger subsets via one addition:</p>
<p><span class="math display">\[
dp[S] = \min_{i \in S} \big( dp[S \setminus {i}] + cost[i] \big)
\]</span></p>
<p>Then by induction:</p>
<ul>
<li>Base case: <span class="math inline">\(dp[\emptyset]\)</span> is known (often 0).</li>
<li>Inductive step: each subset <span class="math inline">\(S\)</span> builds on smaller subsets. All subsets are processed in increasing order of size, ensuring correctness.</li>
</ul>
</section>
<section id="try-it-yourself-90" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-90">Try It Yourself</h4>
<ol type="1">
<li>Implement Subset DP for Sum Over Subsets (SOS DP).</li>
<li>Solve Traveling Salesman using state compression.</li>
<li>Adapt to Assignment Problem (<span class="math inline">\(n!\)</span> → <span class="math inline">\(2^n n\)</span> states).</li>
<li>Use mask parity (even/odd bits) for combinatorial constraints.</li>
<li>Print masks in binary to visualize transitions.</li>
</ol>
</section>
<section id="test-cases-90" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-90">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>Description</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cost = [3, 2, 5]</td>
<td>choose all 3 elements</td>
<td>10</td>
</tr>
<tr class="even">
<td>cost = [1, 2]</td>
<td>2 elements</td>
<td>3</td>
</tr>
<tr class="odd">
<td>cost = [5]</td>
<td>single item</td>
<td>5</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-90" class="level4">
<h4 class="anchored" data-anchor-id="complexity-90">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \cdot 2^n)\)</span></li>
<li>Space: <span class="math inline">\(O(2^n)\)</span></li>
</ul>
<p>State Compression DP is your gateway to subset reasoning, compact, powerful, and fundamental for solving exponential combinatorial spaces with structure.</p>
</section>
</section>
<section id="transition-optimization-template" class="level3">
<h3 class="anchored" data-anchor-id="transition-optimization-template">492 Transition Optimization Template</h3>
<p>Transition Optimization is a core technique for improving the efficiency of DP transitions by precomputing or structuring recurrence updates. Many DP recurrences involve nested loops or repeated evaluations that can be simplified through mathematical properties, monotonicity, or auxiliary data structures.</p>
<section id="what-problem-are-we-solving-91" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-91">What Problem Are We Solving?</h4>
<p>In many DPs, each state depends on a range or set of previous states:</p>
<p><span class="math display">\[
dp[i] = \min_{j &lt; i} \big( dp[j] + cost(j, i) \big)
\]</span></p>
<p>Naively, this takes <span class="math inline">\(O(n^2)\)</span> time. But if <span class="math inline">\(cost(j, i)\)</span> has special structure (monotonicity, convexity, quadrangle inequality), we can reduce it to <span class="math inline">\(O(n \log n)\)</span> or even <span class="math inline">\(O(n)\)</span> using optimized transitions.</p>
<p>Transition optimization finds patterns or data structures to accelerate these computations.</p>
</section>
<section id="how-does-it-work-plain-language-88" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-88">How Does It Work (Plain Language)</h4>
<p>When you notice repeated transitions like:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb199"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> cost<span class="op">(</span>j<span class="op">,</span> i<span class="op">));</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>…you’re paying an <span class="math inline">\(O(n^2)\)</span> cost. But often, <code>cost(j, i)</code> follows a pattern (e.g.&nbsp;linear, convex, or monotonic), so we can optimize:</p>
<ul>
<li>Monotonic Queue Optimization: for sliding window minimums.</li>
<li>Divide &amp; Conquer DP: when optimal j’s move monotonically.</li>
<li>Convex Hull Trick: when <span class="math inline">\(cost(j, i) = m_j \cdot x_i + b_j\)</span> is linear.</li>
<li>Knuth Optimization: when quadrangle inequality holds.</li>
</ul>
<p>Each approach precomputes or narrows transitions.</p>
</section>
<section id="example-transition-generic" class="level4">
<h4 class="anchored" data-anchor-id="example-transition-generic">Example Transition (Generic)</h4>
<p><span class="math display">\[
dp[i] = \min_{j &lt; i} \big( dp[j] + f(j, i) \big)
\]</span></p>
<p>If <span class="math inline">\(f\)</span> satisfies the Monge property or quadrangle inequality, we can determine that the optimal <span class="math inline">\(j\)</span> moves in one direction only (monotonic). That means we can use divide &amp; conquer or pointer tricks to find it efficiently.</p>
</section>
<section id="tiny-code-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-12">Tiny Code</h4>
<p>C (Naive Transition)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb200"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> candidate <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> cost<span class="op">(</span>j<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>candidate <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> candidate<span class="op">;</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (Optimized with Monotonic Pointer)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb201"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ptr <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>ptr <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> i <span class="op">&amp;&amp;</span> better<span class="op">(</span>ptr <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> ptr<span class="op">,</span> i<span class="op">))</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>        ptr<span class="op">++;</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>ptr<span class="op">]</span> <span class="op">+</span> cost<span class="op">(</span>ptr<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>better(a, b, i)</code> checks whether <code>a</code> gives a smaller cost than <code>b</code> for <code>dp[i]</code>.</p>
</section>
<section id="python-sliding-window-optimization" class="level4">
<h4 class="anchored" data-anchor-id="python-sliding-window-optimization">Python (Sliding Window Optimization)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb202"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> deque([<span class="dv">0</span>])</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(q) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> better(q[<span class="dv">1</span>], q[<span class="dv">0</span>], i):</span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a>        q.popleft()</span>
<span id="cb202-9"><a href="#cb202-9" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> q[<span class="dv">0</span>]</span>
<span id="cb202-10"><a href="#cb202-10" aria-hidden="true" tabindex="-1"></a>    dp[i] <span class="op">=</span> dp[j] <span class="op">+</span> cost(j, i)</span>
<span id="cb202-11"><a href="#cb202-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(q) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> cross(q[<span class="op">-</span><span class="dv">2</span>], q[<span class="op">-</span><span class="dv">1</span>], i):</span>
<span id="cb202-12"><a href="#cb202-12" aria-hidden="true" tabindex="-1"></a>        q.pop()</span>
<span id="cb202-13"><a href="#cb202-13" aria-hidden="true" tabindex="-1"></a>    q.append(i)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This structure appears in Convex Hull Trick and Monotonic Queue Optimization.</p>
</section>
<section id="why-it-matters-91" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-91">Why It Matters</h4>
<ul>
<li><p>Reduces <span class="math inline">\(O(n^2)\)</span> → <span class="math inline">\(O(n \log n)\)</span> or <span class="math inline">\(O(n)\)</span> transitions.</p></li>
<li><p>Exploits structure (monotonicity, convexity) in DP cost functions.</p></li>
<li><p>Powers major optimizations:</p>
<ul>
<li>Knuth Optimization</li>
<li>Divide &amp; Conquer DP</li>
<li>Convex Hull Trick</li>
<li>Slope Trick</li>
<li>Monotone Queue DP</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-78" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-78">A Gentle Proof (Why It Works)</h4>
<p>If the recurrence satisfies Monotonicity of the Argmin, i.e.:</p>
<p><span class="math display">\[
opt[i] \le opt[i+1]
\]</span></p>
<p>then the best transition index <span class="math inline">\(j\)</span> moves non-decreasingly. This means we can find optimal <span class="math inline">\(j\)</span> for all <span class="math inline">\(i\)</span> in one sweep, using either:</p>
<ul>
<li>Two-pointer traversal (Monotone Queue)</li>
<li>Divide &amp; Conquer recursion (Knuth or D&amp;C DP)</li>
<li>Line container (Convex Hull Trick)</li>
</ul>
<p>By exploiting this structure, we avoid recomputation.</p>
</section>
<section id="try-it-yourself-91" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-91">Try It Yourself</h4>
<ol type="1">
<li>Identify a DP where each state depends on a range of previous states.</li>
<li>Check if <code>cost(j, i)</code> satisfies monotonic or convex properties.</li>
<li>Apply divide &amp; conquer optimization to reduce <span class="math inline">\(O(n^2)\)</span>.</li>
<li>Implement Convex Hull Trick for linear cost forms.</li>
<li>Use deque-based Monotonic Queue for sliding range DP.</li>
</ol>
</section>
<section id="test-cases-91" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-91">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 51%">
<col style="width: 22%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Case</th>
<th>Recurrence</th>
<th>Optimization</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(dp[i] = \min_{j&lt;i}(dp[j]+c(i-j))\)</span></td>
<td><span class="math inline">\(c\)</span> convex</td>
<td>Convex Hull Trick</td>
</tr>
<tr class="even">
<td><span class="math inline">\(dp[i] = \min_{j&lt;i}(dp[j]+w(j,i))\)</span></td>
<td>Monotone argmin</td>
<td>Divide &amp; Conquer</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(dp[i] = \min_{j&lt;i}(dp[j]) + a_i\)</span></td>
<td>sliding window</td>
<td>Monotonic Queue</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-91" class="level4">
<h4 class="anchored" data-anchor-id="complexity-91">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> to <span class="math inline">\(O(n \log n)\)</span> (depends on method)</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Transition Optimization is the art of seeing structure in cost, once you spot monotonicity or convexity, your DP becomes faster, cleaner, and smarter.</p>
</section>
</section>
<section id="space-optimization-template" class="level3">
<h3 class="anchored" data-anchor-id="space-optimization-template">493 Space Optimization Template</h3>
<p>Space Optimization is the art of trimming away unused dimensions in a DP table by realizing that only a limited subset of previous states is needed at each step. Many classic DPs that start with large <span class="math inline">\(O(n^2)\)</span> or <span class="math inline">\(O(nm)\)</span> tables can be reduced to rolling arrays or single-row updates, cutting memory usage drastically.</p>
<section id="what-problem-are-we-solving-92" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-92">What Problem Are We Solving?</h4>
<p>Dynamic Programming often uses multi-dimensional arrays:</p>
<p><span class="math display">\[
dp[i][j] = \text{answer using first } i \text{ items with capacity } j
\]</span></p>
<p>But not all dimensions are necessary. If each state <span class="math inline">\(dp[i]\)</span> only depends on previous row <span class="math inline">\(dp[i-1]\)</span>, we can reuse memory, keeping just two rows (or even one).</p>
<p>Space Optimization lets us move from <span class="math inline">\(O(nm)\)</span> to <span class="math inline">\(O(m)\)</span>, or from 2D → 1D, or 3D → 2D, without changing logic.</p>
</section>
<section id="how-does-it-work-plain-language-89" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-89">How Does It Work (Plain Language)</h4>
<p>DP updates come from previous states, not all states.</p>
<p>For example, in 0/1 Knapsack:</p>
<p><span class="math display">\[
dp[i][w] = \max(dp[i-1][w], dp[i-1][w - wt[i]] + val[i])
\]</span></p>
<p>Only <code>dp[i-1][*]</code> is needed when computing <code>dp[i][*]</code>. So we can collapse the DP table into a single array <code>dp[w]</code>, updating it in reverse (to avoid overwriting states we still need).</p>
<p>If transitions depend on current or previous row, choose direction carefully:</p>
<ul>
<li>0/1 Knapsack → reverse loop</li>
<li>Unbounded Knapsack → forward loop</li>
</ul>
</section>
<section id="example-transformation" class="level4">
<h4 class="anchored" data-anchor-id="example-transformation">Example Transformation</h4>
<p>Before (2D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb203"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>n<span class="op">+</span><span class="dv">1</span><span class="op">][</span>W<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">],</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">-</span>wt<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i<span class="op">]);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>After (1D DP)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb204"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>W<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> W<span class="op">;</span> w <span class="op">&gt;=</span> wt<span class="op">[</span>i<span class="op">];</span> w<span class="op">--)</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>w<span class="op">],</span> dp<span class="op">[</span>w<span class="op">-</span>wt<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i<span class="op">]);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-13">Tiny Code</h4>
<p>C (Rolling Array Example)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb205"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define max</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> W <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> W<span class="op">;</span> w <span class="op">&gt;=</span> wt<span class="op">[</span>i<span class="op">];</span> w<span class="op">--)</span></span>
<span id="cb205-12"><a href="#cb205-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>w<span class="op">],</span> dp<span class="op">[</span>w <span class="op">-</span> wt<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb205-13"><a href="#cb205-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-14"><a href="#cb205-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>W<span class="op">]);</span></span>
<span id="cb205-15"><a href="#cb205-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (1D Rolling)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb206"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>n, W <span class="op">=</span> <span class="dv">3</span>, <span class="dv">5</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>wt <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>val <span class="op">=</span> [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">7</span>]</span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(W, wt[i] <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a>        dp[w] <span class="op">=</span> <span class="bu">max</span>(dp[w], dp[w <span class="op">-</span> wt[i]] <span class="op">+</span> val[i])</span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-11"><a href="#cb206-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max value:"</span>, dp[W])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-92" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-92">Why It Matters</h4>
<ul>
<li>Reduces memory from <span class="math inline">\(O(nm)\)</span> → <span class="math inline">\(O(m)\)</span>.</li>
<li>Makes large DP problems feasible under memory limits.</li>
<li>Reveals dependency structure in transitions.</li>
<li>Forms the backbone of iterative bottom-up optimization.</li>
</ul>
<p>Space optimization is vital for:</p>
<ul>
<li>Knapsack, LCS, LIS</li>
<li>Grid path counting</li>
<li>Partition problems</li>
<li>Digit DP (carry compression)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-79" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-79">A Gentle Proof (Why It Works)</h4>
<p>Let’s define <span class="math inline">\(dp[i][j]\)</span> depending only on <span class="math inline">\(dp[i-1][*]\)</span>. Since each new row is computed solely from the previous one:</p>
<p><span class="math display">\[
dp[i][j] = f(dp[i-1][j], dp[i-1][j-w_i])
\]</span></p>
<p>So at iteration <span class="math inline">\(i\)</span>, once <code>dp[i][*]</code> is complete, <code>dp[i-1][*]</code> is never used again. By updating in reverse (to preserve dependencies), the 2D table can be rolled into one.</p>
<p>Formally, space can be reduced from <span class="math inline">\(O(nm)\)</span> to <span class="math inline">\(O(m)\)</span> if and only if:</p>
<ol type="1">
<li>Each <span class="math inline">\(dp[i]\)</span> depends on <span class="math inline">\(dp[i-1]\)</span>, not <span class="math inline">\(dp[i]\)</span> itself.</li>
<li>Transition direction ensures previous states remain unmodified.</li>
</ol>
</section>
<section id="try-it-yourself-92" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-92">Try It Yourself</h4>
<ol type="1">
<li>Convert your 0/1 Knapsack to 1D DP.</li>
<li>Space-optimize the LCS table (2D → 2 rows).</li>
<li>Apply to “Climbing Stairs” (<span class="math inline">\(dp[i]\)</span> only needs last 2 values).</li>
<li>For Unbounded Knapsack, try forward updates.</li>
<li>Compare memory usage before and after.</li>
</ol>
</section>
<section id="test-cases-92" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-92">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Problem</th>
<th>Original Space</th>
<th>Optimized Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0/1 Knapsack</td>
<td><span class="math inline">\(O(nW)\)</span></td>
<td><span class="math inline">\(O(W)\)</span></td>
</tr>
<tr class="even">
<td>LCS</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(2m)\)</span></td>
</tr>
<tr class="odd">
<td>Fibonacci</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-92" class="level4">
<h4 class="anchored" data-anchor-id="complexity-92">Complexity</h4>
<ul>
<li>Time: unchanged</li>
<li>Space: reduced by 1 dimension</li>
<li>Tradeoff: direction of iteration matters</li>
</ul>
<p>Space Optimization is a quiet revolution: by recognizing independence between layers, we free our algorithms from unnecessary memory, one dimension at a time.</p>
</section>
</section>
<section id="multi-dimensional-dp-template" class="level3">
<h3 class="anchored" data-anchor-id="multi-dimensional-dp-template">494 Multi-Dimensional DP Template</h3>
<p>Multi-Dimensional DP extends classic one- or two-dimensional formulations into higher-dimensional state spaces, capturing problems where multiple independent variables evolve together. Each dimension corresponds to a decision axis, time, position, capacity, or some discrete property, making it possible to express rich combinatorial or structural relationships.</p>
<section id="what-problem-are-we-solving-93" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-93">What Problem Are We Solving?</h4>
<p>Some problems require tracking more than one evolving parameter:</p>
<ul>
<li>Knapsack with two capacities → <span class="math inline">\(dp[i][w_1][w_2]\)</span></li>
<li>String interleaving → <span class="math inline">\(dp[i][j][k]\)</span></li>
<li>Dice sum counting → <span class="math inline">\(dp[i][sum][count]\)</span></li>
<li>Grid with keys → <span class="math inline">\(dp[x][y][mask]\)</span></li>
</ul>
<p>When multiple independent factors drive state transitions, a single index DP cannot capture them. Multi-Dimensional DP encodes joint state evolution explicitly.</p>
</section>
<section id="how-does-it-work-plain-language-90" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-90">How Does It Work (Plain Language)</h4>
<p>We define a DP table where each axis tracks a property:</p>
<p><span class="math display">\[
dp[a][b][c] = \text{best result with parameters } (a, b, c)
\]</span></p>
<p>Transitions update along one or more dimensions:</p>
<p><span class="math display">\[
dp[a][b][c] = \min/\max(\text{transitions from neighbors})
\]</span></p>
<p>Think of this as traversing a grid of states, where each move modifies several parameters. The key idea is to fill the table systematically based on topological or nested loops that respect dependency order.</p>
</section>
<section id="example-recurrence-4" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence-4">Example Recurrence</h4>
<p>Multi-dimensional structure often looks like:</p>
<p><span class="math display">\[
dp[i][j][k] = f(dp[i-1][j'][k'], \text{cost}(i, j, k))
\]</span></p>
<p>Example (2D Knapsack):</p>
<p><span class="math display">\[
dp[i][w_1][w_2] = \max(dp[i-1][w_1][w_2],\ dp[i-1][w_1-wt_1[i]][w_2-wt_2[i]] + val[i])
\]</span></p>
</section>
<section id="tiny-code-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-14">Tiny Code</h4>
<p>C (2D Knapsack)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb207"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define max</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&gt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> W1 <span class="op">=</span> <span class="dv">5</span><span class="op">,</span> W2 <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt1<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt2<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">};</span></span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span><span class="dv">4</span><span class="op">][</span><span class="dv">6</span><span class="op">][</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb207-10"><a href="#cb207-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-11"><a href="#cb207-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb207-12"><a href="#cb207-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w1 <span class="op">&lt;=</span> W1<span class="op">;</span> w1<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb207-13"><a href="#cb207-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w2 <span class="op">&lt;=</span> W2<span class="op">;</span> w2<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb207-14"><a href="#cb207-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w1<span class="op">][</span>w2<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w1<span class="op">][</span>w2<span class="op">];</span></span>
<span id="cb207-15"><a href="#cb207-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>w1 <span class="op">&gt;=</span> wt1<span class="op">[</span>i<span class="op">]</span> <span class="op">&amp;&amp;</span> w2 <span class="op">&gt;=</span> wt2<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb207-16"><a href="#cb207-16" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>w1<span class="op">][</span>w2<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>w1<span class="op">][</span>w2<span class="op">],</span></span>
<span id="cb207-17"><a href="#cb207-17" aria-hidden="true" tabindex="-1"></a>                        dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w1 <span class="op">-</span> wt1<span class="op">[</span>i<span class="op">]][</span>w2 <span class="op">-</span> wt2<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb207-18"><a href="#cb207-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb207-19"><a href="#cb207-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb207-20"><a href="#cb207-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb207-21"><a href="#cb207-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb207-22"><a href="#cb207-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-23"><a href="#cb207-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Max value: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>W1<span class="op">][</span>W2<span class="op">]);</span></span>
<span id="cb207-24"><a href="#cb207-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (3D Example: String Interleaving)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb208"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>s1, s2, s3 <span class="op">=</span> <span class="st">"ab"</span>, <span class="st">"cd"</span>, <span class="st">"acbd"</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>n1, n2, n3 <span class="op">=</span> <span class="bu">len</span>(s1), <span class="bu">len</span>(s2), <span class="bu">len</span>(s3)</span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [[[<span class="va">False</span>]<span class="op">*</span>(n3<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n2<span class="op">+</span><span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n1<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n1<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n2<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n3<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb208-10"><a href="#cb208-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> k <span class="op">==</span> <span class="dv">0</span>: <span class="cf">continue</span></span>
<span id="cb208-11"><a href="#cb208-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> s1[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> s3[k<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> dp[i<span class="op">-</span><span class="dv">1</span>][j][k<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb208-12"><a href="#cb208-12" aria-hidden="true" tabindex="-1"></a>                dp[i][j][k] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb208-13"><a href="#cb208-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> s2[j<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> s3[k<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> dp[i][j<span class="op">-</span><span class="dv">1</span>][k<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb208-14"><a href="#cb208-14" aria-hidden="true" tabindex="-1"></a>                dp[i][j][k] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb208-15"><a href="#cb208-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-16"><a href="#cb208-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Interleaving possible:"</span>, dp[n1][n2][n3])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-93" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-93">Why It Matters</h4>
<ul>
<li><p>Captures multi-factor problems elegantly</p></li>
<li><p>Handles constraints coupling (capacity, index, sum)</p></li>
<li><p>Enables state compression when reduced</p></li>
<li><p>Common in:</p>
<ul>
<li>Multi-resource allocation</li>
<li>Interleaving / sequence merging</li>
<li>Multi-knapsack / bounded subset</li>
<li>Grid navigation with additional properties</li>
</ul></li>
</ul>
<p>Multi-dimensional DPs form the foundation of generalized search spaces, where each variable adds a dimension of reasoning.</p>
</section>
<section id="a-gentle-proof-why-it-works-80" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-80">A Gentle Proof (Why It Works)</h4>
<p>By induction over the outermost dimension:</p>
<p>If <span class="math inline">\(dp[i][*][*]\)</span> depends only on <span class="math inline">\(dp[i-1][*][*]\)</span>, and each transition moves from smaller to larger indices, then the DP fills in topological order, ensuring correctness.</p>
<p>Each additional dimension multiplies the state space but does not alter dependency direction. Thus, correctness holds as long as we respect dimension order and initialize base cases properly.</p>
</section>
<section id="try-it-yourself-93" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-93">Try It Yourself</h4>
<ol type="1">
<li>Solve 2D Knapsack with dual capacity.</li>
<li>Implement string interleaving check with 3D DP.</li>
<li>Model shortest path in 3D grid using <span class="math inline">\(dp[x][y][z]\)</span>.</li>
<li>Add bitmask dimension for subset tracking.</li>
<li>Optimize memory using rolling or compression.</li>
</ol>
</section>
<section id="test-cases-93" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-93">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 27%">
<col style="width: 25%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Problem</th>
<th>Dimensions</th>
<th>Example State</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2D Knapsack</td>
<td>3D (item, w1, w2)</td>
<td><span class="math inline">\(dp[i][w1][w2]\)</span></td>
<td>Max value</td>
</tr>
<tr class="even">
<td>String Interleaving</td>
<td>3D</td>
<td><span class="math inline">\(dp[i][j][k]\)</span></td>
<td>True/False</td>
</tr>
<tr class="odd">
<td>Grid with Keys</td>
<td>3D</td>
<td><span class="math inline">\(dp[x][y][mask]\)</span></td>
<td>Min steps</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-93" class="level4">
<h4 class="anchored" data-anchor-id="complexity-93">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(\text{product of dimensions})\)</span></li>
<li>Space: same order; compressible via rolling</li>
<li>Tradeoff: richer state space vs feasibility</li>
</ul>
<p>Multi-Dimensional DP is your tool for multi-constraint reasoning, when life refuses to fit in one dimension, let your DP grow an extra axis.</p>
</section>
</section>
<section id="decision-monotonicity" class="level3">
<h3 class="anchored" data-anchor-id="decision-monotonicity">495 Decision Monotonicity</h3>
<p>Decision Monotonicity is a structural property in DP recurrences that allows us to optimize transition search. When the optimal decision index for <span class="math inline">\(dp[i]\)</span> moves in one direction (non-decreasing) as <span class="math inline">\(i\)</span> increases, we can reduce a naive <span class="math inline">\(O(n^2)\)</span> DP to <span class="math inline">\(O(n \log n)\)</span> or even <span class="math inline">\(O(n)\)</span> using divide-and-conquer or two-pointer techniques.</p>
<section id="what-problem-are-we-solving-94" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-94">What Problem Are We Solving?</h4>
<p>In many DPs, each state <span class="math inline">\(dp[i]\)</span> is computed by choosing a best transition point <span class="math inline">\(j &lt; i\)</span>:</p>
<p><span class="math display">\[
dp[i] = \min_{0 \le j &lt; i} \big( dp[j] + cost(j, i) \big)
\]</span></p>
<p>This naive recurrence requires trying all previous states for every <span class="math inline">\(i\)</span>, leading to <span class="math inline">\(O(n^2)\)</span> time. But if the index of the optimal <span class="math inline">\(j\)</span> (called <span class="math inline">\(opt[i]\)</span>) satisfies:</p>
<p><span class="math display">\[
opt[i] \le opt[i+1]
\]</span></p>
<p>then the decision index moves monotonically, and we can search efficiently, either by divide &amp; conquer DP or sliding pointer optimization.</p>
</section>
<section id="how-does-it-work-plain-language-91" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-91">How Does It Work (Plain Language)</h4>
<p>If as <span class="math inline">\(i\)</span> increases, the best <span class="math inline">\(j\)</span> never moves backward, we can reuse or narrow the search for each next state.</p>
<p>In other words:</p>
<ul>
<li>The “best split point” for <span class="math inline">\(i=10\)</span> will be at or after the best split for <span class="math inline">\(i=9\)</span>.</li>
<li>No need to re-check smaller <span class="math inline">\(j\)</span> again.</li>
<li>You can sweep <span class="math inline">\(j\)</span> forward or recursively restrict the range.</li>
</ul>
<p>This property appears when <span class="math inline">\(cost(j, i)\)</span> satisfies certain quadrangle inequalities or convexity conditions.</p>
</section>
<section id="example-recurrence-5" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence-5">Example Recurrence</h4>
<p><span class="math display">\[
dp[i] = \min_{j &lt; i} \big( dp[j] + (i-j)^2 \big)
\]</span></p>
<p>Here, as <span class="math inline">\(i\)</span> grows, larger <span class="math inline">\(j\)</span> become more favorable because <span class="math inline">\((i-j)^2\)</span> penalizes small gaps. Thus, <span class="math inline">\(opt[i]\)</span> increases monotonically.</p>
<p>Another example: <span class="math display">\[
dp[i] = \min_{j &lt; i} \big( dp[j] + c[j] \cdot a[i] \big)
\]</span> where <span class="math inline">\(a[i]\)</span> is increasing, the convex hull trick applies, and optimal lines appear in increasing order.</p>
</section>
<section id="tiny-code-two-pointer-monotonic-search" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-two-pointer-monotonic-search">Tiny Code (Two-Pointer Monotonic Search)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb209"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n <span class="op">=</span> <span class="op">...;</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> opt<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb209-6"><a href="#cb209-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> start <span class="op">=</span> opt<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb209-7"><a href="#cb209-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> start<span class="op">;</span> j <span class="op">&lt;=</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb209-8"><a href="#cb209-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> val <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> cost<span class="op">(</span>j<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb209-9"><a href="#cb209-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;</span> dp<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb209-10"><a href="#cb209-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb209-11"><a href="#cb209-11" aria-hidden="true" tabindex="-1"></a>            opt<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb209-12"><a href="#cb209-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb209-13"><a href="#cb209-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb209-14"><a href="#cb209-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each <span class="math inline">\(opt[i]\)</span> begins searching from <span class="math inline">\(opt[i-1]\)</span>, cutting redundant checks.</p>
</section>
<section id="python-divide-conquer-optimization" class="level4">
<h4 class="anchored" data-anchor-id="python-divide-conquer-optimization">Python (Divide &amp; Conquer Optimization)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb210"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve(l, r, optL, optR):</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> l <span class="op">&gt;</span> r: <span class="cf">return</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (l <span class="op">+</span> r) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> (<span class="bu">float</span>(<span class="st">'inf'</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(optL, <span class="bu">min</span>(optR, mid) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> dp[j] <span class="op">+</span> cost(j, mid)</span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> val <span class="op">&lt;</span> best[<span class="dv">0</span>]:</span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> (val, j)</span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a>    dp[mid] <span class="op">=</span> best[<span class="dv">0</span>]</span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a>    opt <span class="op">=</span> best[<span class="dv">1</span>]</span>
<span id="cb210-11"><a href="#cb210-11" aria-hidden="true" tabindex="-1"></a>    solve(l, mid <span class="op">-</span> <span class="dv">1</span>, optL, opt)</span>
<span id="cb210-12"><a href="#cb210-12" aria-hidden="true" tabindex="-1"></a>    solve(mid <span class="op">+</span> <span class="dv">1</span>, r, opt, optR)</span>
<span id="cb210-13"><a href="#cb210-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-14"><a href="#cb210-14" aria-hidden="true" tabindex="-1"></a>solve(<span class="dv">1</span>, n, <span class="dv">0</span>, n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-94" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-94">Why It Matters</h4>
<ul>
<li>Reduces complexity from <span class="math inline">\(O(n^2)\)</span> → <span class="math inline">\(O(n \log n)\)</span> or <span class="math inline">\(O(n)\)</span></li>
<li>Enables Divide &amp; Conquer DP, Knuth Optimization, and Convex Hull Trick</li>
<li>Builds foundation for structured cost functions</li>
<li>Helps identify monotonic transitions in scheduling, partitioning, or chain DPs</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-81" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-81">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(opt[i] \le opt[i+1]\)</span>, then <span class="math inline">\(dp[i]\)</span>’s optimal transition comes from no earlier than <span class="math inline">\(opt[i-1]\)</span>. Thus, we can safely restrict search intervals:</p>
<p><span class="math display">\[
dp[i] = \min_{j \in [opt[i-1], i-1]} f(j, i)
\]</span></p>
<p>The proof follows from quadrangle inequality:</p>
<p><span class="math display">\[
f(a, c) + f(b, d) \le f(a, d) + f(b, c)
\]</span></p>
<p>which ensures convex-like structure and monotone decisions.</p>
<p>By induction:</p>
<ul>
<li>Base: <span class="math inline">\(opt[1]\)</span> known.</li>
<li>Step: if <span class="math inline">\(opt[i] \le opt[i+1]\)</span>, then the recurrence preserves order.</li>
</ul>
</section>
<section id="try-it-yourself-94" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-94">Try It Yourself</h4>
<ol type="1">
<li>Implement a divide &amp; conquer DP with <span class="math inline">\(opt\)</span> tracking.</li>
<li>Verify monotonicity of <span class="math inline">\(opt[i]\)</span> experimentally for a sample cost.</li>
<li>Apply to partitioning problems like Divide Array into K Segments.</li>
<li>Compare <span class="math inline">\(O(n^2)\)</span> vs optimized <span class="math inline">\(O(n \log n)\)</span> performance.</li>
<li>Check if your cost satisfies quadrangle inequality.</li>
</ol>
</section>
<section id="test-cases-94" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-94">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 56%">
<col style="width: 22%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th>Recurrence</th>
<th>Property</th>
<th>Optimization</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(dp[i] = \min_{j&lt;i}(dp[j]+(i-j)^2)\)</span></td>
<td>convex</td>
<td>monotone opt</td>
</tr>
<tr class="even">
<td><span class="math inline">\(dp[i] = \min_{j&lt;i}(dp[j]+a[i]\cdot b[j])\)</span></td>
<td>increasing <span class="math inline">\(a[i]\)</span></td>
<td>convex hull</td>
</tr>
<tr class="odd">
<td>Segment DP</td>
<td><span class="math inline">\(cost(l,r)\)</span> Monge</td>
<td>divide &amp; conquer</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-94" class="level4">
<h4 class="anchored" data-anchor-id="complexity-94">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \log n)\)</span> (divide &amp; conquer) or <span class="math inline">\(O(n)\)</span> (two-pointer)</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Decision Monotonicity is the hidden geometry of DP, once you spot that the “best index” moves only forward, your algorithm speeds up dramatically.</p>
</section>
</section>
<section id="monge-array-optimization" class="level3">
<h3 class="anchored" data-anchor-id="monge-array-optimization">496 Monge Array Optimization</h3>
<p>Monge Array Optimization is a powerful tool for accelerating dynamic programming when the cost matrix satisfies a special inequality known as the Monge property. It guarantees that the argmin of each row moves monotonically across columns, allowing us to use Divide &amp; Conquer DP or SMAWK algorithm for subquadratic optimization.</p>
<section id="what-problem-are-we-solving-95" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-95">What Problem Are We Solving?</h4>
<p>Consider a DP of the form:</p>
<p><span class="math display">\[
dp[i][j] = \min_{k &lt; j} \big(dp[i-1][k] + cost[k][j]\big)
\]</span></p>
<p>If the cost matrix <span class="math inline">\(cost[k][j]\)</span> satisfies the Monge property, we can compute all <span class="math inline">\(dp[i][j]\)</span> in <span class="math inline">\(O(n \log n)\)</span> or <span class="math inline">\(O(n)\)</span> per layer, instead of the naive <span class="math inline">\(O(n^2)\)</span>.</p>
<p>This pattern appears in:</p>
<ul>
<li>Partition DP (divide sequence into segments)</li>
<li>Matrix Chain / Knuth DP</li>
<li>Optimal merge / segmentation</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-92" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-92">How Does It Work (Plain Language)</h4>
<p>The Monge property states that for all <span class="math inline">\(a &lt; b\)</span> and <span class="math inline">\(c &lt; d\)</span>:</p>
<p><span class="math display">\[
cost[a][c] + cost[b][d] \le cost[a][d] + cost[b][c]
\]</span></p>
<p>This means the difference in cost is consistent across diagonals, implying convexity in two dimensions. As a result, the optimal split point moves monotonically:</p>
<p><span class="math display">\[
opt[i][j] \le opt[i][j+1]
\]</span></p>
<p>We can therefore restrict our search range for <span class="math inline">\(dp[i][j]\)</span> using Divide &amp; Conquer optimization.</p>
</section>
<section id="example-recurrence-6" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence-6">Example Recurrence</h4>
<p>For segment partitioning:</p>
<p><span class="math display">\[
dp[i][j] = \min_{k &lt; j} \big( dp[i-1][k] + cost[k][j] \big)
\]</span></p>
<p>If <span class="math inline">\(cost[k][j]\)</span> is Monge, then <span class="math inline">\(opt[i][j] \le opt[i][j+1]\)</span>. Thus, when computing <span class="math inline">\(dp[i][j]\)</span>, we only need to search <span class="math inline">\(k\)</span> in <span class="math inline">\([opt[i][j-1], opt[i][j+1]]\)</span>.</p>
</section>
<section id="tiny-code-divide-conquer-over-monge-matrix" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-divide-conquer-over-monge-matrix">Tiny Code (Divide &amp; Conquer over Monge Matrix)</h4>
<p>C (Template)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb211"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compute<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> optL<span class="op">,</span> <span class="dt">int</span> optR<span class="op">)</span> <span class="op">{</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>l <span class="op">&gt;</span> r<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>l <span class="op">+</span> r<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best_k <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb211-5"><a href="#cb211-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> best_val <span class="op">=</span> LLONG_MAX<span class="op">;</span></span>
<span id="cb211-6"><a href="#cb211-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> optL<span class="op">;</span> k <span class="op">&lt;=</span> optR <span class="op">&amp;&amp;</span> k <span class="op">&lt;</span> mid<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb211-7"><a href="#cb211-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> val <span class="op">=</span> dp_prev<span class="op">[</span>k<span class="op">]</span> <span class="op">+</span> cost<span class="op">[</span>k<span class="op">][</span>mid<span class="op">];</span></span>
<span id="cb211-8"><a href="#cb211-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;</span> best_val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb211-9"><a href="#cb211-9" aria-hidden="true" tabindex="-1"></a>            best_val <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb211-10"><a href="#cb211-10" aria-hidden="true" tabindex="-1"></a>            best_k <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb211-11"><a href="#cb211-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb211-12"><a href="#cb211-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb211-13"><a href="#cb211-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>mid<span class="op">]</span> <span class="op">=</span> best_val<span class="op">;</span></span>
<span id="cb211-14"><a href="#cb211-14" aria-hidden="true" tabindex="-1"></a>    compute<span class="op">(</span>i<span class="op">,</span> l<span class="op">,</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> optL<span class="op">,</span> best_k<span class="op">);</span></span>
<span id="cb211-15"><a href="#cb211-15" aria-hidden="true" tabindex="-1"></a>    compute<span class="op">(</span>i<span class="op">,</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> r<span class="op">,</span> best_k<span class="op">,</span> optR<span class="op">);</span></span>
<span id="cb211-16"><a href="#cb211-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each recursive call computes a segment’s midpoint and recursively narrows the search range based on monotonicity.</p>
<p>Python (Monge DP Skeleton)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb212"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute(i, l, r, optL, optR):</span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> l <span class="op">&gt;</span> r:</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (l <span class="op">+</span> r) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> (<span class="bu">float</span>(<span class="st">'inf'</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(optL, <span class="bu">min</span>(optR, mid) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> dp_prev[k] <span class="op">+</span> cost[k][mid]</span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> val <span class="op">&lt;</span> best[<span class="dv">0</span>]:</span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> (val, k)</span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a>    dp[mid] <span class="op">=</span> best[<span class="dv">0</span>]</span>
<span id="cb212-11"><a href="#cb212-11" aria-hidden="true" tabindex="-1"></a>    opt[mid] <span class="op">=</span> best[<span class="dv">1</span>]</span>
<span id="cb212-12"><a href="#cb212-12" aria-hidden="true" tabindex="-1"></a>    compute(i, l, mid <span class="op">-</span> <span class="dv">1</span>, optL, best[<span class="dv">1</span>])</span>
<span id="cb212-13"><a href="#cb212-13" aria-hidden="true" tabindex="-1"></a>    compute(i, mid <span class="op">+</span> <span class="dv">1</span>, r, best[<span class="dv">1</span>], optR)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-95" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-95">Why It Matters</h4>
<ul>
<li><p>Exploits Monge property to skip redundant transitions</p></li>
<li><p>Reduces 2D DP to <span class="math inline">\(O(n \log n)\)</span> or even <span class="math inline">\(O(n)\)</span> per layer</p></li>
<li><p>Powers optimizations like:</p>
<ul>
<li>Divide &amp; Conquer DP</li>
<li>Knuth Optimization (special Monge case)</li>
<li>SMAWK algorithm (row minima in Monge arrays)</li>
</ul></li>
</ul>
<p>Used in:</p>
<ul>
<li>Sequence segmentation</li>
<li>Matrix chain multiplication</li>
<li>Optimal BST</li>
<li>Inventory / scheduling models</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-82" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-82">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(cost\)</span> satisfies Monge inequality:</p>
<p><span class="math display">\[
cost[a][c] + cost[b][d] \le cost[a][d] + cost[b][c]
\]</span></p>
<p>then:</p>
<p><span class="math display">\[
opt[j] \le opt[j+1]
\]</span></p>
<p>That is, as <span class="math inline">\(j\)</span> increases, the best <span class="math inline">\(k\)</span> (split point) cannot move backward. Hence, when computing <span class="math inline">\(dp[j]\)</span>, we can reuse or narrow the search interval using the previous opt index.</p>
<p>This monotonicity of argmin is the key to divide-and-conquer speedups.</p>
</section>
<section id="try-it-yourself-95" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-95">Try It Yourself</h4>
<ol type="1">
<li>Verify Monge property for your cost function.</li>
<li>Implement the Divide &amp; Conquer DP template.</li>
<li>Test on partition DP with convex segment cost.</li>
<li>Compare <span class="math inline">\(O(n^2)\)</span> vs optimized <span class="math inline">\(O(n \log n)\)</span> runtime.</li>
<li>Explore SMAWK for row minima in Monge matrices.</li>
</ol>
</section>
<section id="test-cases-95" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-95">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Cost Function</th>
<th>Monge?</th>
<th>Optimization</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(cost[a][b] = (sum[b]-sum[a])^2\)</span></td>
<td>✅</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(cost[a][b] = (b-a)^2\)</span></td>
<td>✅</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>$cost[a][b] =</td>
<td>b-a</td>
<td>$</td>
<td>❌</td>
<td>No</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-95" class="level4">
<h4 class="anchored" data-anchor-id="complexity-95">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \log n)\)</span> per layer</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
<li>Layers: multiply by <span class="math inline">\(k\)</span> if multi-stage DP</li>
</ul>
<p>Monge Array Optimization transforms a naive DP table into a structured landscape, once your costs align, transitions fall neatly into place with logarithmic grace.</p>
</section>
</section>
<section id="divide-conquer-template" class="level3">
<h3 class="anchored" data-anchor-id="divide-conquer-template">497 Divide &amp; Conquer Template</h3>
<p>Divide &amp; Conquer DP is a technique for optimizing DP transitions when the optimal transition index exhibits monotonicity. By recursively dividing the problem and searching only within a limited range for each midpoint, we reduce complexity from <span class="math inline">\(O(n^2)\)</span> to <span class="math inline">\(O(n \log n)\)</span> or even <span class="math inline">\(O(n)\)</span> per layer.</p>
<section id="what-problem-are-we-solving-96" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-96">What Problem Are We Solving?</h4>
<p>Many DP formulations involve transitions like:</p>
<p><span class="math display">\[
dp[i] = \min_{j &lt; i} \big( dp[j] + cost(j, i) \big)
\]</span></p>
<p>If <span class="math inline">\(opt[i] \le opt[i+1]\)</span>, meaning the best transition index moves monotonically forward, we can use divide and conquer to find optimal <span class="math inline">\(j\)</span> efficiently instead of scanning all <span class="math inline">\(j &lt; i\)</span>.</p>
<p>This structure is common in:</p>
<ul>
<li>Partition DP (divide array into <span class="math inline">\(k\)</span> segments)</li>
<li>Monge or Convex cost problems</li>
<li>Segment-based recurrence with monotone argmin</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-93" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-93">How Does It Work (Plain Language)</h4>
<p>We recursively divide the range <span class="math inline">\([L, R]\)</span>, compute <span class="math inline">\(dp[mid]\)</span> using the best transition from a restricted interval <span class="math inline">\([optL, optR]\)</span>, then:</p>
<ul>
<li>Left half <span class="math inline">\([L, mid-1]\)</span> searches <span class="math inline">\([optL, opt[mid]]\)</span></li>
<li>Right half <span class="math inline">\([mid+1, R]\)</span> searches <span class="math inline">\([opt[mid], optR]\)</span></li>
</ul>
<p>By maintaining monotone search boundaries, we ensure correctness and avoid redundant checks.</p>
<p>Think of it as a guided binary search over DP indices, powered by structural guarantees.</p>
</section>
<section id="example-recurrence-7" class="level4">
<h4 class="anchored" data-anchor-id="example-recurrence-7">Example Recurrence</h4>
<p><span class="math display">\[
dp[i] = \min_{j &lt; i} \big( dp[j] + cost(j, i) \big)
\]</span></p>
<p>If <span class="math inline">\(cost\)</span> satisfies quadrangle inequality or Monge property, then:</p>
<p><span class="math display">\[
opt[i] \le opt[i+1]
\]</span></p>
<p>Thus, we can recursively compute <span class="math inline">\(dp\)</span> over subranges.</p>
</section>
<section id="tiny-code-c" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb213"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define min</span><span class="op">(</span><span class="pp">a</span><span class="op">,</span><span class="pp">b</span><span class="op">)</span><span class="pp"> </span><span class="op">((</span><span class="pp">a</span><span class="op">)&lt;(</span><span class="pp">b</span><span class="op">)?(</span><span class="pp">a</span><span class="op">):(</span><span class="pp">b</span><span class="op">))</span></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb213-8"><a href="#cb213-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span><span class="dv">10005</span><span class="op">],</span> prev_dp<span class="op">[</span><span class="dv">10005</span><span class="op">];</span></span>
<span id="cb213-9"><a href="#cb213-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-10"><a href="#cb213-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Example cost function (prefix sums)</span></span>
<span id="cb213-11"><a href="#cb213-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> prefix<span class="op">[</span><span class="dv">10005</span><span class="op">];</span></span>
<span id="cb213-12"><a href="#cb213-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cost<span class="op">(</span><span class="dt">int</span> j<span class="op">,</span> <span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb213-13"><a href="#cb213-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sum <span class="op">=</span> prefix<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> prefix<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb213-14"><a href="#cb213-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum <span class="op">*</span> sum<span class="op">;</span></span>
<span id="cb213-15"><a href="#cb213-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb213-16"><a href="#cb213-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-17"><a href="#cb213-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compute<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> optL<span class="op">,</span> <span class="dt">int</span> optR<span class="op">)</span> <span class="op">{</span></span>
<span id="cb213-18"><a href="#cb213-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>l <span class="op">&gt;</span> r<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb213-19"><a href="#cb213-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>l <span class="op">+</span> r<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb213-20"><a href="#cb213-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best_k <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb213-21"><a href="#cb213-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> best_val <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb213-22"><a href="#cb213-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-23"><a href="#cb213-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> optL<span class="op">;</span> k <span class="op">&lt;=</span> optR <span class="op">&amp;&amp;</span> k <span class="op">&lt;</span> mid<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb213-24"><a href="#cb213-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> val <span class="op">=</span> prev_dp<span class="op">[</span>k<span class="op">]</span> <span class="op">+</span> cost<span class="op">(</span>k<span class="op">,</span> mid<span class="op">);</span></span>
<span id="cb213-25"><a href="#cb213-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;</span> best_val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb213-26"><a href="#cb213-26" aria-hidden="true" tabindex="-1"></a>            best_val <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb213-27"><a href="#cb213-27" aria-hidden="true" tabindex="-1"></a>            best_k <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb213-28"><a href="#cb213-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb213-29"><a href="#cb213-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb213-30"><a href="#cb213-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-31"><a href="#cb213-31" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>mid<span class="op">]</span> <span class="op">=</span> best_val<span class="op">;</span></span>
<span id="cb213-32"><a href="#cb213-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-33"><a href="#cb213-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recurse left and right halves</span></span>
<span id="cb213-34"><a href="#cb213-34" aria-hidden="true" tabindex="-1"></a>    compute<span class="op">(</span>l<span class="op">,</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> optL<span class="op">,</span> best_k<span class="op">);</span></span>
<span id="cb213-35"><a href="#cb213-35" aria-hidden="true" tabindex="-1"></a>    compute<span class="op">(</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> r<span class="op">,</span> best_k<span class="op">,</span> optR<span class="op">);</span></span>
<span id="cb213-36"><a href="#cb213-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb213-37"><a href="#cb213-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-38"><a href="#cb213-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb213-39"><a href="#cb213-39" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb213-40"><a href="#cb213-40" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb213-41"><a href="#cb213-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> prefix<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> prefix<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb213-42"><a href="#cb213-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> prev_dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">*</span>i<span class="op">;</span></span>
<span id="cb213-43"><a href="#cb213-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-44"><a href="#cb213-44" aria-hidden="true" tabindex="-1"></a>    compute<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb213-45"><a href="#cb213-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-46"><a href="#cb213-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"dp[</span><span class="sc">%d</span><span class="st">] = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb213-47"><a href="#cb213-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb214"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cost(j, i):</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> prefix[i] <span class="op">-</span> prefix[j]</span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s <span class="op">*</span> s</span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute(l, r, optL, optR):</span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> l <span class="op">&gt;</span> r:</span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (l <span class="op">+</span> r) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> (<span class="bu">float</span>(<span class="st">'inf'</span>), <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(optL, <span class="bu">min</span>(optR, mid) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> prev_dp[k] <span class="op">+</span> cost(k, mid)</span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> val <span class="op">&lt;</span> best[<span class="dv">0</span>]:</span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> (val, k)</span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>    dp[mid], opt[mid] <span class="op">=</span> best</span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a>    compute(l, mid <span class="op">-</span> <span class="dv">1</span>, optL, best[<span class="dv">1</span>])</span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a>    compute(mid <span class="op">+</span> <span class="dv">1</span>, r, best[<span class="dv">1</span>], optR)</span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb214-19"><a href="#cb214-19" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb214-20"><a href="#cb214-20" aria-hidden="true" tabindex="-1"></a>prefix <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb214-21"><a href="#cb214-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> arr: prefix.append(prefix[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> x)</span>
<span id="cb214-22"><a href="#cb214-22" aria-hidden="true" tabindex="-1"></a>prev_dp <span class="op">=</span> [i<span class="op">*</span>i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(arr))]</span>
<span id="cb214-23"><a href="#cb214-23" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb214-24"><a href="#cb214-24" aria-hidden="true" tabindex="-1"></a>opt <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb214-25"><a href="#cb214-25" aria-hidden="true" tabindex="-1"></a>compute(<span class="dv">1</span>, n, <span class="dv">0</span>, n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb214-26"><a href="#cb214-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dp[<span class="dv">1</span>:])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-96" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-96">Why It Matters</h4>
<ul>
<li><p>Reduces complexity dramatically: <span class="math inline">\(O(n \log n)\)</span> per layer</p></li>
<li><p>Works on structured recurrences with monotonic <span class="math inline">\(opt[i]\)</span></p></li>
<li><p>Forms backbone for:</p>
<ul>
<li>Knuth Optimization</li>
<li>Monge Array DP</li>
<li>Segment Partition DP</li>
</ul></li>
</ul>
<p>You can think of it as “binary search for DP transitions.”</p>
</section>
<section id="a-gentle-proof-why-it-works-83" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-83">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(opt[i] \le opt[i+1]\)</span>, then each <span class="math inline">\(dp[mid]\)</span>’s optimal index <span class="math inline">\(k^*\)</span> lies between <span class="math inline">\(optL\)</span> and <span class="math inline">\(optR\)</span>. When dividing the range:</p>
<ul>
<li>Left child (<span class="math inline">\(L, mid-1\)</span>) searches <span class="math inline">\([optL, k^*]\)</span></li>
<li>Right child (<span class="math inline">\(mid+1, R\)</span>) searches <span class="math inline">\([k^*, optR]\)</span></li>
</ul>
<p>By induction, every segment explores only valid transitions. Since each <span class="math inline">\(k\)</span> is visited <span class="math inline">\(O(\log n)\)</span> times, total time is <span class="math inline">\(O(n \log n)\)</span>.</p>
</section>
<section id="try-it-yourself-96" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-96">Try It Yourself</h4>
<ol type="1">
<li>Implement partition DP with convex segment cost.</li>
<li>Verify monotonicity of <span class="math inline">\(opt[i]\)</span> numerically.</li>
<li>Compare <span class="math inline">\(O(n^2)\)</span> vs optimized <span class="math inline">\(O(n \log n)\)</span>.</li>
<li>Combine with space optimization (roll arrays).</li>
<li>Extend to multi-layer DP (e.g., k-partition).</li>
</ol>
</section>
<section id="test-cases-96" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-96">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 59%">
<col style="width: 11%">
<col style="width: 16%">
<col style="width: 8%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Recurrence</th>
<th>Property</th>
<th>Optimization</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(dp[i]=\min_{j&lt;i}(dp[j]+(sum[i]-sum[j])^2)\)</span></td>
<td>convex</td>
<td>yes</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(dp[i]=\min_{j&lt;i}(dp[j]+                    | i-j      | )\)</span></td>
<td>linear</td>
<td>yes</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(dp[i]=\min_{j&lt;i}(dp[j]+cost[j][i])\)</span></td>
<td>Monge</td>
<td>yes</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-96" class="level4">
<h4 class="anchored" data-anchor-id="complexity-96">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \log n)\)</span> per layer</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
<li>Layers: multiply by <span class="math inline">\(k\)</span> for multi-stage DP</li>
</ul>
<p>Divide &amp; Conquer DP is your scalpel for quadratic DPs, once you find monotonicity, you slice complexity cleanly in half at every level.</p>
</section>
</section>
<section id="rerooting-template" class="level3">
<h3 class="anchored" data-anchor-id="rerooting-template">498 Rerooting Template</h3>
<p>Rerooting DP is a powerful tree dynamic programming pattern that lets you compute results for every node as the root, efficiently reusing computations from parent-to-child transitions. It’s like rotating the tree root through all nodes without recomputing everything from scratch.</p>
<section id="what-problem-are-we-solving-97" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-97">What Problem Are We Solving?</h4>
<p>Given a tree, we often want to compute a property for each node as if it were the root. For example:</p>
<ul>
<li>Sum of distances to all nodes</li>
<li>Size of subtree or value based on children</li>
<li>Number of valid colorings rooted at each node</li>
</ul>
<p>Naively, you could rerun DP for every node, <span class="math inline">\(O(n^2)\)</span>, but rerooting reduces this to <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(n \log n)\)</span> by cleverly reusing partial results.</p>
</section>
<section id="how-does-it-work-plain-language-94" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-94">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>First pass (postorder): compute DP values bottom-up for a fixed root (usually node 1).</li>
<li>Second pass (preorder): propagate results top-down, rerooting along each edge and combining parent contributions.</li>
</ol>
<p>When moving the root from <code>u</code> to <code>v</code>:</p>
<ul>
<li>Remove <code>v</code>’s contribution from <code>u</code>’s DP.</li>
<li>Add <code>u</code>’s contribution (excluding <code>v</code>) into <code>v</code>’s DP.</li>
</ul>
<p>This way, each node inherits a correct rerooted DP in one traversal.</p>
</section>
<section id="example-problem-2" class="level4">
<h4 class="anchored" data-anchor-id="example-problem-2">Example Problem</h4>
<p>Compute sum of distances from every node to all others.</p>
<p>Let:</p>
<ul>
<li><span class="math inline">\(dp[u]\)</span> = sum of distances from <span class="math inline">\(u\)</span> to all nodes in its subtree</li>
<li><span class="math inline">\(sz[u]\)</span> = size of subtree of <span class="math inline">\(u\)</span></li>
</ul>
<p>We can reroot using: <span class="math display">\[
dp[v] = dp[u] - sz[v] + (n - sz[v])
\]</span> when moving root from <span class="math inline">\(u\)</span> to child <span class="math inline">\(v\)</span>.</p>
</section>
<section id="tiny-code-c-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-1">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb215"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">100005</span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>using namespace std<span class="op">;</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> adj<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb215-8"><a href="#cb215-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb215-9"><a href="#cb215-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sz<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb215-10"><a href="#cb215-10" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb215-11"><a href="#cb215-11" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> ans<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb215-12"><a href="#cb215-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-13"><a href="#cb215-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb215-14"><a href="#cb215-14" aria-hidden="true" tabindex="-1"></a>    sz<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb215-15"><a href="#cb215-15" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb215-16"><a href="#cb215-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="cf">if</span> <span class="op">(</span>v <span class="op">!=</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb215-17"><a href="#cb215-17" aria-hidden="true" tabindex="-1"></a>        dfs1<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb215-18"><a href="#cb215-18" aria-hidden="true" tabindex="-1"></a>        sz<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> sz<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb215-19"><a href="#cb215-19" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>v<span class="op">]</span> <span class="op">+</span> sz<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb215-20"><a href="#cb215-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb215-21"><a href="#cb215-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb215-22"><a href="#cb215-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-23"><a href="#cb215-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb215-24"><a href="#cb215-24" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb215-25"><a href="#cb215-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="cf">if</span> <span class="op">(</span>v <span class="op">!=</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb215-26"><a href="#cb215-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> dp_u <span class="op">=</span> dp<span class="op">[</span>u<span class="op">],</span> dp_v <span class="op">=</span> dp<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb215-27"><a href="#cb215-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sz_u <span class="op">=</span> sz<span class="op">[</span>u<span class="op">],</span> sz_v <span class="op">=</span> sz<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb215-28"><a href="#cb215-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-29"><a href="#cb215-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Move root from u to v</span></span>
<span id="cb215-30"><a href="#cb215-30" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">-=</span> dp<span class="op">[</span>v<span class="op">]</span> <span class="op">+</span> sz<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb215-31"><a href="#cb215-31" aria-hidden="true" tabindex="-1"></a>        sz<span class="op">[</span>u<span class="op">]</span> <span class="op">-=</span> sz<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb215-32"><a href="#cb215-32" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>v<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> sz<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb215-33"><a href="#cb215-33" aria-hidden="true" tabindex="-1"></a>        sz<span class="op">[</span>v<span class="op">]</span> <span class="op">+=</span> sz<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb215-34"><a href="#cb215-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-35"><a href="#cb215-35" aria-hidden="true" tabindex="-1"></a>        dfs2<span class="op">(</span>v<span class="op">,</span> u<span class="op">);</span></span>
<span id="cb215-36"><a href="#cb215-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-37"><a href="#cb215-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Restore</span></span>
<span id="cb215-38"><a href="#cb215-38" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dp_u<span class="op">;</span> dp<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dp_v<span class="op">;</span></span>
<span id="cb215-39"><a href="#cb215-39" aria-hidden="true" tabindex="-1"></a>        sz<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> sz_u<span class="op">;</span> sz<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> sz_v<span class="op">;</span></span>
<span id="cb215-40"><a href="#cb215-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb215-41"><a href="#cb215-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb215-42"><a href="#cb215-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-43"><a href="#cb215-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb215-44"><a href="#cb215-44" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb215-45"><a href="#cb215-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">-</span><span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb215-46"><a href="#cb215-46" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span> v<span class="op">;</span></span>
<span id="cb215-47"><a href="#cb215-47" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">,</span> <span class="op">&amp;</span>v<span class="op">);</span></span>
<span id="cb215-48"><a href="#cb215-48" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb215-49"><a href="#cb215-49" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb215-50"><a href="#cb215-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb215-51"><a href="#cb215-51" aria-hidden="true" tabindex="-1"></a>    dfs1<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb215-52"><a href="#cb215-52" aria-hidden="true" tabindex="-1"></a>    dfs2<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb215-53"><a href="#cb215-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb215-54"><a href="#cb215-54" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Sum of distances from </span><span class="sc">%d</span><span class="st">: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> ans<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb215-55"><a href="#cb215-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb216"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>adj <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">3</span>,<span class="dv">5</span>)]</span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>    adj[u].append(v)</span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a>    adj[v].append(u)</span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a>sz <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a>ans <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb216-13"><a href="#cb216-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-14"><a href="#cb216-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs1(u,p):</span>
<span id="cb216-15"><a href="#cb216-15" aria-hidden="true" tabindex="-1"></a>    sz[u] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb216-16"><a href="#cb216-16" aria-hidden="true" tabindex="-1"></a>    dp[u] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb216-17"><a href="#cb216-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> adj[u]:</span>
<span id="cb216-18"><a href="#cb216-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb216-19"><a href="#cb216-19" aria-hidden="true" tabindex="-1"></a>        dfs1(v,u)</span>
<span id="cb216-20"><a href="#cb216-20" aria-hidden="true" tabindex="-1"></a>        sz[u] <span class="op">+=</span> sz[v]</span>
<span id="cb216-21"><a href="#cb216-21" aria-hidden="true" tabindex="-1"></a>        dp[u] <span class="op">+=</span> dp[v] <span class="op">+</span> sz[v]</span>
<span id="cb216-22"><a href="#cb216-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-23"><a href="#cb216-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs2(u,p):</span>
<span id="cb216-24"><a href="#cb216-24" aria-hidden="true" tabindex="-1"></a>    ans[u] <span class="op">=</span> dp[u]</span>
<span id="cb216-25"><a href="#cb216-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> adj[u]:</span>
<span id="cb216-26"><a href="#cb216-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb216-27"><a href="#cb216-27" aria-hidden="true" tabindex="-1"></a>        dp_u, dp_v <span class="op">=</span> dp[u], dp[v]</span>
<span id="cb216-28"><a href="#cb216-28" aria-hidden="true" tabindex="-1"></a>        sz_u, sz_v <span class="op">=</span> sz[u], sz[v]</span>
<span id="cb216-29"><a href="#cb216-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-30"><a href="#cb216-30" aria-hidden="true" tabindex="-1"></a>        dp[u] <span class="op">-=</span> dp[v] <span class="op">+</span> sz[v]</span>
<span id="cb216-31"><a href="#cb216-31" aria-hidden="true" tabindex="-1"></a>        sz[u] <span class="op">-=</span> sz[v]</span>
<span id="cb216-32"><a href="#cb216-32" aria-hidden="true" tabindex="-1"></a>        dp[v] <span class="op">+=</span> dp[u] <span class="op">+</span> sz[u]</span>
<span id="cb216-33"><a href="#cb216-33" aria-hidden="true" tabindex="-1"></a>        sz[v] <span class="op">+=</span> sz[u]</span>
<span id="cb216-34"><a href="#cb216-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-35"><a href="#cb216-35" aria-hidden="true" tabindex="-1"></a>        dfs2(v,u)</span>
<span id="cb216-36"><a href="#cb216-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-37"><a href="#cb216-37" aria-hidden="true" tabindex="-1"></a>        dp[u], dp[v] <span class="op">=</span> dp_u, dp_v</span>
<span id="cb216-38"><a href="#cb216-38" aria-hidden="true" tabindex="-1"></a>        sz[u], sz[v] <span class="op">=</span> sz_u, sz_v</span>
<span id="cb216-39"><a href="#cb216-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-40"><a href="#cb216-40" aria-hidden="true" tabindex="-1"></a>dfs1(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb216-41"><a href="#cb216-41" aria-hidden="true" tabindex="-1"></a>dfs2(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb216-42"><a href="#cb216-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-43"><a href="#cb216-43" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb216-44"><a href="#cb216-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Sum of distances from </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>ans[i]<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-97" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-97">Why It Matters</h4>
<ul>
<li><p>Enables <span class="math inline">\(O(n)\)</span> computation of per-node DP values.</p></li>
<li><p>Reuses child and parent information via reversible transitions.</p></li>
<li><p>Crucial for:</p>
<ul>
<li>Distance sums</li>
<li>Subtree aggregations</li>
<li>Coloring and constraint propagation</li>
</ul></li>
</ul>
<p>You can reroot any tree once you know how to move contributions.</p>
</section>
<section id="a-gentle-proof-why-it-works-84" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-84">A Gentle Proof (Why It Works)</h4>
<p>The rerooting relation ensures:</p>
<ul>
<li><span class="math inline">\(dp[u]\)</span> stores full-tree values when rooted at <span class="math inline">\(u\)</span>.</li>
<li>When rerooting to <span class="math inline">\(v\)</span>, subtract <span class="math inline">\(v\)</span>’s contribution from <span class="math inline">\(u\)</span>, then add <span class="math inline">\(u\)</span>’s contribution to <span class="math inline">\(v\)</span>.</li>
</ul>
<p>Because each edge is traversed twice, total complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>This is a direct application of DP reusability under tree decomposition.</p>
</section>
<section id="try-it-yourself-97" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-97">Try It Yourself</h4>
<ol type="1">
<li>Compute subtree sums and reroot to get sum of values at distance ≤ k.</li>
<li>Apply rerooting to count paths passing through each node.</li>
<li>Modify transitions for tree coloring or centroid scoring.</li>
<li>Visualize contribution flow parent↔︎child.</li>
</ol>
</section>
<section id="test-cases-97" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-97">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Query</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line (1–2–3–4)</td>
<td>Distance sums</td>
<td>6, 4, 4, 6</td>
</tr>
<tr class="even">
<td>Star (1–2,1–3,1–4)</td>
<td>Distance sums</td>
<td>3, 5, 5, 5</td>
</tr>
<tr class="odd">
<td>Balanced tree</td>
<td>Aggregation</td>
<td>symmetric</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-97" class="level4">
<h4 class="anchored" data-anchor-id="complexity-97">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Rerooting DP is your “walk the tree” trick, one bottom-up pass, one top-down pass, and you know what every node would see if it stood at the root.</p>
</section>
</section>
<section id="iterative-dp-pattern" class="level3">
<h3 class="anchored" data-anchor-id="iterative-dp-pattern">499 Iterative DP Pattern</h3>
<p>Iterative (bottom-up) dynamic programming is the most systematic and efficient way to compute state-based solutions. Instead of recursion and memoization, we explicitly build tables in increasing order of dependency, turning recurrence relations into simple loops.</p>
<section id="what-problem-are-we-solving-98" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-98">What Problem Are We Solving?</h4>
<p>When you have a recurrence like:</p>
<p><span class="math display">\[
dp[i] = f(dp[i-1], dp[i-2], \ldots)
\]</span></p>
<p>you don’t need recursion, you can iterate from base to target. This approach avoids call stack overhead, ensures predictable memory access, and simplifies debugging.</p>
<p>Iterative DP is ideal for:</p>
<ul>
<li>Counting problems (e.g.&nbsp;Fibonacci, climbing stairs)</li>
<li>Path minimization (e.g.&nbsp;shortest path, knapsack)</li>
<li>Sequence alignment (e.g.&nbsp;LCS, edit distance)</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-95" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-95">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>Define the state <span class="math inline">\(dp[i]\)</span>: what does it represent?</li>
<li>Identify base cases (e.g.&nbsp;<span class="math inline">\(dp[0]\)</span>, <span class="math inline">\(dp[1]\)</span>).</li>
<li>Establish transition using smaller states.</li>
<li>Iterate from smallest to largest index, ensuring dependencies are filled before use.</li>
<li>Extract result (e.g.&nbsp;<span class="math inline">\(dp[n]\)</span> or <span class="math inline">\(\max_i dp[i]\)</span>).</li>
</ol>
<p>The iteration order must match dependency direction.</p>
</section>
<section id="example-climbing-stairs" class="level4">
<h4 class="anchored" data-anchor-id="example-climbing-stairs">Example: Climbing Stairs</h4>
<p>You can climb either 1 or 2 steps at a time. Number of ways to reach step <span class="math inline">\(n\)</span>:</p>
<p><span class="math display">\[
dp[i] = dp[i-1] + dp[i-2]
\]</span></p>
<p>with base cases <span class="math inline">\(dp[0] = 1\)</span>, <span class="math inline">\(dp[1] = 1\)</span>.</p>
</section>
<section id="tiny-code-c-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-2">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb217"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span><span class="dv">6</span><span class="op">];</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb217-10"><a href="#cb217-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Ways to climb </span><span class="sc">%d</span><span class="st"> stairs: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> n<span class="op">,</span> dp<span class="op">[</span>n<span class="op">]);</span></span>
<span id="cb217-11"><a href="#cb217-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb218"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>dp[<span class="dv">0</span>] <span class="op">=</span> dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>    dp[i] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Ways to climb </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> stairs: </span><span class="sc">{</span>dp[n]<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-98" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-98">Why It Matters</h4>
<ul>
<li>Performance: Iteration eliminates recursion overhead.</li>
<li>Clarity: Each state is computed once, in a known order.</li>
<li>Memory Optimization: You can reduce space when only recent states are needed (rolling array).</li>
<li>Foundation: All advanced DPs (knapsack, edit distance, LIS) can be written iteratively.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-85" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-85">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(dp[i]\)</span> depends only on smaller indices, then filling <span class="math inline">\(dp[0 \ldots n]\)</span> in order guarantees correctness.</p>
<p>By induction:</p>
<ul>
<li>Base cases true by definition.</li>
<li>Assuming <span class="math inline">\(dp[0..i-1]\)</span> correct, then <span class="math inline">\(dp[i] = f(dp[0..i-1])\)</span> produces correct result.</li>
</ul>
<p>No state is used before it’s computed.</p>
</section>
<section id="try-it-yourself-98" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-98">Try It Yourself</h4>
<ol type="1">
<li>Implement iterative Fibonacci with constant space.</li>
<li>Convert recursive knapsack into iterative table form.</li>
<li>Write bottom-up LCS for two strings.</li>
<li>Try 2D iterative DP for grid paths.</li>
</ol>
</section>
<section id="test-cases-98" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-98">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>Expected Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(n=0\)</span></td>
<td>1</td>
</tr>
<tr class="even">
<td><span class="math inline">\(n=1\)</span></td>
<td>1</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(n=5\)</span></td>
<td>8</td>
</tr>
<tr class="even">
<td><span class="math inline">\(n=10\)</span></td>
<td>89</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-98" class="level4">
<h4 class="anchored" data-anchor-id="complexity-98">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span> (or <span class="math inline">\(O(1)\)</span> with rolling array)</li>
</ul>
<p>Iterative DP is the canonical form, the simplest, most direct way to think about recursion unrolled into loops.</p>
</section>
</section>
<section id="memoization-template" class="level3">
<h3 class="anchored" data-anchor-id="memoization-template">500 Memoization Template</h3>
<p>Memoization is the top-down form of dynamic programming, you solve the problem recursively, but store answers so you never recompute the same state twice. It’s the natural bridge between pure recursion and iterative DP.</p>
<section id="what-problem-are-we-solving-99" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-99">What Problem Are We Solving?</h4>
<p>Many recursive problems revisit the same subproblems multiple times. For example, Fibonacci recursion:</p>
<p><span class="math display">\[
F(n) = F(n-1) + F(n-2)
\]</span></p>
<p>recomputes <span class="math inline">\(F(k)\)</span> many times. Memoization avoids this by caching results after the first computation.</p>
<p>Whenever your recursion tree overlaps, memoization converts exponential time into polynomial time.</p>
</section>
<section id="how-does-it-work-plain-language-96" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-96">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>Define the state: what parameters describe your subproblem?</li>
<li>Check if cached: if already solved, return memoized value.</li>
<li>Recurse: compute using smaller states.</li>
<li>Store result before returning.</li>
<li>Return the cached value next time it’s needed.</li>
</ol>
<p>Memoization is ideal for:</p>
<ul>
<li>Recursive definitions (Fibonacci, Knapsack, LCS)</li>
<li>Combinatorial counting with overlapping subproblems</li>
<li>Tree/graph traversal with repeated subpaths</li>
</ul>
</section>
<section id="example-fibonacci-with-memoization" class="level4">
<h4 class="anchored" data-anchor-id="example-fibonacci-with-memoization">Example: Fibonacci with Memoization</h4>
<p><span class="math display">\[
F(n) =
\begin{cases}
1, &amp; n \le 1,\\
F(n-1) + F(n-2), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>We store each <span class="math inline">\(F(k)\)</span> the first time it’s computed.</p>
</section>
<section id="tiny-code-c-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-3">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb219"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> memo<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fib<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>n<span class="op">]</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> fib<span class="op">(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> fib<span class="op">(</span>n<span class="op">-</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Fib(</span><span class="sc">%d</span><span class="st">) = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> n<span class="op">,</span> fib<span class="op">(</span>n<span class="op">));</span></span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb220"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>memo <span class="op">=</span> {}</span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib(n):</span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> fib(n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib(n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(fib(<span class="dv">10</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-99" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-99">Why It Matters</h4>
<ul>
<li>Bridges recursion and iteration: You keep the elegance of recursion with the performance of DP.</li>
<li>Faster prototypes: Great for quickly building correct solutions.</li>
<li>Easier to reason: You only define recurrence, not filling order.</li>
<li>Transition step: Helps derive bottom-up equivalents later.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-86" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-86">A Gentle Proof (Why It Works)</h4>
<p>We prove correctness by induction:</p>
<ul>
<li>Base case: <span class="math inline">\(dp[0]\)</span> and <span class="math inline">\(dp[1]\)</span> defined directly.</li>
<li>Inductive step: Each call to <span class="math inline">\(f(n)\)</span> only uses smaller arguments <span class="math inline">\(f(k)\)</span>, which are correct by the inductive hypothesis.</li>
<li>Caching: Ensures each <span class="math inline">\(f(k)\)</span> computed exactly once, guaranteeing <span class="math inline">\(O(n)\)</span> total calls.</li>
</ul>
<p>Thus, memoization preserves recursion semantics while achieving optimal time.</p>
</section>
<section id="try-it-yourself-99" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-99">Try It Yourself</h4>
<ol type="1">
<li>Write memoized knapsack with signature <code>solve(i, w)</code></li>
<li>Memoize subset sum (<code>solve(i, sum)</code>)</li>
<li>Build LCS recursively with <code>(i, j)</code> as state</li>
<li>Compare memoized and bottom-up versions for runtime</li>
</ol>
</section>
<section id="test-cases-99" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-99">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input</th>
<th>Expected Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(fib(0)\)</span></td>
<td>1</td>
</tr>
<tr class="even">
<td><span class="math inline">\(fib(1)\)</span></td>
<td>1</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(fib(5)\)</span></td>
<td>8</td>
</tr>
<tr class="even">
<td><span class="math inline">\(fib(10)\)</span></td>
<td>89</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-99" class="level4">
<h4 class="anchored" data-anchor-id="complexity-99">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> (each state computed once)</li>
<li>Space: <span class="math inline">\(O(n)\)</span> recursion + cache</li>
</ul>
<p>Memoization is the conceptual core of DP, it reveals how subproblems overlap and prepares you for crafting iterative solutions.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../books/en-us/list-4.html" class="pagination-link" aria-label="Chapter 4. Graph Algorithms">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Chapter 4. Graph Algorithms</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>
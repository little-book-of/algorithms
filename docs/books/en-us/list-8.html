<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Chapter 8. Geometry, Graphics and Spatial Algorithms – The Little Book of Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../books/en-us/list-9.html" rel="next">
<link href="../../books/en-us/list-7.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-27c261d06b905028a18691de25d09dde.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../books/en-us/list-8.html"><span class="chapter-title">Chapter 8. Geometry, Graphics and Spatial Algorithms</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">The Little Book of Algorithms</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Content</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/cheatsheet.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Cheatsheet</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/book.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/plan.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Plan</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-1.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 1. Foundations of Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-2.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 2. Sorting and searching</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-3.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 3. Data Structure in Action</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-4.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 4. Graph Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-5.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 5. Dynamic Programming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-6.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 6. Mathematics for Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-7.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 7. Strings and Text Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-8.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Chapter 8. Geometry, Graphics and Spatial Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-9.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 9. Systems, Databases and Distributed Algorithms</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#section-71.-convex-hull" id="toc-section-71.-convex-hull" class="nav-link active" data-scroll-target="#section-71.-convex-hull">Section 71. Convex Hull</a>
  <ul class="collapse">
  <li><a href="#gift-wrapping-jarvis-march" id="toc-gift-wrapping-jarvis-march" class="nav-link" data-scroll-target="#gift-wrapping-jarvis-march">701 Gift Wrapping (Jarvis March)</a></li>
  <li><a href="#graham-scan" id="toc-graham-scan" class="nav-link" data-scroll-target="#graham-scan">702 Graham Scan</a></li>
  <li><a href="#andrews-monotone-chain" id="toc-andrews-monotone-chain" class="nav-link" data-scroll-target="#andrews-monotone-chain">703 Andrew’s Monotone Chain</a></li>
  <li><a href="#chans-algorithm" id="toc-chans-algorithm" class="nav-link" data-scroll-target="#chans-algorithm">704 Chan’s Algorithm</a></li>
  <li><a href="#quickhull" id="toc-quickhull" class="nav-link" data-scroll-target="#quickhull">705 QuickHull</a></li>
  <li><a href="#incremental-convex-hull" id="toc-incremental-convex-hull" class="nav-link" data-scroll-target="#incremental-convex-hull">706 Incremental Convex Hull</a></li>
  <li><a href="#divide-conquer-hull" id="toc-divide-conquer-hull" class="nav-link" data-scroll-target="#divide-conquer-hull">707 Divide &amp; Conquer Hull</a></li>
  <li><a href="#d-convex-hull" id="toc-d-convex-hull" class="nav-link" data-scroll-target="#d-convex-hull">708 3D Convex Hull</a></li>
  <li><a href="#dynamic-convex-hull" id="toc-dynamic-convex-hull" class="nav-link" data-scroll-target="#dynamic-convex-hull">709 Dynamic Convex Hull</a></li>
  <li><a href="#rotating-calipers" id="toc-rotating-calipers" class="nav-link" data-scroll-target="#rotating-calipers">710 Rotating Calipers</a></li>
  </ul></li>
  <li><a href="#section-72.-closest-pair-and-segment-algorithms" id="toc-section-72.-closest-pair-and-segment-algorithms" class="nav-link" data-scroll-target="#section-72.-closest-pair-and-segment-algorithms">Section 72. Closest Pair and Segment Algorithms</a>
  <ul class="collapse">
  <li><a href="#closest-pair-divide-conquer" id="toc-closest-pair-divide-conquer" class="nav-link" data-scroll-target="#closest-pair-divide-conquer">711 Closest Pair (Divide &amp; Conquer)</a></li>
  <li><a href="#closest-pair-sweep-line" id="toc-closest-pair-sweep-line" class="nav-link" data-scroll-target="#closest-pair-sweep-line">712 Closest Pair (Sweep Line)</a></li>
  <li><a href="#brute-force-closest-pair" id="toc-brute-force-closest-pair" class="nav-link" data-scroll-target="#brute-force-closest-pair">713 Brute Force Closest Pair</a></li>
  <li><a href="#bentleyottmann" id="toc-bentleyottmann" class="nav-link" data-scroll-target="#bentleyottmann">714 Bentley–Ottmann</a></li>
  <li><a href="#segment-intersection-test" id="toc-segment-intersection-test" class="nav-link" data-scroll-target="#segment-intersection-test">715 Segment Intersection Test</a></li>
  <li><a href="#line-sweep-for-segments" id="toc-line-sweep-for-segments" class="nav-link" data-scroll-target="#line-sweep-for-segments">716 Line Sweep for Segments</a></li>
  <li><a href="#intersection-via-orientation-ccw-test" id="toc-intersection-via-orientation-ccw-test" class="nav-link" data-scroll-target="#intersection-via-orientation-ccw-test">717 Intersection via Orientation (CCW Test)</a></li>
  <li><a href="#circle-intersection" id="toc-circle-intersection" class="nav-link" data-scroll-target="#circle-intersection">718 Circle Intersection</a></li>
  <li><a href="#polygon-intersection" id="toc-polygon-intersection" class="nav-link" data-scroll-target="#polygon-intersection">719 Polygon Intersection</a></li>
  <li><a href="#nearest-neighbor-pair-with-kd-tree" id="toc-nearest-neighbor-pair-with-kd-tree" class="nav-link" data-scroll-target="#nearest-neighbor-pair-with-kd-tree">720 Nearest Neighbor Pair (with KD-Tree)</a></li>
  </ul></li>
  <li><a href="#section-73.-line-sweep-and-plane-sweep-algorithms" id="toc-section-73.-line-sweep-and-plane-sweep-algorithms" class="nav-link" data-scroll-target="#section-73.-line-sweep-and-plane-sweep-algorithms">Section 73. Line Sweep and Plane Sweep Algorithms</a>
  <ul class="collapse">
  <li><a href="#sweep-line-for-events" id="toc-sweep-line-for-events" class="nav-link" data-scroll-target="#sweep-line-for-events">721 Sweep Line for Events</a></li>
  <li><a href="#interval-scheduling" id="toc-interval-scheduling" class="nav-link" data-scroll-target="#interval-scheduling">722 Interval Scheduling</a></li>
  <li><a href="#rectangle-union-area" id="toc-rectangle-union-area" class="nav-link" data-scroll-target="#rectangle-union-area">723 Rectangle Union Area</a></li>
  <li><a href="#segment-intersection-bentleyottmann-variant" id="toc-segment-intersection-bentleyottmann-variant" class="nav-link" data-scroll-target="#segment-intersection-bentleyottmann-variant">724 Segment Intersection (Bentley–Ottmann Variant)</a></li>
  <li><a href="#skyline-problem" id="toc-skyline-problem" class="nav-link" data-scroll-target="#skyline-problem">725 Skyline Problem</a></li>
  <li><a href="#closest-pair-sweep" id="toc-closest-pair-sweep" class="nav-link" data-scroll-target="#closest-pair-sweep">726 Closest Pair Sweep</a></li>
  <li><a href="#circle-arrangement-sweep" id="toc-circle-arrangement-sweep" class="nav-link" data-scroll-target="#circle-arrangement-sweep">727 Circle Arrangement Sweep</a></li>
  <li><a href="#sweep-for-overlapping-rectangles" id="toc-sweep-for-overlapping-rectangles" class="nav-link" data-scroll-target="#sweep-for-overlapping-rectangles">728 Sweep for Overlapping Rectangles</a></li>
  <li><a href="#range-counting" id="toc-range-counting" class="nav-link" data-scroll-target="#range-counting">729 Range Counting</a></li>
  <li><a href="#range-counting-1" id="toc-range-counting-1" class="nav-link" data-scroll-target="#range-counting-1">729 Range Counting</a></li>
  <li><a href="#plane-sweep-for-triangles" id="toc-plane-sweep-for-triangles" class="nav-link" data-scroll-target="#plane-sweep-for-triangles">730 Plane Sweep for Triangles</a></li>
  </ul></li>
  <li><a href="#section-74.-delaunay-and-voronoi-diagrams" id="toc-section-74.-delaunay-and-voronoi-diagrams" class="nav-link" data-scroll-target="#section-74.-delaunay-and-voronoi-diagrams">Section 74. Delaunay and Voronoi Diagrams</a>
  <ul class="collapse">
  <li><a href="#delaunay-triangulation-incremental" id="toc-delaunay-triangulation-incremental" class="nav-link" data-scroll-target="#delaunay-triangulation-incremental">731 Delaunay Triangulation (Incremental)</a></li>
  <li><a href="#delaunay-divide-conquer" id="toc-delaunay-divide-conquer" class="nav-link" data-scroll-target="#delaunay-divide-conquer">732 Delaunay (Divide &amp; Conquer)</a></li>
  <li><a href="#delaunay-fortunes-sweep" id="toc-delaunay-fortunes-sweep" class="nav-link" data-scroll-target="#delaunay-fortunes-sweep">733 Delaunay (Fortune’s Sweep)</a></li>
  <li><a href="#voronoi-diagram-fortunes-sweep" id="toc-voronoi-diagram-fortunes-sweep" class="nav-link" data-scroll-target="#voronoi-diagram-fortunes-sweep">734 Voronoi Diagram (Fortune’s Sweep)</a></li>
  <li><a href="#incremental-voronoi" id="toc-incremental-voronoi" class="nav-link" data-scroll-target="#incremental-voronoi">735 Incremental Voronoi</a></li>
  <li><a href="#bowyerwatson" id="toc-bowyerwatson" class="nav-link" data-scroll-target="#bowyerwatson">736 Bowyer–Watson</a></li>
  <li><a href="#duality-transform" id="toc-duality-transform" class="nav-link" data-scroll-target="#duality-transform">737 Duality Transform</a></li>
  <li><a href="#power-diagram-weighted-voronoi" id="toc-power-diagram-weighted-voronoi" class="nav-link" data-scroll-target="#power-diagram-weighted-voronoi">738 Power Diagram (Weighted Voronoi)</a></li>
  <li><a href="#lloyds-relaxation" id="toc-lloyds-relaxation" class="nav-link" data-scroll-target="#lloyds-relaxation">739 Lloyd’s Relaxation</a></li>
  <li><a href="#voronoi-nearest-neighbor" id="toc-voronoi-nearest-neighbor" class="nav-link" data-scroll-target="#voronoi-nearest-neighbor">740 Voronoi Nearest Neighbor</a></li>
  </ul></li>
  <li><a href="#section-75.-point-in-polygon-and-polygon-triangulation" id="toc-section-75.-point-in-polygon-and-polygon-triangulation" class="nav-link" data-scroll-target="#section-75.-point-in-polygon-and-polygon-triangulation">Section 75. Point in Polygon and Polygon Triangulation</a>
  <ul class="collapse">
  <li><a href="#ray-casting" id="toc-ray-casting" class="nav-link" data-scroll-target="#ray-casting">741 Ray Casting</a></li>
  <li><a href="#winding-number" id="toc-winding-number" class="nav-link" data-scroll-target="#winding-number">742 Winding Number</a></li>
  <li><a href="#convex-polygon-point-test" id="toc-convex-polygon-point-test" class="nav-link" data-scroll-target="#convex-polygon-point-test">743 Convex Polygon Point Test</a></li>
  <li><a href="#ear-clipping-triangulation" id="toc-ear-clipping-triangulation" class="nav-link" data-scroll-target="#ear-clipping-triangulation">744 Ear Clipping Triangulation</a></li>
  <li><a href="#monotone-polygon-triangulation" id="toc-monotone-polygon-triangulation" class="nav-link" data-scroll-target="#monotone-polygon-triangulation">745 Monotone Polygon Triangulation</a></li>
  <li><a href="#delaunay-triangulation-optimal-triangle-quality" id="toc-delaunay-triangulation-optimal-triangle-quality" class="nav-link" data-scroll-target="#delaunay-triangulation-optimal-triangle-quality">746 Delaunay Triangulation (Optimal Triangle Quality)</a></li>
  <li><a href="#convex-decomposition" id="toc-convex-decomposition" class="nav-link" data-scroll-target="#convex-decomposition">747 Convex Decomposition</a></li>
  <li><a href="#polygon-area-shoelace-formula" id="toc-polygon-area-shoelace-formula" class="nav-link" data-scroll-target="#polygon-area-shoelace-formula">748 Polygon Area (Shoelace Formula)</a></li>
  <li><a href="#minkowski-sum" id="toc-minkowski-sum" class="nav-link" data-scroll-target="#minkowski-sum">749 Minkowski Sum</a></li>
  <li><a href="#polygon-intersection-weileratherton-clipping" id="toc-polygon-intersection-weileratherton-clipping" class="nav-link" data-scroll-target="#polygon-intersection-weileratherton-clipping">750 Polygon Intersection (Weiler–Atherton Clipping)</a></li>
  </ul></li>
  <li><a href="#section-76.-spatial-data-structures" id="toc-section-76.-spatial-data-structures" class="nav-link" data-scroll-target="#section-76.-spatial-data-structures">Section 76. Spatial Data Structures</a>
  <ul class="collapse">
  <li><a href="#kd-tree-build" id="toc-kd-tree-build" class="nav-link" data-scroll-target="#kd-tree-build">751 KD-Tree Build</a></li>
  <li><a href="#kd-tree-search" id="toc-kd-tree-search" class="nav-link" data-scroll-target="#kd-tree-search">752 KD-Tree Search</a></li>
  <li><a href="#range-search-in-kd-tree" id="toc-range-search-in-kd-tree" class="nav-link" data-scroll-target="#range-search-in-kd-tree">753 Range Search in KD-Tree</a></li>
  <li><a href="#nearest-neighbor-search-in-kd-tree" id="toc-nearest-neighbor-search-in-kd-tree" class="nav-link" data-scroll-target="#nearest-neighbor-search-in-kd-tree">754 Nearest Neighbor Search in KD-Tree</a></li>
  <li><a href="#r-tree-build" id="toc-r-tree-build" class="nav-link" data-scroll-target="#r-tree-build">755 R-Tree Build</a></li>
  <li><a href="#r-tree" id="toc-r-tree" class="nav-link" data-scroll-target="#r-tree">756 R*-Tree</a></li>
  <li><a href="#quad-tree" id="toc-quad-tree" class="nav-link" data-scroll-target="#quad-tree">757 Quad Tree</a></li>
  <li><a href="#octree" id="toc-octree" class="nav-link" data-scroll-target="#octree">758 Octree</a></li>
  <li><a href="#bsp-tree-binary-space-partition-tree" id="toc-bsp-tree-binary-space-partition-tree" class="nav-link" data-scroll-target="#bsp-tree-binary-space-partition-tree">759 BSP Tree (Binary Space Partition Tree)</a></li>
  <li><a href="#morton-order-z-curve" id="toc-morton-order-z-curve" class="nav-link" data-scroll-target="#morton-order-z-curve">760 Morton Order (Z-Curve)</a></li>
  </ul></li>
  <li><a href="#section-77.-rasterization-and-scanline-techniques" id="toc-section-77.-rasterization-and-scanline-techniques" class="nav-link" data-scroll-target="#section-77.-rasterization-and-scanline-techniques">Section 77. Rasterization and Scanline Techniques</a>
  <ul class="collapse">
  <li><a href="#bresenhams-line-algorithm" id="toc-bresenhams-line-algorithm" class="nav-link" data-scroll-target="#bresenhams-line-algorithm">761 Bresenham’s Line Algorithm</a></li>
  <li><a href="#midpoint-circle-algorithm" id="toc-midpoint-circle-algorithm" class="nav-link" data-scroll-target="#midpoint-circle-algorithm">762 Midpoint Circle Algorithm</a></li>
  <li><a href="#scanline-fill" id="toc-scanline-fill" class="nav-link" data-scroll-target="#scanline-fill">763 Scanline Fill</a></li>
  <li><a href="#edge-table-fill" id="toc-edge-table-fill" class="nav-link" data-scroll-target="#edge-table-fill">764 Edge Table Fill</a></li>
  <li><a href="#z-buffer-algorithm" id="toc-z-buffer-algorithm" class="nav-link" data-scroll-target="#z-buffer-algorithm">765 Z-Buffer Algorithm</a></li>
  <li><a href="#painters-algorithm" id="toc-painters-algorithm" class="nav-link" data-scroll-target="#painters-algorithm">766 Painter’s Algorithm</a></li>
  <li><a href="#gouraud-shading" id="toc-gouraud-shading" class="nav-link" data-scroll-target="#gouraud-shading">767 Gouraud Shading</a></li>
  <li><a href="#phong-shading" id="toc-phong-shading" class="nav-link" data-scroll-target="#phong-shading">768 Phong Shading</a></li>
  <li><a href="#anti-aliasing-supersampling" id="toc-anti-aliasing-supersampling" class="nav-link" data-scroll-target="#anti-aliasing-supersampling">769 Anti-Aliasing (Supersampling)</a></li>
  <li><a href="#scanline-polygon-clipping" id="toc-scanline-polygon-clipping" class="nav-link" data-scroll-target="#scanline-polygon-clipping">770 Scanline Polygon Clipping</a></li>
  </ul></li>
  <li><a href="#section-78.-computer-vision" id="toc-section-78.-computer-vision" class="nav-link" data-scroll-target="#section-78.-computer-vision">Section 78. Computer Vision</a>
  <ul class="collapse">
  <li><a href="#canny-edge-detector" id="toc-canny-edge-detector" class="nav-link" data-scroll-target="#canny-edge-detector">771 Canny Edge Detector</a></li>
  <li><a href="#sobel-operator" id="toc-sobel-operator" class="nav-link" data-scroll-target="#sobel-operator">772 Sobel Operator</a></li>
  <li><a href="#hough-transform-lines" id="toc-hough-transform-lines" class="nav-link" data-scroll-target="#hough-transform-lines">773 Hough Transform (Lines)</a></li>
  <li><a href="#hough-transform-circles" id="toc-hough-transform-circles" class="nav-link" data-scroll-target="#hough-transform-circles">774 Hough Transform (Circles)</a></li>
  <li><a href="#harris-corner-detector" id="toc-harris-corner-detector" class="nav-link" data-scroll-target="#harris-corner-detector">775 Harris Corner Detector</a></li>
  <li><a href="#fast-corner-detector" id="toc-fast-corner-detector" class="nav-link" data-scroll-target="#fast-corner-detector">776 FAST Corner Detector</a></li>
  <li><a href="#sift-scale-invariant-feature-transform" id="toc-sift-scale-invariant-feature-transform" class="nav-link" data-scroll-target="#sift-scale-invariant-feature-transform">777 SIFT (Scale-Invariant Feature Transform)</a></li>
  <li><a href="#surf-speeded-up-robust-features" id="toc-surf-speeded-up-robust-features" class="nav-link" data-scroll-target="#surf-speeded-up-robust-features">778 SURF (Speeded-Up Robust Features)</a></li>
  <li><a href="#orb-oriented-fast-and-rotated-brief" id="toc-orb-oriented-fast-and-rotated-brief" class="nav-link" data-scroll-target="#orb-oriented-fast-and-rotated-brief">779 ORB (Oriented FAST and Rotated BRIEF)</a></li>
  <li><a href="#ransac-random-sample-consensus" id="toc-ransac-random-sample-consensus" class="nav-link" data-scroll-target="#ransac-random-sample-consensus">780 RANSAC (Random Sample Consensus)</a></li>
  </ul></li>
  <li><a href="#section-79.-pathfinding-in-space" id="toc-section-79.-pathfinding-in-space" class="nav-link" data-scroll-target="#section-79.-pathfinding-in-space">Section 79. Pathfinding in Space</a>
  <ul class="collapse">
  <li><a href="#a-search" id="toc-a-search" class="nav-link" data-scroll-target="#a-search">781 A* Search</a></li>
  <li><a href="#dijkstra-for-grid" id="toc-dijkstra-for-grid" class="nav-link" data-scroll-target="#dijkstra-for-grid">782 Dijkstra for Grid</a></li>
  <li><a href="#theta-any-angle-pathfinding" id="toc-theta-any-angle-pathfinding" class="nav-link" data-scroll-target="#theta-any-angle-pathfinding">783 Theta* (Any-Angle Pathfinding)</a></li>
  <li><a href="#jump-point-search-grid-acceleration" id="toc-jump-point-search-grid-acceleration" class="nav-link" data-scroll-target="#jump-point-search-grid-acceleration">784 Jump Point Search (Grid Acceleration)</a></li>
  <li><a href="#rapidly-exploring-random-tree-rrt" id="toc-rapidly-exploring-random-tree-rrt" class="nav-link" data-scroll-target="#rapidly-exploring-random-tree-rrt">785 Rapidly-Exploring Random Tree (RRT)</a></li>
  <li><a href="#rapidly-exploring-random-tree-star-rrt" id="toc-rapidly-exploring-random-tree-star-rrt" class="nav-link" data-scroll-target="#rapidly-exploring-random-tree-star-rrt">786 Rapidly-Exploring Random Tree Star (RRT*)</a></li>
  <li><a href="#probabilistic-roadmap-prm" id="toc-probabilistic-roadmap-prm" class="nav-link" data-scroll-target="#probabilistic-roadmap-prm">787 Probabilistic Roadmap (PRM)</a></li>
  <li><a href="#visibility-graph" id="toc-visibility-graph" class="nav-link" data-scroll-target="#visibility-graph">788 Visibility Graph</a></li>
  <li><a href="#potential-field-pathfinding" id="toc-potential-field-pathfinding" class="nav-link" data-scroll-target="#potential-field-pathfinding">789 Potential Field Pathfinding</a></li>
  <li><a href="#bug-algorithms" id="toc-bug-algorithms" class="nav-link" data-scroll-target="#bug-algorithms">790 Bug Algorithms</a></li>
  </ul></li>
  <li><a href="#section-80.-computational-geometry-variants-and-applications" id="toc-section-80.-computational-geometry-variants-and-applications" class="nav-link" data-scroll-target="#section-80.-computational-geometry-variants-and-applications">Section 80. Computational Geometry Variants and Applications</a>
  <ul class="collapse">
  <li><a href="#convex-polygon-intersection" id="toc-convex-polygon-intersection" class="nav-link" data-scroll-target="#convex-polygon-intersection">791 Convex Polygon Intersection</a></li>
  <li><a href="#minkowski-sum-1" id="toc-minkowski-sum-1" class="nav-link" data-scroll-target="#minkowski-sum-1">792 Minkowski Sum</a></li>
  <li><a href="#rotating-calipers-1" id="toc-rotating-calipers-1" class="nav-link" data-scroll-target="#rotating-calipers-1">793 Rotating Calipers</a></li>
  <li><a href="#half-plane-intersection" id="toc-half-plane-intersection" class="nav-link" data-scroll-target="#half-plane-intersection">794 Half-Plane Intersection</a></li>
  <li><a href="#line-arrangement" id="toc-line-arrangement" class="nav-link" data-scroll-target="#line-arrangement">795 Line Arrangement</a></li>
  <li><a href="#point-location-trapezoidal-map" id="toc-point-location-trapezoidal-map" class="nav-link" data-scroll-target="#point-location-trapezoidal-map">796 Point Location (Trapezoidal Map)</a></li>
  <li><a href="#voronoi-nearest-facility" id="toc-voronoi-nearest-facility" class="nav-link" data-scroll-target="#voronoi-nearest-facility">797 Voronoi Nearest Facility</a></li>
  <li><a href="#delaunay-mesh-generation" id="toc-delaunay-mesh-generation" class="nav-link" data-scroll-target="#delaunay-mesh-generation">798 Delaunay Mesh Generation</a></li>
  <li><a href="#smallest-enclosing-circle-welzls-algorithm" id="toc-smallest-enclosing-circle-welzls-algorithm" class="nav-link" data-scroll-target="#smallest-enclosing-circle-welzls-algorithm">799 Smallest Enclosing Circle (Welzl’s Algorithm)</a></li>
  <li><a href="#collision-detection-separating-axis-theorem" id="toc-collision-detection-separating-axis-theorem" class="nav-link" data-scroll-target="#collision-detection-separating-axis-theorem">800 Collision Detection (Separating Axis Theorem)</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Chapter 8. Geometry, Graphics and Spatial Algorithms</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="section-71.-convex-hull" class="level1">
<h1>Section 71. Convex Hull</h1>
<section id="gift-wrapping-jarvis-march" class="level3">
<h3 class="anchored" data-anchor-id="gift-wrapping-jarvis-march">701 Gift Wrapping (Jarvis March)</h3>
<p>Gift Wrapping, or Jarvis March, is one of the simplest and most intuitive algorithms for finding the convex hull of a set of points, the smallest convex polygon that encloses them all. Think of it like wrapping a rubber band around nails on a board.</p>
<p>It “wraps” the hull one point at a time by repeatedly selecting the most counterclockwise point until it returns to the start.</p>
<section id="what-problem-are-we-solving" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving">What Problem Are We Solving?</h4>
<p>Given n points in the plane, we want to compute their convex hull, the polygon formed by connecting the outermost points in order. The convex hull is fundamental in geometry, graphics, and robotics.</p>
<p>Formally, the convex hull H(S) of a set S is the smallest convex set containing S.</p>
<p>We want an algorithm that:</p>
<ul>
<li>Finds all points on the hull.</li>
<li>Orders them along the perimeter.</li>
<li>Works reliably even with collinear points.</li>
</ul>
<p>Jarvis March is conceptually simple and good for small or nearly convex sets.</p>
</section>
<section id="how-does-it-work-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language">How Does It Work (Plain Language)?</h4>
<p>Imagine standing at the leftmost point and walking around the outside, always turning as left as possible (counterclockwise). That ensures we trace the hull boundary.</p>
<p>Algorithm steps:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 3%">
<col style="width: 96%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Start from the leftmost (or lowest) point.</td>
</tr>
<tr class="even">
<td>2</td>
<td>Choose the next point p such that all other points lie to the right of the line (current, p).</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Move to p, add it to the hull.</td>
</tr>
<tr class="even">
<td>4</td>
<td>Repeat until you return to the start.</td>
</tr>
</tbody>
</table>
<p>This mimics “wrapping” around all points, hence Gift Wrapping.</p>
</section>
<section id="example-walkthrough" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough">Example Walkthrough</h4>
<p>Suppose we have 6 points: A(0,0), B(2,1), C(1,2), D(3,3), E(0,3), F(3,0)</p>
<p>Start at A(0,0) (leftmost). From A, the most counterclockwise point is E(0,3). From E, turn leftmost again → D(3,3). From D → F(3,0). From F → back to A.</p>
<p>Hull = [A, E, D, F]</p>
</section>
<section id="tiny-code-easy-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> orientation<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> val <span class="op">=</span> <span class="op">(</span>b<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>c<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">)</span> <span class="op">-</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                 <span class="op">(</span>b<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>c<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>val <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>      <span class="co">// collinear</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>val <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span><span class="op">;</span>    <span class="co">// 1: clockwise, 2: counterclockwise</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> convexHull<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">3</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> hull<span class="op">[</span><span class="dv">100</span><span class="op">],</span> h <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>x <span class="op">&lt;</span> pts<span class="op">[</span>l<span class="op">].</span>x<span class="op">)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> p <span class="op">=</span> l<span class="op">,</span> q<span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        hull<span class="op">[</span>h<span class="op">++]</span> <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> n<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>orientation<span class="op">(</span>pts<span class="op">[</span>p<span class="op">],</span> pts<span class="op">[</span>i<span class="op">],</span> pts<span class="op">[</span>q<span class="op">])</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                q <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> q<span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>p <span class="op">!=</span> l<span class="op">);</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Convex Hull:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> h<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> pts<span class="op">[</span>hull<span class="op">[</span>i<span class="op">]].</span>x<span class="op">,</span> pts<span class="op">[</span>hull<span class="op">[</span>i<span class="op">]].</span>y<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    Point pts<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">0</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">}};</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    convexHull<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orientation(a, b, c):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    val <span class="op">=</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>]) <span class="op">-</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> val <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> val <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">2</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convex_hull(points):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">3</span>: <span class="cf">return</span> []</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> <span class="bu">min</span>(<span class="bu">range</span>(n), key<span class="op">=</span><span class="kw">lambda</span> i: points[i][<span class="dv">0</span>])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    hull <span class="op">=</span> []</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> l</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        hull.append(points[p])</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> (p <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> orientation(points[p], points[i], points[q]) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                q <span class="op">=</span> i</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> q</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p <span class="op">==</span> l: <span class="cf">break</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hull</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">0</span>)]</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Convex Hull:"</span>, convex_hull(pts))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters">Why It Matters</h4>
<ul>
<li>Simple and intuitive: easy to visualize and implement.</li>
<li>Works on any set of points, even non-sorted.</li>
<li>Output-sensitive: time depends on number of hull points <em>h</em>.</li>
<li>Good baseline for comparing more advanced algorithms (Graham, Chan).</li>
</ul>
<p>Applications:</p>
<ul>
<li>Robotics and path planning (boundary detection)</li>
<li>Computer graphics (collision envelopes)</li>
<li>GIS and mapping (territory outline)</li>
<li>Clustering and outlier detection</li>
</ul>
</section>
<section id="try-it-yourself" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself">Try It Yourself</h4>
<ol type="1">
<li>Try with points forming a square, triangle, or concave shape.</li>
<li>Add collinear points, see if they’re included.</li>
<li>Visualize each orientation step (plot arrows).</li>
<li>Count comparisons (to verify O(nh)).</li>
<li>Compare with Graham Scan and Andrew’s Monotone Chain.</li>
</ol>
</section>
<section id="test-cases" class="level4">
<h4 class="anchored" data-anchor-id="test-cases">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 45%">
<col style="width: 28%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Points</th>
<th>Hull Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square (0,0),(0,1),(1,0),(1,1)</td>
<td>All 4 points</td>
<td>Perfect rectangle</td>
</tr>
<tr class="even">
<td>Triangle (0,0),(2,0),(1,1)</td>
<td>3 points</td>
<td>Simple convex</td>
</tr>
<tr class="odd">
<td>Concave shape</td>
<td>Outer boundary only</td>
<td>Concavity ignored</td>
</tr>
<tr class="even">
<td>Random points</td>
<td>Varies</td>
<td>Always convex</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity" class="level4">
<h4 class="anchored" data-anchor-id="complexity">Complexity</h4>
<ul>
<li>Time: O(nh), where <em>h</em> = hull points count</li>
<li>Space: O(h) for output list</li>
</ul>
<p>Gift Wrapping is your first compass in computational geometry, follow the leftmost turns, and the shape of your data reveals itself.</p>
</section>
</section>
<section id="graham-scan" class="level3">
<h3 class="anchored" data-anchor-id="graham-scan">702 Graham Scan</h3>
<p>Graham Scan is a fast, elegant algorithm for finding the convex hull of a set of points. It works by sorting the points by angle around an anchor and then scanning to build the hull while maintaining a stack of turning directions.</p>
<p>Think of it like sorting all your stars around a basepoint, then tracing the outermost ring without stepping back inside.</p>
<section id="what-problem-are-we-solving-1" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-1">What Problem Are We Solving?</h4>
<p>Given n points on a plane, we want to find the convex hull, the smallest convex polygon enclosing all points.</p>
<p>Unlike Gift Wrapping, which walks around points one by one, Graham Scan sorts them first, then efficiently traces the hull in a single pass.</p>
<p>We need:</p>
<ul>
<li>A consistent ordering (polar angle)</li>
<li>A way to test turns (orientation)</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-1" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-1">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Pick the anchor point, the one with the lowest y (and lowest x if tie).</p></li>
<li><p>Sort all points by polar angle with respect to the anchor.</p></li>
<li><p>Scan through sorted points, maintaining a stack of hull vertices.</p></li>
<li><p>For each point, check the last two in the stack:</p>
<ul>
<li>If they make a non-left turn (clockwise), pop the last one.</li>
<li>Keep doing this until it turns left (counterclockwise).</li>
<li>Push the new point.</li>
</ul></li>
<li><p>At the end, the stack holds the convex hull in order.</p></li>
</ol>
</section>
<section id="example-walkthrough-1" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-1">Example Walkthrough</h4>
<p>Points: A(0,0), B(2,1), C(1,2), D(3,3), E(0,3), F(3,0)</p>
<ol type="1">
<li><p>Anchor: A(0,0)</p></li>
<li><p>Sort by polar angle → F(3,0), B(2,1), D(3,3), C(1,2), E(0,3)</p></li>
<li><p>Scan:</p>
<ul>
<li>Start [A, F, B]</li>
<li>Check next D → left turn → push</li>
<li>Next C → right turn → pop D</li>
<li>Push C → check with B, still right turn → pop B</li>
<li>Continue until all are scanned Hull: A(0,0), F(3,0), D(3,3), E(0,3)</li>
</ul></li>
</ol>
</section>
<section id="tiny-code-easy-version-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-1">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>Point anchor<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> orientation<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> val <span class="op">=</span> <span class="op">(</span>b<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>c<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">)</span> <span class="op">-</span> </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                 <span class="op">(</span>b<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>c<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>val <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>val <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> dist<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx <span class="op">=</span> a<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">,</span> dy <span class="op">=</span> a<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dx <span class="op">*</span> dx <span class="op">+</span> dy <span class="op">*</span> dy<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> compare<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>p1<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>p2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    Point a <span class="op">=</span> <span class="op">*(</span>Point <span class="op">*)</span>p1<span class="op">,</span> b <span class="op">=</span> <span class="op">*(</span>Point <span class="op">*)</span>p2<span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> o <span class="op">=</span> orientation<span class="op">(</span>anchor<span class="op">,</span> a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dist<span class="op">(</span>anchor<span class="op">,</span> a<span class="op">)</span> <span class="op">&lt;</span> dist<span class="op">(</span>anchor<span class="op">,</span> b<span class="op">)</span> <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>o <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> grahamScan<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ymin <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>y <span class="op">&lt;</span> pts<span class="op">[</span>ymin<span class="op">].</span>y <span class="op">||</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>           <span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>y <span class="op">==</span> pts<span class="op">[</span>ymin<span class="op">].</span>y <span class="op">&amp;&amp;</span> pts<span class="op">[</span>i<span class="op">].</span>x <span class="op">&lt;</span> pts<span class="op">[</span>ymin<span class="op">].</span>x<span class="op">))</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>            ymin <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    Point temp <span class="op">=</span> pts<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> pts<span class="op">[</span>ymin<span class="op">];</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    pts<span class="op">[</span>ymin<span class="op">]</span> <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    anchor <span class="op">=</span> pts<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>pts <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Point<span class="op">),</span> compare<span class="op">);</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    Point stack<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> pts<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> pts<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> pts<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>orientation<span class="op">(</span>stack<span class="op">[</span>top <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> stack<span class="op">[</span>top<span class="op">],</span> pts<span class="op">[</span>i<span class="op">])</span> <span class="op">!=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>            top<span class="op">--;</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        stack<span class="op">[++</span>top<span class="op">]</span> <span class="op">=</span> pts<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Convex Hull:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> top<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> stack<span class="op">[</span>i<span class="op">].</span>x<span class="op">,</span> stack<span class="op">[</span>i<span class="op">].</span>y<span class="op">);</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>    Point pts<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">0</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">}};</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    grahamScan<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orientation(a, b, c):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    val <span class="op">=</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>]) <span class="op">-</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> val <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> val <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">2</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> graham_scan(points):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    anchor <span class="op">=</span> <span class="bu">min</span>(points, key<span class="op">=</span><span class="kw">lambda</span> p: (p[<span class="dv">1</span>], p[<span class="dv">0</span>]))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    sorted_pts <span class="op">=</span> <span class="bu">sorted</span>(points, key<span class="op">=</span><span class="kw">lambda</span> p: (</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        atan2(p[<span class="dv">1</span>]<span class="op">-</span>anchor[<span class="dv">1</span>], p[<span class="dv">0</span>]<span class="op">-</span>anchor[<span class="dv">0</span>]), (p[<span class="dv">0</span>]<span class="op">-</span>anchor[<span class="dv">0</span>])<span class="dv">2</span> <span class="op">+</span> (p[<span class="dv">1</span>]<span class="op">-</span>anchor[<span class="dv">1</span>])<span class="dv">2</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    hull <span class="op">=</span> []</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> sorted_pts:</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(hull) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> orientation(hull[<span class="op">-</span><span class="dv">2</span>], hull[<span class="op">-</span><span class="dv">1</span>], p) <span class="op">!=</span> <span class="dv">2</span>:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            hull.pop()</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        hull.append(p)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hull</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> atan2</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">0</span>)]</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Convex Hull:"</span>, graham_scan(pts))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-1" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-1">Why It Matters</h4>
<ul>
<li>Efficient: O(n log n) from sorting; scanning is linear.</li>
<li>Robust: Handles collinearity with tie-breaking.</li>
<li>Canonical: Foundational convex hull algorithm in computational geometry.</li>
</ul>
<p>Applications:</p>
<ul>
<li>Graphics: convex outlines, mesh simplification</li>
<li>Collision detection and physics</li>
<li>GIS boundary analysis</li>
<li>Clustering hulls and convex enclosures</li>
</ul>
</section>
<section id="try-it-yourself-1" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-1">Try It Yourself</h4>
<ol type="1">
<li>Plot 10 random points, sort them by angle.</li>
<li>Trace turns manually to see the hull shape.</li>
<li>Add collinear points, test tie-breaking.</li>
<li>Compare with Jarvis March for same data.</li>
<li>Measure performance as n grows.</li>
</ol>
</section>
<section id="test-cases-1" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-1">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Hull</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square corners</td>
<td>All 4</td>
<td>Classic hull</td>
</tr>
<tr class="even">
<td>Triangle + interior point</td>
<td>3 outer points</td>
<td>Interior ignored</td>
</tr>
<tr class="odd">
<td>Collinear points</td>
<td>Endpoints only</td>
<td>Correct</td>
</tr>
<tr class="even">
<td>Random scatter</td>
<td>Outer ring</td>
<td>Verified shape</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-1" class="level4">
<h4 class="anchored" data-anchor-id="complexity-1">Complexity</h4>
<ul>
<li>Time: O(n log n)</li>
<li>Space: O(n) for sorting + stack</li>
</ul>
<p>Graham Scan blends geometry and order, sort the stars, follow the turns, and the hull emerges clean and sharp.</p>
</section>
</section>
<section id="andrews-monotone-chain" class="level3">
<h3 class="anchored" data-anchor-id="andrews-monotone-chain">703 Andrew’s Monotone Chain</h3>
<p>Andrew’s Monotone Chain is a clean, efficient convex hull algorithm that’s both easy to implement and fast in practice. It’s essentially a simplified variant of Graham Scan, but instead of sorting by angle, it sorts by x-coordinate and constructs the hull in two sweeps, one for the lower hull, one for the upper.</p>
<p>Think of it as building a fence twice, once along the bottom, then along the top, and joining them together into a complete boundary.</p>
<section id="what-problem-are-we-solving-2" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-2">What Problem Are We Solving?</h4>
<p>Given n points, find their convex hull, the smallest convex polygon enclosing them.</p>
<p>Andrew’s algorithm provides:</p>
<ul>
<li>Deterministic sorting by x (and y)</li>
<li>A simple loop-based build (no angle math)</li>
<li>An O(n log n) solution, matching Graham Scan</li>
</ul>
<p>It’s widely used for simplicity and numerical stability.</p>
</section>
<section id="how-does-it-work-plain-language-2" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-2">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Sort all points lexicographically by x, then y.</p></li>
<li><p>Build lower hull:</p>
<ul>
<li>Traverse points left to right.</li>
<li>While the last two points + new one make a non-left turn, pop the last.</li>
<li>Push new point.</li>
</ul></li>
<li><p>Build upper hull:</p>
<ul>
<li>Traverse points right to left.</li>
<li>Repeat the same popping rule.</li>
</ul></li>
<li><p>Concatenate lower + upper hulls, excluding duplicate endpoints.</p></li>
</ol>
<p>You end up with the full convex hull in counterclockwise order.</p>
</section>
<section id="example-walkthrough-2" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-2">Example Walkthrough</h4>
<p>Points: A(0,0), B(2,1), C(1,2), D(3,3), E(0,3), F(3,0)</p>
<ol type="1">
<li><p>Sort by x → A(0,0), E(0,3), C(1,2), B(2,1), D(3,3), F(3,0)</p></li>
<li><p>Lower hull</p>
<ul>
<li>Start A(0,0), E(0,3) → right turn → pop E</li>
<li>Add C(1,2), B(2,1), F(3,0) → keep left turns only → Lower hull: [A, B, F]</li>
</ul></li>
<li><p>Upper hull</p>
<ul>
<li>Start F(3,0), D(3,3), E(0,3), A(0,0) → maintain left turns → Upper hull: [F, D, E, A]</li>
</ul></li>
<li><p>Combine (remove duplicates): Hull: [A, B, F, D, E]</p></li>
</ol>
</section>
<section id="tiny-code-easy-version-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-2">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmp<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    Point p <span class="op">=</span> <span class="op">*(</span>Point<span class="op">*)</span>a<span class="op">,</span> q <span class="op">=</span> <span class="op">*(</span>Point<span class="op">*)</span>b<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span>x <span class="op">==</span> q<span class="op">.</span>x<span class="op">)</span> <span class="cf">return</span> <span class="op">(</span>p<span class="op">.</span>y <span class="op">&gt;</span> q<span class="op">.</span>y<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>p<span class="op">.</span>y <span class="op">&lt;</span> q<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>p<span class="op">.</span>x <span class="op">&gt;</span> q<span class="op">.</span>x<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>p<span class="op">.</span>x <span class="op">&lt;</span> q<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> cross<span class="op">(</span>Point o<span class="op">,</span> Point a<span class="op">,</span> Point b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>a<span class="op">.</span>x <span class="op">-</span> o<span class="op">.</span>x<span class="op">)*(</span>b<span class="op">.</span>y <span class="op">-</span> o<span class="op">.</span>y<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>a<span class="op">.</span>y <span class="op">-</span> o<span class="op">.</span>y<span class="op">)*(</span>b<span class="op">.</span>x <span class="op">-</span> o<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> monotoneChain<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>pts<span class="op">,</span> n<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Point<span class="op">),</span> cmp<span class="op">);</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    Point hull<span class="op">[</span><span class="dv">200</span><span class="op">];</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build lower hull</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>k <span class="op">&gt;=</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> cross<span class="op">(</span>hull<span class="op">[</span>k<span class="op">-</span><span class="dv">2</span><span class="op">],</span> hull<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">],</span> pts<span class="op">[</span>i<span class="op">])</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            k<span class="op">--;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        hull<span class="op">[</span>k<span class="op">++]</span> <span class="op">=</span> pts<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build upper hull</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">-</span><span class="dv">2</span><span class="op">,</span> t <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>k <span class="op">&gt;=</span> t <span class="op">&amp;&amp;</span> cross<span class="op">(</span>hull<span class="op">[</span>k<span class="op">-</span><span class="dv">2</span><span class="op">],</span> hull<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">],</span> pts<span class="op">[</span>i<span class="op">])</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            k<span class="op">--;</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        hull<span class="op">[</span>k<span class="op">++]</span> <span class="op">=</span> pts<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    k<span class="op">--;</span> <span class="co">// last point is same as first</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Convex Hull:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> hull<span class="op">[</span>i<span class="op">].</span>x<span class="op">,</span> hull<span class="op">[</span>i<span class="op">].</span>y<span class="op">);</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    Point pts<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">0</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">}};</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    monotoneChain<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross(o, a, b):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])<span class="op">*</span>(b[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>]) <span class="op">-</span> (a[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>])<span class="op">*</span>(b[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> monotone_chain(points):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> <span class="bu">sorted</span>(points)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> []</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(lower) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> cross(lower[<span class="op">-</span><span class="dv">2</span>], lower[<span class="op">-</span><span class="dv">1</span>], p) <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            lower.pop()</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        lower.append(p)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> []</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> <span class="bu">reversed</span>(points):</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(upper) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> cross(upper[<span class="op">-</span><span class="dv">2</span>], upper[<span class="op">-</span><span class="dv">1</span>], p) <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            upper.pop()</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        upper.append(p)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lower[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> upper[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">0</span>)]</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Convex Hull:"</span>, monotone_chain(pts))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-2" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-2">Why It Matters</h4>
<ul>
<li>Simpler than Graham Scan, no polar sorting needed</li>
<li>Stable and robust against collinear points</li>
<li>Commonly used in practice due to clean implementation</li>
<li>Good starting point for 2D computational geometry</li>
</ul>
<p>Applications:</p>
<ul>
<li>2D collision detection</li>
<li>Convex envelopes in graphics</li>
<li>Bounding regions in mapping</li>
<li>Hull preprocessing for advanced geometry (Voronoi, Delaunay)</li>
</ul>
</section>
<section id="try-it-yourself-2" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-2">Try It Yourself</h4>
<ol type="1">
<li>Sort by x and draw points by hand.</li>
<li>Step through both passes (lower, upper).</li>
<li>Visualize popping during non-left turns.</li>
<li>Add collinear points, verify handling.</li>
<li>Compare hulls with Graham Scan and Jarvis March.</li>
</ol>
</section>
<section id="test-cases-2" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-2">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Hull</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square (4 corners)</td>
<td>4 corners</td>
<td>Classic rectangle</td>
</tr>
<tr class="even">
<td>Triangle + center point</td>
<td>Outer 3 only</td>
<td>Center ignored</td>
</tr>
<tr class="odd">
<td>Collinear points</td>
<td>2 endpoints</td>
<td>Handled</td>
</tr>
<tr class="even">
<td>Random scatter</td>
<td>Correct convex ring</td>
<td>Stable</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-2" class="level4">
<h4 class="anchored" data-anchor-id="complexity-2">Complexity</h4>
<ul>
<li>Time: O(n log n) (sorting dominates)</li>
<li>Space: O(n)</li>
</ul>
<p>Andrew’s Monotone Chain is geometry at its cleanest, sort, sweep, stitch, a simple loop carves the perfect boundary.</p>
</section>
</section>
<section id="chans-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="chans-algorithm">704 Chan’s Algorithm</h3>
<p>Chan’s Algorithm is a clever output-sensitive convex hull algorithm, meaning its running time depends not just on the total number of points <em>n</em>, but also on the number of points <em>h</em> that actually form the hull. It smartly combines Graham Scan and Jarvis March to get the best of both worlds.</p>
<p>Think of it like organizing a big crowd by grouping them, tracing each group’s boundary, and then merging those outer lines into one smooth hull.</p>
<section id="what-problem-are-we-solving-3" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-3">What Problem Are We Solving?</h4>
<p>We want to find the convex hull of a set of <em>n</em> points, but we don’t want to pay the full cost of sorting all of them if only a few are on the hull.</p>
<p>Chan’s algorithm solves this with:</p>
<ul>
<li>Subproblem decomposition (divide into chunks)</li>
<li>Fast local hulls (via Graham Scan)</li>
<li>Efficient merging (via wrapping)</li>
</ul>
<p>Result: O(n log h) time, faster when <em>h</em> is small.</p>
</section>
<section id="how-does-it-work-plain-language-3" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-3">How Does It Work (Plain Language)?</h4>
<p>Chan’s algorithm works in three main steps:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 2%">
<col style="width: 97%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Partition points into groups of size <em>m</em>.</td>
</tr>
<tr class="even">
<td>2</td>
<td>For each group, compute local convex hull (using Graham Scan).</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Use Gift Wrapping (Jarvis March) across all hulls to find the global one, but limit the number of hull vertices explored to <em>m</em>.</td>
</tr>
</tbody>
</table>
<p>If it fails (h &gt; m), double m and repeat.</p>
<p>This “guess and check” approach ensures you find the full hull in <em>O(n log h)</em> time.</p>
</section>
<section id="example-walkthrough-3" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-3">Example Walkthrough</h4>
<p>Imagine 30 points, but only 6 form the hull.</p>
<ol type="1">
<li>Choose <em>m = 4</em>, so you have about 8 groups.</li>
<li>Compute hull for each group with Graham Scan (fast).</li>
<li>Combine by wrapping around, at each step, pick the next tangent across all hulls.</li>
<li>If more than <em>m</em> steps are needed, double <em>m</em> → <em>m = 8</em>, repeat.</li>
<li>When all hull vertices are found, stop.</li>
</ol>
<p>Result: Global convex hull with minimal extra work.</p>
</section>
<section id="tiny-code-conceptual-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-conceptual-pseudocode">Tiny Code (Conceptual Pseudocode)</h4>
<p>This algorithm is intricate, but here’s a simple conceptual version:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chans_algorithm(points):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> math</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> <span class="bu">min</span>(<span class="dv">2</span><span class="op">*</span>m, n)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        groups <span class="op">=</span> [points[i:i<span class="op">+</span>m] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n, m)]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: compute local hulls</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        local_hulls <span class="op">=</span> [graham_scan(g) <span class="cf">for</span> g <span class="kw">in</span> groups]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: merge using wrapping</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        hull <span class="op">=</span> []</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> <span class="bu">min</span>(points)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> start</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            hull.append(p)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            q <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> H <span class="kw">in</span> local_hulls:</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                <span class="co"># choose tangent point on each local hull</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>                cand <span class="op">=</span> tangent_from_point(p, H)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> q <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> orientation(p, q, cand) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                    q <span class="op">=</span> cand</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> q</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p <span class="op">==</span> start:</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> hull</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Key idea: combine small hulls efficiently without reprocessing all points each time.</p>
</section>
<section id="why-it-matters-3" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-3">Why It Matters</h4>
<ul>
<li>Output-sensitive: best performance when hull size is small.</li>
<li>Bridges theory and practice, shows how combining algorithms can reduce asymptotic cost.</li>
<li>Demonstrates divide and conquer + wrapping synergy.</li>
<li>Important theoretical foundation for higher-dimensional hulls.</li>
</ul>
<p>Applications:</p>
<ul>
<li>Geometric computing frameworks</li>
<li>Robotics path envelopes</li>
<li>Computational geometry libraries</li>
<li>Performance-critical mapping or collision systems</li>
</ul>
</section>
<section id="try-it-yourself-3" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-3">Try It Yourself</h4>
<ol type="1">
<li>Try with small <em>h</em> (few hull points) and large <em>n</em>, note faster performance.</li>
<li>Compare running time with Graham Scan.</li>
<li>Visualize groups and their local hulls.</li>
<li>Track doubling of <em>m</em> per iteration.</li>
<li>Measure performance growth as hull grows.</li>
</ol>
</section>
<section id="test-cases-3" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-3">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 42%">
<col style="width: 28%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Points</th>
<th>Hull</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6-point convex set</td>
<td>All points</td>
<td>Single iteration</td>
</tr>
<tr class="even">
<td>Dense cluster + few outliers</td>
<td>Outer boundary only</td>
<td>Output-sensitive</td>
</tr>
<tr class="odd">
<td>Random 2D</td>
<td>Correct hull</td>
<td>Matches Graham Scan</td>
</tr>
<tr class="even">
<td>1,000 points, 10 hull</td>
<td>O(n log 10)</td>
<td>Very fast</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-3" class="level4">
<h4 class="anchored" data-anchor-id="complexity-3">Complexity</h4>
<ul>
<li>Time: O(n log h)</li>
<li>Space: O(n)</li>
<li>Best for: Small hull size relative to total points</li>
</ul>
<p>Chan’s Algorithm is geometry’s quiet optimizer, it guesses, tests, and doubles back, wrapping the world one layer at a time.</p>
</section>
</section>
<section id="quickhull" class="level3">
<h3 class="anchored" data-anchor-id="quickhull">705 QuickHull</h3>
<p>QuickHull is a divide-and-conquer algorithm for finding the convex hull, conceptually similar to QuickSort, but in geometry. It recursively splits the set of points into smaller groups, finding extreme points and building the hull piece by piece.</p>
<p>Imagine you’re stretching a rubber band around nails: pick the farthest nails, draw a line, and split the rest into those above and below that line. Repeat until every segment is “tight.”</p>
<section id="what-problem-are-we-solving-4" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-4">What Problem Are We Solving?</h4>
<p>Given n points, we want to construct the convex hull, the smallest convex polygon containing all points.</p>
<p>QuickHull achieves this by:</p>
<ul>
<li>Choosing extreme points as anchors</li>
<li>Partitioning the set into subproblems</li>
<li>Recursively finding farthest points forming hull edges</li>
</ul>
<p>It’s intuitive and often fast on average, though can degrade to <em>O(n²)</em> in worst cases (e.g.&nbsp;all points on the hull).</p>
</section>
<section id="how-does-it-work-plain-language-4" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-4">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Find leftmost and rightmost points (A and B). These form a baseline of the hull.</p></li>
<li><p>Split points into two groups:</p>
<ul>
<li>Above line AB</li>
<li>Below line AB</li>
</ul></li>
<li><p>For each side:</p>
<ul>
<li>Find the point C farthest from AB.</li>
<li>This forms a triangle ABC.</li>
<li>Any points inside triangle ABC are not on the hull.</li>
<li>Recur on the outer subsets (A–C and C–B).</li>
</ul></li>
<li><p>Combine the recursive hulls from both sides.</p></li>
</ol>
<p>Each recursive step adds one vertex, the farthest point, building the hull piece by piece.</p>
</section>
<section id="example-walkthrough-4" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-4">Example Walkthrough</h4>
<p>Points: A(0,0), B(4,0), C(2,3), D(1,1), E(3,1)</p>
<ol type="1">
<li>Leftmost = A(0,0), Rightmost = B(4,0)</li>
<li>Points above AB = {C}, below AB = {}</li>
<li>Farthest from AB (above) = C(2,3) → Hull edge: A–C–B</li>
<li>No points left below AB → done</li>
</ol>
<p>Hull = [A(0,0), C(2,3), B(4,0)]</p>
</section>
<section id="tiny-code-easy-version-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-3">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> cross<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>b<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">)*(</span>c<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>b<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)*(</span>c<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> distance<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fabs<span class="op">(</span>cross<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> c<span class="op">));</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> quickHullRec<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">,</span> Point a<span class="op">,</span> Point b<span class="op">,</span> <span class="dt">int</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> idx <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> maxDist <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> val <span class="op">=</span> cross<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> pts<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>side <span class="op">*</span> val<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> fabs<span class="op">(</span>val<span class="op">)</span> <span class="op">&gt;</span> maxDist<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            maxDist <span class="op">=</span> fabs<span class="op">(</span>val<span class="op">);</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>idx <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> a<span class="op">.</span>x<span class="op">,</span> a<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> b<span class="op">.</span>x<span class="op">,</span> b<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    quickHullRec<span class="op">(</span>pts<span class="op">,</span> n<span class="op">,</span> a<span class="op">,</span> pts<span class="op">[</span>idx<span class="op">],</span> <span class="op">-</span>cross<span class="op">(</span>a<span class="op">,</span> pts<span class="op">[</span>idx<span class="op">],</span> b<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    quickHullRec<span class="op">(</span>pts<span class="op">,</span> n<span class="op">,</span> pts<span class="op">[</span>idx<span class="op">],</span> b<span class="op">,</span> <span class="op">-</span>cross<span class="op">(</span>pts<span class="op">[</span>idx<span class="op">],</span> b<span class="op">,</span> a<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> quickHull<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> min <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> max <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>x <span class="op">&lt;</span> pts<span class="op">[</span>min<span class="op">].</span>x<span class="op">)</span> min <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>x <span class="op">&gt;</span> pts<span class="op">[</span>max<span class="op">].</span>x<span class="op">)</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>    Point A <span class="op">=</span> pts<span class="op">[</span>min<span class="op">],</span> B <span class="op">=</span> pts<span class="op">[</span>max<span class="op">];</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>    quickHullRec<span class="op">(</span>pts<span class="op">,</span> n<span class="op">,</span> A<span class="op">,</span> B<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>    quickHullRec<span class="op">(</span>pts<span class="op">,</span> n<span class="op">,</span> A<span class="op">,</span> B<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>    Point pts<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">4</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">1</span><span class="op">}};</span></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Convex Hull:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>    quickHull<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross(a, b, c):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(a, b, c):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">abs</span>(cross(a, b, c))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quickhull_rec(points, a, b, side):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    idx, max_dist <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>(points):</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> cross(a, b, p)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> side <span class="op">*</span> val <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="bu">abs</span>(val) <span class="op">&gt;</span> max_dist:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            idx, max_dist <span class="op">=</span> i, <span class="bu">abs</span>(val)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> idx <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [a, b]</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> points[idx]</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (quickhull_rec(points, a, c, <span class="op">-</span><span class="dv">1</span> <span class="cf">if</span> cross(a, c, b) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span>) <span class="op">+</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            quickhull_rec(points, c, b, <span class="op">-</span><span class="dv">1</span> <span class="cf">if</span> cross(c, b, a) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span>))</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quickhull(points):</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> <span class="bu">sorted</span>(points)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> points[<span class="dv">0</span>], points[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>({<span class="op">*</span>quickhull_rec(points, a, b, <span class="dv">1</span>), <span class="op">*</span>quickhull_rec(points, a, b, <span class="op">-</span><span class="dv">1</span>)})</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">3</span>,<span class="dv">1</span>)]</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Convex Hull:"</span>, quickhull(pts))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-4" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-4">Why It Matters</h4>
<ul>
<li>Elegant and recursive, conceptually simple.</li>
<li>Good average-case performance for random points.</li>
<li>Divide-and-conquer design teaches geometric recursion.</li>
<li>Intuitive visualization for teaching convex hulls.</li>
</ul>
<p>Applications:</p>
<ul>
<li>Geometric modeling</li>
<li>Game development (collision envelopes)</li>
<li>Path planning and mesh simplification</li>
<li>Visualization tools for spatial datasets</li>
</ul>
</section>
<section id="try-it-yourself-4" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-4">Try It Yourself</h4>
<ol type="1">
<li>Plot random points and walk through recursive splits.</li>
<li>Add collinear points and see how they’re handled.</li>
<li>Compare step count to Graham Scan.</li>
<li>Time on sparse vs dense hulls.</li>
<li>Trace recursive tree visually, each node is a hull edge.</li>
</ol>
</section>
<section id="test-cases-4" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-4">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Hull</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>3 points</td>
<td>Simple hull</td>
</tr>
<tr class="even">
<td>Square corners + center</td>
<td>4 corners</td>
<td>Center ignored</td>
</tr>
<tr class="odd">
<td>Random scatter</td>
<td>Outer ring</td>
<td>Matches others</td>
</tr>
<tr class="even">
<td>All collinear</td>
<td>Endpoints only</td>
<td>Handles degenerate case</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-4" class="level4">
<h4 class="anchored" data-anchor-id="complexity-4">Complexity</h4>
<ul>
<li>Average: O(n log n)</li>
<li>Worst: O(n²)</li>
<li>Space: O(n) (recursion stack)</li>
</ul>
<p>QuickHull is the geometric sibling of QuickSort, split, recurse, and join the pieces into a clean convex boundary.</p>
</section>
</section>
<section id="incremental-convex-hull" class="level3">
<h3 class="anchored" data-anchor-id="incremental-convex-hull">706 Incremental Convex Hull</h3>
<p>The Incremental Convex Hull algorithm builds the hull step by step, starting from a small convex set (like a triangle) and inserting points one at a time, updating the hull dynamically as each point is added.</p>
<p>It’s like growing a soap bubble around points: each new point either floats inside (ignored) or pushes out the bubble wall (updates the hull).</p>
<section id="what-problem-are-we-solving-5" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-5">What Problem Are We Solving?</h4>
<p>Given n points, we want to construct their convex hull.</p>
<p>Instead of sorting or splitting (as in Graham or QuickHull), the incremental method:</p>
<ul>
<li>Builds an initial hull from a few points</li>
<li>Adds each remaining point</li>
<li>Updates the hull edges when new points extend the boundary</li>
</ul>
<p>This pattern generalizes nicely to higher dimensions, making it foundational for 3D hulls and computational geometry libraries.</p>
</section>
<section id="how-does-it-work-plain-language-5" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-5">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Start with a small hull (e.g.&nbsp;first 3 non-collinear points).</p></li>
<li><p>For each new point P:</p>
<ul>
<li><p>Check if P is inside the current hull.</p></li>
<li><p>If not:</p>
<ul>
<li>Find all visible edges (edges facing P).</li>
<li>Remove those edges from the hull.</li>
<li>Connect P to the boundary of the visible region.</li>
</ul></li>
</ul></li>
<li><p>Continue until all points are processed.</p></li>
</ol>
<p>The hull grows incrementally, always staying convex.</p>
</section>
<section id="example-walkthrough-5" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-5">Example Walkthrough</h4>
<p>Points: A(0,0), B(4,0), C(2,3), D(1,1), E(3,2)</p>
<ol type="1">
<li>Start hull with {A, B, C}.</li>
<li>Add D(1,1): lies inside hull → ignore.</li>
<li>Add E(3,2): lies on boundary or inside → ignore.</li>
</ol>
<p>Hull remains [A, B, C].</p>
<p>If you added F(5,1):</p>
<ul>
<li>F lies outside, so update hull to include it → [A, B, F, C]</li>
</ul>
</section>
<section id="tiny-code-easy-version-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-4">Tiny Code (Easy Version)</h4>
<p>C (Conceptual)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> cross<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>b<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">)*(</span>c<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>b<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)*(</span>c<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Simplified incremental hull for 2D (no edge pruning)</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> incrementalHull<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Start with first 3 points forming a triangle</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    Point hull<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> h <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span> hull<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> pts<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        Point p <span class="op">=</span> pts<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> visible<span class="op">[</span><span class="dv">100</span><span class="op">],</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Mark edges visible from p</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> h<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            Point a <span class="op">=</span> hull<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>            Point b <span class="op">=</span> hull<span class="op">[(</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)%</span>h<span class="op">];</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>cross<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> p<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> visible<span class="op">[</span>count<span class="op">++]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If none visible, point is inside</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>count <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Remove visible edges and insert new connections (simplified)</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Here: we just print added point for demo</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Adding point (</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">) to hull</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> p<span class="op">.</span>x<span class="op">,</span> p<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Final hull (approx):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> h<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> hull<span class="op">[</span>i<span class="op">].</span>x<span class="op">,</span> hull<span class="op">[</span>i<span class="op">].</span>y<span class="op">);</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>    Point pts<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">4</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">2</span><span class="op">},{</span><span class="dv">5</span><span class="op">,</span><span class="dv">1</span><span class="op">}};</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    incrementalHull<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simplified)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross(a, b, c):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_inside(hull, p):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(hull)):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> hull[i], hull[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(hull)]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cross(a, b, p) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> incremental_hull(points):</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    hull <span class="op">=</span> points[:<span class="dv">3</span>]</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points[<span class="dv">3</span>:]:</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_inside(hull, p):</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            hull.append(p)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            <span class="co"># In practice, re-sort hull in CCW order</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            hull <span class="op">=</span> <span class="bu">sorted</span>(hull, key<span class="op">=</span><span class="kw">lambda</span> q: (q[<span class="dv">0</span>], q[<span class="dv">1</span>]))</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hull</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">3</span>,<span class="dv">2</span>),(<span class="dv">5</span>,<span class="dv">1</span>)]</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Convex Hull:"</span>, incremental_hull(pts))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-5" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-5">Why It Matters</h4>
<ul>
<li>Conceptually simple, easy to extend to 3D and higher.</li>
<li>Online: can update hull dynamically as points stream in.</li>
<li>Used in real-time simulations, collision detection, and geometry libraries.</li>
<li>Foundation for dynamic hull maintenance (next section).</li>
</ul>
<p>Applications:</p>
<ul>
<li>Incremental geometry algorithms</li>
<li>Data streams and real-time convexity checks</li>
<li>Building Delaunay or Voronoi structures incrementally</li>
</ul>
</section>
<section id="try-it-yourself-5" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-5">Try It Yourself</h4>
<ol type="1">
<li>Add points one by one, draw hull at each step.</li>
<li>Observe how interior points don’t change the hull.</li>
<li>Try random insertion orders, hull stays consistent.</li>
<li>Compare with Graham Scan’s static approach.</li>
<li>Extend to 3D using visible-face detection.</li>
</ol>
</section>
<section id="test-cases-5" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-5">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Hull</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle + inside points</td>
<td>Outer 3</td>
<td>Inside ignored</td>
</tr>
<tr class="even">
<td>Square + center point</td>
<td>Corners only</td>
<td>Works</td>
</tr>
<tr class="odd">
<td>Random points</td>
<td>Outer ring</td>
<td>Verified</td>
</tr>
<tr class="even">
<td>Incremental additions</td>
<td>Correct updates</td>
<td>Dynamic hull</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-5" class="level4">
<h4 class="anchored" data-anchor-id="complexity-5">Complexity</h4>
<ul>
<li>Time: O(n²) naive, O(n log n) with optimization</li>
<li>Space: O(h)</li>
</ul>
<p>The incremental method teaches geometry’s patience, one point at a time, reshaping the boundary as the world grows.</p>
</section>
</section>
<section id="divide-conquer-hull" class="level3">
<h3 class="anchored" data-anchor-id="divide-conquer-hull">707 Divide &amp; Conquer Hull</h3>
<p>The Divide &amp; Conquer Hull algorithm builds the convex hull by splitting the set of points into halves, recursively computing hulls for each half, and then merging them, much like Merge Sort, but for geometry.</p>
<p>Imagine cutting your set of points into two clouds, wrapping each cloud separately, then stitching the two wraps into one smooth boundary.</p>
<section id="what-problem-are-we-solving-6" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-6">What Problem Are We Solving?</h4>
<p>Given n points on a plane, we want to construct their convex hull.</p>
<p>The divide and conquer approach provides:</p>
<ul>
<li>A clean O(n log n) runtime</li>
<li>Elegant structure (recursion + merge)</li>
<li>Strong foundation for higher-dimensional hulls</li>
</ul>
<p>It’s a canonical example of applying divide and conquer to geometric data.</p>
</section>
<section id="how-does-it-work-plain-language-6" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-6">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Sort all points by x-coordinate.</p></li>
<li><p>Divide the points into two halves.</p></li>
<li><p>Recursively compute the convex hull for each half.</p></li>
<li><p>Merge the two hulls:</p>
<ul>
<li>Find upper tangent: the line touching both hulls from above</li>
<li>Find lower tangent: the line touching both from below</li>
<li>Remove interior points between tangents</li>
<li>Join remaining points to form the merged hull</li>
</ul></li>
</ol>
<p>This process repeats until all points are enclosed in one convex boundary.</p>
</section>
<section id="example-walkthrough-6" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-6">Example Walkthrough</h4>
<p>Points: A(0,0), B(4,0), C(2,3), D(1,1), E(3,2)</p>
<ol type="1">
<li><p>Sort by x: [A, D, C, E, B]</p></li>
<li><p>Divide: Left = [A, D, C], Right = [E, B]</p></li>
<li><p>Hull(Left) = [A, C] Hull(Right) = [E, B]</p></li>
<li><p>Merge:</p>
<ul>
<li>Find upper tangent → connects C and E</li>
<li>Find lower tangent → connects A and B Hull = [A, B, E, C]</li>
</ul></li>
</ol>
</section>
<section id="tiny-code-conceptual-pseudocode-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-conceptual-pseudocode-1">Tiny Code (Conceptual Pseudocode)</h4>
<p>To illustrate the logic (omitting low-level tangent-finding details):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> divide_conquer_hull(points):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">3</span>:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Base: simple convex polygon</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sorted</span>(points)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> divide_conquer_hull(points[:mid])</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> divide_conquer_hull(points[mid:])</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge_hulls(left, right)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_hulls(left, right):</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find upper and lower tangents</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> find_upper_tangent(left, right)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> find_lower_tangent(left, right)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine points between tangents</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    hull <span class="op">=</span> []</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> left.index(upper[<span class="dv">0</span>])</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left[i] <span class="op">!=</span> lower[<span class="dv">0</span>]:</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        hull.append(left[i])</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(left)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    hull.append(lower[<span class="dv">0</span>])</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> right.index(lower[<span class="dv">1</span>])</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> right[j] <span class="op">!=</span> upper[<span class="dv">1</span>]:</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        hull.append(right[j])</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> (j <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(right)</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    hull.append(upper[<span class="dv">1</span>])</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hull</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In practice, tangent-finding uses orientation tests and cyclic traversal.</p>
</section>
<section id="why-it-matters-6" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-6">Why It Matters</h4>
<ul>
<li>Elegant recursion: geometry meets algorithm design.</li>
<li>Balanced performance: deterministic O(n log n).</li>
<li>Ideal for batch processing or parallel implementations.</li>
<li>Extends well to 3D convex hulls (divide in planes).</li>
</ul>
<p>Applications:</p>
<ul>
<li>Computational geometry toolkits</li>
<li>Spatial analysis and map merging</li>
<li>Parallel geometry processing</li>
<li>Geometry-based clustering</li>
</ul>
</section>
<section id="try-it-yourself-6" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-6">Try It Yourself</h4>
<ol type="1">
<li>Draw 10 points, split by x-midpoint.</li>
<li>Build hulls for left and right manually.</li>
<li>Find upper/lower tangents and merge.</li>
<li>Compare result to Graham Scan.</li>
<li>Trace recursion tree (like merge sort).</li>
</ol>
</section>
<section id="test-cases-6" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-6">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Hull</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>3 points</td>
<td>Simple base case</td>
</tr>
<tr class="even">
<td>Square</td>
<td>All corners</td>
<td>Perfect merge</td>
</tr>
<tr class="odd">
<td>Random scatter</td>
<td>Outer boundary</td>
<td>Verified</td>
</tr>
<tr class="even">
<td>Collinear points</td>
<td>Endpoints only</td>
<td>Correct</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-6" class="level4">
<h4 class="anchored" data-anchor-id="complexity-6">Complexity</h4>
<ul>
<li>Time: O(n log n)</li>
<li>Space: O(n)</li>
<li>Best Case: Balanced splits → efficient merges</li>
</ul>
<p>Divide &amp; Conquer Hull is geometric harmony, each half finds its shape, and together they trace the perfect outline of all points.</p>
</section>
</section>
<section id="d-convex-hull" class="level3">
<h3 class="anchored" data-anchor-id="d-convex-hull">708 3D Convex Hull</h3>
<p>The 3D Convex Hull is the natural extension of the planar hull into space. Instead of connecting points into a polygon, you connect them into a polyhedron, a 3D envelope enclosing all given points.</p>
<p>Think of it as wrapping a shrink film around scattered pebbles in 3D space, it tightens into a surface formed by triangular faces.</p>
<section id="what-problem-are-we-solving-7" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-7">What Problem Are We Solving?</h4>
<p>Given n points in 3D, find the convex polyhedron (set of triangular faces) that completely encloses them.</p>
<p>We want to compute:</p>
<ul>
<li>Vertices (points on the hull)</li>
<li>Edges (lines between them)</li>
<li>Faces (planar facets forming the surface)</li>
</ul>
<p>The goal: A minimal set of faces such that every point lies inside or on the hull.</p>
</section>
<section id="how-does-it-work-plain-language-7" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-7">How Does It Work (Plain Language)?</h4>
<p>Several algorithms extend from 2D to 3D, but one classic approach is the Incremental 3D Hull:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 95%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Start with a non-degenerate tetrahedron (4 points not on the same plane).</td>
</tr>
<tr class="even">
<td>2</td>
<td>For each remaining point P:</td>
</tr>
<tr class="odd">
<td></td>
<td>– Identify visible faces (faces where P is outside).</td>
</tr>
<tr class="even">
<td></td>
<td>– Remove those faces (forming a “hole”).</td>
</tr>
<tr class="odd">
<td></td>
<td>– Create new faces connecting P to the boundary of the hole.</td>
</tr>
<tr class="even">
<td>3</td>
<td>Continue until all points are processed.</td>
</tr>
<tr class="odd">
<td>4</td>
<td>The remaining faces define the 3D convex hull.</td>
</tr>
</tbody>
</table>
<p>Each insertion either adds new faces or lies inside and is ignored.</p>
</section>
<section id="example-walkthrough-7" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-7">Example Walkthrough</h4>
<p>Points: A(0,0,0), B(1,0,0), C(0,1,0), D(0,0,1), E(1,1,1)</p>
<ol type="1">
<li><p>Start with base tetrahedron: A, B, C, D</p></li>
<li><p>Add E(1,1,1):</p>
<ul>
<li>Find faces visible from E</li>
<li>Remove them</li>
<li>Connect E to boundary edges of the visible region</li>
</ul></li>
<li><p>New hull has 5 vertices, forming a convex polyhedron.</p></li>
</ol>
</section>
<section id="tiny-code-conceptual-pseudocode-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-conceptual-pseudocode-2">Tiny Code (Conceptual Pseudocode)</h4>
<p>A high-level idea, practical versions use complex data structures (face adjacency, conflict graph):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> incremental_3d_hull(points):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    hull <span class="op">=</span> initialize_tetrahedron(points)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> point_inside_hull(hull, p):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        visible_faces <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> hull <span class="cf">if</span> face_visible(f, p)]</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        hole_edges <span class="op">=</span> find_boundary_edges(visible_faces)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        hull <span class="op">=</span> [f <span class="cf">for</span> f <span class="kw">in</span> hull <span class="cf">if</span> f <span class="kw">not</span> <span class="kw">in</span> visible_faces]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> e <span class="kw">in</span> hole_edges:</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>            hull.append(make_face(e, p))</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hull</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each face is represented by a triple of points (a, b, c), with orientation tests via determinants or triple products.</p>
</section>
<section id="why-it-matters-7" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-7">Why It Matters</h4>
<ul>
<li><p>Foundation for 3D geometry, meshes, solids, and physics.</p></li>
<li><p>Used in computational geometry, graphics, CAD, physics engines.</p></li>
<li><p>Forms building blocks for:</p>
<ul>
<li>Delaunay Triangulation (3D)</li>
<li>Voronoi Diagrams (3D)</li>
<li>Convex decomposition and collision detection</li>
</ul></li>
</ul>
<p>Applications:</p>
<ul>
<li>3D modeling and rendering</li>
<li>Convex decomposition (physics engines)</li>
<li>Spatial analysis, convex enclosures</li>
<li>Game geometry, mesh simplification</li>
</ul>
</section>
<section id="try-it-yourself-7" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-7">Try It Yourself</h4>
<ol type="1">
<li>Start with 4 non-coplanar points, visualize the tetrahedron.</li>
<li>Add one point outside and sketch new faces.</li>
<li>Add a point inside, confirm no hull change.</li>
<li>Compare 3D hulls for cube corners, random points, sphere samples.</li>
<li>Use a geometry viewer to visualize updates step-by-step.</li>
</ol>
</section>
<section id="test-cases-7" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-7">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Hull Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4 non-coplanar</td>
<td>Tetrahedron</td>
<td>Base case</td>
</tr>
<tr class="even">
<td>Cube corners</td>
<td>8 vertices</td>
<td>Classic box hull</td>
</tr>
<tr class="odd">
<td>Random points on sphere</td>
<td>All points</td>
<td>Convex set</td>
</tr>
<tr class="even">
<td>Random interior points</td>
<td>Only outer</td>
<td>Inner ignored</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-7" class="level4">
<h4 class="anchored" data-anchor-id="complexity-7">Complexity</h4>
<ul>
<li>Time: O(n log n) average, O(n²) worst-case</li>
<li>Space: O(n)</li>
</ul>
<p>The 3D Convex Hull lifts geometry into space, from wrapping a string to wrapping a surface, it turns scattered points into shape.</p>
</section>
</section>
<section id="dynamic-convex-hull" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-convex-hull">709 Dynamic Convex Hull</h3>
<p>A Dynamic Convex Hull is a data structure (and algorithm family) that maintains the convex hull as points are inserted (and sometimes deleted), without recomputing the entire hull from scratch.</p>
<p>Think of it like a living rubber band that flexes and tightens as you add or remove pegs, always adjusting itself to stay convex.</p>
<section id="what-problem-are-we-solving-8" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-8">What Problem Are We Solving?</h4>
<p>Given a sequence of updates (insertions or deletions of points), we want to maintain the current convex hull efficiently, so that:</p>
<ul>
<li>Insert(point) adjusts the hull in sublinear time.</li>
<li>Query() returns the hull or answers questions (area, diameter, point location).</li>
<li>Delete(point) (optional) removes a point and repairs the hull.</li>
</ul>
<p>A dynamic hull is crucial when data evolves, streaming points, moving agents, or incremental datasets.</p>
</section>
<section id="how-does-it-work-plain-language-8" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-8">How Does It Work (Plain Language)?</h4>
<p>Several strategies exist depending on whether we need full dynamism (inserts + deletes) or semi-dynamic (inserts only):</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 44%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Variant</th>
<th>Idea</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Semi-Dynamic</td>
<td>Only insertions, maintain hull incrementally</td>
<td>O(log n) amortized per insert</td>
</tr>
<tr class="even">
<td>Fully Dynamic</td>
<td>Both insertions and deletions</td>
<td>O(log² n) per update</td>
</tr>
<tr class="odd">
<td>Online Hull (1D / 2D)</td>
<td>Maintain upper &amp; lower chains separately</td>
<td>Logarithmic updates</td>
</tr>
</tbody>
</table>
<p>Common structure:</p>
<ol type="1">
<li><p>Split hull into upper and lower chains.</p></li>
<li><p>Store each chain in a balanced BST or ordered set.</p></li>
<li><p>On insert:</p>
<ul>
<li>Locate insertion position by x-coordinate.</li>
<li>Check for turn direction (orientation tests).</li>
<li>Remove interior points (not convex) and add new vertex.</li>
</ul></li>
<li><p>On delete:</p>
<ul>
<li>Remove vertex, re-link neighbors, recheck convexity.</li>
</ul></li>
</ol>
</section>
<section id="example-walkthrough-semi-dynamic" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-semi-dynamic">Example Walkthrough (Semi-Dynamic)</h4>
<p>Start with empty hull. Insert points one by one:</p>
<ol type="1">
<li><p>Add A(0,0) → hull = [A]</p></li>
<li><p>Add B(2,0) → hull = [A, B]</p></li>
<li><p>Add C(1,2) → hull = [A, B, C]</p></li>
<li><p>Add D(3,1):</p>
<ul>
<li>Upper hull = [A, C, D]</li>
<li>Lower hull = [A, B, D] Hull updates dynamically without recomputing all points.</li>
</ul></li>
</ol>
<p>If D lies inside, skip it. If D extends hull, remove covered edges and reinsert.</p>
</section>
<section id="tiny-code-python-sketch" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch">Tiny Code (Python Sketch)</h4>
<p>A simple incremental hull using sorted chains:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross(o, a, b):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])<span class="op">*</span>(b[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>]) <span class="op">-</span> (a[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>])<span class="op">*</span>(b[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DynamicHull:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.upper <span class="op">=</span> []</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lower <span class="op">=</span> []</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, p):</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._insert_chain(<span class="va">self</span>.upper, p, <span class="dv">1</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._insert_chain(<span class="va">self</span>.lower, p, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _insert_chain(<span class="va">self</span>, chain, p, sign):</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        chain.append(p)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        chain.sort()  <span class="co"># maintain order by x</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(chain) <span class="op">&gt;=</span> <span class="dv">3</span> <span class="kw">and</span> sign <span class="op">*</span> cross(chain[<span class="op">-</span><span class="dv">3</span>], chain[<span class="op">-</span><span class="dv">2</span>], chain[<span class="op">-</span><span class="dv">1</span>]) <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">del</span> chain[<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_hull(<span class="va">self</span>):</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.lower[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="va">self</span>.upper[::<span class="op">-</span><span class="dv">1</span>][:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>dh <span class="op">=</span> DynamicHull()</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">1</span>)]:</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    dh.insert(p)</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Hull:"</span>, dh.get_hull())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-8" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-8">Why It Matters</h4>
<ul>
<li>Real-time geometry: used in moving point sets, games, robotics.</li>
<li>Streaming analytics: convex envelopes of live data.</li>
<li>Incremental algorithms: maintain convexity without full rebuild.</li>
<li>Data structures research: connects geometry to balanced trees.</li>
</ul>
<p>Applications:</p>
<ul>
<li>Collision detection (objects moving step-by-step)</li>
<li>Real-time visualization</li>
<li>Geometric median or bounding region updates</li>
<li>Computational geometry libraries (CGAL, Boost.Geometry)</li>
</ul>
</section>
<section id="try-it-yourself-8" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-8">Try It Yourself</h4>
<ol type="1">
<li>Insert points one by one, sketch hull after each.</li>
<li>Try inserting an interior point (no hull change).</li>
<li>Insert a point outside, watch edges removed and added.</li>
<li>Extend code to handle deletions.</li>
<li>Compare with Incremental Hull (static order).</li>
</ol>
</section>
<section id="test-cases-8" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-8">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert outer points</td>
<td>Expanding hull</td>
<td>Expected growth</td>
</tr>
<tr class="even">
<td>Insert interior point</td>
<td>No change</td>
<td>Stable</td>
</tr>
<tr class="odd">
<td>Insert collinear</td>
<td>Adds endpoint</td>
<td>Interior ignored</td>
</tr>
<tr class="even">
<td>Delete hull vertex</td>
<td>Reconnect boundary</td>
<td>Fully dynamic variant</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-8" class="level4">
<h4 class="anchored" data-anchor-id="complexity-8">Complexity</h4>
<ul>
<li>Semi-Dynamic (insert-only): O(log n) amortized per insert</li>
<li>Fully Dynamic: O(log² n) per update</li>
<li>Query (return hull): O(h)</li>
</ul>
<p>The dynamic convex hull is a shape that grows with time, a memory of extremes, always ready for the next point to bend its boundary.</p>
</section>
</section>
<section id="rotating-calipers" class="level3">
<h3 class="anchored" data-anchor-id="rotating-calipers">710 Rotating Calipers</h3>
<p>The Rotating Calipers technique is a geometric powerhouse, a way to systematically explore pairs of points, edges, or directions on a convex polygon by “rotating” a set of imaginary calipers around its boundary.</p>
<p>It’s like placing a pair of measuring arms around the convex hull, rotating them in sync, and recording distances, widths, or diameters at every step.</p>
<section id="what-problem-are-we-solving-9" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-9">What Problem Are We Solving?</h4>
<p>Once you have a convex hull, many geometric quantities can be computed efficiently using rotating calipers:</p>
<ul>
<li>Farthest pair (diameter)</li>
<li>Minimum width / bounding box</li>
<li>Closest pair of parallel edges</li>
<li>Antipodal point pairs</li>
<li>Polygon area and width in given direction</li>
</ul>
<p>It transforms geometric scanning into an O(n) walk, no nested loops needed.</p>
</section>
<section id="how-does-it-work-plain-language-9" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-9">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Start with a convex polygon (points ordered CCW).</p></li>
<li><p>Imagine a caliper, a line touching one vertex, with another parallel line touching the opposite edge.</p></li>
<li><p>Rotate these calipers around the hull:</p>
<ul>
<li>At each step, advance the side whose next edge causes the smaller rotation.</li>
<li>Measure whatever quantity you need (distance, area, width).</li>
</ul></li>
<li><p>Stop when calipers make a full rotation.</p></li>
</ol>
<p>Every “event” (vertex alignment) corresponds to an antipodal pair, useful for finding extremal distances.</p>
</section>
<section id="example-walkthrough-farthest-pair-diameter" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-farthest-pair-diameter">Example Walkthrough: Farthest Pair (Diameter)</h4>
<p>Hull: A(0,0), B(4,0), C(4,3), D(0,3)</p>
<ol type="1">
<li>Start with edge AB and find point farthest from AB (D).</li>
<li>Rotate calipers to next edge (BC), advance opposite point as needed.</li>
<li>Continue rotating until full sweep.</li>
<li>Track max distance found → here: between A(0,0) and C(4,3)</li>
</ol>
<p>Result: Diameter = 5</p>
</section>
<section id="tiny-code-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python">Tiny Code (Python)</h4>
<p>Farthest pair (diameter) using rotating calipers on a convex hull:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> dist</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rotating_calipers(hull):</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(hull)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (hull[<span class="dv">0</span>], hull[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (hull[<span class="dv">0</span>], hull[<span class="dv">1</span>], dist(hull[<span class="dv">0</span>], hull[<span class="dv">1</span>]))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> area2(a, b, c):</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">abs</span>((b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>]))</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    max_d <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    best_pair <span class="op">=</span> (hull[<span class="dv">0</span>], hull[<span class="dv">0</span>])</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        ni <span class="op">=</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> area2(hull[i], hull[ni], hull[(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n]) <span class="op">&gt;</span> area2(hull[i], hull[ni], hull[j]):</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> (j <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> dist(hull[i], hull[j])</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&gt;</span> max_d:</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>            max_d <span class="op">=</span> d</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>            best_pair <span class="op">=</span> (hull[i], hull[j])</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_pair <span class="op">+</span> (max_d,)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Example hull (square)</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>hull <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">3</span>)]</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>a, b, d <span class="op">=</span> rotating_calipers(hull)</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Farthest pair: </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">, distance=</span><span class="sc">{</span>d<span class="sc">:.2f}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-9" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-9">Why It Matters</h4>
<ul>
<li>Elegant O(n) solutions for many geometric problems</li>
<li>Turns geometric search into synchronized sweeps</li>
<li>Used widely in computational geometry, graphics, and robotics</li>
<li>Core step in bounding box, minimum width, and collision algorithms</li>
</ul>
<p>Applications:</p>
<ul>
<li>Shape analysis (diameter, width, bounding box)</li>
<li>Collision detection (support functions in physics engines)</li>
<li>Robotics (clearance computation)</li>
<li>GIS and mapping (directional hull properties)</li>
</ul>
</section>
<section id="try-it-yourself-9" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-9">Try It Yourself</h4>
<ol type="1">
<li>Draw a convex polygon.</li>
<li>Place a pair of parallel lines tangent to two opposite edges.</li>
<li>Rotate them and record farthest point pairs.</li>
<li>Compare with brute force O(n²) distance check.</li>
<li>Extend to compute minimum-area bounding box.</li>
</ol>
</section>
<section id="test-cases-9" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-9">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Hull</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square 4×3</td>
<td>A(0,0)-C(4,3)</td>
<td>Diagonal = 5</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td>Longest edge</td>
<td>Works</td>
</tr>
<tr class="odd">
<td>Regular hexagon</td>
<td>Opposite vertices</td>
<td>Symmetric</td>
</tr>
<tr class="even">
<td>Irregular polygon</td>
<td>Antipodal max pair</td>
<td>Verified</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-9" class="level4">
<h4 class="anchored" data-anchor-id="complexity-9">Complexity</h4>
<ul>
<li>Time: O(n) (linear scan around hull)</li>
<li>Space: O(1)</li>
</ul>
<p>Rotating Calipers is geometry’s precision instrument, smooth, synchronized, and exact, it measures the world by turning gently around its edges.</p>
</section>
</section>
</section>
<section id="section-72.-closest-pair-and-segment-algorithms" class="level1">
<h1>Section 72. Closest Pair and Segment Algorithms</h1>
<section id="closest-pair-divide-conquer" class="level3">
<h3 class="anchored" data-anchor-id="closest-pair-divide-conquer">711 Closest Pair (Divide &amp; Conquer)</h3>
<p>The Closest Pair (Divide &amp; Conquer) algorithm finds the two points in a set that are closest together, faster than brute force. It cleverly combines sorting, recursion, and geometric insight to achieve O(n log n) time.</p>
<p>Think of it as zooming in on pairs step by step: split the plane, solve each side, then check only the narrow strip where cross-boundary pairs might hide.</p>
<section id="what-problem-are-we-solving-10" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-10">What Problem Are We Solving?</h4>
<p>Given n points in the plane, find the pair (p, q) with the smallest Euclidean distance:</p>
<p><span class="math display">\[
d(p, q) = \sqrt{(p_x - q_x)^2 + (p_y - q_y)^2}
\]</span></p>
<p>A naive solution checks all pairs (O(n²)), but divide-and-conquer reduces the work by cutting the problem in half and only merging near-boundary candidates.</p>
</section>
<section id="how-does-it-work-plain-language-10" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-10">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li>Sort all points by x-coordinate.<br>
</li>
<li>Divide the points into two halves: left and right.<br>
</li>
<li>Recursively find the closest pair in each half → distances <span class="math inline">\(d_L\)</span> and <span class="math inline">\(d_R\)</span>.<br>
</li>
<li>Let <span class="math inline">\(d = \min(d_L, d_R)\)</span>.<br>
</li>
<li>Merge step:
<ul>
<li>Collect points within distance <span class="math inline">\(d\)</span> of the dividing line (a vertical strip).<br>
</li>
<li>Sort these strip points by y.<br>
</li>
<li>For each point, only check the next few neighbors (at most 7) in y-order.<br>
</li>
</ul></li>
<li>The smallest distance found in these checks is the answer.</li>
</ol>
<p>This restriction, “check only a few nearby points,” is what keeps the algorithm <span class="math inline">\(O(n \log n)\)</span>.</p>
</section>
<section id="example-walkthrough-8" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-8">Example Walkthrough</h4>
<p>Points:<br>
A(0,0), B(3,4), C(1,1), D(4,5), E(2,2)</p>
<ol type="1">
<li>Sort by x → [A(0,0), C(1,1), E(2,2), B(3,4), D(4,5)]<br>
</li>
<li>Split into Left [A, C, E] and Right [B, D].<br>
</li>
<li>Left recursion → closest = A–C = <span class="math inline">\(\sqrt{2}\)</span><br>
Right recursion → closest = B–D = <span class="math inline">\(\sqrt{2}\)</span><br>
So <span class="math inline">\(d = \min(\sqrt{2}, \sqrt{2}) = \sqrt{2}\)</span>.<br>
</li>
<li>Strip near divide (<span class="math inline">\(x \approx 2\)</span>) → E(2,2), B(3,4), D(4,5)<br>
Check pairs:
<ul>
<li>E–B = <span class="math inline">\(\sqrt{5}\)</span><br>
</li>
<li>E–D = <span class="math inline">\(\sqrt{10}\)</span><br>
No smaller distance found.</li>
</ul></li>
</ol>
<p>Result: Closest Pair = (A, C), distance = <span class="math inline">\(\sqrt{2}\)</span>.</p>
</section>
<section id="tiny-code-easy-version-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-5">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;float.h&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmpX<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    Point <span class="op">*</span>p <span class="op">=</span> <span class="op">(</span>Point<span class="op">*)</span>a<span class="op">,</span> <span class="op">*</span>q <span class="op">=</span> <span class="op">(</span>Point<span class="op">*)</span>b<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>p<span class="op">-&gt;</span>x <span class="op">&gt;</span> q<span class="op">-&gt;</span>x<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>p<span class="op">-&gt;</span>x <span class="op">&lt;</span> q<span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmpY<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    Point <span class="op">*</span>p <span class="op">=</span> <span class="op">(</span>Point<span class="op">*)</span>a<span class="op">,</span> <span class="op">*</span>q <span class="op">=</span> <span class="op">(</span>Point<span class="op">*)</span>b<span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>p<span class="op">-&gt;</span>y <span class="op">&gt;</span> q<span class="op">-&gt;</span>y<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>p<span class="op">-&gt;</span>y <span class="op">&lt;</span> q<span class="op">-&gt;</span>y<span class="op">);</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> dist<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx <span class="op">=</span> a<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">,</span> dy <span class="op">=</span> a<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy<span class="op">);</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> brute<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> min <span class="op">=</span> DBL_MAX<span class="op">;</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j<span class="op">&lt;</span>n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dist<span class="op">(</span>pts<span class="op">[</span>i<span class="op">],</span> pts<span class="op">[</span>j<span class="op">])</span> <span class="op">&lt;</span> min<span class="op">)</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>                min <span class="op">=</span> dist<span class="op">(</span>pts<span class="op">[</span>i<span class="op">],</span> pts<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min<span class="op">;</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> stripClosest<span class="op">(</span>Point strip<span class="op">[],</span> <span class="dt">int</span> size<span class="op">,</span> <span class="dt">double</span> d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> min <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>strip<span class="op">,</span> size<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Point<span class="op">),</span> cmpY<span class="op">);</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j<span class="op">&lt;</span>size <span class="op">&amp;&amp;</span> <span class="op">(</span>strip<span class="op">[</span>j<span class="op">].</span>y <span class="op">-</span> strip<span class="op">[</span>i<span class="op">].</span>y<span class="op">)</span> <span class="op">&lt;</span> min<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dist<span class="op">(</span>strip<span class="op">[</span>i<span class="op">],</span> strip<span class="op">[</span>j<span class="op">])</span> <span class="op">&lt;</span> min<span class="op">)</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>                min <span class="op">=</span> dist<span class="op">(</span>strip<span class="op">[</span>i<span class="op">],</span> strip<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min<span class="op">;</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> closestRec<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">3</span><span class="op">)</span> <span class="cf">return</span> brute<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid <span class="op">=</span> n<span class="op">/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>    Point midPoint <span class="op">=</span> pts<span class="op">[</span>mid<span class="op">];</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dl <span class="op">=</span> closestRec<span class="op">(</span>pts<span class="op">,</span> mid<span class="op">);</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dr <span class="op">=</span> closestRec<span class="op">(</span>pts<span class="op">+</span>mid<span class="op">,</span> n<span class="op">-</span>mid<span class="op">);</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d <span class="op">=</span> dl <span class="op">&lt;</span> dr <span class="op">?</span> dl <span class="op">:</span> dr<span class="op">;</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    Point strip<span class="op">[</span><span class="dv">1000</span><span class="op">];</span></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>fabs<span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>x <span class="op">-</span> midPoint<span class="op">.</span>x<span class="op">)</span> <span class="op">&lt;</span> d<span class="op">)</span></span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>            strip<span class="op">[</span>j<span class="op">++]</span> <span class="op">=</span> pts<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fmin<span class="op">(</span>d<span class="op">,</span> stripClosest<span class="op">(</span>strip<span class="op">,</span> j<span class="op">,</span> d<span class="op">));</span></span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> closestPair<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>pts<span class="op">,</span> n<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Point<span class="op">),</span> cmpX<span class="op">);</span></span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> closestRec<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>    Point pts<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">}};</span></span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Closest distance = </span><span class="sc">%.3f\n</span><span class="st">"</span><span class="op">,</span> closestPair<span class="op">(</span>pts<span class="op">,</span> n<span class="op">));</span></span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(a,b):</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt((a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>])<span class="dv">2</span> <span class="op">+</span> (a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])<span class="dv">2</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> brute(pts):</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(pts)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>,n):</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            d <span class="op">=</span> <span class="bu">min</span>(d, dist(pts[i], pts[j]))</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> strip_closest(strip, d):</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    strip.sort(key<span class="op">=</span><span class="kw">lambda</span> p: p[<span class="dv">1</span>])</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(strip)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, m):</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (strip[j][<span class="dv">1</span>] <span class="op">-</span> strip[i][<span class="dv">1</span>]) <span class="op">&gt;=</span> d:</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>            d <span class="op">=</span> <span class="bu">min</span>(d, dist(strip[i], strip[j]))</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closest_pair(points):</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">3</span>:</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> brute(points)</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    midx <span class="op">=</span> points[mid][<span class="dv">0</span>]</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">min</span>(closest_pair(points[:mid]), closest_pair(points[mid:]))</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    strip <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> points <span class="cf">if</span> <span class="bu">abs</span>(p[<span class="dv">0</span>]<span class="op">-</span>midx) <span class="op">&lt;</span> d]</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(d, strip_closest(strip, d))</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">2</span>,<span class="dv">2</span>)]</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>pts.sort()</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Closest distance:"</span>, closest_pair(pts))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-10" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-10">Why It Matters</h4>
<ul>
<li>Classic example of divide &amp; conquer in geometry.</li>
<li>Efficient and elegant, the leap from O(n²) to O(n log n).</li>
<li>Builds intuition for other planar algorithms (Delaunay, Voronoi).</li>
</ul>
<p>Applications:</p>
<ul>
<li>Clustering (detect near neighbors)</li>
<li>Collision detection (find minimal separation)</li>
<li>Astronomy / GIS (closest stars, cities)</li>
<li>Machine learning (nearest-neighbor initialization)</li>
</ul>
</section>
<section id="try-it-yourself-10" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-10">Try It Yourself</h4>
<ol type="1">
<li>Try random 2D points, verify result vs brute force.</li>
<li>Add collinear points, confirm distance along line.</li>
<li>Visualize split and strip, draw dividing line and strip area.</li>
<li>Extend to 3D closest pair (check z too).</li>
<li>Measure runtime as n doubles.</li>
</ol>
</section>
<section id="test-cases-10" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-10">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Closest Pair</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0),(1,1),(2,2)</td>
<td>(0,0)-(1,1)</td>
<td>√2</td>
</tr>
<tr class="even">
<td>(0,0),(3,4),(1,1),(4,5),(2,2)</td>
<td>(0,0)-(1,1)</td>
<td>√2</td>
</tr>
<tr class="odd">
<td>Random</td>
<td>Verified</td>
<td>O(n log n)</td>
</tr>
<tr class="even">
<td>Duplicate points</td>
<td>Distance = 0</td>
<td>Edge case</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-10" class="level4">
<h4 class="anchored" data-anchor-id="complexity-10">Complexity</h4>
<ul>
<li>Time: O(n log n)</li>
<li>Space: O(n)</li>
<li>Brute Force: O(n²) for comparison</li>
</ul>
<p>Divide-and-conquer finds structure in chaos, sorting, splitting, and merging until the closest pair stands alone.</p>
</section>
</section>
<section id="closest-pair-sweep-line" class="level3">
<h3 class="anchored" data-anchor-id="closest-pair-sweep-line">712 Closest Pair (Sweep Line)</h3>
<p>The Closest Pair (Sweep Line) algorithm is a beautifully efficient O(n log n) technique that scans the plane from left to right, maintaining a sliding window (or “active set”) of candidate points that could form the closest pair.</p>
<p>Think of it as sweeping a vertical line across a field of stars, as each star appears, you check only its close neighbors, not the whole sky.</p>
<section id="what-problem-are-we-solving-11" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-11">What Problem Are We Solving?</h4>
<p>Given n points in 2D space, we want to find the pair with the minimum Euclidean distance.</p>
<p>Unlike Divide &amp; Conquer, which splits recursively, the Sweep Line solution processes points incrementally, one at a time, maintaining an active set of points close enough in x to be possible contenders.</p>
<p>This approach is intuitive, iterative, and particularly nice to implement with balanced search trees or ordered sets.</p>
</section>
<section id="how-does-it-work-plain-language-11" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-11">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Sort points by x-coordinate.</p></li>
<li><p>Initialize an empty active set (sorted by y).</p></li>
<li><p>Sweep from left to right:</p>
<ul>
<li><p>For each point p,</p>
<ul>
<li>Remove points whose x-distance from p exceeds the current best distance d (they’re too far left).</li>
<li>In the remaining active set, only check points whose y-distance &lt; d.</li>
<li>Update d if a closer pair is found.</li>
</ul></li>
<li><p>Insert p into the active set.</p></li>
</ul></li>
<li><p>Continue until all points are processed.</p></li>
</ol>
<p>Since each point enters and leaves the active set once, and each is compared with a constant number of nearby points, total time is O(n log n).</p>
</section>
<section id="example-walkthrough-9" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-9">Example Walkthrough</h4>
<p>Points: A(0,0), B(3,4), C(1,1), D(2,2), E(4,5)</p>
<ol type="1">
<li>Sort by x → [A, C, D, B, E]</li>
<li>Start with A → active = {A}, d = ∞</li>
<li>Add C: dist(A,C) = √2 → d = √2</li>
<li>Add D: check neighbors (A,C) → C–D = √2 (no improvement)</li>
<li>Add B: remove A (B.x - A.x &gt; √2), check C–B (dist &gt; √2), D–B (dist = √5)</li>
<li>Add E: remove C (E.x - C.x &gt; √2), check D–E, B–E Closest Pair: (A, C) with distance √2</li>
</ol>
</section>
<section id="tiny-code-easy-version-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-6">Tiny Code (Easy Version)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> bisect</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(a, b):</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt((a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>])<span class="dv">2</span> <span class="op">+</span> (a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])<span class="dv">2</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closest_pair_sweep(points):</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    points.sort(key<span class="op">=</span><span class="kw">lambda</span> p: p[<span class="dv">0</span>])  <span class="co"># sort by x</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> []</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    best_pair <span class="op">=</span> <span class="va">None</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove points too far in x</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> active <span class="kw">and</span> p[<span class="dv">0</span>] <span class="op">-</span> active[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">&gt;</span> best:</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>            active.pop(<span class="dv">0</span>)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Filter active points by y range</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        candidates <span class="op">=</span> [q <span class="cf">for</span> q <span class="kw">in</span> active <span class="cf">if</span> <span class="bu">abs</span>(q[<span class="dv">1</span>] <span class="op">-</span> p[<span class="dv">1</span>]) <span class="op">&lt;</span> best]</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check each candidate</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> q <span class="kw">in</span> candidates:</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>            d <span class="op">=</span> dist(p, q)</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&lt;</span> best:</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> d</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>                best_pair <span class="op">=</span> (p, q)</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Insert current point (keep sorted by y)</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        bisect.insort(active, p, key<span class="op">=</span><span class="kw">lambda</span> r: r[<span class="dv">1</span>] <span class="cf">if</span> <span class="bu">hasattr</span>(bisect, <span class="st">"insort"</span>) <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_pair, best</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">2</span>),(<span class="dv">4</span>,<span class="dv">5</span>)]</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>pair, d <span class="op">=</span> closest_pair_sweep(pts)</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Closest pair:"</span>, pair, <span class="st">"distance:"</span>, <span class="bu">round</span>(d,<span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>(Note: <code>bisect</code> can’t sort by key directly; in real code use <code>sortedcontainers</code> or a balanced tree.)</em></p>
<p>C (Pseudocode) In C, implement with:</p>
<ul>
<li><code>qsort</code> by x</li>
<li>Balanced BST (by y) for active set</li>
<li>Window update and neighbor checks (Real implementations use AVL trees or ordered arrays)</li>
</ul>
</section>
<section id="why-it-matters-11" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-11">Why It Matters</h4>
<ul>
<li>Incremental and online: processes one point at a time.</li>
<li>Conceptual simplicity, a geometric sliding window.</li>
<li>Practical alternative to divide &amp; conquer.</li>
</ul>
<p>Applications:</p>
<ul>
<li>Streaming geometry</li>
<li>Real-time collision detection</li>
<li>Nearest-neighbor estimation</li>
<li>Computational geometry visualizations</li>
</ul>
</section>
<section id="try-it-yourself-11" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-11">Try It Yourself</h4>
<ol type="1">
<li>Step through manually with sorted points.</li>
<li>Track how the active set shrinks and grows.</li>
<li>Add interior points and see how many are compared.</li>
<li>Try 1,000 random points, verify fast runtime.</li>
<li>Compare with Divide &amp; Conquer approach, same result, different path.</li>
</ol>
</section>
<section id="test-cases-11" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-11">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 35%">
<col style="width: 15%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Points</th>
<th>Closest Pair</th>
<th>Distance</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0),(1,1),(2,2)</td>
<td>(0,0)-(1,1)</td>
<td>√2</td>
<td>Simple line</td>
</tr>
<tr class="even">
<td>Random scatter</td>
<td>Correct pair</td>
<td>O(n log n)</td>
<td>Efficient</td>
</tr>
<tr class="odd">
<td>Clustered near origin</td>
<td>Finds nearest neighbors</td>
<td>Works</td>
<td></td>
</tr>
<tr class="even">
<td>Duplicates</td>
<td>Distance 0</td>
<td>Edge case</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-11" class="level4">
<h4 class="anchored" data-anchor-id="complexity-11">Complexity</h4>
<ul>
<li>Time: O(n log n)</li>
<li>Space: O(n)</li>
<li>Active Set Size: O(n) (usually small window)</li>
</ul>
<p>The Sweep Line is geometry’s steady heartbeat, moving left to right, pruning the past, and focusing only on the nearby present to find the closest pair.</p>
</section>
</section>
<section id="brute-force-closest-pair" class="level3">
<h3 class="anchored" data-anchor-id="brute-force-closest-pair">713 Brute Force Closest Pair</h3>
<p>The Brute Force Closest Pair algorithm is the simplest way to find the closest two points in a set, you check every possible pair and pick the one with the smallest distance.</p>
<p>It’s the geometric equivalent of “try them all,” a perfect first step for understanding how smarter algorithms improve upon it.</p>
<section id="what-problem-are-we-solving-12" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-12">What Problem Are We Solving?</h4>
<p>Given n points on a plane, we want to find the pair (p, q) with the smallest Euclidean distance:</p>
<p><span class="math display">\[
d(p, q) = \sqrt{(p_x - q_x)^2 + (p_y - q_y)^2}
\]</span></p>
<p>Brute force means:</p>
<ul>
<li>Compare each pair once.</li>
<li>Track the minimum distance found so far.</li>
<li>Return the pair with that distance.</li>
</ul>
<p>It’s slow, O(n²), but straightforward and unbeatable in simplicity.</p>
</section>
<section id="how-does-it-work-plain-language-12" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-12">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Initialize best distance ( d = ).</p></li>
<li><p>Loop over all points ( i = 1..n-1 ):</p>
<ul>
<li>For each ( j = i+1..n ), compute distance ( d(i, j) ).</li>
<li>If ( d(i, j) &lt; d ), update ( d ) and store pair.</li>
</ul></li>
<li><p>Return the smallest ( d ) and its pair.</p></li>
</ol>
<p>Because each pair is checked exactly once, it’s easy to reason about, and perfect for small datasets or testing.</p>
</section>
<section id="example-walkthrough-10" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-10">Example Walkthrough</h4>
<p>Points: A(0,0), B(3,4), C(1,1), D(2,2)</p>
<p>Pairs and distances:</p>
<ul>
<li>A–B = 5</li>
<li>A–C = √2</li>
<li>A–D = √8</li>
<li>B–C = √13</li>
<li>B–D = √5</li>
<li>C–D = √2</li>
</ul>
<p>Minimum distance = √2 (pairs A–C and C–D) Return first or all minimal pairs.</p>
</section>
<section id="tiny-code-easy-version-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-7">Tiny Code (Easy Version)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;float.h&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> dist<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx <span class="op">=</span> a<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">,</span> dy <span class="op">=</span> a<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy<span class="op">);</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> closestPairBrute<span class="op">(</span>Point pts<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> best <span class="op">=</span> DBL_MAX<span class="op">;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    Point p1<span class="op">,</span> p2<span class="op">;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> d <span class="op">=</span> dist<span class="op">(</span>pts<span class="op">[</span>i<span class="op">],</span> pts<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>d <span class="op">&lt;</span> best<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>                p1 <span class="op">=</span> pts<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>                p2 <span class="op">=</span> pts<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Closest Pair: (</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">) and (</span><span class="sc">%.1f</span><span class="st">, </span><span class="sc">%.1f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> p1<span class="op">.</span>x<span class="op">,</span> p1<span class="op">.</span>y<span class="op">,</span> p2<span class="op">.</span>x<span class="op">,</span> p2<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Distance: </span><span class="sc">%.3f\n</span><span class="st">"</span><span class="op">,</span> best<span class="op">);</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>    Point pts<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">}};</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">)/</span><span class="kw">sizeof</span><span class="op">(</span>pts<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>    closestPairBrute<span class="op">(</span>pts<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(a, b):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt((a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>])<span class="dv">2</span> <span class="op">+</span> (a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])<span class="dv">2</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closest_pair_brute(points):</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    pair <span class="op">=</span> <span class="va">None</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n):</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>            d <span class="op">=</span> dist(points[i], points[j])</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&lt;</span> best:</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> d</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>                pair <span class="op">=</span> (points[i], points[j])</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pair, best</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">2</span>)]</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>pair, d <span class="op">=</span> closest_pair_brute(pts)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Closest pair:"</span>, pair, <span class="st">"distance:"</span>, <span class="bu">round</span>(d,<span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-12" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-12">Why It Matters</h4>
<ul>
<li>Foundation for understanding divide-and-conquer and sweep line improvements.</li>
<li>Small n → simplest, most reliable method.</li>
<li>Useful for testing optimized algorithms.</li>
<li>A gentle introduction to geometric iteration and distance functions.</li>
</ul>
<p>Applications:</p>
<ul>
<li>Educational baseline for geometric problems</li>
<li>Verification in computational geometry toolkits</li>
<li>Debugging optimized implementations</li>
<li>Very small point sets (n &lt; 100)</li>
</ul>
</section>
<section id="try-it-yourself-12" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-12">Try It Yourself</h4>
<ol type="1">
<li>Add 5–10 random points, list all pair distances manually.</li>
<li>Check correctness against optimized versions.</li>
<li>Extend to 3D, just add a z term.</li>
<li>Modify for Manhattan distance.</li>
<li>Print all equally minimal pairs (ties).</li>
</ol>
</section>
<section id="test-cases-12" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-12">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Closest Pair</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0),(1,1),(2,2)</td>
<td>(0,0)-(1,1)</td>
<td>√2</td>
</tr>
<tr class="even">
<td>(0,0),(3,4),(1,1),(2,2)</td>
<td>(0,0)-(1,1)</td>
<td>√2</td>
</tr>
<tr class="odd">
<td>Random</td>
<td>Verified</td>
<td>Matches optimized</td>
</tr>
<tr class="even">
<td>Duplicates</td>
<td>Distance = 0</td>
<td>Edge case</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-12" class="level4">
<h4 class="anchored" data-anchor-id="complexity-12">Complexity</h4>
<ul>
<li>Time: O(n²)</li>
<li>Space: O(1)</li>
</ul>
<p>Brute Force is geometry’s first instinct, simple, certain, and slow, but a solid foundation for all the cleverness that follows.</p>
</section>
</section>
<section id="bentleyottmann" class="level3">
<h3 class="anchored" data-anchor-id="bentleyottmann">714 Bentley–Ottmann</h3>
<p>The Bentley–Ottmann algorithm is a classical sweep line method that efficiently finds all intersection points among a set of line segments in the plane. It runs in</p>
<p><span class="math display">\[
O\big((n + k)\log n\big)
\]</span></p>
<p>time, where <span class="math inline">\(n\)</span> is the number of segments and <span class="math inline">\(k\)</span> is the number of intersections.</p>
<p>The key insight is to move a vertical sweep line across the plane, maintaining an active set of intersecting segments ordered by <span class="math inline">\(y\)</span>, and using an event queue to process only three types of points: segment starts, segment ends, and discovered intersections.</p>
<section id="what-problem-are-we-solving-13" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-13">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> line segments, we want to compute all intersection points between them.</p>
<p>A naive approach checks all pairs:</p>
<p><span class="math display">\[
\binom{n}{2} = \frac{n(n-1)}{2}
\]</span></p>
<p>which leads to <span class="math inline">\(O(n^2)\)</span> time. The Bentley–Ottmann algorithm reduces this to <span class="math inline">\(O\big((n + k)\log n\big)\)</span> by only testing neighboring segments in the sweep line’s active set.</p>
</section>
<section id="how-does-it-work-plain-language-13" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-13">How Does It Work (Plain Language)?</h4>
<p>We maintain two data structures during the sweep:</p>
<ol type="1">
<li>Event Queue (EQ), all x-sorted events: segment starts, segment ends, and discovered intersections.</li>
<li>Active Set (AS), all segments currently intersected by the sweep line, sorted by y-coordinate.</li>
</ol>
<p>The sweep progresses from left to right:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 3%">
<col style="width: 96%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Initialize the event queue with all segment endpoints.</td>
</tr>
<tr class="even">
<td>2</td>
<td>Sweep from left to right across all events.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>For each event <span class="math inline">\(p\)</span>:</td>
</tr>
<tr class="even">
<td>a.</td>
<td>If <span class="math inline">\(p\)</span> is a segment start, insert the segment into AS and test for intersections with its immediate neighbors.</td>
</tr>
<tr class="odd">
<td>b.</td>
<td>If <span class="math inline">\(p\)</span> is a segment end, remove the segment from AS.</td>
</tr>
<tr class="even">
<td>c.</td>
<td>If <span class="math inline">\(p\)</span> is an intersection, record it, swap the two intersecting segments in AS, and check their new neighbors.</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Continue until the event queue is empty.</td>
</tr>
</tbody>
</table>
<p>Each operation on the event queue or active set takes <span class="math inline">\(O(\log n)\)</span> time, using balanced search trees.</p>
</section>
<section id="example-walkthrough-11" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-11">Example Walkthrough</h4>
<p>Segments:</p>
<ul>
<li><span class="math inline">\(S_1: (0,0)\text{–}(4,4)\)</span></li>
<li><span class="math inline">\(S_2: (0,4)\text{–}(4,0)\)</span></li>
<li><span class="math inline">\(S_3: (1,3)\text{–}(3,3)\)</span></li>
</ul>
<p>Event queue (sorted by <span class="math inline">\(x\)</span>): <span class="math inline">\((0,0), (0,4), (1,3), (2,2), (3,3), (4,0), (4,4)\)</span></p>
<p>Process:</p>
<ol type="1">
<li>At <span class="math inline">\(x=0\)</span>: insert <span class="math inline">\(S_1, S_2\)</span>. They intersect at <span class="math inline">\((2,2)\)</span> → schedule intersection event.</li>
<li>At <span class="math inline">\(x=1\)</span>: insert <span class="math inline">\(S_3\)</span>; check <span class="math inline">\(S_1, S_2, S_3\)</span> for local intersections.</li>
<li>At <span class="math inline">\(x=2\)</span>: process <span class="math inline">\((2,2)\)</span>, swap <span class="math inline">\(S_1, S_2\)</span>, recheck neighbors.</li>
<li>Continue; all intersections discovered.</li>
</ol>
<p>Output: intersection <span class="math inline">\((2,2)\)</span>.</p>
</section>
<section id="tiny-code-conceptual-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-conceptual-python">Tiny Code (Conceptual Python)</h4>
<p>A simplified sketch of the algorithm (real implementation requires a priority queue and balanced tree):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> namedtuple</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>Event <span class="op">=</span> namedtuple(<span class="st">"Event"</span>, [<span class="st">"x"</span>, <span class="st">"y"</span>, <span class="st">"type"</span>, <span class="st">"segment"</span>])</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orientation(a, b, c):</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersects(s1, s2):</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> s1</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    c, d <span class="op">=</span> s2</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    o1 <span class="op">=</span> orientation(a, b, c)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    o2 <span class="op">=</span> orientation(a, b, d)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    o3 <span class="op">=</span> orientation(c, d, a)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    o4 <span class="op">=</span> orientation(c, d, b)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (o1 <span class="op">*</span> o2 <span class="op">&lt;</span> <span class="dv">0</span>) <span class="kw">and</span> (o3 <span class="op">*</span> o4 <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bentley_ottmann(segments):</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> segments:</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        (x1, y1), (x2, y2) <span class="op">=</span> s</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x1 <span class="op">&gt;</span> x2:</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> ((x2, y2), (x1, y1))</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>        events.append((x1, y1, <span class="st">'start'</span>, s))</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>        events.append((x2, y2, <span class="st">'end'</span>, s))</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    events.sort()</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> []</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    intersections <span class="op">=</span> []</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y, etype, s <span class="kw">in</span> events:</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> etype <span class="op">==</span> <span class="st">'start'</span>:</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>            active.append(s)</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> other <span class="kw">in</span> active:</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> other <span class="op">!=</span> s <span class="kw">and</span> intersects(s, other):</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>                    intersections.append((x, y))</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> etype <span class="op">==</span> <span class="st">'end'</span>:</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>            active.remove(s)</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> intersections</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>segments <span class="op">=</span> [((<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">4</span>)), ((<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">4</span>,<span class="dv">0</span>)), ((<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">3</span>))]</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Intersections:"</span>, bentley_ottmann(segments))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-13" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-13">Why It Matters</h4>
<ul>
<li>Efficient: <span class="math inline">\(O((n + k)\log n)\)</span> vs.&nbsp;<span class="math inline">\(O(n^2)\)</span></li>
<li>Elegant: only neighboring segments are checked</li>
<li>General-purpose: fundamental for event-driven geometry</li>
</ul>
<p>Applications:</p>
<ul>
<li>CAD systems (curve crossings)</li>
<li>GIS (map overlays, road intersections)</li>
<li>Graphics (segment collision detection)</li>
<li>Robotics (motion planning, visibility graphs)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works">A Gentle Proof (Why It Works)</h4>
<p>At any sweep position, the segments in the active set are ordered by their <span class="math inline">\(y\)</span>-coordinate. When two segments intersect, their order must swap at the intersection point.</p>
<p>Hence:</p>
<ul>
<li>Every intersection is revealed exactly once when the sweep reaches its <span class="math inline">\(x\)</span>-coordinate.</li>
<li>Only neighboring segments can swap; thus only local checks are needed.</li>
<li>Each event (insert, delete, or intersection) requires <span class="math inline">\(O(\log n)\)</span> time for balanced tree operations.</li>
</ul>
<p>Total cost:</p>
<p><span class="math display">\[
O\big((n + k)\log n\big)
\]</span></p>
<p>where <span class="math inline">\(n\)</span> contributes endpoints and <span class="math inline">\(k\)</span> contributes discovered intersections.</p>
</section>
<section id="try-it-yourself-13" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-13">Try It Yourself</h4>
<ol type="1">
<li>Draw several segments that intersect at various points.</li>
<li>Sort all endpoints by <span class="math inline">\(x\)</span>-coordinate.</li>
<li>Simulate the sweep: maintain an active set sorted by <span class="math inline">\(y\)</span>.</li>
<li>At each event, check only adjacent segments.</li>
<li>Verify each intersection appears once and only once.</li>
<li>Compare with a brute-force <span class="math inline">\(O(n^2)\)</span> method.</li>
</ol>
</section>
<section id="test-cases-13" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-13">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Segments</th>
<th>Intersections</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Two diagonals of a square</td>
<td>1</td>
<td>Intersection at center</td>
</tr>
<tr class="even">
<td>Five-point star</td>
<td>10</td>
<td>All pairs intersect</td>
</tr>
<tr class="odd">
<td>Parallel lines</td>
<td>0</td>
<td>No intersections</td>
</tr>
<tr class="even">
<td>Random crossings</td>
<td>Verified</td>
<td>Matches expected output</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-13" class="level4">
<h4 class="anchored" data-anchor-id="complexity-13">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O\big((n + k)\log n\big), \quad
\text{Space: } O(n)
\]</span></p>
<p>The Bentley–Ottmann algorithm is a model of geometric precision, sweeping across the plane, maintaining order, and revealing every crossing exactly once.</p>
</section>
</section>
<section id="segment-intersection-test" class="level3">
<h3 class="anchored" data-anchor-id="segment-intersection-test">715 Segment Intersection Test</h3>
<p>The Segment Intersection Test is the fundamental geometric routine that checks whether two line segments intersect in the plane. It forms the building block for many larger algorithms, from polygon clipping to sweep line methods like Bentley–Ottmann.</p>
<p>At its heart is a simple principle: two segments intersect if and only if they straddle each other, determined by orientation tests using cross products.</p>
<section id="what-problem-are-we-solving-14" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-14">What Problem Are We Solving?</h4>
<p>Given two segments:</p>
<ul>
<li><span class="math inline">\(S_1 = (p_1, q_1)\)</span></li>
<li><span class="math inline">\(S_2 = (p_2, q_2)\)</span></li>
</ul>
<p>we want to determine whether they intersect, either at a point inside both segments or at an endpoint.</p>
<p>Mathematically, <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> intersect if:</p>
<ol type="1">
<li>The two segments cross each other, or</li>
<li>They are collinear and overlap.</li>
</ol>
</section>
<section id="how-does-it-work-plain-language-14" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-14">How Does It Work (Plain Language)?</h4>
<p>We use orientation tests to check the relative position of points.</p>
<p>For any three points <span class="math inline">\(a, b, c\)</span>, define:</p>
<p><span class="math display">\[
\text{orient}(a, b, c) = (b_x - a_x)(c_y - a_y) - (b_y - a_y)(c_x - a_x)
\]</span></p>
<ul>
<li><span class="math inline">\(\text{orient}(a, b, c) &gt; 0\)</span>: <span class="math inline">\(c\)</span> is left of the line <span class="math inline">\(ab\)</span></li>
<li><span class="math inline">\(\text{orient}(a, b, c) &lt; 0\)</span>: <span class="math inline">\(c\)</span> is right of the line <span class="math inline">\(ab\)</span></li>
<li><span class="math inline">\(\text{orient}(a, b, c) = 0\)</span>: points are collinear</li>
</ul>
<p>For segments <span class="math inline">\((p_1, q_1)\)</span> and <span class="math inline">\((p_2, q_2)\)</span>:</p>
<p>Compute orientations:</p>
<ul>
<li><span class="math inline">\(o_1 = \text{orient}(p_1, q_1, p_2)\)</span></li>
<li><span class="math inline">\(o_2 = \text{orient}(p_1, q_1, q_2)\)</span></li>
<li><span class="math inline">\(o_3 = \text{orient}(p_2, q_2, p_1)\)</span></li>
<li><span class="math inline">\(o_4 = \text{orient}(p_2, q_2, q_1)\)</span></li>
</ul>
<p>Two segments properly intersect if:</p>
<p><span class="math display">\[
(o_1 \neq o_2) \quad \text{and} \quad (o_3 \neq o_4)
\]</span></p>
<p>If any <span class="math inline">\(o_i = 0\)</span>, check if the corresponding point lies on the segment (collinear overlap).</p>
</section>
<section id="example-walkthrough-12" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-12">Example Walkthrough</h4>
<p>Segments:</p>
<ul>
<li><span class="math inline">\(S_1: (0,0)\text{–}(4,4)\)</span></li>
<li><span class="math inline">\(S_2: (0,4)\text{–}(4,0)\)</span></li>
</ul>
<p>Compute orientations:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Pair</th>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(o_1 = \text{orient}(0,0),(4,4),(0,4)\)</span></td>
<td><span class="math inline">\(&gt; 0\)</span></td>
<td>left turn</td>
</tr>
<tr class="even">
<td><span class="math inline">\(o_2 = \text{orient}(0,0),(4,4),(4,0)\)</span></td>
<td><span class="math inline">\(&lt; 0\)</span></td>
<td>right turn</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(o_3 = \text{orient}(0,4),(4,0),(0,0)\)</span></td>
<td><span class="math inline">\(&lt; 0\)</span></td>
<td>right turn</td>
</tr>
<tr class="even">
<td><span class="math inline">\(o_4 = \text{orient}(0,4),(4,0),(4,4)\)</span></td>
<td><span class="math inline">\(&gt; 0\)</span></td>
<td>left turn</td>
</tr>
</tbody>
</table>
<p>Since <span class="math inline">\(o_1 \neq o_2\)</span> and <span class="math inline">\(o_3 \neq o_4\)</span>, the segments intersect at <span class="math inline">\((2,2)\)</span>.</p>
</section>
<section id="tiny-code-c" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> orient<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>b<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">)*(</span>c<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>b<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)*(</span>c<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> onSegment<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b<span class="op">.</span>x <span class="op">&lt;=</span> fmax<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span> c<span class="op">.</span>x<span class="op">)</span> <span class="op">&amp;&amp;</span> b<span class="op">.</span>x <span class="op">&gt;=</span> fmin<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span> c<span class="op">.</span>x<span class="op">)</span> <span class="op">&amp;&amp;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>           b<span class="op">.</span>y <span class="op">&lt;=</span> fmax<span class="op">(</span>a<span class="op">.</span>y<span class="op">,</span> c<span class="op">.</span>y<span class="op">)</span> <span class="op">&amp;&amp;</span> b<span class="op">.</span>y <span class="op">&gt;=</span> fmin<span class="op">(</span>a<span class="op">.</span>y<span class="op">,</span> c<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> intersect<span class="op">(</span>Point p1<span class="op">,</span> Point q1<span class="op">,</span> Point p2<span class="op">,</span> Point q2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o1 <span class="op">=</span> orient<span class="op">(</span>p1<span class="op">,</span> q1<span class="op">,</span> p2<span class="op">);</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o2 <span class="op">=</span> orient<span class="op">(</span>p1<span class="op">,</span> q1<span class="op">,</span> q2<span class="op">);</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o3 <span class="op">=</span> orient<span class="op">(</span>p2<span class="op">,</span> q2<span class="op">,</span> p1<span class="op">);</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o4 <span class="op">=</span> orient<span class="op">(</span>p2<span class="op">,</span> q2<span class="op">,</span> q1<span class="op">);</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o1<span class="op">*</span>o2 <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> o3<span class="op">*</span>o4 <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o1 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p1<span class="op">,</span> p2<span class="op">,</span> q1<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o2 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p1<span class="op">,</span> q2<span class="op">,</span> q1<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o3 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p2<span class="op">,</span> p1<span class="op">,</span> q2<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o4 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p2<span class="op">,</span> q1<span class="op">,</span> q2<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>    Point a<span class="op">={</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},</span> b<span class="op">={</span><span class="dv">4</span><span class="op">,</span><span class="dv">4</span><span class="op">},</span> c<span class="op">={</span><span class="dv">0</span><span class="op">,</span><span class="dv">4</span><span class="op">},</span> d<span class="op">={</span><span class="dv">4</span><span class="op">,</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Intersect? </span><span class="sc">%s\n</span><span class="st">"</span><span class="op">,</span> intersect<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>d<span class="op">)</span> <span class="op">?</span> <span class="st">"Yes"</span> <span class="op">:</span> <span class="st">"No"</span><span class="op">);</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-python-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-1">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orient(a, b, c):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> on_segment(a, b, c):</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="bu">min</span>(a[<span class="dv">0</span>], c[<span class="dv">0</span>]) <span class="op">&lt;=</span> b[<span class="dv">0</span>] <span class="op">&lt;=</span> <span class="bu">max</span>(a[<span class="dv">0</span>], c[<span class="dv">0</span>]) <span class="kw">and</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">min</span>(a[<span class="dv">1</span>], c[<span class="dv">1</span>]) <span class="op">&lt;=</span> b[<span class="dv">1</span>] <span class="op">&lt;=</span> <span class="bu">max</span>(a[<span class="dv">1</span>], c[<span class="dv">1</span>]))</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(p1, q1, p2, q2):</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    o1 <span class="op">=</span> orient(p1, q1, p2)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    o2 <span class="op">=</span> orient(p1, q1, q2)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    o3 <span class="op">=</span> orient(p2, q2, p1)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    o4 <span class="op">=</span> orient(p2, q2, q1)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o1<span class="op">*</span>o2 <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">and</span> o3<span class="op">*</span>o4 <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o1 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p1, p2, q1): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o2 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p1, q2, q1): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o3 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p2, p1, q2): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o4 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p2, q1, q2): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(intersect((<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">4</span>,<span class="dv">0</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-14" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-14">Why It Matters</h4>
<ul>
<li>Core primitive for many geometry algorithms</li>
<li>Enables polygon intersection, clipping, and triangulation</li>
<li>Used in computational geometry, GIS, CAD, and physics engines</li>
</ul>
<p>Applications:</p>
<ul>
<li>Detecting collisions or crossings</li>
<li>Building visibility graphs</li>
<li>Checking self-intersections in polygons</li>
<li>Foundation for sweep line and clipping algorithms</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-1" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-1">A Gentle Proof (Why It Works)</h4>
<p>For segments <span class="math inline">\(AB\)</span> and <span class="math inline">\(CD\)</span> to intersect, they must straddle each other. That is, <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> must lie on different sides of <span class="math inline">\(AB\)</span>, and <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> must lie on different sides of <span class="math inline">\(CD\)</span>.</p>
<p>The orientation function <span class="math inline">\(\text{orient}(a,b,c)\)</span> gives the signed area of triangle <span class="math inline">\((a,b,c)\)</span>. If the signs of <span class="math inline">\(\text{orient}(A,B,C)\)</span> and <span class="math inline">\(\text{orient}(A,B,D)\)</span> differ, <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> are on opposite sides of <span class="math inline">\(AB\)</span>.</p>
<p>Thus, if:</p>
<p><span class="math display">\[
\text{sign}(\text{orient}(A,B,C)) \neq \text{sign}(\text{orient}(A,B,D))
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\text{sign}(\text{orient}(C,D,A)) \neq \text{sign}(\text{orient}(C,D,B))
\]</span></p>
<p>then the two segments must cross. Collinear cases (<span class="math inline">\(\text{orient}=0\)</span>) are handled separately by checking for overlap.</p>
</section>
<section id="try-it-yourself-14" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-14">Try It Yourself</h4>
<ol type="1">
<li>Draw two crossing segments, verify signs of orientations.</li>
<li>Try parallel non-intersecting segments, confirm test returns false.</li>
<li>Test collinear overlapping segments.</li>
<li>Extend to 3D (use vector cross products).</li>
<li>Combine with bounding box checks for faster filtering.</li>
</ol>
</section>
<section id="test-cases-14" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-14">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Segments</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((0,0)-(4,4)\)</span> and <span class="math inline">\((0,4)-(4,0)\)</span></td>
<td>Intersect</td>
<td>Cross at <span class="math inline">\((2,2)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((0,0)-(4,0)\)</span> and <span class="math inline">\((5,0)-(6,0)\)</span></td>
<td>No</td>
<td>Disjoint collinear</td>
</tr>
<tr class="odd">
<td><span class="math inline">\((0,0)-(4,0)\)</span> and <span class="math inline">\((2,0)-(6,0)\)</span></td>
<td>Yes</td>
<td>Overlapping</td>
</tr>
<tr class="even">
<td><span class="math inline">\((0,0)-(4,0)\)</span> and <span class="math inline">\((0,1)-(4,1)\)</span></td>
<td>No</td>
<td>Parallel</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-14" class="level4">
<h4 class="anchored" data-anchor-id="complexity-14">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(1), \quad \text{Space: } O(1)
\]</span></p>
<p>The segment intersection test is geometry’s atomic operation, a single, precise check built from cross products and orientation logic.</p>
</section>
</section>
<section id="line-sweep-for-segments" class="level3">
<h3 class="anchored" data-anchor-id="line-sweep-for-segments">716 Line Sweep for Segments</h3>
<p>The Line Sweep for Segments algorithm is a general event-driven framework for detecting intersections, overlaps, or coverage among many line segments efficiently. It processes events (segment starts, ends, and intersections) in sorted order using a moving vertical sweep line and a balanced tree to track active segments.</p>
<p>This is the conceptual backbone behind algorithms like Bentley–Ottmann, rectangle union area, and overlap counting.</p>
<section id="what-problem-are-we-solving-15" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-15">What Problem Are We Solving?</h4>
<p>Given a set of <span class="math inline">\(n\)</span> segments (or intervals) on the plane, we want to efficiently:</p>
<ul>
<li>Detect intersections among them</li>
<li>Count overlaps or coverage</li>
<li>Compute union or intersection regions</li>
</ul>
<p>A naive approach would compare every pair (<span class="math inline">\(O(n^2)\)</span>), but a sweep line avoids unnecessary checks by maintaining only the local neighborhood of segments currently intersecting the sweep.</p>
</section>
<section id="how-does-it-work-plain-language-15" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-15">How Does It Work (Plain Language)?</h4>
<p>We conceptually slide a vertical line across the plane from left to right, processing key events in x-sorted order:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 51%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Event queue (EQ): all segment endpoints and known intersections, sorted by <span class="math inline">\(x\)</span>.</td>
</tr>
<tr class="even">
<td>2</td>
<td>Active set (AS): segments currently intersecting the sweep line, ordered by <span class="math inline">\(y\)</span>.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Process each event <span class="math inline">\(e\)</span> from left to right:</td>
</tr>
<tr class="even">
<td>&nbsp;&nbsp;a. Start event: insert segment into AS; check intersection with immediate neighbors.</td>
<td></td>
</tr>
<tr class="odd">
<td>&nbsp;&nbsp;b. End event: remove segment from AS.</td>
<td></td>
</tr>
<tr class="even">
<td>&nbsp;&nbsp;c.&nbsp;Intersection event: report intersection; swap segment order; check new neighbors.</td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td>Continue until EQ is empty.</td>
</tr>
</tbody>
</table>
<p>At each step, the active set contains only those segments that are currently “alive” under the sweep line. Only neighbor pairs in AS can intersect.</p>
</section>
<section id="example-walkthrough-13" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-13">Example Walkthrough</h4>
<p>Segments:</p>
<ul>
<li><span class="math inline">\(S_1: (0,0)\text{–}(4,4)\)</span></li>
<li><span class="math inline">\(S_2: (0,4)\text{–}(4,0)\)</span></li>
<li><span class="math inline">\(S_3: (1,3)\text{–}(3,3)\)</span></li>
</ul>
<p>Events (sorted by x): <span class="math inline">\((0,0), (0,4), (1,3), (2,2), (3,3), (4,0), (4,4)\)</span></p>
<p>Steps:</p>
<ol type="1">
<li>At <span class="math inline">\(x=0\)</span>: insert <span class="math inline">\(S_1, S_2\)</span> → check intersection <span class="math inline">\((2,2)\)</span> → enqueue event.</li>
<li>At <span class="math inline">\(x=1\)</span>: insert <span class="math inline">\(S_3\)</span> → check against neighbors <span class="math inline">\(S_1\)</span>, <span class="math inline">\(S_2\)</span>.</li>
<li>At <span class="math inline">\(x=2\)</span>: process intersection event <span class="math inline">\((2,2)\)</span> → swap order of <span class="math inline">\(S_1\)</span>, <span class="math inline">\(S_2\)</span>.</li>
<li>Continue until all segments processed.</li>
</ol>
<p>Output: intersection point <span class="math inline">\((2,2)\)</span>.</p>
</section>
<section id="tiny-code-python-concept" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-concept">Tiny Code (Python Concept)</h4>
<p>A conceptual skeleton for segment sweeping:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> insort</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> namedtuple</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>Event <span class="op">=</span> namedtuple(<span class="st">"Event"</span>, [<span class="st">"x"</span>, <span class="st">"y"</span>, <span class="st">"type"</span>, <span class="st">"segment"</span>])</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orientation(a, b, c):</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(s1, s2):</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> s1</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    c, d <span class="op">=</span> s2</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    o1 <span class="op">=</span> orientation(a, b, c)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    o2 <span class="op">=</span> orientation(a, b, d)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    o3 <span class="op">=</span> orientation(c, d, a)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    o4 <span class="op">=</span> orientation(c, d, b)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (o1<span class="op">*</span>o2 <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">and</span> o3<span class="op">*</span>o4 <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sweep_segments(segments):</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> segments:</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>        (x1, y1), (x2, y2) <span class="op">=</span> s</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x1 <span class="op">&gt;</span> x2: s <span class="op">=</span> ((x2, y2), (x1, y1))</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>        events <span class="op">+=</span> [(x1, y1, <span class="st">'start'</span>, s), (x2, y2, <span class="st">'end'</span>, s)]</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    events.sort()</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> []</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    intersections <span class="op">=</span> []</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y, t, s <span class="kw">in</span> events:</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t <span class="op">==</span> <span class="st">'start'</span>:</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>            insort(active, s)</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># check neighbors</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> other <span class="kw">in</span> active:</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> other <span class="op">!=</span> s <span class="kw">and</span> intersect(s, other):</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>                    intersections.append((x, y))</span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> t <span class="op">==</span> <span class="st">'end'</span>:</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>            active.remove(s)</span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> intersections</span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>segments <span class="op">=</span> [((<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">4</span>)), ((<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">4</span>,<span class="dv">0</span>)), ((<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">3</span>))]</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Intersections:"</span>, sweep_segments(segments))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-15" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-15">Why It Matters</h4>
<ul>
<li>Unified approach for many geometry problems</li>
<li>Forms the base of Bentley–Ottmann, rectangle union, and sweep circle algorithms</li>
<li>Efficient: local checks instead of global comparisons</li>
</ul>
<p>Applications:</p>
<ul>
<li>Detecting collisions or intersections</li>
<li>Computing union area of shapes</li>
<li>Event-driven simulations</li>
<li>Visibility graphs and motion planning</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-2" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-2">A Gentle Proof (Why It Works)</h4>
<p>At each <span class="math inline">\(x\)</span>-coordinate, the active set represents the current “slice” of segments under the sweep line.</p>
<p>Key invariants:</p>
<ol type="1">
<li>The active set is ordered by y-coordinate, reflecting vertical order at the sweep line.</li>
<li>Two segments can only intersect if they are adjacent in this ordering.</li>
<li>Every intersection corresponds to a swap in order, so each is discovered once.</li>
</ol>
<p>Each event (insert, remove, swap) takes <span class="math inline">\(O(\log n)\)</span> with balanced trees. Each intersection adds one event, so total complexity:</p>
<p><span class="math display">\[
O\big((n + k)\log n\big)
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is the number of intersections.</p>
</section>
<section id="try-it-yourself-15" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-15">Try It Yourself</h4>
<ol type="1">
<li>Draw several segments, label start and end events.</li>
<li>Sort events by <span class="math inline">\(x\)</span>, step through the sweep.</li>
<li>Maintain a vertical ordering at each step.</li>
<li>Add a horizontal segment, see it overlap multiple active segments.</li>
<li>Count intersections and confirm correctness.</li>
</ol>
</section>
<section id="test-cases-15" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-15">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 47%">
<col style="width: 19%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Segments</th>
<th>Intersections</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((0,0)\)</span>–<span class="math inline">\((4,4)\)</span>, <span class="math inline">\((0,4)\)</span>–<span class="math inline">\((4,0)\)</span></td>
<td>1</td>
<td>Cross at <span class="math inline">\((2,2)\)</span></td>
</tr>
<tr class="even">
<td>Parallel non-overlapping</td>
<td>0</td>
<td>No intersection</td>
</tr>
<tr class="odd">
<td>Horizontal overlaps</td>
<td>Multiple</td>
<td>Shared region</td>
</tr>
<tr class="even">
<td>Random crossings</td>
<td>Verified</td>
<td>Matches expected output</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-15" class="level4">
<h4 class="anchored" data-anchor-id="complexity-15">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O\big((n + k)\log n\big), \quad
\text{Space: } O(n)
\]</span></p>
<p>The line sweep framework is the geometric scheduler, moving steadily across the plane, tracking active shapes, and catching every event exactly when it happens.</p>
</section>
</section>
<section id="intersection-via-orientation-ccw-test" class="level3">
<h3 class="anchored" data-anchor-id="intersection-via-orientation-ccw-test">717 Intersection via Orientation (CCW Test)</h3>
<p>The Intersection via Orientation method, often called the CCW test (Counter-Clockwise test), is one of the simplest and most elegant tools in computational geometry. It determines whether two line segments intersect by analyzing their orientations, that is, whether triples of points turn clockwise or counterclockwise.</p>
<p>It’s a clean, purely algebraic way to reason about geometry without explicitly solving equations for line intersections.</p>
<section id="what-problem-are-we-solving-16" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-16">What Problem Are We Solving?</h4>
<p>Given two line segments:</p>
<ul>
<li><span class="math inline">\(S_1 = (p_1, q_1)\)</span></li>
<li><span class="math inline">\(S_2 = (p_2, q_2)\)</span></li>
</ul>
<p>we want to determine if they intersect, either at a point inside both segments or at an endpoint.</p>
<p>The CCW test works entirely with determinants (cross products), avoiding floating-point divisions and handling edge cases like collinearity.</p>
</section>
<section id="how-does-it-work-plain-language-16" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-16">How Does It Work (Plain Language)?</h4>
<p>For three points <span class="math inline">\(a, b, c\)</span>, define the orientation function:</p>
<p><span class="math display">\[
\text{orient}(a, b, c) = (b_x - a_x)(c_y - a_y) - (b_y - a_y)(c_x - a_x)
\]</span></p>
<ul>
<li><span class="math inline">\(\text{orient}(a,b,c) &gt; 0\)</span> → counter-clockwise turn (CCW)</li>
<li><span class="math inline">\(\text{orient}(a,b,c) &lt; 0\)</span> → clockwise turn (CW)</li>
<li><span class="math inline">\(\text{orient}(a,b,c) = 0\)</span> → collinear</li>
</ul>
<p>For two segments <span class="math inline">\((p_1, q_1)\)</span> and <span class="math inline">\((p_2, q_2)\)</span>, we compute:</p>
<p><span class="math display">\[
\begin{aligned}
o_1 &amp;= \text{orient}(p_1, q_1, p_2) \
o_2 &amp;= \text{orient}(p_1, q_1, q_2) \
o_3 &amp;= \text{orient}(p_2, q_2, p_1) \
o_4 &amp;= \text{orient}(p_2, q_2, q_1)
\end{aligned}
\]</span></p>
<p>The two segments intersect if and only if:</p>
<p><span class="math display">\[
(o_1 \neq o_2) \quad \text{and} \quad (o_3 \neq o_4)
\]</span></p>
<p>This ensures that each segment straddles the other.</p>
<p>If any <span class="math inline">\(o_i = 0\)</span>, we check for collinear overlap using a bounding-box test.</p>
</section>
<section id="example-walkthrough-14" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-14">Example Walkthrough</h4>
<p>Segments:</p>
<ul>
<li><span class="math inline">\(S_1: (0,0)\text{–}(4,4)\)</span></li>
<li><span class="math inline">\(S_2: (0,4)\text{–}(4,0)\)</span></li>
</ul>
<p>Compute orientations:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Expression</th>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(o_1 = \text{orient}(0,0,4,4,0,4)\)</span></td>
<td><span class="math inline">\(&gt; 0\)</span></td>
<td>CCW</td>
</tr>
<tr class="even">
<td><span class="math inline">\(o_2 = \text{orient}(0,0,4,4,4,0)\)</span></td>
<td><span class="math inline">\(&lt; 0\)</span></td>
<td>CW</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(o_3 = \text{orient}(0,4,4,0,0,0)\)</span></td>
<td><span class="math inline">\(&lt; 0\)</span></td>
<td>CW</td>
</tr>
<tr class="even">
<td><span class="math inline">\(o_4 = \text{orient}(0,4,4,0,4,4)\)</span></td>
<td><span class="math inline">\(&gt; 0\)</span></td>
<td>CCW</td>
</tr>
</tbody>
</table>
<p>Because <span class="math inline">\(o_1 \neq o_2\)</span> and <span class="math inline">\(o_3 \neq o_4\)</span>, the segments intersect at <span class="math inline">\((2,2)\)</span>.</p>
</section>
<section id="tiny-code-python-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-2">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orient(a, b, c):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> on_segment(a, b, c):</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="bu">min</span>(a[<span class="dv">0</span>], c[<span class="dv">0</span>]) <span class="op">&lt;=</span> b[<span class="dv">0</span>] <span class="op">&lt;=</span> <span class="bu">max</span>(a[<span class="dv">0</span>], c[<span class="dv">0</span>]) <span class="kw">and</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">min</span>(a[<span class="dv">1</span>], c[<span class="dv">1</span>]) <span class="op">&lt;=</span> b[<span class="dv">1</span>] <span class="op">&lt;=</span> <span class="bu">max</span>(a[<span class="dv">1</span>], c[<span class="dv">1</span>]))</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(p1, q1, p2, q2):</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    o1 <span class="op">=</span> orient(p1, q1, p2)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    o2 <span class="op">=</span> orient(p1, q1, q2)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    o3 <span class="op">=</span> orient(p2, q2, p1)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    o4 <span class="op">=</span> orient(p2, q2, q1)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o1 <span class="op">*</span> o2 <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">and</span> o3 <span class="op">*</span> o4 <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span>  <span class="co"># general case</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Special cases: collinear overlap</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o1 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p1, p2, q1): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o2 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p1, q2, q1): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o3 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p2, p1, q2): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> o4 <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> on_segment(p2, q1, q2): <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(intersect((<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">4</span>,<span class="dv">0</span>)))  <span class="co"># True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-1">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> orient<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>b<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">)*(</span>c<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>b<span class="op">.</span>y <span class="op">-</span> a<span class="op">.</span>y<span class="op">)*(</span>c<span class="op">.</span>x <span class="op">-</span> a<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> onSegment<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b<span class="op">.</span>x <span class="op">&lt;=</span> fmax<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span> c<span class="op">.</span>x<span class="op">)</span> <span class="op">&amp;&amp;</span> b<span class="op">.</span>x <span class="op">&gt;=</span> fmin<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span> c<span class="op">.</span>x<span class="op">)</span> <span class="op">&amp;&amp;</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>           b<span class="op">.</span>y <span class="op">&lt;=</span> fmax<span class="op">(</span>a<span class="op">.</span>y<span class="op">,</span> c<span class="op">.</span>y<span class="op">)</span> <span class="op">&amp;&amp;</span> b<span class="op">.</span>y <span class="op">&gt;=</span> fmin<span class="op">(</span>a<span class="op">.</span>y<span class="op">,</span> c<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> intersect<span class="op">(</span>Point p1<span class="op">,</span> Point q1<span class="op">,</span> Point p2<span class="op">,</span> Point q2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o1 <span class="op">=</span> orient<span class="op">(</span>p1<span class="op">,</span> q1<span class="op">,</span> p2<span class="op">);</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o2 <span class="op">=</span> orient<span class="op">(</span>p1<span class="op">,</span> q1<span class="op">,</span> q2<span class="op">);</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o3 <span class="op">=</span> orient<span class="op">(</span>p2<span class="op">,</span> q2<span class="op">,</span> p1<span class="op">);</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> o4 <span class="op">=</span> orient<span class="op">(</span>p2<span class="op">,</span> q2<span class="op">,</span> q1<span class="op">);</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o1<span class="op">*</span>o2 <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> o3<span class="op">*</span>o4 <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o1 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p1<span class="op">,</span> p2<span class="op">,</span> q1<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o2 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p1<span class="op">,</span> q2<span class="op">,</span> q1<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o3 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p2<span class="op">,</span> p1<span class="op">,</span> q2<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o4 <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> onSegment<span class="op">(</span>p2<span class="op">,</span> q1<span class="op">,</span> q2<span class="op">))</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>    Point a<span class="op">={</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">},</span> b<span class="op">={</span><span class="dv">4</span><span class="op">,</span><span class="dv">4</span><span class="op">},</span> c<span class="op">={</span><span class="dv">0</span><span class="op">,</span><span class="dv">4</span><span class="op">},</span> d<span class="op">={</span><span class="dv">4</span><span class="op">,</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Intersect? </span><span class="sc">%s\n</span><span class="st">"</span><span class="op">,</span> intersect<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>d<span class="op">)</span> <span class="op">?</span> <span class="st">"Yes"</span> <span class="op">:</span> <span class="st">"No"</span><span class="op">);</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-16" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-16">Why It Matters</h4>
<ul>
<li>Fundamental primitive in geometry and computational graphics</li>
<li>Forms the core of polygon intersection, clipping, and triangulation</li>
<li>Numerically stable, avoids divisions or floating-point slopes</li>
<li>Used in collision detection, pathfinding, and geometry kernels</li>
</ul>
<p>Applications:</p>
<ul>
<li>Detecting intersections in polygon meshes</li>
<li>Checking path crossings in navigation systems</li>
<li>Implementing clipping algorithms (e.g., Weiler–Atherton)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-3" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-3">A Gentle Proof (Why It Works)</h4>
<p>A segment <span class="math inline">\(AB\)</span> and <span class="math inline">\(CD\)</span> intersect if each pair of endpoints straddles the other segment. The orientation function <span class="math inline">\(\text{orient}(A,B,C)\)</span> gives the signed area of the triangle <span class="math inline">\((A,B,C)\)</span>.</p>
<ul>
<li>If <span class="math inline">\(\text{orient}(A,B,C)\)</span> and <span class="math inline">\(\text{orient}(A,B,D)\)</span> have opposite signs, then <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> are on different sides of <span class="math inline">\(AB\)</span>.</li>
<li>Similarly, if <span class="math inline">\(\text{orient}(C,D,A)\)</span> and <span class="math inline">\(\text{orient}(C,D,B)\)</span> have opposite signs, then <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are on different sides of <span class="math inline">\(CD\)</span>.</li>
</ul>
<p>Therefore, if:</p>
<p><span class="math display">\[
\text{sign}(\text{orient}(A,B,C)) \neq \text{sign}(\text{orient}(A,B,D))
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\text{sign}(\text{orient}(C,D,A)) \neq \text{sign}(\text{orient}(C,D,B))
\]</span></p>
<p>then the two segments must cross. If any orientation is <span class="math inline">\(0\)</span>, we simply check whether the collinear point lies within the segment bounds.</p>
</section>
<section id="try-it-yourself-16" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-16">Try It Yourself</h4>
<ol type="1">
<li>Sketch two crossing segments; label orientation signs at each vertex.</li>
<li>Try non-intersecting and parallel cases, confirm orientation tests differ.</li>
<li>Check collinear overlapping segments.</li>
<li>Implement a version that counts intersections among many segments.</li>
<li>Compare with brute-force coordinate intersection.</li>
</ol>
</section>
<section id="test-cases-16" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-16">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Segments</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((0,0)\)</span>–<span class="math inline">\((4,4)\)</span> and <span class="math inline">\((0,4)\)</span>–<span class="math inline">\((4,0)\)</span></td>
<td>Intersect</td>
<td>Cross at <span class="math inline">\((2,2)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((0,0)\)</span>–<span class="math inline">\((4,0)\)</span> and <span class="math inline">\((5,0)\)</span>–<span class="math inline">\((6,0)\)</span></td>
<td>No</td>
<td>Disjoint collinear</td>
</tr>
<tr class="odd">
<td><span class="math inline">\((0,0)\)</span>–<span class="math inline">\((4,0)\)</span> and <span class="math inline">\((2,0)\)</span>–<span class="math inline">\((6,0)\)</span></td>
<td>Yes</td>
<td>Overlap</td>
</tr>
<tr class="even">
<td><span class="math inline">\((0,0)\)</span>–<span class="math inline">\((4,0)\)</span> and <span class="math inline">\((0,1)\)</span>–<span class="math inline">\((4,1)\)</span></td>
<td>No</td>
<td>Parallel lines</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-16" class="level4">
<h4 class="anchored" data-anchor-id="complexity-16">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(1), \quad \text{Space: } O(1)
\]</span></p>
<p>The CCW test distills intersection detection into a single algebraic test, a foundation of geometric reasoning built from orientation signs.</p>
</section>
</section>
<section id="circle-intersection" class="level3">
<h3 class="anchored" data-anchor-id="circle-intersection">718 Circle Intersection</h3>
<p>The Circle Intersection problem asks whether two circles intersect, and if so, to compute their intersection points. It’s a classic example of blending algebraic geometry with spatial reasoning, used in collision detection, Venn diagrams, and range queries.</p>
<p>Two circles can have 0, 1, 2, or infinite (coincident) intersection points, depending on their relative positions.</p>
<section id="what-problem-are-we-solving-17" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-17">What Problem Are We Solving?</h4>
<p>Given two circles:</p>
<ul>
<li><span class="math inline">\(C_1\)</span>: center <span class="math inline">\((x_1, y_1)\)</span>, radius <span class="math inline">\(r_1\)</span></li>
<li><span class="math inline">\(C_2\)</span>: center <span class="math inline">\((x_2, y_2)\)</span>, radius <span class="math inline">\(r_2\)</span></li>
</ul>
<p>we want to determine:</p>
<ol type="1">
<li>Do they intersect?</li>
<li>If yes, what are the intersection points?</li>
</ol>
</section>
<section id="how-does-it-work-plain-language-17" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-17">How Does It Work (Plain Language)?</h4>
<p>Let the distance between centers be:</p>
<p><span class="math display">\[
d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\]</span></p>
<p>Now compare <span class="math inline">\(d\)</span> with <span class="math inline">\(r_1\)</span> and <span class="math inline">\(r_2\)</span>:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 33%">
<col style="width: 12%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Condition</th>
<th>Meaning</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(d &gt; r_1 + r_2\)</span></td>
<td>Circles are separate (no intersection)</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(d = r_1 + r_2\)</span></td>
<td>Circles touch externally (1 point)</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>$</td>
<td>r_1 - r_2</td>
<td>&lt; d &lt; r_1 + r_2$</td>
<td>Circles intersect (2 points)</td>
</tr>
<tr class="even">
<td>$d =</td>
<td>r_1 - r_2</td>
<td>$</td>
<td>Circles touch internally (1 point)</td>
</tr>
<tr class="odd">
<td>$d &lt;</td>
<td>r_1 - r_2</td>
<td>$</td>
<td>One circle is inside the other (no intersection)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(d = 0, r_1 = r_2\)</span></td>
<td>Circles are coincident (infinite points)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>If they intersect (<span class="math inline">\(|r_1 - r_2| &lt; d &lt; r_1 + r_2\)</span>), the intersection points can be computed geometrically.</p>
</section>
<section id="derivation-of-intersection-points" class="level4">
<h4 class="anchored" data-anchor-id="derivation-of-intersection-points">Derivation of Intersection Points</h4>
<p>We find the line of intersection between the two circles.</p>
<p>Let:</p>
<p><span class="math display">\[
a = \frac{r_1^2 - r_2^2 + d^2}{2d}
\]</span></p>
<p>Then, the point <span class="math inline">\(P\)</span> on the line connecting centers where the intersection chord crosses is:</p>
<p><span class="math display">\[
P_x = x_1 + a \cdot \frac{x_2 - x_1}{d}
\]</span> <span class="math display">\[
P_y = y_1 + a \cdot \frac{y_2 - y_1}{d}
\]</span></p>
<p>The height from <span class="math inline">\(P\)</span> to each intersection point is:</p>
<p><span class="math display">\[
h = \sqrt{r_1^2 - a^2}
\]</span></p>
<p>The intersection points are:</p>
<p><span class="math display">\[
(x_3, y_3) = \big(P_x \pm h \cdot \frac{y_2 - y_1}{d},; P_y \mp h \cdot \frac{x_2 - x_1}{d}\big)
\]</span></p>
<p>These two points represent the intersection of the circles.</p>
</section>
<section id="example-walkthrough-15" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-15">Example Walkthrough</h4>
<p>Circles:</p>
<ul>
<li><span class="math inline">\(C_1: (0, 0), r_1 = 5\)</span></li>
<li><span class="math inline">\(C_2: (6, 0), r_2 = 5\)</span></li>
</ul>
<p>Compute:</p>
<ul>
<li><span class="math inline">\(d = 6\)</span></li>
<li><span class="math inline">\(r_1 + r_2 = 10\)</span>, <span class="math inline">\(|r_1 - r_2| = 0\)</span> So <span class="math inline">\(|r_1 - r_2| &lt; d &lt; r_1 + r_2\)</span> → 2 intersection points</li>
</ul>
<p>Then:</p>
<p><span class="math display">\[
a = \frac{5^2 - 5^2 + 6^2}{2 \cdot 6} = 3
\]</span> <span class="math display">\[
h = \sqrt{5^2 - 3^2} = 4
\]</span></p>
<p><span class="math inline">\(P = (3, 0)\)</span> → intersection points:</p>
<p><span class="math display">\[
(x_3, y_3) = (3, \pm 4)
\]</span></p>
<p>Intersections: <span class="math inline">\((3, 4)\)</span> and <span class="math inline">\((3, -4)\)</span></p>
</section>
<section id="tiny-code-python-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-3">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circle_intersection(x1, y1, r1, x2, y2, r2):</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    dx, dy <span class="op">=</span> x2 <span class="op">-</span> x1, y2 <span class="op">-</span> y1</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> sqrt(dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> d <span class="op">&gt;</span> r1 <span class="op">+</span> r2 <span class="kw">or</span> d <span class="op">&lt;</span> <span class="bu">abs</span>(r1 <span class="op">-</span> r2) <span class="kw">or</span> d <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> r1 <span class="op">==</span> r2:</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> (r1<span class="op">*</span>r1 <span class="op">-</span> r2<span class="op">*</span>r2 <span class="op">+</span> d<span class="op">*</span>d) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>d)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> sqrt(r1<span class="op">*</span>r1 <span class="op">-</span> a<span class="op">*</span>a)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    xm <span class="op">=</span> x1 <span class="op">+</span> a <span class="op">*</span> dx <span class="op">/</span> d</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    ym <span class="op">=</span> y1 <span class="op">+</span> a <span class="op">*</span> dy <span class="op">/</span> d</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    rx <span class="op">=</span> <span class="op">-</span>dy <span class="op">*</span> (h <span class="op">/</span> d)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    ry <span class="op">=</span>  dx <span class="op">*</span> (h <span class="op">/</span> d)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [(xm <span class="op">+</span> rx, ym <span class="op">+</span> ry), (xm <span class="op">-</span> rx, ym <span class="op">-</span> ry)]</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(circle_intersection(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">0</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-2">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> circle_intersection<span class="op">(</span><span class="dt">double</span> x1<span class="op">,</span> <span class="dt">double</span> y1<span class="op">,</span> <span class="dt">double</span> r1<span class="op">,</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                         <span class="dt">double</span> x2<span class="op">,</span> <span class="dt">double</span> y2<span class="op">,</span> <span class="dt">double</span> r2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx <span class="op">=</span> x2 <span class="op">-</span> x1<span class="op">,</span> dy <span class="op">=</span> y2 <span class="op">-</span> y1<span class="op">;</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d <span class="op">=</span> sqrt<span class="op">(</span>dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy<span class="op">);</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>d <span class="op">&gt;</span> r1 <span class="op">+</span> r2 <span class="op">||</span> d <span class="op">&lt;</span> fabs<span class="op">(</span>r1 <span class="op">-</span> r2<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>d <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> r1 <span class="op">==</span> r2<span class="op">))</span> <span class="op">{</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"No unique intersection</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> a <span class="op">=</span> <span class="op">(</span>r1<span class="op">*</span>r1 <span class="op">-</span> r2<span class="op">*</span>r2 <span class="op">+</span> d<span class="op">*</span>d<span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="dv">2</span><span class="op">*</span>d<span class="op">);</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> h <span class="op">=</span> sqrt<span class="op">(</span>r1<span class="op">*</span>r1 <span class="op">-</span> a<span class="op">*</span>a<span class="op">);</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> xm <span class="op">=</span> x1 <span class="op">+</span> a <span class="op">*</span> dx <span class="op">/</span> d<span class="op">;</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> ym <span class="op">=</span> y1 <span class="op">+</span> a <span class="op">*</span> dy <span class="op">/</span> d<span class="op">;</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> rx <span class="op">=</span> <span class="op">-</span>dy <span class="op">*</span> <span class="op">(</span>h <span class="op">/</span> d<span class="op">);</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> ry <span class="op">=</span>  dx <span class="op">*</span> <span class="op">(</span>h <span class="op">/</span> d<span class="op">);</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Intersection points:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.2f</span><span class="st">, </span><span class="sc">%.2f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> xm <span class="op">+</span> rx<span class="op">,</span> ym <span class="op">+</span> ry<span class="op">);</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"(</span><span class="sc">%.2f</span><span class="st">, </span><span class="sc">%.2f</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> xm <span class="op">-</span> rx<span class="op">,</span> ym <span class="op">-</span> ry<span class="op">);</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>    circle_intersection<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-17" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-17">Why It Matters</h4>
<ul>
<li>Fundamental geometric building block</li>
<li>Used in collision detection, Venn diagrams, circle packing, sensor range overlap</li>
<li>Enables circle clipping, lens area computation, and circle graph construction</li>
</ul>
<p>Applications:</p>
<ul>
<li>Graphics (drawing arcs, blending circles)</li>
<li>Robotics (sensing overlap)</li>
<li>Physics engines (sphere–sphere collision)</li>
<li>GIS (circular buffer intersection)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-4" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-4">A Gentle Proof (Why It Works)</h4>
<p>The two circle equations are:</p>
<p><span class="math display">\[
(x - x_1)^2 + (y - y_1)^2 = r_1^2
\]</span> <span class="math display">\[
(x - x_2)^2 + (y - y_2)^2 = r_2^2
\]</span></p>
<p>Subtracting eliminates squares and yields a linear equation for the line connecting intersection points (the radical line). Solving this line together with one circle’s equation gives two symmetric points, derived via <span class="math inline">\(a\)</span> and <span class="math inline">\(h\)</span> from the geometry of chords.</p>
<p>Thus, the solution is exact and symmetric, and naturally handles 0, 1, or 2 intersections depending on <span class="math inline">\(d\)</span>.</p>
</section>
<section id="try-it-yourself-17" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-17">Try It Yourself</h4>
<ol type="1">
<li>Draw two overlapping circles and compute <span class="math inline">\(d\)</span>, <span class="math inline">\(a\)</span>, <span class="math inline">\(h\)</span>.</li>
<li>Compare geometric sketch with computed points.</li>
<li>Test tangent circles (<span class="math inline">\(d = r_1 + r_2\)</span>).</li>
<li>Test nested circles (<span class="math inline">\(d &lt; |r_1 - r_2|\)</span>).</li>
<li>Extend to 3D sphere–sphere intersection (circle of intersection).</li>
</ol>
</section>
<section id="test-cases-17" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-17">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Circle 1</th>
<th>Circle 2</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((0,0), r=5\)</span></td>
<td><span class="math inline">\((6,0), r=5\)</span></td>
<td><span class="math inline">\((3, 4)\)</span>, <span class="math inline">\((3, -4)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((0,0), r=3\)</span></td>
<td><span class="math inline">\((6,0), r=3\)</span></td>
<td>Tangent (1 point)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\((0,0), r=2\)</span></td>
<td><span class="math inline">\((0,0), r=2\)</span></td>
<td>Coincident (infinite)</td>
</tr>
<tr class="even">
<td><span class="math inline">\((0,0), r=2\)</span></td>
<td><span class="math inline">\((5,0), r=2\)</span></td>
<td>No intersection</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-17" class="level4">
<h4 class="anchored" data-anchor-id="complexity-17">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(1), \quad \text{Space: } O(1)
\]</span></p>
<p>Circle intersection blends algebra and geometry, a precise construction revealing where two round worlds meet.</p>
</section>
</section>
<section id="polygon-intersection" class="level3">
<h3 class="anchored" data-anchor-id="polygon-intersection">719 Polygon Intersection</h3>
<p>The Polygon Intersection problem asks us to compute the overlapping region (or intersection) between two polygons. It’s a fundamental operation in computational geometry, forming the basis for clipping, boolean operations, map overlays, and collision detection.</p>
<p>There are several standard methods:</p>
<ul>
<li>Sutherland–Hodgman (clip subject polygon against convex clip polygon)</li>
<li>Weiler–Atherton (general polygons with holes)</li>
<li>Greiner–Hormann (robust for complex shapes)</li>
</ul>
<section id="what-problem-are-we-solving-18" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-18">What Problem Are We Solving?</h4>
<p>Given two polygons <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>, we want to compute:</p>
<p><span class="math display">\[
R = P \cap Q
\]</span></p>
<p>where <span class="math inline">\(R\)</span> is the intersection polygon, representing the region common to both.</p>
<p>For convex polygons, intersection is straightforward; for concave or self-intersecting polygons, careful clipping is needed.</p>
</section>
<section id="how-does-it-work-plain-language-18" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-18">How Does It Work (Plain Language)?</h4>
<p>Let’s describe the classic Sutherland–Hodgman approach (for convex clipping polygons):</p>
<ol type="1">
<li><p>Initialize: Let the output polygon = subject polygon.</p></li>
<li><p>Iterate over each edge of the clip polygon.</p></li>
<li><p>Clip the current output polygon against the clip edge:</p>
<ul>
<li>Keep points inside the edge.</li>
<li>Compute intersection points for edges crossing the boundary.</li>
</ul></li>
<li><p>After all edges processed, the remaining polygon is the intersection.</p></li>
</ol>
<p>This works because every edge trims the subject polygon step by step.</p>
</section>
<section id="key-idea" class="level4">
<h4 class="anchored" data-anchor-id="key-idea">Key Idea</h4>
<p>For a directed edge <span class="math inline">\((C_i, C_{i+1})\)</span> of the clip polygon, a point <span class="math inline">\(P\)</span> is inside if:</p>
<p><span class="math display">\[
(C_{i+1} - C_i) \times (P - C_i) \ge 0
\]</span></p>
<p>This uses the cross product to check orientation relative to the clip edge.</p>
<p>Each polygon edge pair may produce at most one intersection point.</p>
</section>
<section id="example-walkthrough-16" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-16">Example Walkthrough</h4>
<p>Clip polygon (square): <span class="math inline">\((0,0)\)</span>, <span class="math inline">\((5,0)\)</span>, <span class="math inline">\((5,5)\)</span>, <span class="math inline">\((0,5)\)</span></p>
<p>Subject polygon (triangle): <span class="math inline">\((2,-1)\)</span>, <span class="math inline">\((6,2)\)</span>, <span class="math inline">\((2,6)\)</span></p>
<p>Process edges:</p>
<ol type="1">
<li>Clip against bottom edge <span class="math inline">\((0,0)\)</span>–<span class="math inline">\((5,0)\)</span> → remove points below <span class="math inline">\(y=0\)</span></li>
<li>Clip against right edge <span class="math inline">\((5,0)\)</span>–<span class="math inline">\((5,5)\)</span> → cut off <span class="math inline">\(x&gt;5\)</span></li>
<li>Clip against top <span class="math inline">\((5,5)\)</span>–<span class="math inline">\((0,5)\)</span> → trim above <span class="math inline">\(y=5\)</span></li>
<li>Clip against left <span class="math inline">\((0,5)\)</span>–<span class="math inline">\((0,0)\)</span> → trim <span class="math inline">\(x&lt;0\)</span></li>
</ol>
<p>Output polygon: a pentagon representing the overlap inside the square.</p>
</section>
<section id="tiny-code-python-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-4">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inside(p, cp1, cp2):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (cp2[<span class="dv">0</span>]<span class="op">-</span>cp1[<span class="dv">0</span>])<span class="op">*</span>(p[<span class="dv">1</span>]<span class="op">-</span>cp1[<span class="dv">1</span>]) <span class="op">&gt;</span> (cp2[<span class="dv">1</span>]<span class="op">-</span>cp1[<span class="dv">1</span>])<span class="op">*</span>(p[<span class="dv">0</span>]<span class="op">-</span>cp1[<span class="dv">0</span>])</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersection(s, e, cp1, cp2):</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    dc <span class="op">=</span> (cp1[<span class="dv">0</span>]<span class="op">-</span>cp2[<span class="dv">0</span>], cp1[<span class="dv">1</span>]<span class="op">-</span>cp2[<span class="dv">1</span>])</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> (s[<span class="dv">0</span>]<span class="op">-</span>e[<span class="dv">0</span>], s[<span class="dv">1</span>]<span class="op">-</span>e[<span class="dv">1</span>])</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    n1 <span class="op">=</span> cp1[<span class="dv">0</span>]<span class="op">*</span>cp2[<span class="dv">1</span>] <span class="op">-</span> cp1[<span class="dv">1</span>]<span class="op">*</span>cp2[<span class="dv">0</span>]</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    n2 <span class="op">=</span> s[<span class="dv">0</span>]<span class="op">*</span>e[<span class="dv">1</span>] <span class="op">-</span> s[<span class="dv">1</span>]<span class="op">*</span>e[<span class="dv">0</span>]</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    denom <span class="op">=</span> dc[<span class="dv">0</span>]<span class="op">*</span>dp[<span class="dv">1</span>] <span class="op">-</span> dc[<span class="dv">1</span>]<span class="op">*</span>dp[<span class="dv">0</span>]</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> denom <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> e</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> (n1<span class="op">*</span>dp[<span class="dv">0</span>] <span class="op">-</span> n2<span class="op">*</span>dc[<span class="dv">0</span>]) <span class="op">/</span> denom</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> (n1<span class="op">*</span>dp[<span class="dv">1</span>] <span class="op">-</span> n2<span class="op">*</span>dc[<span class="dv">1</span>]) <span class="op">/</span> denom</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x, y)</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> suth_hodg_clip(subject, clip):</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> subject</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(clip)):</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        input_list <span class="op">=</span> output</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> []</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>        cp1 <span class="op">=</span> clip[i]</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>        cp2 <span class="op">=</span> clip[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(clip)]</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(input_list)):</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> input_list[j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>            e <span class="op">=</span> input_list[j]</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> inside(e, cp1, cp2):</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> inside(s, cp1, cp2):</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>                    output.append(intersection(s, e, cp1, cp2))</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>                output.append(e)</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> inside(s, cp1, cp2):</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>                output.append(intersection(s, e, cp1, cp2))</span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>subject <span class="op">=</span> [(<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">6</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">6</span>)]</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>clip <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">5</span>,<span class="dv">0</span>),(<span class="dv">5</span>,<span class="dv">5</span>),(<span class="dv">0</span>,<span class="dv">5</span>)]</span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(suth_hodg_clip(subject, clip))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-18" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-18">Why It Matters</h4>
<ul>
<li>Core of polygon operations: intersection, union, difference</li>
<li>Used in clipping pipelines, rendering, CAD, GIS</li>
<li>Efficient (<span class="math inline">\(O(nm)\)</span>) for <span class="math inline">\(n\)</span>-vertex subject and <span class="math inline">\(m\)</span>-vertex clip polygon</li>
<li>Stable for convex clipping polygons</li>
</ul>
<p>Applications:</p>
<ul>
<li>Graphics: clipping polygons to viewport</li>
<li>Mapping: overlaying shapes, zoning regions</li>
<li>Simulation: detecting overlapping regions</li>
<li>Computational geometry: polygon boolean ops</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-5" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-5">A Gentle Proof (Why It Works)</h4>
<p>Each clip edge defines a half-plane. The intersection of convex polygons equals the intersection of all half-planes bounding the clip polygon.</p>
<p>Formally: <span class="math display">\[
R = P \cap \bigcap_{i=1}^{m} H_i
\]</span> where <span class="math inline">\(H_i\)</span> is the half-plane on the interior side of clip edge <span class="math inline">\(i\)</span>.</p>
<p>At each step, we take the polygon–half-plane intersection, which is itself convex. Thus, after clipping against all edges, we obtain the exact intersection.</p>
<p>Since each vertex can generate at most one intersection per edge, the total complexity is <span class="math inline">\(O(nm)\)</span>.</p>
</section>
<section id="try-it-yourself-18" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-18">Try It Yourself</h4>
<ol type="1">
<li>Draw a triangle and clip it against a square, follow each step.</li>
<li>Try reversing clip and subject polygons.</li>
<li>Test degenerate cases (no intersection, full containment).</li>
<li>Compare convex vs concave clip polygons.</li>
<li>Extend to Weiler–Atherton for non-convex shapes.</li>
</ol>
</section>
<section id="test-cases-18" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-18">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Subject Polygon</th>
<th>Clip Polygon</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle across square</td>
<td>Square</td>
<td>Clipped pentagon</td>
</tr>
<tr class="even">
<td>Fully inside</td>
<td>Square</td>
<td>Unchanged</td>
</tr>
<tr class="odd">
<td>Fully outside</td>
<td>Square</td>
<td>Empty</td>
</tr>
<tr class="even">
<td>Overlapping rectangles</td>
<td>Both</td>
<td>Intersection rectangle</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-18" class="level4">
<h4 class="anchored" data-anchor-id="complexity-18">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(nm), \quad \text{Space: } O(n + m)
\]</span></p>
<p>Polygon intersection is geometry’s boolean operator, trimming shapes step by step until only the shared region remains.</p>
</section>
</section>
<section id="nearest-neighbor-pair-with-kd-tree" class="level3">
<h3 class="anchored" data-anchor-id="nearest-neighbor-pair-with-kd-tree">720 Nearest Neighbor Pair (with KD-Tree)</h3>
<p>The Nearest Neighbor Pair problem asks us to find the pair of points that are closest together in a given set, a fundamental question in computational geometry and spatial data analysis.</p>
<p>It underpins algorithms in clustering, graphics, machine learning, and collision detection, and can be solved efficiently using divide and conquer, sweep line, or spatial data structures like KD-Trees.</p>
<section id="what-problem-are-we-solving-19" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-19">What Problem Are We Solving?</h4>
<p>Given a set of <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {p_1, p_2, \dots, p_n}\)</span> in the plane, find two distinct points <span class="math inline">\((p_i, p_j)\)</span> such that the Euclidean distance</p>
<p><span class="math display">\[
d(p_i, p_j) = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}
\]</span></p>
<p>is minimized.</p>
<p>Naively checking all <span class="math inline">\(\binom{n}{2}\)</span> pairs takes <span class="math inline">\(O(n^2)\)</span> time. We want an <span class="math inline">\(O(n \log n)\)</span> or better solution.</p>
</section>
<section id="how-does-it-work-plain-language-19" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-19">How Does It Work (Plain Language)?</h4>
<p>We’ll focus on the KD-Tree approach, which efficiently supports nearest-neighbor queries in low-dimensional space.</p>
<p>A KD-Tree (k-dimensional tree) recursively partitions space along coordinate axes:</p>
<ol type="1">
<li><p>Build phase</p>
<ul>
<li>Sort points by <span class="math inline">\(x\)</span>, split at median → root node</li>
<li>Recursively build left (smaller <span class="math inline">\(x\)</span>) and right (larger <span class="math inline">\(x\)</span>) subtrees</li>
<li>Alternate axis at each depth (<span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, …)</li>
</ul></li>
<li><p>Query phase (for each point)</p>
<ul>
<li>Traverse KD-Tree to find nearest candidate</li>
<li>Backtrack to check subtrees that might contain closer points</li>
<li>Maintain global minimum distance and pair</li>
</ul></li>
</ol>
<p>By leveraging axis-aligned bounding boxes, many regions are pruned (ignored) early.</p>
</section>
<section id="step-by-step-conceptual" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-conceptual">Step-by-Step (Conceptual)</h4>
<ol type="1">
<li>Build KD-Tree in <span class="math inline">\(O(n \log n)\)</span>.</li>
<li>For each point <span class="math inline">\(p\)</span>, search for its nearest neighbor in <span class="math inline">\(O(\log n)\)</span> expected time.</li>
<li>Track global minimum pair <span class="math inline">\((p, q)\)</span> with smallest distance.</li>
</ol>
</section>
<section id="example-walkthrough-17" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-17">Example Walkthrough</h4>
<p>Points: <span class="math display">\[
P = {(1,1), (4,4), (5,1), (7,2)}
\]</span></p>
<ol type="1">
<li><p>Build KD-Tree splitting by <span class="math inline">\(x\)</span>: root = <span class="math inline">\((4,4)\)</span> left subtree = <span class="math inline">\((1,1)\)</span> right subtree = <span class="math inline">\((5,1),(7,2)\)</span></p></li>
<li><p>Query nearest for each:</p>
<ul>
<li><span class="math inline">\((1,1)\)</span> → nearest = <span class="math inline">\((4,4)\)</span> (<span class="math inline">\(d=4.24\)</span>)</li>
<li><span class="math inline">\((4,4)\)</span> → nearest = <span class="math inline">\((5,1)\)</span> (<span class="math inline">\(d=3.16\)</span>)</li>
<li><span class="math inline">\((5,1)\)</span> → nearest = <span class="math inline">\((7,2)\)</span> (<span class="math inline">\(d=2.24\)</span>)</li>
<li><span class="math inline">\((7,2)\)</span> → nearest = <span class="math inline">\((5,1)\)</span> (<span class="math inline">\(d=2.24\)</span>)</li>
</ul></li>
</ol>
<p>Closest pair: <span class="math inline">\((5,1)\)</span> and <span class="math inline">\((7,2)\)</span></p>
</section>
<section id="tiny-code-python-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-5">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(a, b):</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt((a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>])<span class="dv">2</span> <span class="op">+</span> (a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])<span class="dv">2</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_kdtree(points, depth<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> points: <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    axis <span class="op">=</span> depth <span class="op">%</span> k</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    points.sort(key<span class="op">=</span><span class="kw">lambda</span> p: p[axis])</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(points) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'point'</span>: points[mid],</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'left'</span>: build_kdtree(points[:mid], depth<span class="op">+</span><span class="dv">1</span>),</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'right'</span>: build_kdtree(points[mid<span class="op">+</span><span class="dv">1</span>:], depth<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nearest_neighbor(tree, target, depth<span class="op">=</span><span class="dv">0</span>, best<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tree <span class="kw">is</span> <span class="va">None</span>: <span class="cf">return</span> best</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>    point <span class="op">=</span> tree[<span class="st">'point'</span>]</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> best <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> dist(target, point) <span class="op">&lt;</span> dist(target, best):</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> point</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    axis <span class="op">=</span> depth <span class="op">%</span> <span class="dv">2</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    next_branch <span class="op">=</span> tree[<span class="st">'left'</span>] <span class="cf">if</span> target[axis] <span class="op">&lt;</span> point[axis] <span class="cf">else</span> tree[<span class="st">'right'</span>]</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> nearest_neighbor(next_branch, target, depth<span class="op">+</span><span class="dv">1</span>, best)</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">4</span>,<span class="dv">4</span>), (<span class="dv">5</span>,<span class="dv">1</span>), (<span class="dv">7</span>,<span class="dv">2</span>)]</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> build_kdtree(points)</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>best_pair <span class="op">=</span> <span class="va">None</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>best_dist <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> nearest_neighbor(tree, p)</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> q <span class="op">!=</span> p:</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> dist(p, q)</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&lt;</span> best_dist:</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>            best_pair <span class="op">=</span> (p, q)</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>            best_dist <span class="op">=</span> d</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Closest pair:"</span>, best_pair, <span class="st">"Distance:"</span>, best_dist)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-conceptual-sketch" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-conceptual-sketch">Tiny Code (C, Conceptual Sketch)</h4>
<p>Building a full KD-tree in C is more elaborate, but core logic:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> dist<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx <span class="op">=</span> a<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">,</span> dy <span class="op">=</span> a<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy<span class="op">);</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Recursively split points along x or y based on depth</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>Node<span class="op">*</span> build_kdtree<span class="op">(</span>Point<span class="op">*</span> points<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> depth<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort by axis, select median as root</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recurse for left and right</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Search nearest neighbor recursively with pruning</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> nearest_neighbor<span class="op">(</span>Node<span class="op">*</span> root<span class="op">,</span> Point target<span class="op">,</span> Point<span class="op">*</span> best<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> bestDist<span class="op">,</span> <span class="dt">int</span> depth<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compare current point, recurse in promising branch</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Backtrack if other branch may contain closer point</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-19" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-19">Why It Matters</h4>
<ul>
<li>Avoids <span class="math inline">\(O(n^2)\)</span> brute-force</li>
<li>Scales well for moderate dimensions (2D, 3D)</li>
<li>Generalizes to range search, radius queries, clustering</li>
</ul>
<p>Applications:</p>
<ul>
<li>Graphics (object proximity, mesh simplification)</li>
<li>Machine learning (k-NN classification)</li>
<li>Robotics (nearest obstacle detection)</li>
<li>Spatial databases (geo queries)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-6" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-6">A Gentle Proof (Why It Works)</h4>
<p>Each recursive partition defines a half-space where points are stored. When searching, we always explore the side containing the query point, but must check the other side if the hypersphere around the query point crosses the partition plane.</p>
<p>Since each level splits data roughly in half, the expected number of visited nodes is <span class="math inline">\(O(\log n)\)</span>. Building the tree is <span class="math inline">\(O(n \log n)\)</span> by recursive median finding.</p>
<p>Overall nearest-pair complexity:</p>
<p><span class="math display">\[
O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-19" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-19">Try It Yourself</h4>
<ol type="1">
<li>Draw 10 random points, compute brute-force pair.</li>
<li>Build a KD-tree manually (alternate x/y).</li>
<li>Trace nearest neighbor search steps.</li>
<li>Compare search order and pruning decisions.</li>
<li>Extend to 3D points.</li>
</ol>
</section>
<section id="test-cases-19" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-19">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0), (1,1), (3,3)</td>
<td>(0,0)-(1,1)</td>
<td><span class="math inline">\(d=\sqrt2\)</span></td>
</tr>
<tr class="even">
<td>(1,1), (2,2), (2,1.1)</td>
<td>(2,2)-(2,1.1)</td>
<td>Closest</td>
</tr>
<tr class="odd">
<td>Random 10 pts</td>
<td>Verified</td>
<td>Matches brute force</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-19" class="level4">
<h4 class="anchored" data-anchor-id="complexity-19">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Nearest Neighbor Pair is geometry’s instinct, finding the closest companionship in a crowded space with elegant divide-and-search reasoning.</p>
</section>
</section>
</section>
<section id="section-73.-line-sweep-and-plane-sweep-algorithms" class="level1">
<h1>Section 73. Line Sweep and Plane Sweep Algorithms</h1>
<section id="sweep-line-for-events" class="level3">
<h3 class="anchored" data-anchor-id="sweep-line-for-events">721 Sweep Line for Events</h3>
<p>The Sweep Line Algorithm is a unifying framework for solving many geometric problems by processing events in sorted order along a moving line (usually vertical). It transforms spatial relationships into a temporal sequence, allowing us to track intersections, overlaps, or active objects efficiently using a dynamic active set.</p>
<p>This paradigm lies at the heart of algorithms like Bentley–Ottmann, closest pair, rectangle union, and skyline problems.</p>
<section id="what-problem-are-we-solving-20" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-20">What Problem Are We Solving?</h4>
<p>We want to process geometric events, points, segments, rectangles, circles, that interact in the plane. The challenge: many spatial problems become simple if we consider only what’s active at a specific sweep position.</p>
<p>For example:</p>
<ul>
<li>In intersection detection, only neighboring segments can intersect.</li>
<li>In rectangle union, only active intervals contribute to total area.</li>
<li>In skyline computation, only the tallest current height matters.</li>
</ul>
<p>So we reformulate the problem:</p>
<blockquote class="blockquote">
<p>Move a sweep line across the plane, handle events one by one, and update the active set as geometry enters or leaves.</p>
</blockquote>
</section>
<section id="how-does-it-work-plain-language-20" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-20">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Event Queue (EQ)</p>
<ul>
<li>All critical points sorted by <span class="math inline">\(x\)</span> (or time).</li>
<li>Each event marks a start, end, or change (like intersection).</li>
</ul></li>
<li><p>Active Set (AS)</p>
<ul>
<li>Stores currently “active” objects that intersect the sweep line.</li>
<li>Maintained in a structure ordered by another coordinate (like <span class="math inline">\(y\)</span>).</li>
</ul></li>
<li><p>Main Loop Process each event in sorted order:</p>
<ul>
<li>Insert new geometry into AS.</li>
<li>Remove expired geometry.</li>
<li>Query or update relationships (neighbors, counts, intersections).</li>
</ul></li>
<li><p>Continue until EQ is empty.</p></li>
</ol>
<p>Each step is logarithmic with balanced trees, so total complexity is <span class="math inline">\(O((n+k)\log n)\)</span>, where <span class="math inline">\(k\)</span> is number of interactions (e.g.&nbsp;intersections).</p>
</section>
<section id="example-walkthrough-18" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-18">Example Walkthrough</h4>
<p>Let’s take line segment intersection as an example:</p>
<p>Segments:</p>
<ul>
<li><span class="math inline">\(S_1: (0,0)\)</span>–<span class="math inline">\((4,4)\)</span></li>
<li><span class="math inline">\(S_2: (0,4)\)</span>–<span class="math inline">\((4,0)\)</span></li>
</ul>
<p>Events: endpoints sorted by <span class="math inline">\(x\)</span>: <span class="math inline">\((0,0)\)</span>, <span class="math inline">\((0,4)\)</span>, <span class="math inline">\((4,0)\)</span>, <span class="math inline">\((4,4)\)</span></p>
<p>Steps:</p>
<ol type="1">
<li>At <span class="math inline">\(x=0\)</span>, insert <span class="math inline">\(S_1\)</span>, <span class="math inline">\(S_2\)</span>.</li>
<li>Check active set order → detect intersection at <span class="math inline">\((2,2)\)</span> → enqueue intersection event.</li>
<li>At <span class="math inline">\(x=2\)</span>, process intersection → swap order in AS.</li>
<li>Continue → all intersections reported.</li>
</ol>
<p>Result: intersection point <span class="math inline">\((2,2)\)</span> found by event-driven sweep.</p>
</section>
<section id="tiny-code-python-sketch-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-1">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sweep_line(events):</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    heapq.heapify(events)  <span class="co"># min-heap by x</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> events:</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>        x, event_type, obj <span class="op">=</span> heapq.heappop(events)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> event_type <span class="op">==</span> <span class="st">'start'</span>:</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>            active.add(obj)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> event_type <span class="op">==</span> <span class="st">'end'</span>:</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>            active.remove(obj)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> event_type <span class="op">==</span> <span class="st">'intersection'</span>:</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Intersection at x ="</span>, x)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># handle neighbors in active set if needed</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<ul>
<li>Fill <code>events</code> with tuples <code>(x, type, object)</code></li>
<li>Insert / remove from <code>active</code> as sweep proceeds</li>
</ul>
</section>
<section id="tiny-code-c-skeleton" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-skeleton">Tiny Code (C Skeleton)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">;</span> <span class="dt">int</span> type<span class="op">;</span> <span class="dt">int</span> id<span class="op">;</span> <span class="op">}</span> Event<span class="op">;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmp<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x1 <span class="op">=</span> <span class="op">((</span>Event<span class="op">*)</span>a<span class="op">)-&gt;</span>x<span class="op">,</span> x2 <span class="op">=</span> <span class="op">((</span>Event<span class="op">*)</span>b<span class="op">)-&gt;</span>x<span class="op">;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>x1 <span class="op">&lt;</span> x2<span class="op">)</span> <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> <span class="op">(</span>x1 <span class="op">&gt;</span> x2<span class="op">);</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sweep_line<span class="op">(</span>Event<span class="op">*</span> events<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>events<span class="op">,</span> n<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Event<span class="op">),</span> cmp<span class="op">);</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>events<span class="op">[</span>i<span class="op">].</span>type <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"Start event at x=</span><span class="sc">%.2f\n</span><span class="st">"</span><span class="op">,</span> events<span class="op">[</span>i<span class="op">].</span>x<span class="op">);</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>events<span class="op">[</span>i<span class="op">].</span>type <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"End event at x=</span><span class="sc">%.2f\n</span><span class="st">"</span><span class="op">,</span> events<span class="op">[</span>i<span class="op">].</span>x<span class="op">);</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-20" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-20">Why It Matters</h4>
<ul>
<li>Universal pattern in computational geometry</li>
<li>Turns 2D problems into sorted 1D scans</li>
<li>Enables efficient detection of intersections, unions, and counts</li>
<li>Used in graphics, GIS, simulation, CAD</li>
</ul>
<p>Applications:</p>
<ul>
<li>Bentley–Ottmann (line intersections)</li>
<li>Rectangle union area</li>
<li>Range counting and queries</li>
<li>Plane subdivision and visibility graphs</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-7" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-7">A Gentle Proof (Why It Works)</h4>
<p>At any moment, only objects crossing the sweep line can influence the outcome. By processing events in sorted order, we guarantee that:</p>
<ul>
<li>Every change in geometric relationships happens at an event.</li>
<li>Between events, the structure of the active set remains stable.</li>
</ul>
<p>Thus, we can maintain local state (neighbors, counts, maxima) incrementally, never revisiting old positions.</p>
<p>For <span class="math inline">\(n\)</span> input elements and <span class="math inline">\(k\)</span> interactions, total cost:</p>
<p><span class="math display">\[
O((n + k)\log n)
\]</span></p>
<p>since each insert, delete, or neighbor check is <span class="math inline">\(O(\log n)\)</span>.</p>
</section>
<section id="try-it-yourself-20" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-20">Try It Yourself</h4>
<ol type="1">
<li>Draw segments and sort endpoints by <span class="math inline">\(x\)</span>.</li>
<li>Sweep a vertical line and track which segments it crosses.</li>
<li>Record every time two segments change order → intersection!</li>
<li>Try rectangles or intervals, observe how active set changes.</li>
</ol>
</section>
<section id="test-cases-20" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-20">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 43%">
<col style="width: 23%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Input</th>
<th>Expected</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2 segments crossing</td>
<td>1 intersection</td>
<td>at center</td>
</tr>
<tr class="even">
<td>3 segments crossing pairwise</td>
<td>3 intersections</td>
<td>all detected</td>
</tr>
<tr class="odd">
<td>Non-overlapping</td>
<td>none</td>
<td>active set stays small</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-20" class="level4">
<h4 class="anchored" data-anchor-id="complexity-20">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O((n + k)\log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The sweep line is geometry’s conveyor belt, sliding across space, updating the world one event at a time.</p>
</section>
</section>
<section id="interval-scheduling" class="level3">
<h3 class="anchored" data-anchor-id="interval-scheduling">722 Interval Scheduling</h3>
<p>The Interval Scheduling algorithm is a cornerstone of greedy optimization on the line. Given a set of time intervals, each representing a job or task, the goal is to select the maximum number of non-overlapping intervals. This simple yet profound algorithm forms the heart of resource allocation, timeline planning, and spatial scheduling problems.</p>
<section id="what-problem-are-we-solving-21" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-21">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> intervals:</p>
<p><span class="math display">\[
I_i = [s_i, f_i), \quad i = 1, \ldots, n
\]</span></p>
<p>we want to find the largest subset of intervals such that no two overlap.<br>
Formally, find <span class="math inline">\(S \subseteq \{1, \ldots, n\}\)</span> such that for all <span class="math inline">\(i, j \in S\)</span>,</p>
<p><span class="math display">\[
[s_i, f_i) \cap [s_j, f_j) = \emptyset
\]</span></p>
<p>and <span class="math inline">\(|S|\)</span> is maximized.</p>
<p>Example:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Interval</th>
<th>Start</th>
<th>Finish</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(I_1\)</span></td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td><span class="math inline">\(I_2\)</span></td>
<td>3</td>
<td>5</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(I_3\)</span></td>
<td>0</td>
<td>6</td>
</tr>
<tr class="even">
<td><span class="math inline">\(I_4\)</span></td>
<td>5</td>
<td>7</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(I_5\)</span></td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>Optimal schedule: <span class="math inline">\(I_1, I_4, I_5\)</span> (3 intervals)</p>
</section>
<section id="how-does-it-work-plain-language-21" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-21">How Does It Work (Plain Language)?</h4>
<p>The greedy insight:</p>
<blockquote class="blockquote">
<p>Always pick the interval that finishes earliest, then discard all overlapping ones, and repeat.</p>
</blockquote>
<p>Reasoning:</p>
<ul>
<li>Finishing early leaves more room for future tasks.<br>
</li>
<li>No earlier finish can increase the count; it only blocks later intervals.</li>
</ul>
</section>
<section id="algorithm-greedy-strategy" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-greedy-strategy">Algorithm (Greedy Strategy)</h4>
<ol type="1">
<li><p>Sort intervals by finishing time <span class="math inline">\(f_i\)</span>.</p></li>
<li><p>Initialize empty set <span class="math inline">\(S\)</span>.</p></li>
<li><p>For each interval <span class="math inline">\(I_i\)</span> in order:</p>
<ul>
<li>If <span class="math inline">\(I_i\)</span> starts after or at the finish time of last selected interval → select it.</li>
</ul></li>
<li><p>Return <span class="math inline">\(S\)</span>.</p></li>
</ol>
</section>
<section id="example-walkthrough-19" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-19">Example Walkthrough</h4>
<p>Input: <span class="math inline">\((1,4), (3,5), (0,6), (5,7), (8,9)\)</span></p>
<ol type="1">
<li><p>Sort by finish: <span class="math inline">\((1,4), (3,5), (0,6), (5,7), (8,9)\)</span></p></li>
<li><p>Start with <span class="math inline">\((1,4)\)</span></p>
<ul>
<li>Next <span class="math inline">\((3,5)\)</span> overlaps → skip</li>
<li><span class="math inline">\((0,6)\)</span> overlaps → skip</li>
<li><span class="math inline">\((5,7)\)</span> fits → select</li>
<li><span class="math inline">\((8,9)\)</span> fits → select</li>
</ul></li>
</ol>
<p>Output: <span class="math inline">\((1,4), (5,7), (8,9)\)</span></p>
</section>
<section id="tiny-code-python-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-6">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interval_scheduling(intervals):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    intervals.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])  <span class="co"># sort by finish time</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    selected <span class="op">=</span> []</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    current_end <span class="op">=</span> <span class="bu">float</span>(<span class="st">'-inf'</span>)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (s, f) <span class="kw">in</span> intervals:</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s <span class="op">&gt;=</span> current_end:</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>            selected.append((s, f))</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>            current_end <span class="op">=</span> f</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> selected</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">0</span>,<span class="dv">6</span>),(<span class="dv">5</span>,<span class="dv">7</span>),(<span class="dv">8</span>,<span class="dv">9</span>)]</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optimal schedule:"</span>, interval_scheduling(intervals))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-3">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> s<span class="op">,</span> f<span class="op">;</span> <span class="op">}</span> Interval<span class="op">;</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmp<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">((</span>Interval<span class="op">*)</span>a<span class="op">)-&gt;</span>f <span class="op">-</span> <span class="op">((</span>Interval<span class="op">*)</span>b<span class="op">)-&gt;</span>f<span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> interval_scheduling<span class="op">(</span>Interval arr<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>arr<span class="op">,</span> n<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Interval<span class="op">),</span> cmp<span class="op">);</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> last_finish <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">].</span>s <span class="op">&gt;=</span> last_finish<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"(</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> arr<span class="op">[</span>i<span class="op">].</span>s<span class="op">,</span> arr<span class="op">[</span>i<span class="op">].</span>f<span class="op">);</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>            last_finish <span class="op">=</span> arr<span class="op">[</span>i<span class="op">].</span>f<span class="op">;</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    Interval arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">3</span><span class="op">,</span><span class="dv">5</span><span class="op">},{</span><span class="dv">0</span><span class="op">,</span><span class="dv">6</span><span class="op">},{</span><span class="dv">5</span><span class="op">,</span><span class="dv">7</span><span class="op">},{</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span><span class="op">}};</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    interval_scheduling<span class="op">(</span>arr<span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-21" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-21">Why It Matters</h4>
<ul>
<li>Greedy proof: earliest finishing interval never harms optimality</li>
<li>Foundation for resource scheduling, CPU job selection, meeting room planning</li>
<li>Basis for weighted variants, interval partitioning, segment trees</li>
</ul>
<p>Applications:</p>
<ul>
<li>CPU process scheduling</li>
<li>Railway or runway slot allocation</li>
<li>Event planning and booking systems</li>
<li>Non-overlapping task assignment</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-8" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-8">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(S^*\)</span> be an optimal solution, and <span class="math inline">\(I_g\)</span> be the earliest finishing interval chosen by the greedy algorithm. We can transform <span class="math inline">\(S^*\)</span> so that it also includes <span class="math inline">\(I_g\)</span> without reducing its size, by replacing any overlapping interval with <span class="math inline">\(I_g\)</span>.</p>
<p>Hence by induction:</p>
<ul>
<li>The greedy algorithm always finds an optimal subset.</li>
</ul>
<p>Total running time is dominated by sorting:</p>
<p><span class="math display">\[
O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-21" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-21">Try It Yourself</h4>
<ol type="1">
<li>Draw intervals on a line, simulate greedy selection.</li>
<li>Add overlapping intervals and see which get skipped.</li>
<li>Compare to a brute-force approach (check all subsets).</li>
<li>Extend to weighted interval scheduling (with DP).</li>
</ol>
</section>
<section id="test-cases-21" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-21">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Intervals</th>
<th>Optimal Schedule</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(1,4),(3,5),(0,6),(5,7),(8,9)</td>
<td>(1,4),(5,7),(8,9)</td>
<td>3</td>
</tr>
<tr class="even">
<td>(0,2),(1,3),(2,4),(3,5)</td>
<td>(0,2),(2,4)</td>
<td>2</td>
</tr>
<tr class="odd">
<td>(1,10),(2,3),(3,4),(4,5)</td>
<td>(2,3),(3,4),(4,5)</td>
<td>3</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-21" class="level4">
<h4 class="anchored" data-anchor-id="complexity-21">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(1)
\]</span></p>
<p>The Interval Scheduling algorithm is the epitome of greedy elegance, choosing the earliest finish, one decision at a time, to paint the longest non-overlapping path across the timeline.</p>
</section>
</section>
<section id="rectangle-union-area" class="level3">
<h3 class="anchored" data-anchor-id="rectangle-union-area">723 Rectangle Union Area</h3>
<p>The Rectangle Union Area algorithm computes the total area covered by a set of axis-aligned rectangles. Overlaps should be counted only once, even if multiple rectangles cover the same region.</p>
<p>This problem is a classic demonstration of the sweep line technique combined with interval management, transforming a 2D geometry question into a sequence of 1D range computations.</p>
<section id="what-problem-are-we-solving-22" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-22">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> rectangles aligned with coordinate axes, each rectangle <span class="math inline">\(R_i = [x_1, x_2) \times [y_1, y_2)\)</span>,</p>
<p>we want to compute the total area of their union:</p>
<p><span class="math display">\[
A = \text{area}\left(\bigcup_{i=1}^n R_i\right)
\]</span></p>
<p>Overlapping regions must only be counted once. Brute-force grid enumeration is too expensive, we need a geometric, event-driven approach.</p>
</section>
<section id="how-does-it-work-plain-language-22" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-22">How Does It Work (Plain Language)?</h4>
<p>We use a vertical sweep line across the <span class="math inline">\(x\)</span>-axis:</p>
<ol type="1">
<li><p>Events: Each rectangle generates two events:</p>
<ul>
<li>at <span class="math inline">\(x_1\)</span>: add vertical interval <span class="math inline">\([y_1, y_2)\)</span></li>
<li>at <span class="math inline">\(x_2\)</span>: remove vertical interval <span class="math inline">\([y_1, y_2)\)</span></li>
</ul></li>
<li><p>Active Set: During the sweep, maintain a structure storing active y-intervals, representing where the sweep line currently intersects rectangles.</p></li>
<li><p>Area Accumulation: As the sweep line moves from <span class="math inline">\(x_i\)</span> to <span class="math inline">\(x_{i+1}\)</span>, the covered y-length (<span class="math inline">\(L\)</span>) is computed from the active set, and the contributed area is:</p>
<p><span class="math display">\[
A += L \times (x_{i+1} - x_i)
\]</span></p></li>
</ol>
<p>By processing all <span class="math inline">\(x\)</span>-events in sorted order, we capture all additions/removals and accumulate exact area.</p>
</section>
<section id="example-walkthrough-20" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-20">Example Walkthrough</h4>
<p>Rectangles:</p>
<ol type="1">
<li><span class="math inline">\((1, 1, 3, 3)\)</span></li>
<li><span class="math inline">\((2, 2, 4, 4)\)</span></li>
</ol>
<p>Events:</p>
<ul>
<li><span class="math inline">\(x=1\)</span>: add [1,3]</li>
<li><span class="math inline">\(x=2\)</span>: add [2,4]</li>
<li><span class="math inline">\(x=3\)</span>: remove [1,3]</li>
<li><span class="math inline">\(x=4\)</span>: remove [2,4]</li>
</ul>
<p>Step-by-step:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Interval</th>
<th>x-range</th>
<th>y-covered</th>
<th>Area</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[1,3]</td>
<td>1→2</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>[1,3]+[2,4] → merge [1,4]</td>
<td>2→3</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>[2,4]</td>
<td>3→4</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Total area = 2 + 3 + 2 = 7</p>
</section>
<section id="tiny-code-python-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-7">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> union_area(rectangles):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x1, y1, x2, y2) <span class="kw">in</span> rectangles:</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        events.append((x1, <span class="dv">1</span>, y1, y2))  <span class="co"># start</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>        events.append((x2, <span class="op">-</span><span class="dv">1</span>, y1, y2)) <span class="co"># end</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    events.sort()  <span class="co"># sort by x</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_y_length(active):</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># merge intervals</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        merged, last_y2, total <span class="op">=</span> [], <span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>), <span class="dv">0</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> y1, y2 <span class="kw">in</span> <span class="bu">sorted</span>(active):</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>            y1 <span class="op">=</span> <span class="bu">max</span>(y1, last_y2)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> y2 <span class="op">&gt;</span> y1:</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>                total <span class="op">+=</span> y2 <span class="op">-</span> y1</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>                last_y2 <span class="op">=</span> y2</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>    active, prev_x, area <span class="op">=</span> [], <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, typ, y1, y2 <span class="kw">in</span> events:</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>        area <span class="op">+=</span> compute_y_length(active) <span class="op">*</span> (x <span class="op">-</span> prev_x)</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>            active.append((y1, y2))</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>            active.remove((y1, y2))</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>        prev_x <span class="op">=</span> x</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> area</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>rects <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>)]</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Union area:"</span>, union_area(rects))  <span class="co"># 7</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-conceptual" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-conceptual">Tiny Code (C, Conceptual)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb37"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">;</span> <span class="dt">int</span> type<span class="op">;</span> <span class="dt">double</span> y1<span class="op">,</span> y2<span class="op">;</span> <span class="op">}</span> Event<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>Sort events by <span class="math inline">\(x\)</span></li>
<li>Maintain active intervals (linked list or segment tree)</li>
<li>Compute merged <span class="math inline">\(y\)</span>-length and accumulate <span class="math inline">\(L \times \Delta x\)</span></li>
</ul>
<p>Efficient implementations use segment trees to track coverage counts and total length in <span class="math inline">\(O(\log n)\)</span> per update.</p>
</section>
<section id="why-it-matters-22" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-22">Why It Matters</h4>
<ul>
<li>Foundational for computational geometry, GIS, graphics</li>
<li>Handles union area, perimeter, volume (higher-dim analogues)</li>
<li>Basis for collision areas, coverage computation, map overlays</li>
</ul>
<p>Applications:</p>
<ul>
<li>Rendering overlapping rectangles</li>
<li>Land or parcel union areas</li>
<li>Collision detection (2D bounding boxes)</li>
<li>CAD and layout design tools</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-9" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-9">A Gentle Proof (Why It Works)</h4>
<p>At each sweep position, all changes occur at event boundaries (<span class="math inline">\(x_i\)</span>). Between <span class="math inline">\(x_i\)</span> and <span class="math inline">\(x_{i+1}\)</span>, the set of active intervals remains fixed. Hence, area can be computed incrementally:</p>
<p><span class="math display">\[
A = \sum_{i} L_i \cdot (x_{i+1} - x_i)
\]</span></p>
<p>where <span class="math inline">\(L_i\)</span> is total <span class="math inline">\(y\)</span>-length covered at <span class="math inline">\(x_i\)</span>. Since every insertion/removal updates only local intervals, correctness follows from maintaining the union of active intervals.</p>
</section>
<section id="try-it-yourself-22" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-22">Try It Yourself</h4>
<ol type="1">
<li>Draw 2–3 overlapping rectangles.</li>
<li>List their <span class="math inline">\(x\)</span>-events.</li>
<li>Sweep and track active <span class="math inline">\(y\)</span>-intervals.</li>
<li>Merge overlaps to compute <span class="math inline">\(L_i\)</span>.</li>
<li>Multiply by <span class="math inline">\(\Delta x\)</span> for each step.</li>
</ol>
</section>
<section id="test-cases-22" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-22">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Rectangles</th>
<th>Expected Area</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(1,1,3,3), (2,2,4,4)</td>
<td>7</td>
<td>partial overlap</td>
</tr>
<tr class="even">
<td>(0,0,1,1), (1,0,2,1)</td>
<td>2</td>
<td>disjoint</td>
</tr>
<tr class="odd">
<td>(0,0,2,2), (1,1,3,3)</td>
<td>7</td>
<td>overlap at corner</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-22" class="level4">
<h4 class="anchored" data-anchor-id="complexity-22">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Rectangle Union Area algorithm turns a complex 2D union into a 1D sweep with active interval merging, precise, elegant, and scalable.</p>
</section>
</section>
<section id="segment-intersection-bentleyottmann-variant" class="level3">
<h3 class="anchored" data-anchor-id="segment-intersection-bentleyottmann-variant">724 Segment Intersection (Bentley–Ottmann Variant)</h3>
<p>The Segment Intersection problem asks us to find all intersection points among a set of <span class="math inline">\(n\)</span> line segments in the plane. The Bentley–Ottmann algorithm is the canonical sweep line approach, improving naive <span class="math inline">\(O(n^2)\)</span> pairwise checking to</p>
<p><span class="math display">\[
O\big((n + k)\log n\big)
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is the number of intersection points.</p>
<p>This variant is a direct application of the event-driven sweep line method specialized for segments.</p>
<section id="what-problem-are-we-solving-23" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-23">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> line segments</p>
<p><span class="math display">\[
S = { s_1, s_2, \ldots, s_n }
\]</span></p>
<p>we want to compute the set of all intersection points between any two segments. We need both which segments intersect and where.</p>
</section>
<section id="naive-vs.-sweep-line" class="level4">
<h4 class="anchored" data-anchor-id="naive-vs.-sweep-line">Naive vs.&nbsp;Sweep Line</h4>
<ul>
<li><p>Naive approach: Check all <span class="math inline">\(\binom{n}{2}\)</span> pairs → <span class="math inline">\(O(n^2)\)</span> time. Even for small <span class="math inline">\(n\)</span>, this is wasteful when few intersections exist.</p></li>
<li><p>Sweep Line (Bentley–Ottmann):</p>
<ul>
<li>Process events in increasing <span class="math inline">\(x\)</span> order</li>
<li>Maintain active segments ordered by <span class="math inline">\(y\)</span></li>
<li>Only neighboring segments can intersect → local checks only</li>
</ul></li>
</ul>
<p>This turns a quadratic search into an output-sensitive algorithm.</p>
</section>
<section id="how-does-it-work-plain-language-23" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-23">How Does It Work (Plain Language)</h4>
<p>We move a vertical sweep line from left to right, handling three event types:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Event Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Start</td>
<td>Add segment to active set</td>
</tr>
<tr class="even">
<td>End</td>
<td>Remove segment from active set</td>
</tr>
<tr class="odd">
<td>Intersection</td>
<td>Two segments cross; record point, swap order</td>
</tr>
</tbody>
</table>
<p>The active set is kept sorted by segment height (<span class="math inline">\(y\)</span>) at the sweep line. When a new segment is inserted, we only test its neighbors for intersection. After a swap, we only test new adjacent pairs.</p>
</section>
<section id="example-walkthrough-21" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-21">Example Walkthrough</h4>
<p>Segments:</p>
<ul>
<li><span class="math inline">\(S_1: (0,0)\)</span>–<span class="math inline">\((4,4)\)</span></li>
<li><span class="math inline">\(S_2: (0,4)\)</span>–<span class="math inline">\((4,0)\)</span></li>
<li><span class="math inline">\(S_3: (1,0)\)</span>–<span class="math inline">\((1,3)\)</span></li>
</ul>
<p>Event queue (sorted by <span class="math inline">\(x\)</span>): <span class="math inline">\((0,0)\)</span>, <span class="math inline">\((0,4)\)</span>, <span class="math inline">\((1,0)\)</span>, <span class="math inline">\((1,3)\)</span>, <span class="math inline">\((4,0)\)</span>, <span class="math inline">\((4,4)\)</span></p>
<ol type="1">
<li><span class="math inline">\(x=0\)</span>: Insert <span class="math inline">\(S_1\)</span>, <span class="math inline">\(S_2\)</span> → check pair → intersection <span class="math inline">\((2,2)\)</span> found.</li>
<li><span class="math inline">\(x=1\)</span>: Insert <span class="math inline">\(S_3\)</span>, check with neighbors, no new intersections.</li>
<li><span class="math inline">\(x=2\)</span>: Process intersection <span class="math inline">\((2,2)\)</span>, swap order of <span class="math inline">\(S_1\)</span>, <span class="math inline">\(S_2\)</span>.</li>
<li>Continue → remove as sweep passes segment ends.</li>
</ol>
<p>Output: intersection point <span class="math inline">\((2,2)\)</span>.</p>
</section>
<section id="geometric-test-orientation" class="level4">
<h4 class="anchored" data-anchor-id="geometric-test-orientation">Geometric Test: Orientation</h4>
<p>Given segments <span class="math inline">\(AB\)</span> and <span class="math inline">\(CD\)</span>, they intersect if and only if</p>
<p><span class="math display">\[
\text{orient}(A, B, C) \ne \text{orient}(A, B, D)
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\text{orient}(C, D, A) \ne \text{orient}(C, D, B)
\]</span></p>
<p>This uses cross product orientation to test if points are on opposite sides.</p>
</section>
<section id="tiny-code-python-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-8">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orient(a, b, c):</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(a, b, c, d):</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    o1 <span class="op">=</span> orient(a, b, c)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    o2 <span class="op">=</span> orient(a, b, d)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    o3 <span class="op">=</span> orient(c, d, a)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    o4 <span class="op">=</span> orient(c, d, b)</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> o1<span class="op">*</span>o2 <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">and</span> o3<span class="op">*</span>o4 <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bentley_ottmann(segments):</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> segments:</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>        (x1,y1),(x2,y2) <span class="op">=</span> s</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x1 <span class="op">&gt;</span> x2:</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> ((x2,y2),(x1,y1))</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>        events.append((x1, <span class="st">'start'</span>, s))</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>        events.append((x2, <span class="st">'end'</span>, s))</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    heapq.heapify(events)</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    active, intersections <span class="op">=</span> [], []</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> events:</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>        x, typ, seg <span class="op">=</span> heapq.heappop(events)</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="st">'start'</span>:</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>            active.append(seg)</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> other <span class="kw">in</span> active:</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> other <span class="op">!=</span> seg <span class="kw">and</span> intersect(seg[<span class="dv">0</span>], seg[<span class="dv">1</span>], other[<span class="dv">0</span>], other[<span class="dv">1</span>]):</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>                    intersections.append(x)</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> typ <span class="op">==</span> <span class="st">'end'</span>:</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>            active.remove(seg)</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> intersections</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>segments <span class="op">=</span> [((<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">4</span>,<span class="dv">4</span>)), ((<span class="dv">0</span>,<span class="dv">4</span>),(<span class="dv">4</span>,<span class="dv">0</span>)), ((<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">3</span>))]</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Intersections:"</span>, bentley_ottmann(segments))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-23" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-23">Why It Matters</h4>
<ul>
<li>Output-sensitive: scales with actual number of intersections</li>
<li>Core of geometry engines, CAD tools, and graphics pipelines</li>
<li>Used in polygon clipping, mesh overlay, and map intersection</li>
</ul>
<p>Applications:</p>
<ul>
<li>Detecting segment crossings in vector maps</li>
<li>Overlaying geometric layers in GIS</li>
<li>Path intersection detection (roads, wires, edges)</li>
<li>Preprocessing for triangulation and visibility graphs</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-10" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-10">A Gentle Proof (Why It Works)</h4>
<p>Every intersection event corresponds to a swap in the vertical order of segments. Since order changes only at intersections, all are discovered by processing:</p>
<ol type="1">
<li>Insertions/Deletions (start/end events)</li>
<li>Swaps (intersection events)</li>
</ol>
<p>We never miss or duplicate an intersection because only neighboring pairs can intersect between events.</p>
<p>Total operations:</p>
<ul>
<li><span class="math inline">\(n\)</span> starts, <span class="math inline">\(n\)</span> ends, <span class="math inline">\(k\)</span> intersections → <span class="math inline">\(O(n + k)\)</span> events</li>
<li>Each event uses <span class="math inline">\(O(\log n)\)</span> operations (heap/tree)</li>
</ul>
<p>Therefore</p>
<p><span class="math display">\[
O\big((n + k)\log n\big)
\]</span></p>
</section>
<section id="try-it-yourself-23" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-23">Try It Yourself</h4>
<ol type="1">
<li>Draw segments with multiple crossings.</li>
<li>Sort endpoints by <span class="math inline">\(x\)</span>.</li>
<li>Sweep and maintain ordered active set.</li>
<li>Record intersections as swaps occur.</li>
<li>Compare with brute-force pair checking.</li>
</ol>
</section>
<section id="test-cases-23" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-23">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Segments</th>
<th>Intersections</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Diagonals of square</td>
<td>1</td>
</tr>
<tr class="even">
<td>Grid crossings</td>
<td>Multiple</td>
</tr>
<tr class="odd">
<td>Parallel lines</td>
<td>0</td>
</tr>
<tr class="even">
<td>Random segments</td>
<td>Verified</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-23" class="level4">
<h4 class="anchored" data-anchor-id="complexity-23">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O((n + k)\log n), \quad \text{Space: } O(n + k)
\]</span></p>
<p>The Bentley–Ottmann variant of segment intersection is the benchmark technique, a precise dance of events and swaps that captures every crossing once, and only once.</p>
</section>
</section>
<section id="skyline-problem" class="level3">
<h3 class="anchored" data-anchor-id="skyline-problem">725 Skyline Problem</h3>
<p>The Skyline Problem is a classic geometric sweep line challenge: given a collection of rectangular buildings in a cityscape, compute the outline (or silhouette) that forms the skyline when viewed from afar.</p>
<p>This is a quintessential divide-and-conquer and line sweep example, converting overlapping rectangles into a piecewise height function that rises and falls as the sweep progresses.</p>
<section id="what-problem-are-we-solving-24" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-24">What Problem Are We Solving?</h4>
<p>Each building <span class="math inline">\(B_i\)</span> is defined by three numbers:</p>
<p><span class="math display">\[
B_i = (x_{\text{left}}, x_{\text{right}}, h)
\]</span></p>
<p>We want to compute the skyline, a sequence of critical points:</p>
<p><span class="math display">\[
\]</span>(x_1, h_1), (x_2, h_2), , (x_m, 0)] $$</p>
<p>such that the upper contour of all buildings is traced exactly once.</p>
<p>Example input:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Building</th>
<th>Left</th>
<th>Right</th>
<th>Height</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>9</td>
<td>10</td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td>7</td>
<td>15</td>
</tr>
<tr class="odd">
<td>3</td>
<td>5</td>
<td>12</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>Output:</p>
<p><span class="math display">\[
\]</span>(2,10), (3,15), (7,12), (12,0)] $$</p>
</section>
<section id="how-does-it-work-plain-language-24" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-24">How Does It Work (Plain Language)</h4>
<p>The skyline changes only at building edges, left or right sides. We treat each edge as an event in a sweep line moving from left to right:</p>
<ol type="1">
<li>At left edge (<span class="math inline">\(x_\text{left}\)</span>): add building height to active set.</li>
<li>At right edge (<span class="math inline">\(x_\text{right}\)</span>): remove height from active set.</li>
<li>After each event, the skyline height = max(active set).</li>
<li>If height changes, append <span class="math inline">\((x, h)\)</span> to result.</li>
</ol>
<p>This efficiently constructs the outline by tracking current tallest building.</p>
</section>
<section id="example-walkthrough-22" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-22">Example Walkthrough</h4>
<p>Input: <span class="math inline">\((2,9,10), (3,7,15), (5,12,12)\)</span></p>
<p>Events:</p>
<ul>
<li>(2, start, 10)</li>
<li>(3, start, 15)</li>
<li>(5, start, 12)</li>
<li>(7, end, 15)</li>
<li>(9, end, 10)</li>
<li>(12, end, 12)</li>
</ul>
<p>Steps:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>x</th>
<th>Event</th>
<th>Active Heights</th>
<th>Max Height</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>Start 10</td>
<td>{10}</td>
<td>10</td>
<td>(2,10)</td>
</tr>
<tr class="even">
<td>3</td>
<td>Start 15</td>
<td>{10,15}</td>
<td>15</td>
<td>(3,15)</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Start 12</td>
<td>{10,15,12}</td>
<td>15</td>
<td>–</td>
</tr>
<tr class="even">
<td>7</td>
<td>End 15</td>
<td>{10,12}</td>
<td>12</td>
<td>(7,12)</td>
</tr>
<tr class="odd">
<td>9</td>
<td>End 10</td>
<td>{12}</td>
<td>12</td>
<td>–</td>
</tr>
<tr class="even">
<td>12</td>
<td>End 12</td>
<td>{}</td>
<td>0</td>
<td>(12,0)</td>
</tr>
</tbody>
</table>
<p>Output skyline: <span class="math display">\[
\]</span>(2,10), (3,15), (7,12), (12,0)] $$</p>
</section>
<section id="tiny-code-python-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-9">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> skyline(buildings):</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> L, R, H <span class="kw">in</span> buildings:</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>        events.append((L, <span class="op">-</span>H))  <span class="co"># start</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>        events.append((R, H))   <span class="co"># end</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    events.sort()</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    heap <span class="op">=</span> [<span class="dv">0</span>]  <span class="co"># max-heap (store negatives)</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    prev_max <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> {}</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, h <span class="kw">in</span> events:</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> h <span class="op">&lt;</span> <span class="dv">0</span>:  <span class="co"># start</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(heap, h)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:      <span class="co"># end</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>            active[h] <span class="op">=</span> active.get(h, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span>  <span class="co"># mark for removal</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Clean up ended heights</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> heap <span class="kw">and</span> active.get(<span class="op">-</span>heap[<span class="dv">0</span>], <span class="dv">0</span>):</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>            active[<span class="op">-</span>heap[<span class="dv">0</span>]] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> active[<span class="op">-</span>heap[<span class="dv">0</span>]] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>                <span class="kw">del</span> active[<span class="op">-</span>heap[<span class="dv">0</span>]]</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>            heapq.heappop(heap)</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>        curr_max <span class="op">=</span> <span class="op">-</span>heap[<span class="dv">0</span>]</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> curr_max <span class="op">!=</span> prev_max:</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>            result.append((x, curr_max))</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>            prev_max <span class="op">=</span> curr_max</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>buildings <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">9</span>,<span class="dv">10</span>), (<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">15</span>), (<span class="dv">5</span>,<span class="dv">12</span>,<span class="dv">12</span>)]</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Skyline:"</span>, skyline(buildings))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-conceptual-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-conceptual-1">Tiny Code (C, Conceptual)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> x<span class="op">,</span> h<span class="op">,</span> type<span class="op">;</span> <span class="op">}</span> Event<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol type="1">
<li>Sort events by <span class="math inline">\(x\)</span> (and height for tie-breaking).</li>
<li>Use balanced tree (multiset) to maintain active heights.</li>
<li>On start, insert height; on end, remove height.</li>
<li>Record changes in max height as output points.</li>
</ol>
</section>
<section id="why-it-matters-24" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-24">Why It Matters</h4>
<ul>
<li>Demonstrates event-based sweeping with priority queues</li>
<li>Core in rendering, city modeling, interval aggregation</li>
<li>Dual of rectangle union, here we care about upper contour, not area</li>
</ul>
<p>Applications:</p>
<ul>
<li>Cityscape rendering</li>
<li>Range aggregation visualization</li>
<li>Histogram or bar merge outlines</li>
<li>Shadow or coverage profiling</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-11" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-11">A Gentle Proof (Why It Works)</h4>
<p>The skyline changes only at edges, since interior points are covered continuously. Between edges, the set of active buildings is constant, so the max height is constant.</p>
<p>By processing all edges in order and recording each height change, we reconstruct the exact upper envelope.</p>
<p>Each insertion/removal is <span class="math inline">\(O(\log n)\)</span> (heap), and there are <span class="math inline">\(2n\)</span> events:</p>
<p><span class="math display">\[
O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-24" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-24">Try It Yourself</h4>
<ol type="1">
<li>Draw 2–3 overlapping buildings.</li>
<li>Sort all edges by <span class="math inline">\(x\)</span>.</li>
<li>Sweep and track active heights.</li>
<li>Record output every time the max height changes.</li>
<li>Verify with manual outline tracing.</li>
</ol>
</section>
<section id="test-cases-24" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-24">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Buildings</th>
<th>Skyline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(2,9,10),(3,7,15),(5,12,12)</td>
<td>(2,10),(3,15),(7,12),(12,0)</td>
</tr>
<tr class="even">
<td>(1,3,3),(2,4,4),(5,6,1)</td>
<td>(1,3),(2,4),(4,0),(5,1),(6,0)</td>
</tr>
<tr class="odd">
<td>(1,2,1),(2,3,2),(3,4,3)</td>
<td>(1,1),(2,2),(3,3),(4,0)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-24" class="level4">
<h4 class="anchored" data-anchor-id="complexity-24">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Skyline Problem captures the rising and falling rhythm of geometry, a stepwise silhouette built from overlapping shapes and the elegance of sweeping through events.</p>
</section>
</section>
<section id="closest-pair-sweep" class="level3">
<h3 class="anchored" data-anchor-id="closest-pair-sweep">726 Closest Pair Sweep</h3>
<p>The Closest Pair Sweep algorithm finds the minimum distance between any two points in the plane using a sweep line and an active set. It’s one of the most elegant examples of combining sorting, geometry, and locality, transforming an <span class="math inline">\(O(n^2)\)</span> search into an <span class="math inline">\(O(n \log n)\)</span> algorithm.</p>
<section id="what-problem-are-we-solving-25" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-25">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {p_1, p_2, \ldots, p_n}\)</span> in the plane, find two distinct points <span class="math inline">\((p_i, p_j)\)</span> such that their Euclidean distance is minimal:</p>
<p><span class="math display">\[
d(p_i, p_j) = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}
\]</span></p>
<p>We want both the distance and the pair that achieves it.</p>
<p>A naive <span class="math inline">\(O(n^2)\)</span> algorithm checks all pairs. We’ll do better using a sweep line and spatial pruning.</p>
</section>
<section id="how-does-it-work-plain-language-25" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-25">How Does It Work (Plain Language)</h4>
<p>The key insight: When sweeping from left to right, only points within a narrow vertical strip can be the closest pair.</p>
<p>Algorithm outline:</p>
<ol type="1">
<li><p>Sort points by <span class="math inline">\(x\)</span>-coordinate.</p></li>
<li><p>Maintain an active set (ordered by <span class="math inline">\(y\)</span>) of points within the current strip width (equal to best distance found so far).</p></li>
<li><p>For each new point:</p>
<ul>
<li>Remove points with <span class="math inline">\(x\)</span> too far left.</li>
<li>Compare only to points within <span class="math inline">\(\delta\)</span> vertically, where <span class="math inline">\(\delta\)</span> is current best distance.</li>
<li>Update best distance if smaller found.</li>
</ul></li>
<li><p>Continue until all points processed.</p></li>
</ol>
<p>This works because in a <span class="math inline">\(\delta \times 2\delta\)</span> strip, at most 6 points can be close enough to improve the best distance.</p>
</section>
<section id="example-walkthrough-23" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-23">Example Walkthrough</h4>
<p>Points: <span class="math display">\[
P = {(1,1), (2,3), (3,2), (5,5)}
\]</span></p>
<ol type="1">
<li><p>Sort by <span class="math inline">\(x\)</span>: <span class="math inline">\((1,1), (2,3), (3,2), (5,5)\)</span></p></li>
<li><p>Start with first point <span class="math inline">\((1,1)\)</span></p></li>
<li><p>Add <span class="math inline">\((2,3)\)</span> → <span class="math inline">\(d=\sqrt{5}\)</span></p></li>
<li><p>Add <span class="math inline">\((3,2)\)</span> → compare with last 2 points</p>
<ul>
<li><span class="math inline">\(d((2,3),(3,2)) = \sqrt{2}\)</span> → best <span class="math inline">\(\delta = \sqrt{2}\)</span></li>
</ul></li>
<li><p>Add <span class="math inline">\((5,5)\)</span> → <span class="math inline">\(x\)</span> difference &gt; <span class="math inline">\(\delta\)</span> from <span class="math inline">\((1,1)\)</span>, remove it</p>
<ul>
<li>Compare <span class="math inline">\((5,5)\)</span> with <span class="math inline">\((2,3),(3,2)\)</span> → no smaller found</li>
</ul></li>
</ol>
<p>Output: closest pair <span class="math inline">\((2,3),(3,2)\)</span>, distance <span class="math inline">\(\sqrt{2}\)</span>.</p>
</section>
<section id="tiny-code-python-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-10">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> bisect</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(a, b):</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt((a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>])<span class="dv">2</span> <span class="op">+</span> (a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])<span class="dv">2</span>)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closest_pair(points):</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    points.sort()  <span class="co"># sort by x</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    best_pair <span class="op">=</span> <span class="va">None</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> []  <span class="co"># sorted by y</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>(points):</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> p</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (x <span class="op">-</span> points[j][<span class="dv">0</span>]) <span class="op">&gt;</span> best:</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>            active.remove(points[j])</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> bisect.bisect_left(active, (y <span class="op">-</span> best, <span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>)))</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pos <span class="op">&lt;</span> <span class="bu">len</span>(active) <span class="kw">and</span> active[pos][<span class="dv">0</span>] <span class="op">&lt;=</span> y <span class="op">+</span> best:</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>            d <span class="op">=</span> dist(p, active[pos])</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&lt;</span> best:</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>                best, best_pair <span class="op">=</span> d, (p, active[pos])</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>        bisect.insort(active, p)</span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best, best_pair</span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">2</span>,<span class="dv">3</span>), (<span class="dv">3</span>,<span class="dv">2</span>), (<span class="dv">5</span>,<span class="dv">5</span>)]</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Closest pair:"</span>, closest_pair(points))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-conceptual-sketch-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-conceptual-sketch-1">Tiny Code (C, Conceptual Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x<span class="op">,</span> y<span class="op">;</span> <span class="op">}</span> Point<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> dist<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dx <span class="op">=</span> a<span class="op">.</span>x <span class="op">-</span> b<span class="op">.</span>x<span class="op">,</span> dy <span class="op">=</span> a<span class="op">.</span>y <span class="op">-</span> b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy<span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Sort by x, maintain active set (balanced BST by y)</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">// For each new point, remove far x, search nearby y, update best distance</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Efficient implementations use balanced search trees or ordered lists.</p>
</section>
<section id="why-it-matters-25" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-25">Why It Matters</h4>
<ul>
<li>Classic in computational geometry</li>
<li>Combines sorting + sweeping + local search</li>
<li>Model for spatial algorithms using geometric pruning</li>
</ul>
<p>Applications:</p>
<ul>
<li>Nearest neighbor search</li>
<li>Clustering and pattern recognition</li>
<li>Motion planning (min separation)</li>
<li>Spatial indexing and range queries</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-12" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-12">A Gentle Proof (Why It Works)</h4>
<p>At each step, points farther than <span class="math inline">\(\delta\)</span> in <span class="math inline">\(x\)</span> cannot improve the best distance. In the <span class="math inline">\(\delta\)</span>-strip, each point has at most 6 neighbors (packing argument in a <span class="math inline">\(\delta \times \delta\)</span> grid). Thus, total comparisons are linear after sorting.</p>
<p>Overall complexity:</p>
<p><span class="math display">\[
O(n \log n)
\]</span></p>
<p>from initial sort and logarithmic insertions/removals.</p>
</section>
<section id="try-it-yourself-25" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-25">Try It Yourself</h4>
<ol type="1">
<li>Plot a few points.</li>
<li>Sort by <span class="math inline">\(x\)</span>.</li>
<li>Sweep from left to right.</li>
<li>Keep strip width <span class="math inline">\(\delta\)</span>, check only local neighbors.</li>
<li>Compare with brute-force for verification.</li>
</ol>
</section>
<section id="test-cases-25" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-25">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Closest Pair</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(1,1),(2,3),(3,2),(5,5)</td>
<td>(2,3),(3,2)</td>
<td><span class="math inline">\(\sqrt{2}\)</span></td>
</tr>
<tr class="even">
<td>(0,0),(1,0),(2,0)</td>
<td>(0,0),(1,0)</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Random 10 points</td>
<td>Verified</td>
<td>Matches brute force</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-25" class="level4">
<h4 class="anchored" data-anchor-id="complexity-25">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Closest Pair Sweep is geometry’s precision tool, narrowing the search to a moving strip and comparing only those neighbors that truly matter.</p>
</section>
</section>
<section id="circle-arrangement-sweep" class="level3">
<h3 class="anchored" data-anchor-id="circle-arrangement-sweep">727 Circle Arrangement Sweep</h3>
<p>The Circle Arrangement Sweep algorithm computes the arrangement of a set of circles, the subdivision of the plane induced by all circle arcs and their intersection points. It’s a generalization of line and segment arrangements, extended to curved edges, requiring event-driven sweeping and geometric reasoning.</p>
<section id="what-problem-are-we-solving-26" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-26">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> circles <span class="math display">\[
C_i: (x_i, y_i, r_i)
\]</span> we want to compute their arrangement: the decomposition of the plane into faces, edges, and vertices formed by intersections between circles.</p>
<p>A simpler variant focuses on counting intersections and constructing intersection points.</p>
<p>Each pair of circles can intersect at most two points, so there can be at most</p>
<p><span class="math display">\[
O(n^2)
\]</span> intersection points.</p>
</section>
<section id="why-its-harder-than-lines" class="level4">
<h4 class="anchored" data-anchor-id="why-its-harder-than-lines">Why It’s Harder Than Lines</h4>
<ul>
<li>A circle introduces nonlinear boundaries.</li>
<li>The sweep line must handle arc segments, not just straight intervals.</li>
<li>Events occur at circle start/end x-coordinates and at intersection points.</li>
</ul>
<p>This means each circle enters and exits the sweep twice, and new intersections can emerge dynamically.</p>
</section>
<section id="how-does-it-work-plain-language-26" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-26">How Does It Work (Plain Language)</h4>
<p>The sweep line moves left to right, intersecting circles as vertical slices. We maintain an active set of circle arcs currently intersecting the line.</p>
<p>At each event:</p>
<ol type="1">
<li>Leftmost point (<span class="math inline">\(x_i - r_i\)</span>): insert circle arc.</li>
<li>Rightmost point (<span class="math inline">\(x_i + r_i\)</span>): remove circle arc.</li>
<li>Intersection points: when two arcs cross, schedule intersection event.</li>
</ol>
<p>Each time arcs are inserted or swapped, check local neighbors for intersections (like Bentley–Ottmann, but with curved segments).</p>
</section>
<section id="circlecircle-intersection-formula" class="level4">
<h4 class="anchored" data-anchor-id="circlecircle-intersection-formula">Circle–Circle Intersection Formula</h4>
<p>Two circles:</p>
<p><span class="math display">\[
(x_1, y_1, r_1), \quad (x_2, y_2, r_2)
\]</span></p>
<p>Distance between centers:</p>
<p><span class="math display">\[
d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\]</span></p>
<p>If <span class="math inline">\(|r_1 - r_2| \le d \le r_1 + r_2\)</span>, they intersect at two points:</p>
<p><span class="math display">\[
a = \frac{r_1^2 - r_2^2 + d^2}{2d}
\]</span></p>
<p><span class="math display">\[
h = \sqrt{r_1^2 - a^2}
\]</span></p>
<p>Then intersection coordinates:</p>
<p><span class="math display">\[
x_3 = x_1 + a \cdot \frac{x_2 - x_1}{d} \pm h \cdot \frac{y_2 - y_1}{d}
\]</span></p>
<p><span class="math display">\[
y_3 = y_1 + a \cdot \frac{y_2 - y_1}{d} \mp h \cdot \frac{x_2 - x_1}{d}
\]</span></p>
<p>Each intersection point becomes an event in the sweep.</p>
</section>
<section id="example-3-circles" class="level4">
<h4 class="anchored" data-anchor-id="example-3-circles">Example (3 Circles)</h4>
<p>Circles:</p>
<ul>
<li><span class="math inline">\(C_1: (0,0,2)\)</span></li>
<li><span class="math inline">\(C_2: (3,0,2)\)</span></li>
<li><span class="math inline">\(C_3: (1.5,2,1.5)\)</span></li>
</ul>
<p>Each pair intersects in 2 points → up to 6 intersection points. The arrangement has vertices (intersections), edges (arcs), and faces (regions).</p>
<p>The sweep processes:</p>
<ul>
<li><span class="math inline">\(x = -2\)</span>: <span class="math inline">\(C_1\)</span> starts</li>
<li><span class="math inline">\(x = 1\)</span>: <span class="math inline">\(C_2\)</span> starts</li>
<li><span class="math inline">\(x = 1.5\)</span>: intersection events</li>
<li><span class="math inline">\(x = 3\)</span>: <span class="math inline">\(C_3\)</span> starts</li>
<li><span class="math inline">\(x = 5\)</span>: circles end</li>
</ul>
</section>
<section id="tiny-code-python-sketch-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-2">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circle_intersections(c1, c2):</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    (x1, y1, r1), (x2, y2, r2) <span class="op">=</span> c1, c2</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    dx, dy <span class="op">=</span> x2 <span class="op">-</span> x1, y2 <span class="op">-</span> y1</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> sqrt(dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> d <span class="op">&gt;</span> r1 <span class="op">+</span> r2 <span class="kw">or</span> d <span class="op">&lt;</span> <span class="bu">abs</span>(r1 <span class="op">-</span> r2) <span class="kw">or</span> d <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> (r1<span class="op">*</span>r1 <span class="op">-</span> r2<span class="op">*</span>r2 <span class="op">+</span> d<span class="op">*</span>d) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>d)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> sqrt(r1<span class="op">*</span>r1 <span class="op">-</span> a<span class="op">*</span>a)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    xm <span class="op">=</span> x1 <span class="op">+</span> a <span class="op">*</span> dx <span class="op">/</span> d</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    ym <span class="op">=</span> y1 <span class="op">+</span> a <span class="op">*</span> dy <span class="op">/</span> d</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>    xs1 <span class="op">=</span> xm <span class="op">+</span> h <span class="op">*</span> dy <span class="op">/</span> d</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    ys1 <span class="op">=</span> ym <span class="op">-</span> h <span class="op">*</span> dx <span class="op">/</span> d</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    xs2 <span class="op">=</span> xm <span class="op">-</span> h <span class="op">*</span> dy <span class="op">/</span> d</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    ys2 <span class="op">=</span> ym <span class="op">+</span> h <span class="op">*</span> dx <span class="op">/</span> d</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [(xs1, ys1), (xs2, ys2)]</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circle_arrangement(circles):</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, c1 <span class="kw">in</span> <span class="bu">enumerate</span>(circles):</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j, c2 <span class="kw">in</span> <span class="bu">enumerate</span>(circles[i<span class="op">+</span><span class="dv">1</span>:], i<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>            pts <span class="op">=</span> circle_intersections(c1, c2)</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>            events.extend(pts)</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(events)</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>circles <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>), (<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">2</span>), (<span class="fl">1.5</span>,<span class="dv">2</span>,<span class="fl">1.5</span>)]</span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Intersections:"</span>, circle_arrangement(circles))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This simplified version enumerates intersection points, suitable for event scheduling.</p>
</section>
<section id="why-it-matters-26" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-26">Why It Matters</h4>
<ul>
<li>Foundation for geometric arrangements with curved objects</li>
<li>Used in motion planning, robotics, cellular coverage, CAD</li>
<li>Step toward full algebraic geometry arrangements (conics, ellipses)</li>
</ul>
<p>Applications:</p>
<ul>
<li>Cellular network planning (coverage overlaps)</li>
<li>Path regions for robots</li>
<li>Venn diagrams and spatial reasoning</li>
<li>Graph embedding on circular arcs</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-13" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-13">A Gentle Proof (Why It Works)</h4>
<p>Each circle adds at most two intersections with others; Each intersection event is processed once; At most <span class="math inline">\(O(n^2)\)</span> intersections, each with <span class="math inline">\(O(\log n)\)</span> handling (tree insertion/removal).</p>
<p>Therefore:</p>
<p><span class="math display">\[
O(n^2 \log n)
\]</span></p>
<p>The correctness follows from local adjacency: only neighboring arcs can swap during events, so all intersections are captured.</p>
</section>
<section id="try-it-yourself-26" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-26">Try It Yourself</h4>
<ol type="1">
<li>Draw 3 circles overlapping partially.</li>
<li>Compute pairwise intersections.</li>
<li>Mark points, connect arcs in clockwise order.</li>
<li>Sweep from leftmost to rightmost.</li>
<li>Count faces (regions) formed.</li>
</ol>
</section>
<section id="test-cases-26" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-26">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Circles</th>
<th>Intersections</th>
<th>Faces</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2 overlapping</td>
<td>2</td>
<td>3 regions</td>
</tr>
<tr class="even">
<td>3 overlapping</td>
<td>6</td>
<td>8 regions</td>
</tr>
<tr class="odd">
<td>Disjoint</td>
<td>0</td>
<td>n regions</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-26" class="level4">
<h4 class="anchored" data-anchor-id="complexity-26">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n^2 \log n), \quad \text{Space: } O(n^2)
\]</span></p>
<p>The Circle Arrangement Sweep transforms smooth geometry into discrete structure, every arc, crossing, and face traced by a patient sweep across the plane.</p>
</section>
</section>
<section id="sweep-for-overlapping-rectangles" class="level3">
<h3 class="anchored" data-anchor-id="sweep-for-overlapping-rectangles">728 Sweep for Overlapping Rectangles</h3>
<p>The Sweep for Overlapping Rectangles algorithm detects intersections or collisions among a set of axis-aligned rectangles. It’s a practical and elegant use of line sweep methods for 2D collision detection, spatial joins, and layout engines.</p>
<section id="what-problem-are-we-solving-27" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-27">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> axis-aligned rectangles</p>
<p><span class="math display">\[
R_i = [x_{1i}, x_{2i}] \times [y_{1i}, y_{2i}]
\]</span></p>
<p>we want to find all pairs <span class="math inline">\((R_i, R_j)\)</span> that overlap, meaning</p>
<p><span class="math display">\[
[x_{1i}, x_{2i}] \cap [x_{1j}, x_{2j}] \ne \emptyset
\]</span> and <span class="math display">\[
[y_{1i}, y_{2i}] \cap [y_{1j}, y_{2j}] \ne \emptyset
\]</span></p>
<p>This is a common subproblem in graphics, GIS, and physics engines.</p>
</section>
<section id="naive-approach" class="level4">
<h4 class="anchored" data-anchor-id="naive-approach">Naive Approach</h4>
<p>Check every pair of rectangles: <span class="math display">\[
O(n^2)
\]</span></p>
<p>Too slow when <span class="math inline">\(n\)</span> is large.</p>
<p>We’ll use a sweep line along <span class="math inline">\(x\)</span>, maintaining an active set of rectangles whose x-intervals overlap the current position.</p>
</section>
<section id="how-does-it-work-plain-language-27" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-27">How Does It Work (Plain Language)</h4>
<p>We process events in increasing <span class="math inline">\(x\)</span>:</p>
<ul>
<li>Start event: at <span class="math inline">\(x_{1i}\)</span>, rectangle enters active set.</li>
<li>End event: at <span class="math inline">\(x_{2i}\)</span>, rectangle leaves active set.</li>
</ul>
<p>At each insertion, we check new rectangle against all active rectangles for y-overlap.</p>
<p>Because active rectangles all overlap in <span class="math inline">\(x\)</span>, we only need to test <span class="math inline">\(y\)</span>-intervals.</p>
</section>
<section id="example-walkthrough-24" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-24">Example Walkthrough</h4>
<p>Rectangles:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>ID</th>
<th><span class="math inline">\(x_1\)</span></th>
<th><span class="math inline">\(x_2\)</span></th>
<th><span class="math inline">\(y_1\)</span></th>
<th><span class="math inline">\(y_2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R1</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>R2</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>4</td>
</tr>
<tr class="odd">
<td>R3</td>
<td>6</td>
<td>8</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Events (sorted by <span class="math inline">\(x\)</span>): <span class="math inline">\((1,\text{start},R1)\)</span>, <span class="math inline">\((2,\text{start},R2)\)</span>, <span class="math inline">\((4,\text{end},R1)\)</span>, <span class="math inline">\((5,\text{end},R2)\)</span>, <span class="math inline">\((6,\text{start},R3)\)</span>, <span class="math inline">\((8,\text{end},R3)\)</span></p>
<p>Sweep:</p>
<ol type="1">
<li><p><span class="math inline">\(x=1\)</span>: Add R1 → active = {R1}.</p></li>
<li><p><span class="math inline">\(x=2\)</span>: Add R2 → check overlap with R1:</p>
<ul>
<li><span class="math inline">\([1,3] \cap [2,4] = [2,3] \ne \emptyset\)</span> → overlap found (R1, R2).</li>
</ul></li>
<li><p><span class="math inline">\(x=4\)</span>: Remove R1.</p></li>
<li><p><span class="math inline">\(x=5\)</span>: Remove R2.</p></li>
<li><p><span class="math inline">\(x=6\)</span>: Add R3.</p></li>
<li><p><span class="math inline">\(x=8\)</span>: Remove R3.</p></li>
</ol>
<p>Output: Overlap pair (R1, R2).</p>
</section>
<section id="overlap-condition" class="level4">
<h4 class="anchored" data-anchor-id="overlap-condition">Overlap Condition</h4>
<p>Two rectangles <span class="math inline">\(R_i, R_j\)</span> overlap iff</p>
<p><span class="math display">\[
x_{1i} &lt; x_{2j} \ \text{and}\ x_{2i} &gt; x_{1j}
\]</span></p>
<p>and</p>
<p><span class="math display">\[
y_{1i} &lt; y_{2j} \ \text{and}\ y_{2i} &gt; y_{1j}
\]</span></p>
</section>
<section id="tiny-code-python-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-11">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> overlaps(r1, r2):</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">not</span> (r1[<span class="dv">1</span>] <span class="op">&lt;=</span> r2[<span class="dv">0</span>] <span class="kw">or</span> r2[<span class="dv">1</span>] <span class="op">&lt;=</span> r1[<span class="dv">0</span>] <span class="kw">or</span> </span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>                r1[<span class="dv">3</span>] <span class="op">&lt;=</span> r2[<span class="dv">2</span>] <span class="kw">or</span> r2[<span class="dv">3</span>] <span class="op">&lt;=</span> r1[<span class="dv">2</span>])</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sweep_rectangles(rects):</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (x1, x2, y1, y2) <span class="kw">in</span> <span class="bu">enumerate</span>(rects):</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>        events.append((x1, <span class="st">'start'</span>, i))</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>        events.append((x2, <span class="st">'end'</span>, i))</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    events.sort()</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> []</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, typ, idx <span class="kw">in</span> events:</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="st">'start'</span>:</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> active:</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> overlaps(rects[idx], rects[j]):</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>                    result.append((idx, j))</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>            active.append(idx)</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>            active.remove(idx)</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>rects <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">2</span>)]</span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Overlaps:"</span>, sweep_rectangles(rects))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-c-sketch" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-sketch">Tiny Code (C Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">double</span> x1<span class="op">,</span> x2<span class="op">,</span> y1<span class="op">,</span> y2<span class="op">;</span> <span class="op">}</span> Rect<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> overlaps<span class="op">(</span>Rect a<span class="op">,</span> Rect b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>a<span class="op">.</span>x2 <span class="op">&lt;=</span> b<span class="op">.</span>x1 <span class="op">||</span> b<span class="op">.</span>x2 <span class="op">&lt;=</span> a<span class="op">.</span>x1 <span class="op">||</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>             a<span class="op">.</span>y2 <span class="op">&lt;=</span> b<span class="op">.</span>y1 <span class="op">||</span> b<span class="op">.</span>y2 <span class="op">&lt;=</span> a<span class="op">.</span>y1<span class="op">);</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Use an array of events, sort by <span class="math inline">\(x\)</span>, maintain active list.</p>
</section>
<section id="why-it-matters-27" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-27">Why It Matters</h4>
<ul>
<li>Core idea behind broad-phase collision detection</li>
<li>Used in 2D games, UI layout engines, spatial joins</li>
<li>Extends easily to 3D box intersection via multi-axis sweep</li>
</ul>
<p>Applications:</p>
<ul>
<li>Physics simulations (bounding box overlap)</li>
<li>Spatial query systems (R-tree verification)</li>
<li>CAD layout constraint checking</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-14" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-14">A Gentle Proof (Why It Works)</h4>
<ul>
<li>The active set contains exactly rectangles that overlap current <span class="math inline">\(x\)</span>.</li>
<li>By checking only these, we cover all possible overlaps once.</li>
<li>Each insertion/removal: <span class="math inline">\(O(\log n)\)</span> (with balanced tree).</li>
<li>Each pair tested only when <span class="math inline">\(x\)</span>-ranges overlap.</li>
</ul>
<p>Total time:</p>
<p><span class="math display">\[
O((n + k) \log n)
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is number of overlaps.</p>
</section>
<section id="try-it-yourself-27" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-27">Try It Yourself</h4>
<ol type="1">
<li>Draw overlapping rectangles on a grid.</li>
<li>Sort edges by <span class="math inline">\(x\)</span>.</li>
<li>Sweep and maintain active list.</li>
<li>At each insertion, test <span class="math inline">\(y\)</span>-overlap with actives.</li>
<li>Record overlaps, verify visually.</li>
</ol>
</section>
<section id="test-cases-27" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-27">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Rectangles</th>
<th>Overlaps</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R1(1,4,1,3), R2(2,5,2,4)</td>
<td>(R1,R2)</td>
</tr>
<tr class="even">
<td>Disjoint rectangles</td>
<td>None</td>
</tr>
<tr class="odd">
<td>Nested rectangles</td>
<td>All overlapping</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-27" class="level4">
<h4 class="anchored" data-anchor-id="complexity-27">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O((n + k)\log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Sweep for Overlapping Rectangles is a geometric sentinel, sliding across the plane, keeping track of active shapes, and spotting collisions with precision.</p>
</section>
</section>
<section id="range-counting" class="level3">
<h3 class="anchored" data-anchor-id="range-counting">729 Range Counting</h3>
<p>Range Counting asks: given many points in the plane, how many lie inside an axis-aligned query rectangle. It is a staple of geometric data querying, powering interactive plots, maps, and database indices.</p>
<section id="what-problem-are-we-solving-28" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-28">What Problem Are We Solving?</h4>
<p>Input: a static set of <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {(x_i,y_i)}_{i=1}^n\)</span>. Queries: for rectangles <span class="math inline">\(R = [x_L, x_R] \times [y_B, y_T]\)</span>, return</p>
<p><span class="math display">\[
\#\{(x,y) \in P \mid x_L \le x \le x_R,\; y_B \le y \le y_T\}.
\]</span></p>
<p>We want fast query time, ideally sublinear, after a one-time preprocessing step.</p>
</section>
<section id="how-does-it-work-plain-language-28" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-28">How Does It Work (Plain Language)</h4>
<p>Several classic structures support orthogonal range counting.</p>
<ol type="1">
<li><p>Sorted by x + Fenwick over y (offline or sweep): Sort points by <span class="math inline">\(x\)</span>. Sort queries by <span class="math inline">\(x_R\)</span>. Sweep in <span class="math inline">\(x\)</span>, adding points to a Fenwick tree keyed by their compressed <span class="math inline">\(y\)</span>. The count for <span class="math inline">\([x_L,x_R]\times[y_B,y_T]\)</span> equals: <span class="math display">\[
\text{count}(x \le x_R, y \in [y_B,y_T]) - \text{count}(x &lt; x_L, y \in [y_B,y_T]).
\]</span> Time: <span class="math inline">\(O((n + q)\log n)\)</span> offline.</p></li>
<li><p>Range Tree (static, online): Build a balanced BST on <span class="math inline">\(x\)</span>. Each node stores a sorted list of the <span class="math inline">\(y\)</span> values in its subtree. A 2D query decomposes the <span class="math inline">\(x\)</span>-range into <span class="math inline">\(O(\log n)\)</span> canonical nodes, and in each node we binary search the <span class="math inline">\(y\)</span> list to count how many lie in <span class="math inline">\([y_B,y_T]\)</span>. Time: query <span class="math inline">\(O(\log^2 n)\)</span>, space <span class="math inline">\(O(n \log n)\)</span>. With fractional cascading, query improves to <span class="math inline">\(O(\log n)\)</span>.</p></li>
<li><p>Fenwick of Fenwicks or Segment tree of Fenwicks: Index by <span class="math inline">\(x\)</span> with a Fenwick tree. Each Fenwick node stores another Fenwick over <span class="math inline">\(y\)</span>. Fully online updates and queries in <span class="math inline">\(O(\log^2 n)\)</span> with <span class="math inline">\(O(n \log n)\)</span> space after coordinate compression.</p></li>
</ol>
</section>
<section id="example-walkthrough-25" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-25">Example Walkthrough</h4>
<p>Points: <span class="math inline">\((1,1), (2,3), (3,2), (5,4), (6,1)\)</span> Query: <span class="math inline">\(R = [2,5] \times [2,4]\)</span></p>
<p>Points inside: <span class="math inline">\((2,3), (3,2), (5,4)\)</span> Answer: <span class="math inline">\(3\)</span>.</p>
</section>
<section id="tiny-code-1-offline-sweep-with-fenwick-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-1-offline-sweep-with-fenwick-python">Tiny Code 1: Offline Sweep with Fenwick (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Offline orthogonal range counting:</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co"># For each query [xL,xR]x[yB,yT], compute F(xR, yB..yT) - F(xL-ε, yB..yT)</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> bisect_left, bisect_right</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Fenwick:</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fw <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, i, v<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&lt;=</span> <span class="va">self</span>.n:</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.fw[i] <span class="op">+=</span> v</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> i <span class="op">&amp;</span> <span class="op">-</span>i</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">sum</span>(<span class="va">self</span>, i):</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>            s <span class="op">+=</span> <span class="va">self</span>.fw[i]</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> i <span class="op">&amp;</span> <span class="op">-</span>i</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> s</span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> range_sum(<span class="va">self</span>, l, r):</span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r <span class="op">&lt;</span> l: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">sum</span>(r) <span class="op">-</span> <span class="va">self</span>.<span class="bu">sum</span>(l<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> offline_range_count(points, queries):</span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># points: list of (x,y)</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># queries: list of (xL,xR,yB,yT)</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>    ys <span class="op">=</span> <span class="bu">sorted</span>({y <span class="cf">for</span> _,y <span class="kw">in</span> points} <span class="op">|</span> {q[<span class="dv">2</span>] <span class="cf">for</span> q <span class="kw">in</span> queries} <span class="op">|</span> {q[<span class="dv">3</span>] <span class="cf">for</span> q <span class="kw">in</span> queries})</span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> y_id(y): <span class="cf">return</span> bisect_left(ys, y) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># prepare events: add points up to x, then answer queries ending at that x</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb46-32"><a href="#cb46-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i,(x,y) <span class="kw">in</span> <span class="bu">enumerate</span>(points):</span>
<span id="cb46-33"><a href="#cb46-33" aria-hidden="true" tabindex="-1"></a>        events.append((x, <span class="dv">0</span>, i))  <span class="co"># point event</span></span>
<span id="cb46-34"><a href="#cb46-34" aria-hidden="true" tabindex="-1"></a>    Fq <span class="op">=</span> []  <span class="co"># queries on xR</span></span>
<span id="cb46-35"><a href="#cb46-35" aria-hidden="true" tabindex="-1"></a>    Gq <span class="op">=</span> []  <span class="co"># queries on xL-1</span></span>
<span id="cb46-36"><a href="#cb46-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> qi,(xL,xR,yB,yT) <span class="kw">in</span> <span class="bu">enumerate</span>(queries):</span>
<span id="cb46-37"><a href="#cb46-37" aria-hidden="true" tabindex="-1"></a>        Fq.append((xR, <span class="dv">1</span>, qi))</span>
<span id="cb46-38"><a href="#cb46-38" aria-hidden="true" tabindex="-1"></a>        Gq.append((xL<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>, qi))</span>
<span id="cb46-39"><a href="#cb46-39" aria-hidden="true" tabindex="-1"></a>    events <span class="op">+=</span> Fq <span class="op">+</span> Gq</span>
<span id="cb46-40"><a href="#cb46-40" aria-hidden="true" tabindex="-1"></a>    events.sort()</span>
<span id="cb46-41"><a href="#cb46-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-42"><a href="#cb46-42" aria-hidden="true" tabindex="-1"></a>    fw <span class="op">=</span> Fenwick(<span class="bu">len</span>(ys))</span>
<span id="cb46-43"><a href="#cb46-43" aria-hidden="true" tabindex="-1"></a>    ansR <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span><span class="bu">len</span>(queries)</span>
<span id="cb46-44"><a href="#cb46-44" aria-hidden="true" tabindex="-1"></a>    ansL <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span><span class="bu">len</span>(queries)</span>
<span id="cb46-45"><a href="#cb46-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-46"><a href="#cb46-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x,typ,idx <span class="kw">in</span> events:</span>
<span id="cb46-47"><a href="#cb46-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb46-48"><a href="#cb46-48" aria-hidden="true" tabindex="-1"></a>            _,y <span class="op">=</span> points[idx]</span>
<span id="cb46-49"><a href="#cb46-49" aria-hidden="true" tabindex="-1"></a>            fw.add(y_id(y), <span class="dv">1</span>)</span>
<span id="cb46-50"><a href="#cb46-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> typ <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb46-51"><a href="#cb46-51" aria-hidden="true" tabindex="-1"></a>            xL,xR,yB,yT <span class="op">=</span> queries[idx]</span>
<span id="cb46-52"><a href="#cb46-52" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> bisect_left(ys, yB) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb46-53"><a href="#cb46-53" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> bisect_right(ys, yT)</span>
<span id="cb46-54"><a href="#cb46-54" aria-hidden="true" tabindex="-1"></a>            ansR[idx] <span class="op">=</span> fw.range_sum(l, r)</span>
<span id="cb46-55"><a href="#cb46-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb46-56"><a href="#cb46-56" aria-hidden="true" tabindex="-1"></a>            xL,xR,yB,yT <span class="op">=</span> queries[idx]</span>
<span id="cb46-57"><a href="#cb46-57" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> bisect_left(ys, yB) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb46-58"><a href="#cb46-58" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> bisect_right(ys, yT)</span>
<span id="cb46-59"><a href="#cb46-59" aria-hidden="true" tabindex="-1"></a>            ansL[idx] <span class="op">=</span> fw.range_sum(l, r)</span>
<span id="cb46-60"><a href="#cb46-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-61"><a href="#cb46-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [ansR[i] <span class="op">-</span> ansL[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(queries))]</span>
<span id="cb46-62"><a href="#cb46-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-63"><a href="#cb46-63" aria-hidden="true" tabindex="-1"></a><span class="co"># demo</span></span>
<span id="cb46-64"><a href="#cb46-64" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">2</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">6</span>,<span class="dv">1</span>)]</span>
<span id="cb46-65"><a href="#cb46-65" aria-hidden="true" tabindex="-1"></a>queries <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>), (<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">1</span>)]</span>
<span id="cb46-66"><a href="#cb46-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(offline_range_count(points, queries))  <span class="co"># [3, 2]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-2-static-range-tree-query-idea-python-conceptual" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-2-static-range-tree-query-idea-python-conceptual">Tiny Code 2: Static Range Tree Query Idea (Python, conceptual)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build: sort points by x, recursively split;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co"># at each node store the y-sorted list for binary counting.</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> bisect_left, bisect_right</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RangeTree:</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, pts):</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pts sorted by x</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xs <span class="op">=</span> [p[<span class="dv">0</span>] <span class="cf">for</span> p <span class="kw">in</span> pts]</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ys <span class="op">=</span> <span class="bu">sorted</span>(p[<span class="dv">1</span>] <span class="cf">for</span> p <span class="kw">in</span> pts)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(pts) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>            mid <span class="op">=</span> <span class="bu">len</span>(pts)<span class="op">//</span><span class="dv">2</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left <span class="op">=</span> RangeTree(pts[:mid])</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.right <span class="op">=</span> RangeTree(pts[mid:])</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> count_y(<span class="va">self</span>, yB, yT):</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        L <span class="op">=</span> bisect_left(<span class="va">self</span>.ys, yB)</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>        R <span class="op">=</span> bisect_right(<span class="va">self</span>.ys, yT)</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> R <span class="op">-</span> L</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> query(<span class="va">self</span>, xL, xR, yB, yT):</span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># count points with x in [xL,xR] and y in [yB,yT]</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> xR <span class="op">&lt;</span> <span class="va">self</span>.xs[<span class="dv">0</span>] <span class="kw">or</span> xL <span class="op">&gt;</span> <span class="va">self</span>.xs[<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> xL <span class="op">&lt;=</span> <span class="va">self</span>.xs[<span class="dv">0</span>] <span class="kw">and</span> <span class="va">self</span>.xs[<span class="op">-</span><span class="dv">1</span>] <span class="op">&lt;=</span> xR:</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.count_y(yB, yT)</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.left:  <span class="co"># leaf</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">int</span>(xL <span class="op">&lt;=</span> <span class="va">self</span>.xs[<span class="dv">0</span>] <span class="op">&lt;=</span> xR <span class="kw">and</span> yB <span class="op">&lt;=</span> <span class="va">self</span>.ys[<span class="dv">0</span>] <span class="op">&lt;=</span> yT)</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.left.query(xL,xR,yB,yT) <span class="op">+</span> <span class="va">self</span>.right.query(xL,xR,yB,yT)</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> <span class="bu">sorted</span>([(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">2</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">6</span>,<span class="dv">1</span>)])</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>rt <span class="op">=</span> RangeTree(pts)</span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rt.query(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>))  <span class="co"># 3</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-28" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-28">Why It Matters</h4>
<ul>
<li>Core primitive for spatial databases and analytic dashboards</li>
<li>Underlies heatmaps, density queries, and windowed aggregations</li>
<li>Extends to higher dimensions with <span class="math inline">\(k\)</span>-d trees and range trees</li>
</ul>
<p>Applications: map viewports, time window counts, GIS filtering, interactive brushing and linking.</p>
</section>
<section id="a-gentle-proof-why-it-works-15" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-15">A Gentle Proof (Why It Works)</h4>
<p>For the range tree: the <span class="math inline">\(x\)</span>-range <span class="math inline">\([x_L,x_R]\)</span> decomposes into <span class="math inline">\(O(\log n)\)</span> canonical nodes of a balanced BST. Each canonical node stores its subtree’s <span class="math inline">\(y\)</span> values in sorted order. Counting in <span class="math inline">\([y_B,y_T]\)</span> at a node costs <span class="math inline">\(O(\log n)\)</span> by binary searches. Summing over <span class="math inline">\(O(\log n)\)</span> nodes yields <span class="math inline">\(O(\log^2 n)\)</span> per query. With fractional cascading, the second-level searches reuse pointers so all counts are found in <span class="math inline">\(O(\log n)\)</span>.</p>
</section>
<section id="try-it-yourself-28" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-28">Try It Yourself</h4>
<ol type="1">
<li>Implement offline counting with a Fenwick tree and coordinate compression.</li>
<li>Compare against naive <span class="math inline">\(O(n)\)</span> per query to verify.</li>
<li>Build a range tree and time <span class="math inline">\(q\)</span> queries for varying <span class="math inline">\(n\)</span>.</li>
<li>Add updates: switch to Fenwick of Fenwicks for dynamic points.</li>
<li>Extend to 3D with a tree of trees for orthogonal boxes.</li>
</ol>
</section>
<section id="test-cases-28" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-28">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 39%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>Points</th>
<th>Query rectangle</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((1,1),(2,3),(3,2),(5,4),(6,1)\)</span></td>
<td><span class="math inline">\([2,5]\times[2,4]\)</span></td>
<td>3</td>
</tr>
<tr class="even">
<td>same</td>
<td><span class="math inline">\([1,6]\times[1,1]\)</span></td>
<td>2</td>
</tr>
<tr class="odd">
<td><span class="math inline">\((0,0),(10,10)\)</span></td>
<td><span class="math inline">\([1,9]\times[1,9]\)</span></td>
<td>0</td>
</tr>
<tr class="even">
<td>grid <span class="math inline">\(3\times 3\)</span></td>
<td>center <span class="math inline">\([1,2]\times[1,2]\)</span></td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-28" class="level4">
<h4 class="anchored" data-anchor-id="complexity-28">Complexity</h4>
<ul>
<li>Offline sweep with Fenwick: preprocessing plus queries in <span class="math inline">\(O((n+q)\log n)\)</span></li>
<li>Range tree: build <span class="math inline">\(O(n \log n)\)</span>, query <span class="math inline">\(O(\log^2 n)\)</span> or <span class="math inline">\(O(\log n)\)</span> with fractional cascading</li>
<li>Segment or Fenwick of Fenwicks: dynamic updates and queries in <span class="math inline">\(O(\log^2 n)\)</span></li>
</ul>
<p>Range counting turns spatial selection into log-time queries by layering search trees and sorted auxiliary lists.</p>
</section>
</section>
<section id="range-counting-1" class="level3">
<h3 class="anchored" data-anchor-id="range-counting-1">729 Range Counting</h3>
<p>Range Counting asks: given many points in the plane, how many lie inside an axis-aligned query rectangle. It is a staple of geometric data querying, powering interactive plots, maps, and database indices.</p>
<section id="what-problem-are-we-solving-29" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-29">What Problem Are We Solving?</h4>
<p>Input: a static set of <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {(x_i,y_i)}_{i=1}^n\)</span>. Queries: for rectangles <span class="math inline">\(R = [x_L, x_R] \times [y_B, y_T]\)</span>, return</p>
<p><span class="math display">\[
\#\{(x,y) \in P \mid x_L \le x \le x_R,\; y_B \le y \le y_T\}.
\]</span></p>
<p>We want fast query time, ideally sublinear, after a one-time preprocessing step.</p>
</section>
<section id="how-does-it-work-plain-language-29" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-29">How Does It Work (Plain Language)</h4>
<p>Several classic structures support orthogonal range counting.</p>
<ol type="1">
<li><p>Sorted by x + Fenwick over y (offline or sweep): Sort points by <span class="math inline">\(x\)</span>. Sort queries by <span class="math inline">\(x_R\)</span>. Sweep in <span class="math inline">\(x\)</span>, adding points to a Fenwick tree keyed by their compressed <span class="math inline">\(y\)</span>. The count for <span class="math inline">\([x_L,x_R]\times[y_B,y_T]\)</span> equals: <span class="math display">\[
\text{count}(x \le x_R, y \in [y_B,y_T]) - \text{count}(x &lt; x_L, y \in [y_B,y_T]).
\]</span> Time: <span class="math inline">\(O((n + q)\log n)\)</span> offline.</p></li>
<li><p>Range Tree (static, online): Build a balanced BST on <span class="math inline">\(x\)</span>. Each node stores a sorted list of the <span class="math inline">\(y\)</span> values in its subtree. A 2D query decomposes the <span class="math inline">\(x\)</span>-range into <span class="math inline">\(O(\log n)\)</span> canonical nodes, and in each node we binary search the <span class="math inline">\(y\)</span> list to count how many lie in <span class="math inline">\([y_B,y_T]\)</span>. Time: query <span class="math inline">\(O(\log^2 n)\)</span>, space <span class="math inline">\(O(n \log n)\)</span>. With fractional cascading, query improves to <span class="math inline">\(O(\log n)\)</span>.</p></li>
<li><p>Fenwick of Fenwicks or Segment tree of Fenwicks: Index by <span class="math inline">\(x\)</span> with a Fenwick tree. Each Fenwick node stores another Fenwick over <span class="math inline">\(y\)</span>. Fully online updates and queries in <span class="math inline">\(O(\log^2 n)\)</span> with <span class="math inline">\(O(n \log n)\)</span> space after coordinate compression.</p></li>
</ol>
</section>
<section id="example-walkthrough-26" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-26">Example Walkthrough</h4>
<p>Points: <span class="math inline">\((1,1), (2,3), (3,2), (5,4), (6,1)\)</span> Query: <span class="math inline">\(R = [2,5] \times [2,4]\)</span></p>
<p>Points inside: <span class="math inline">\((2,3), (3,2), (5,4)\)</span> Answer: <span class="math inline">\(3\)</span>.</p>
</section>
<section id="tiny-code-1-offline-sweep-with-fenwick-python-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-1-offline-sweep-with-fenwick-python-1">Tiny Code 1: Offline Sweep with Fenwick (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Offline orthogonal range counting:</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co"># For each query [xL,xR]x[yB,yT], compute F(xR, yB..yT) - F(xL-ε, yB..yT)</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> bisect_left, bisect_right</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Fenwick:</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fw <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, i, v<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&lt;=</span> <span class="va">self</span>.n:</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.fw[i] <span class="op">+=</span> v</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> i <span class="op">&amp;</span> <span class="op">-</span>i</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">sum</span>(<span class="va">self</span>, i):</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>            s <span class="op">+=</span> <span class="va">self</span>.fw[i]</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> i <span class="op">&amp;</span> <span class="op">-</span>i</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> s</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> range_sum(<span class="va">self</span>, l, r):</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r <span class="op">&lt;</span> l: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">sum</span>(r) <span class="op">-</span> <span class="va">self</span>.<span class="bu">sum</span>(l<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> offline_range_count(points, queries):</span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># points: list of (x,y)</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># queries: list of (xL,xR,yB,yT)</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>    ys <span class="op">=</span> <span class="bu">sorted</span>({y <span class="cf">for</span> _,y <span class="kw">in</span> points} <span class="op">|</span> {q[<span class="dv">2</span>] <span class="cf">for</span> q <span class="kw">in</span> queries} <span class="op">|</span> {q[<span class="dv">3</span>] <span class="cf">for</span> q <span class="kw">in</span> queries})</span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> y_id(y): <span class="cf">return</span> bisect_left(ys, y) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># prepare events: add points up to x, then answer queries ending at that x</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i,(x,y) <span class="kw">in</span> <span class="bu">enumerate</span>(points):</span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>        events.append((x, <span class="dv">0</span>, i))  <span class="co"># point event</span></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>    Fq <span class="op">=</span> []  <span class="co"># queries on xR</span></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>    Gq <span class="op">=</span> []  <span class="co"># queries on xL-1</span></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> qi,(xL,xR,yB,yT) <span class="kw">in</span> <span class="bu">enumerate</span>(queries):</span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>        Fq.append((xR, <span class="dv">1</span>, qi))</span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>        Gq.append((xL<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>, qi))</span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>    events <span class="op">+=</span> Fq <span class="op">+</span> Gq</span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>    events.sort()</span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>    fw <span class="op">=</span> Fenwick(<span class="bu">len</span>(ys))</span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>    ansR <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span><span class="bu">len</span>(queries)</span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>    ansL <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span><span class="bu">len</span>(queries)</span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x,typ,idx <span class="kw">in</span> events:</span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a>            _,y <span class="op">=</span> points[idx]</span>
<span id="cb48-49"><a href="#cb48-49" aria-hidden="true" tabindex="-1"></a>            fw.add(y_id(y), <span class="dv">1</span>)</span>
<span id="cb48-50"><a href="#cb48-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> typ <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb48-51"><a href="#cb48-51" aria-hidden="true" tabindex="-1"></a>            xL,xR,yB,yT <span class="op">=</span> queries[idx]</span>
<span id="cb48-52"><a href="#cb48-52" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> bisect_left(ys, yB) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb48-53"><a href="#cb48-53" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> bisect_right(ys, yT)</span>
<span id="cb48-54"><a href="#cb48-54" aria-hidden="true" tabindex="-1"></a>            ansR[idx] <span class="op">=</span> fw.range_sum(l, r)</span>
<span id="cb48-55"><a href="#cb48-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb48-56"><a href="#cb48-56" aria-hidden="true" tabindex="-1"></a>            xL,xR,yB,yT <span class="op">=</span> queries[idx]</span>
<span id="cb48-57"><a href="#cb48-57" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> bisect_left(ys, yB) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb48-58"><a href="#cb48-58" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> bisect_right(ys, yT)</span>
<span id="cb48-59"><a href="#cb48-59" aria-hidden="true" tabindex="-1"></a>            ansL[idx] <span class="op">=</span> fw.range_sum(l, r)</span>
<span id="cb48-60"><a href="#cb48-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-61"><a href="#cb48-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [ansR[i] <span class="op">-</span> ansL[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(queries))]</span>
<span id="cb48-62"><a href="#cb48-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-63"><a href="#cb48-63" aria-hidden="true" tabindex="-1"></a><span class="co"># demo</span></span>
<span id="cb48-64"><a href="#cb48-64" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">2</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">6</span>,<span class="dv">1</span>)]</span>
<span id="cb48-65"><a href="#cb48-65" aria-hidden="true" tabindex="-1"></a>queries <span class="op">=</span> [(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>), (<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">1</span>)]</span>
<span id="cb48-66"><a href="#cb48-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(offline_range_count(points, queries))  <span class="co"># [3, 2]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-2-static-range-tree-query-idea-python-conceptual-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-2-static-range-tree-query-idea-python-conceptual-1">Tiny Code 2: Static Range Tree Query Idea (Python, conceptual)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build: sort points by x, recursively split;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co"># at each node store the y-sorted list for binary counting.</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> bisect_left, bisect_right</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RangeTree:</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, pts):</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pts sorted by x</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.xs <span class="op">=</span> [p[<span class="dv">0</span>] <span class="cf">for</span> p <span class="kw">in</span> pts]</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ys <span class="op">=</span> <span class="bu">sorted</span>(p[<span class="dv">1</span>] <span class="cf">for</span> p <span class="kw">in</span> pts)</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(pts) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>            mid <span class="op">=</span> <span class="bu">len</span>(pts)<span class="op">//</span><span class="dv">2</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left <span class="op">=</span> RangeTree(pts[:mid])</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.right <span class="op">=</span> RangeTree(pts[mid:])</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> count_y(<span class="va">self</span>, yB, yT):</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        L <span class="op">=</span> bisect_left(<span class="va">self</span>.ys, yB)</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>        R <span class="op">=</span> bisect_right(<span class="va">self</span>.ys, yT)</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> R <span class="op">-</span> L</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> query(<span class="va">self</span>, xL, xR, yB, yT):</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># count points with x in [xL,xR] and y in [yB,yT]</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> xR <span class="op">&lt;</span> <span class="va">self</span>.xs[<span class="dv">0</span>] <span class="kw">or</span> xL <span class="op">&gt;</span> <span class="va">self</span>.xs[<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> xL <span class="op">&lt;=</span> <span class="va">self</span>.xs[<span class="dv">0</span>] <span class="kw">and</span> <span class="va">self</span>.xs[<span class="op">-</span><span class="dv">1</span>] <span class="op">&lt;=</span> xR:</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.count_y(yB, yT)</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.left:  <span class="co"># leaf</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">int</span>(xL <span class="op">&lt;=</span> <span class="va">self</span>.xs[<span class="dv">0</span>] <span class="op">&lt;=</span> xR <span class="kw">and</span> yB <span class="op">&lt;=</span> <span class="va">self</span>.ys[<span class="dv">0</span>] <span class="op">&lt;=</span> yT)</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.left.query(xL,xR,yB,yT) <span class="op">+</span> <span class="va">self</span>.right.query(xL,xR,yB,yT)</span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> <span class="bu">sorted</span>([(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">2</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">6</span>,<span class="dv">1</span>)])</span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>rt <span class="op">=</span> RangeTree(pts)</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rt.query(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>))  <span class="co"># 3</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-29" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-29">Why It Matters</h4>
<ul>
<li>Core primitive for spatial databases and analytic dashboards</li>
<li>Underlies heatmaps, density queries, and windowed aggregations</li>
<li>Extends to higher dimensions with <span class="math inline">\(k\)</span>-d trees and range trees</li>
</ul>
<p>Applications: map viewports, time window counts, GIS filtering, interactive brushing and linking.</p>
</section>
<section id="a-gentle-proof-why-it-works-16" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-16">A Gentle Proof (Why It Works)</h4>
<p>For the range tree: the <span class="math inline">\(x\)</span>-range <span class="math inline">\([x_L,x_R]\)</span> decomposes into <span class="math inline">\(O(\log n)\)</span> canonical nodes of a balanced BST. Each canonical node stores its subtree’s <span class="math inline">\(y\)</span> values in sorted order. Counting in <span class="math inline">\([y_B,y_T]\)</span> at a node costs <span class="math inline">\(O(\log n)\)</span> by binary searches. Summing over <span class="math inline">\(O(\log n)\)</span> nodes yields <span class="math inline">\(O(\log^2 n)\)</span> per query. With fractional cascading, the second-level searches reuse pointers so all counts are found in <span class="math inline">\(O(\log n)\)</span>.</p>
</section>
<section id="try-it-yourself-29" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-29">Try It Yourself</h4>
<ol type="1">
<li>Implement offline counting with a Fenwick tree and coordinate compression.</li>
<li>Compare against naive <span class="math inline">\(O(n)\)</span> per query to verify.</li>
<li>Build a range tree and time <span class="math inline">\(q\)</span> queries for varying <span class="math inline">\(n\)</span>.</li>
<li>Add updates: switch to Fenwick of Fenwicks for dynamic points.</li>
<li>Extend to 3D with a tree of trees for orthogonal boxes.</li>
</ol>
</section>
<section id="test-cases-29" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-29">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 39%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>Points</th>
<th>Query rectangle</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((1,1),(2,3),(3,2),(5,4),(6,1)\)</span></td>
<td><span class="math inline">\([2,5]\times[2,4]\)</span></td>
<td>3</td>
</tr>
<tr class="even">
<td>same</td>
<td><span class="math inline">\([1,6]\times[1,1]\)</span></td>
<td>2</td>
</tr>
<tr class="odd">
<td><span class="math inline">\((0,0),(10,10)\)</span></td>
<td><span class="math inline">\([1,9]\times[1,9]\)</span></td>
<td>0</td>
</tr>
<tr class="even">
<td>grid <span class="math inline">\(3\times 3\)</span></td>
<td>center <span class="math inline">\([1,2]\times[1,2]\)</span></td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-29" class="level4">
<h4 class="anchored" data-anchor-id="complexity-29">Complexity</h4>
<ul>
<li>Offline sweep with Fenwick: preprocessing plus queries in <span class="math inline">\(O((n+q)\log n)\)</span></li>
<li>Range tree: build <span class="math inline">\(O(n \log n)\)</span>, query <span class="math inline">\(O(\log^2 n)\)</span> or <span class="math inline">\(O(\log n)\)</span> with fractional cascading</li>
<li>Segment or Fenwick of Fenwicks: dynamic updates and queries in <span class="math inline">\(O(\log^2 n)\)</span></li>
</ul>
<p>Range counting turns spatial selection into log-time queries by layering search trees and sorted auxiliary lists.</p>
</section>
</section>
<section id="plane-sweep-for-triangles" class="level3">
<h3 class="anchored" data-anchor-id="plane-sweep-for-triangles">730 Plane Sweep for Triangles</h3>
<p>The Plane Sweep for Triangles algorithm computes intersections, overlaps, or arrangements among a collection of triangles in the plane. It extends line- and segment-based sweeps to polygonal elements, managing both edges and faces as events.</p>
<section id="what-problem-are-we-solving-30" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-30">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> triangles <span class="math display">\[
T_i = {(x_{i1}, y_{i1}), (x_{i2}, y_{i2}), (x_{i3}, y_{i3})}
\]</span> we want to compute:</p>
<ul>
<li>All intersections among triangle edges</li>
<li>Overlapping regions (union area or intersection polygons)</li>
<li>Overlay decomposition: the full planar subdivision induced by triangle boundaries</li>
</ul>
<p>Such sweeps are essential in mesh overlay, computational geometry kernels, and computer graphics.</p>
</section>
<section id="naive-approach-1" class="level4">
<h4 class="anchored" data-anchor-id="naive-approach-1">Naive Approach</h4>
<p>Compare all triangle pairs <span class="math inline">\((T_i, T_j)\)</span> and their 9 edge pairs. Time: <span class="math display">\[
O(n^2)
\]</span> Too expensive for large meshes or spatial data.</p>
<p>We improve using plane sweep over edges and events.</p>
</section>
<section id="how-does-it-work-plain-language-30" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-30">How Does It Work (Plain Language)</h4>
<p>A triangle is composed of 3 line segments. We treat every triangle edge as a segment event and process with a segment sweep line:</p>
<ol type="1">
<li>Convert all triangle edges into a list of segments.</li>
<li>Sort all segment endpoints by <span class="math inline">\(x\)</span>.</li>
<li>Sweep line moves left to right.</li>
<li>Maintain an active set of edges intersecting the sweep.</li>
<li>When two edges intersect, record intersection point and, if needed, subdivide geometry.</li>
</ol>
<p>If computing overlay, intersections subdivide triangles into planar faces.</p>
</section>
<section id="example-walkthrough-27" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-27">Example Walkthrough</h4>
<p>Triangles:</p>
<ul>
<li><span class="math inline">\(T_1\)</span>: <span class="math inline">\((1,1)\)</span>, <span class="math inline">\((4,1)\)</span>, <span class="math inline">\((2,3)\)</span></li>
<li><span class="math inline">\(T_2\)</span>: <span class="math inline">\((2,0)\)</span>, <span class="math inline">\((5,2)\)</span>, <span class="math inline">\((3,4)\)</span></li>
</ul>
<ol type="1">
<li><p>Extract edges:</p>
<ul>
<li><span class="math inline">\(T_1\)</span>: <span class="math inline">\((1,1)-(4,1)\)</span>, <span class="math inline">\((4,1)-(2,3)\)</span>, <span class="math inline">\((2,3)-(1,1)\)</span></li>
<li><span class="math inline">\(T_2\)</span>: <span class="math inline">\((2,0)-(5,2)\)</span>, <span class="math inline">\((5,2)-(3,4)\)</span>, <span class="math inline">\((3,4)-(2,0)\)</span></li>
</ul></li>
<li><p>Collect all endpoints, sort by <span class="math inline">\(x\)</span>: <span class="math inline">\(x = 1, 2, 3, 4, 5\)</span></p></li>
<li><p>Sweep:</p>
<ul>
<li><span class="math inline">\(x=1\)</span>: add edges from <span class="math inline">\(T_1\)</span></li>
<li><span class="math inline">\(x=2\)</span>: add edges from <span class="math inline">\(T_2\)</span>; check intersections with current active set</li>
<li>find intersection between <span class="math inline">\(T_1\)</span>’s sloping edge and <span class="math inline">\(T_2\)</span>’s base edge</li>
<li>record intersection</li>
<li>update geometry if overlay needed</li>
</ul></li>
</ol>
<p>Output: intersection point(s), overlapping region polygon.</p>
</section>
<section id="geometric-predicates" class="level4">
<h4 class="anchored" data-anchor-id="geometric-predicates">Geometric Predicates</h4>
<p>For edges <span class="math inline">\((A,B)\)</span> and <span class="math inline">\((C,D)\)</span>: check intersection with orientation tests:</p>
<p><span class="math display">\[
\text{orient}(A,B,C) \ne \text{orient}(A,B,D)
\]</span> and <span class="math display">\[
\text{orient}(C,D,A) \ne \text{orient}(C,D,B)
\]</span></p>
<p>Intersections subdivide edges and update event queue.</p>
</section>
<section id="tiny-code-python-sketch-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-3">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> orient(a, b, c):</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(a,b,c,d):</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    o1 <span class="op">=</span> orient(a,b,c)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    o2 <span class="op">=</span> orient(a,b,d)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    o3 <span class="op">=</span> orient(c,d,a)</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    o4 <span class="op">=</span> orient(c,d,b)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> o1<span class="op">*</span>o2 <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">and</span> o3<span class="op">*</span>o4 <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sweep_triangles(triangles):</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    segments <span class="op">=</span> []</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tri <span class="kw">in</span> triangles:</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>            a, b <span class="op">=</span> tri[i], tri[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="dv">3</span>]</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a[<span class="dv">0</span>] <span class="op">&gt;</span> b[<span class="dv">0</span>]:</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>                a, b <span class="op">=</span> b, a</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>            segments.append((a,b))</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    events <span class="op">=</span> []</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> segments:</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>        events.append((s[<span class="dv">0</span>][<span class="dv">0</span>],<span class="st">'start'</span>,s))</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>        events.append((s[<span class="dv">1</span>][<span class="dv">0</span>],<span class="st">'end'</span>,s))</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>    events.sort()</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> []</span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>    intersections <span class="op">=</span> []</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x,typ,seg <span class="kw">in</span> events:</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="st">'start'</span>:</span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> active:</span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> intersect(seg[<span class="dv">0</span>],seg[<span class="dv">1</span>],s[<span class="dv">0</span>],s[<span class="dv">1</span>]):</span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>                    intersections.append(x)</span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>            active.append(seg)</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>            active.remove(seg)</span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> intersections</span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>triangles <span class="op">=</span> [[(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">4</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>)],[(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">5</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">4</span>)]]</span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Intersections:"</span>, sweep_triangles(triangles))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This basic form can be extended to compute actual intersection coordinates and polygons.</p>
</section>
<section id="why-it-matters-30" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-30">Why It Matters</h4>
<ul>
<li>Fundamental for overlay of meshes, polygon unions, intersection areas</li>
<li>Used in finite element meshing, map overlay, geometry engines</li>
<li>Generalizes segment sweeps to polygonal inputs</li>
</ul>
<p>Applications:</p>
<ul>
<li>CAD/CAE analysis</li>
<li>GIS overlay operations</li>
<li>Triangulated map intersection</li>
<li>Rendering and occlusion detection</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-17" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-17">A Gentle Proof (Why It Works)</h4>
<p>Each triangle contributes three edges, total <span class="math inline">\(3n\)</span> edges. Each intersection event occurs when two edges cross. The Bentley–Ottmann framework ensures every intersection is detected once, by local adjacency in the active set.</p>
<p>Total complexity:</p>
<p><span class="math display">\[
O((n + k)\log n)
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is number of intersections among edges.</p>
</section>
<section id="try-it-yourself-30" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-30">Try It Yourself</h4>
<ol type="1">
<li>Draw two triangles overlapping partially.</li>
<li>Extract edges, sort endpoints by <span class="math inline">\(x\)</span>.</li>
<li>Sweep, track active edges.</li>
<li>Mark each intersection.</li>
<li>Compare to brute-force intersection of all edge pairs.</li>
</ol>
</section>
<section id="test-cases-30" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-30">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Triangles</th>
<th>Intersections</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Disjoint</td>
<td>0</td>
<td>Non-overlapping</td>
</tr>
<tr class="even">
<td>Partially overlapping</td>
<td>&gt;0</td>
<td>Edge crossings</td>
</tr>
<tr class="odd">
<td>Nested</td>
<td>0</td>
<td>One triangle inside another</td>
</tr>
<tr class="even">
<td>Crossing edges</td>
<td>2</td>
<td>Intersecting boundaries</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-30" class="level4">
<h4 class="anchored" data-anchor-id="complexity-30">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O((n + k)\log n), \quad \text{Space: } O(n + k)
\]</span></p>
<p>The Plane Sweep for Triangles weaves polygon edges through the sweep line, tracing every crossing precisely, building the foundation for polygon overlays and mesh operations.</p>
</section>
</section>
</section>
<section id="section-74.-delaunay-and-voronoi-diagrams" class="level1">
<h1>Section 74. Delaunay and Voronoi Diagrams</h1>
<section id="delaunay-triangulation-incremental" class="level3">
<h3 class="anchored" data-anchor-id="delaunay-triangulation-incremental">731 Delaunay Triangulation (Incremental)</h3>
<p>Delaunay Triangulation is a fundamental structure in computational geometry. Given a set of points in the plane, it connects them into triangles such that no point lies inside the circumcircle of any triangle. The incremental algorithm builds this triangulation step by step, inserting one point at a time and locally restoring the Delaunay condition.</p>
<section id="what-problem-are-we-solving-31" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-31">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {p_1, p_2, \ldots, p_n}\)</span> in the plane, construct a triangulation <span class="math inline">\(T\)</span> such that for every triangle <span class="math inline">\(\triangle abc\)</span> in <span class="math inline">\(T\)</span>:</p>
<p><span class="math display">\[
\text{No other point } p \in P \text{ lies inside the circumcircle of } \triangle abc.
\]</span></p>
<p>This property leads to well-shaped triangles and maximized minimum angles, making Delaunay triangulations ideal for mesh generation, interpolation, and graphics.</p>
</section>
<section id="core-idea" class="level4">
<h4 class="anchored" data-anchor-id="core-idea">Core Idea</h4>
<p>Start with a super-triangle that contains all points. Insert points one by one, and after each insertion, update local connectivity to maintain the empty circle property.</p>
</section>
<section id="how-does-it-work-plain-language-31" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-31">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Initialize: Create a large triangle enclosing all input points.</p></li>
<li><p>Insert each point <span class="math inline">\(p_i\)</span>:</p>
<ul>
<li>Find the triangle that contains <span class="math inline">\(p_i\)</span>.</li>
<li>Split it into sub-triangles connecting <span class="math inline">\(p_i\)</span> to its vertices.</li>
</ul></li>
<li><p>Legalize edges:</p>
<ul>
<li>For each new edge, check the Delaunay condition.</li>
<li>If violated (neighbor’s opposite point inside circumcircle), flip the edge.</li>
</ul></li>
<li><p>Repeat until all points are inserted.</p></li>
<li><p>Remove triangles touching the super-triangle vertices.</p></li>
</ol>
</section>
<section id="example-walkthrough-28" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-28">Example Walkthrough</h4>
<p>Points: <span class="math inline">\(P = {A(0,0), B(2,0), C(1,2), D(1,1)}\)</span></p>
<ol type="1">
<li>Super-triangle covers all points.</li>
<li>Insert <span class="math inline">\(A, B, C\)</span> → initial triangle <span class="math inline">\(\triangle ABC\)</span>.</li>
<li>Insert <span class="math inline">\(D(1,1)\)</span> → split into <span class="math inline">\(\triangle ABD\)</span>, <span class="math inline">\(\triangle BCD\)</span>, <span class="math inline">\(\triangle CAD\)</span>.</li>
<li>Check each edge for circumcircle violation.</li>
<li>Flip edges if needed.</li>
</ol>
<p>Output: triangulation satisfying empty circle condition.</p>
</section>
<section id="delaunay-condition-empty-circle-test" class="level4">
<h4 class="anchored" data-anchor-id="delaunay-condition-empty-circle-test">Delaunay Condition (Empty Circle Test)</h4>
<p>For triangle with vertices <span class="math inline">\(a,b,c\)</span> and point <span class="math inline">\(p\)</span>, <span class="math inline">\(p\)</span> lies inside the circumcircle if the determinant is positive:</p>
<p><span class="math display">\[
\begin{vmatrix}
a_x &amp; a_y &amp; a_x^2 + a_y^2 &amp; 1 \\
b_x &amp; b_y &amp; b_x^2 + b_y^2 &amp; 1 \\
c_x &amp; c_y &amp; c_x^2 + c_y^2 &amp; 1 \\
p_x &amp; p_y &amp; p_x^2 + p_y^2 &amp; 1
\end{vmatrix} &gt; 0
\]</span></p>
<p>If true, flip the edge opposite <span class="math inline">\(p\)</span> to restore Delaunay property.</p>
</section>
<section id="tiny-code-python-sketch-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-4">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circumcircle_contains(a, b, c, p):</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    ax, ay <span class="op">=</span> a</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    bx, by <span class="op">=</span> b</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    cx, cy <span class="op">=</span> c</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    px, py <span class="op">=</span> p</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    mat <span class="op">=</span> [</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>        [ax <span class="op">-</span> px, ay <span class="op">-</span> py, (ax <span class="op">-</span> px)<span class="dv">2</span> <span class="op">+</span> (ay <span class="op">-</span> py)<span class="dv">2</span>],</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        [bx <span class="op">-</span> px, by <span class="op">-</span> py, (bx <span class="op">-</span> px)<span class="dv">2</span> <span class="op">+</span> (by <span class="op">-</span> py)<span class="dv">2</span>],</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        [cx <span class="op">-</span> px, cy <span class="op">-</span> py, (cx <span class="op">-</span> px)<span class="dv">2</span> <span class="op">+</span> (cy <span class="op">-</span> py)<span class="dv">2</span>],</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    det <span class="op">=</span> (</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>        mat[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">*</span> (mat[<span class="dv">1</span>][<span class="dv">1</span>]<span class="op">*</span>mat[<span class="dv">2</span>][<span class="dv">2</span>] <span class="op">-</span> mat[<span class="dv">2</span>][<span class="dv">1</span>]<span class="op">*</span>mat[<span class="dv">1</span>][<span class="dv">2</span>])</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> mat[<span class="dv">1</span>][<span class="dv">0</span>] <span class="op">*</span> (mat[<span class="dv">0</span>][<span class="dv">1</span>]<span class="op">*</span>mat[<span class="dv">2</span>][<span class="dv">2</span>] <span class="op">-</span> mat[<span class="dv">2</span>][<span class="dv">1</span>]<span class="op">*</span>mat[<span class="dv">0</span>][<span class="dv">2</span>])</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> mat[<span class="dv">2</span>][<span class="dv">0</span>] <span class="op">*</span> (mat[<span class="dv">0</span>][<span class="dv">1</span>]<span class="op">*</span>mat[<span class="dv">1</span>][<span class="dv">2</span>] <span class="op">-</span> mat[<span class="dv">1</span>][<span class="dv">1</span>]<span class="op">*</span>mat[<span class="dv">0</span>][<span class="dv">2</span>])</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> det <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> incremental_delaunay(points):</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder: real implementation would use edge-flip structure</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Here we return list of triangles in pseudocode form</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [(<span class="st">"triangulation"</span>, points)]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This pseudocode shows the circumcircle test, core of the legalization step. Full implementation maintains edge adjacency and triangle flipping.</p>
</section>
<section id="why-it-matters-31" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-31">Why It Matters</h4>
<ul>
<li>Produces high-quality meshes (no skinny triangles)</li>
<li>Used in terrain modeling, mesh refinement, finite element methods</li>
<li>Forms basis of Voronoi diagrams (its dual)</li>
</ul>
<p>Applications:</p>
<ul>
<li>3D modeling and rendering</li>
<li>Scientific computing and simulation</li>
<li>GIS interpolation (TIN models)</li>
<li>Computational geometry toolkits (CGAL, Shapely)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-18" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-18">A Gentle Proof (Why It Works)</h4>
<p>The incremental algorithm maintains Delaunay property at each step:</p>
<ul>
<li>Initially, super-triangle satisfies it trivially.</li>
<li>Each insertion subdivides existing triangle(s).</li>
<li>Edge flips restore local optimality.</li>
</ul>
<p>Because every insertion preserves the empty circle condition, the final triangulation is globally Delaunay.</p>
<p>Time complexity depends on insertion order and point distribution:</p>
<p><span class="math display">\[
O(n^2) \text{ worst case}, \quad O(n \log n) \text{ average case.}
\]</span></p>
</section>
<section id="try-it-yourself-31" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-31">Try It Yourself</h4>
<ol type="1">
<li>Draw three points, form triangle.</li>
<li>Add a fourth inside, connect to all vertices.</li>
<li>Check each edge’s circumcircle test.</li>
<li>Flip any violating edges.</li>
<li>Repeat for more points.</li>
</ol>
<p>Observe how the triangulation adapts to stay Delaunay.</p>
</section>
<section id="test-cases-31" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-31">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Triangulation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0),(2,0),(1,2)</td>
<td>Single triangle</td>
</tr>
<tr class="even">
<td>+ (1,1)</td>
<td>3 triangles, Delaunay</td>
</tr>
<tr class="odd">
<td>Random 10 points</td>
<td>Valid triangulation</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-31" class="level4">
<h4 class="anchored" data-anchor-id="complexity-31">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n) \text{ (average)}, \quad O(n^2) \text{ (worst)}
\]</span> <span class="math display">\[
\text{Space: } O(n)
\]</span></p>
<p>The Incremental Delaunay Triangulation builds geometry like a sculptor, point by point, flipping edges until every triangle fits the empty-circle harmony.</p>
</section>
</section>
<section id="delaunay-divide-conquer" class="level3">
<h3 class="anchored" data-anchor-id="delaunay-divide-conquer">732 Delaunay (Divide &amp; Conquer)</h3>
<p>The Divide &amp; Conquer Delaunay Triangulation algorithm constructs the Delaunay triangulation by recursively dividing the point set, triangulating subproblems, and merging them with geometric precision. It’s one of the most elegant and efficient methods, achieving <span class="math display">\[O(n \log n)\]</span> time complexity while guaranteeing the empty-circle property.</p>
<section id="what-problem-are-we-solving-32" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-32">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {p_1, p_2, \ldots, p_n}\)</span> in the plane, find a triangulation such that for each triangle <span class="math inline">\(\triangle abc\)</span>:</p>
<p><span class="math display">\[
\text{No other point } p \in P \text{ lies inside the circumcircle of } \triangle abc
\]</span></p>
<p>We seek a globally Delaunay structure, built recursively from local solutions.</p>
</section>
<section id="how-does-it-work-plain-language-32" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-32">How Does It Work (Plain Language)</h4>
<p>The Divide &amp; Conquer method parallels merge sort:</p>
<ol type="1">
<li><p>Sort points by <span class="math inline">\(x\)</span>-coordinate.</p></li>
<li><p>Divide the set into two halves <span class="math inline">\(P_L\)</span> and <span class="math inline">\(P_R\)</span>.</p></li>
<li><p>Recursively triangulate each half to get <span class="math inline">\(T_L\)</span> and <span class="math inline">\(T_R\)</span>.</p></li>
<li><p>Merge the two triangulations:</p>
<ul>
<li>Find the lower common tangent connecting <span class="math inline">\(T_L\)</span> and <span class="math inline">\(T_R\)</span>.</li>
<li>Then zip upward, adding new Delaunay edges until reaching the upper tangent.</li>
<li>Remove edges that violate the empty-circle condition during merging.</li>
</ul></li>
</ol>
<p>After merging, <span class="math inline">\(T = T_L \cup T_R\)</span> is the full Delaunay triangulation.</p>
</section>
<section id="key-geometric-step-merging" class="level4">
<h4 class="anchored" data-anchor-id="key-geometric-step-merging">Key Geometric Step: Merging</h4>
<p>To merge two Delaunay triangulations:</p>
<ol type="1">
<li>Find the base edge that connects the lowest visible points (the lower tangent).</li>
<li>Iteratively add edges connecting points that form valid Delaunay triangles.</li>
<li>Flip edges if they violate the circumcircle condition.</li>
<li>Continue upward until the upper tangent is reached.</li>
</ol>
<p>This “zipper” merge creates a seamless, globally valid triangulation.</p>
</section>
<section id="example-walkthrough-29" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-29">Example Walkthrough</h4>
<p>Points: <span class="math inline">\(P = {(0,0), (2,0), (1,2), (4,0), (5,2)}\)</span></p>
<ol type="1">
<li><p>Sort by <span class="math inline">\(x\)</span>: <span class="math inline">\((0,0), (1,2), (2,0), (4,0), (5,2)\)</span></p></li>
<li><p>Divide: left half <span class="math inline">\((0,0),(1,2),(2,0)\)</span>, right half <span class="math inline">\((4,0),(5,2)\)</span></p></li>
<li><p>Triangulate each half:</p>
<ul>
<li><span class="math inline">\(T_L\)</span>: <span class="math inline">\(\triangle (0,0),(1,2),(2,0)\)</span></li>
<li><span class="math inline">\(T_R\)</span>: <span class="math inline">\(\triangle (4,0),(5,2)\)</span></li>
</ul></li>
<li><p>Merge:</p>
<ul>
<li>Find lower tangent <span class="math inline">\((2,0)-(4,0)\)</span></li>
<li>Add connecting edges, test with empty-circle condition</li>
<li>Final triangulation: Delaunay over all five points</li>
</ul></li>
</ol>
</section>
<section id="delaunay-test-empty-circle-check" class="level4">
<h4 class="anchored" data-anchor-id="delaunay-test-empty-circle-check">Delaunay Test (Empty Circle Check)</h4>
<p>For each candidate edge <span class="math inline">\((a,b)\)</span> connecting left and right sides, test whether adding a third vertex <span class="math inline">\(c\)</span> maintains Delaunay property:</p>
<p><span class="math display">\[
\begin{vmatrix}
a_x &amp; a_y &amp; a_x^2 + a_y^2 &amp; 1 \\
b_x &amp; b_y &amp; b_x^2 + b_y^2 &amp; 1 \\
c_x &amp; c_y &amp; c_x^2 + c_y^2 &amp; 1 \\
p_x &amp; p_y &amp; p_x^2 + p_y^2 &amp; 1
\end{vmatrix} \le 0
\]</span></p>
<p>If violated (positive determinant), remove or flip edge.</p>
</section>
<section id="tiny-code-python-sketch-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-5">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delaunay_divide(points):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> <span class="bu">sorted</span>(points)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(points) <span class="op">&lt;=</span> <span class="dv">3</span>:</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># base case: direct triangulation</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [<span class="bu">tuple</span>(points)]</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(points)<span class="op">//</span><span class="dv">2</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> delaunay_divide(points[:mid])</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> delaunay_divide(points[mid:])</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge_delaunay(left, right)</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_delaunay(left, right):</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder merge; real version finds tangents and flips edges</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> left <span class="op">+</span> right</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This skeleton shows recursive structure; real implementations maintain adjacency, compute tangents, and apply empty-circle checks.</p>
</section>
<section id="why-it-matters-32" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-32">Why It Matters</h4>
<ul>
<li>Optimal time complexity <span class="math inline">\(O(n \log n)\)</span></li>
<li>Elegant divide-and-conquer paradigm</li>
<li>Basis for Fortune’s sweep and advanced triangulators</li>
<li>Ideal for static point sets, terrain meshes, GIS models</li>
</ul>
<p>Applications:</p>
<ul>
<li>Terrain modeling (TIN generation)</li>
<li>Scientific simulation (finite element meshes)</li>
<li>Voronoi diagram construction (via dual graph)</li>
<li>Computational geometry libraries (CGAL, Triangle)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-19" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-19">A Gentle Proof (Why It Works)</h4>
<ol type="1">
<li><p>Base case: small sets are trivially Delaunay.</p></li>
<li><p>Inductive step: merging preserves Delaunay property since:</p>
<ul>
<li>All edges created during merge satisfy local empty-circle test.</li>
<li>The merge only connects boundary vertices visible to each other.</li>
</ul></li>
</ol>
<p>Therefore, by induction, the final triangulation is Delaunay.</p>
<p>Each merge step takes linear time, and there are <span class="math inline">\(\log n\)</span> levels:</p>
<p><span class="math display">\[
T(n) = 2T(n/2) + O(n) = O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-32" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-32">Try It Yourself</h4>
<ol type="1">
<li>Plot 6–8 points sorted by <span class="math inline">\(x\)</span>.</li>
<li>Divide into two halves, triangulate each.</li>
<li>Draw lower tangent, connect visible vertices.</li>
<li>Flip any edges violating empty-circle property.</li>
<li>Verify final triangulation satisfies Delaunay rule.</li>
</ol>
</section>
<section id="test-cases-32" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-32">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Triangulation Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3 points</td>
<td>Single triangle</td>
</tr>
<tr class="even">
<td>5 points</td>
<td>Merged triangles</td>
</tr>
<tr class="odd">
<td>Random 10 points</td>
<td>Valid Delaunay triangulation</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-32" class="level4">
<h4 class="anchored" data-anchor-id="complexity-32">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Divide &amp; Conquer Delaunay algorithm builds harmony through balance, splitting the plane, solving locally, and merging globally into a perfect empty-circle mosaic.</p>
</section>
</section>
<section id="delaunay-fortunes-sweep" class="level3">
<h3 class="anchored" data-anchor-id="delaunay-fortunes-sweep">733 Delaunay (Fortune’s Sweep)</h3>
<p>The Fortune’s Sweep Algorithm is a brilliant plane-sweep approach to constructing the Delaunay triangulation and its dual, the Voronoi diagram, in <span class="math display">\[
O(n \log n)
\]</span> time. It elegantly slides a sweep line (or parabola) across the plane, maintaining a dynamic structure called the beach line to trace the evolution of Voronoi edges, from which the Delaunay edges can be derived.</p>
<section id="what-problem-are-we-solving-33" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-33">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {p_1, p_2, \ldots, p_n}\)</span> (called <em>sites</em>), construct their Delaunay triangulation, a set of triangles such that no point lies inside the circumcircle of any triangle.</p>
<p>Its dual graph, the Voronoi diagram, partitions the plane into cells, one per point, containing all locations closer to that point than to any other.</p>
<p>Fortune’s algorithm constructs both structures simultaneously, efficiently.</p>
</section>
<section id="key-insight" class="level4">
<h4 class="anchored" data-anchor-id="key-insight">Key Insight</h4>
<p>As a sweep line moves downward, the frontier of influence of each site forms a parabolic arc. The beach line is the union of all active arcs. Voronoi edges appear where arcs meet; Delaunay edges connect sites whose arcs share a boundary.</p>
<p>The algorithm processes two kinds of events:</p>
<ol type="1">
<li>Site Events, when a new site is reached by the sweep line</li>
<li>Circle Events, when arcs vanish as the beach line reshapes (three arcs meet in a circle)</li>
</ol>
</section>
<section id="how-does-it-work-plain-language-33" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-33">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Sort all sites by <span class="math inline">\(y\)</span>-coordinate (top to bottom).</p></li>
<li><p>Sweep a horizontal line downward:</p>
<ul>
<li>At each site event, insert a new parabolic arc into the beach line.</li>
<li>Update intersections to create Voronoi/Delaunay edges.</li>
</ul></li>
<li><p>At each circle event, remove the disappearing arc (when three arcs meet at a vertex of the Voronoi diagram).</p></li>
<li><p>Maintain:</p>
<ul>
<li>Event queue: upcoming site/circle events</li>
<li>Beach line: balanced tree of arcs</li>
<li>Output edges: Voronoi edges / Delaunay edges (dual)</li>
</ul></li>
<li><p>Continue until all events are processed.</p></li>
<li><p>Close all remaining open edges at the bounding box.</p></li>
</ol>
<p>The Delaunay triangulation is recovered by connecting sites that share a Voronoi edge.</p>
</section>
<section id="example-walkthrough-30" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-30">Example Walkthrough</h4>
<p>Points:</p>
<ul>
<li><span class="math inline">\(A(2,6), B(5,5), C(3,3)\)</span></li>
</ul>
<ol type="1">
<li><p>Sort by <span class="math inline">\(y\)</span>: <span class="math inline">\(A, B, C\)</span></p></li>
<li><p>Sweep down:</p>
<ul>
<li>Site <span class="math inline">\(A\)</span>: create new arc</li>
<li>Site <span class="math inline">\(B\)</span>: new arc splits existing arc, new breakpoint → Voronoi edge starts</li>
<li>Site <span class="math inline">\(C\)</span>: another split, more breakpoints</li>
</ul></li>
<li><p>Circle event: arcs merge → Voronoi vertex, record Delaunay triangle</p></li>
<li><p>Output: three Voronoi cells, Delaunay triangle connecting <span class="math inline">\(A, B, C\)</span></p></li>
</ol>
</section>
<section id="data-structures" class="level4">
<h4 class="anchored" data-anchor-id="data-structures">Data Structures</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Structure</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Event queue (priority queue)</td>
<td>Site &amp; circle events sorted by <span class="math inline">\(y\)</span></td>
</tr>
<tr class="even">
<td>Beach line (balanced BST)</td>
<td>Active arcs (parabolas)</td>
</tr>
<tr class="odd">
<td>Output edge list</td>
<td>Voronoi / Delaunay edges</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-pseudocode">Tiny Code (Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fortunes_algorithm(points):</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    points.sort(key<span class="op">=</span><span class="kw">lambda</span> p: <span class="op">-</span>p[<span class="dv">1</span>])  <span class="co"># top to bottom</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    event_queue <span class="op">=</span> [(p[<span class="dv">1</span>], <span class="st">'site'</span>, p) <span class="cf">for</span> p <span class="kw">in</span> points]</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    beach_line <span class="op">=</span> []</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    voronoi_edges <span class="op">=</span> []</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> event_queue:</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>        y, typ, data <span class="op">=</span> event_queue.pop(<span class="dv">0</span>)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="st">'site'</span>:</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>            insert_arc(beach_line, data)</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>            remove_arc(beach_line, data)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>        update_edges(beach_line, voronoi_edges)</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> voronoi_edges</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This sketch omits details but shows the event-driven sweep structure.</p>
</section>
<section id="why-it-matters-33" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-33">Why It Matters</h4>
<ul>
<li>Optimal <span class="math inline">\(O(n \log n)\)</span> Delaunay / Voronoi construction</li>
<li>Avoids complex global flipping</li>
<li>Beautiful geometric interpretation: parabolas + sweep line</li>
<li>Foundation of computational geometry libraries (e.g., CGAL, Boost, Qhull)</li>
</ul>
<p>Applications:</p>
<ul>
<li>Nearest neighbor search (Voronoi regions)</li>
<li>Terrain and mesh generation</li>
<li>Cellular coverage modeling</li>
<li>Motion planning and influence maps</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-20" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-20">A Gentle Proof (Why It Works)</h4>
<p>Each site and circle triggers at most one event, giving <span class="math inline">\(O(n)\)</span> events. Each event takes <span class="math inline">\(O(\log n)\)</span> time (insertion/removal/search in balanced tree). All edges satisfy local Delaunay condition because arcs are created only when parabolas meet (equal distance frontier).</p>
<p>Therefore, total complexity:</p>
<p><span class="math display">\[
O(n \log n)
\]</span></p>
<p>Correctness follows from:</p>
<ul>
<li>Sweep line maintains valid partial Voronoi/Delaunay structure</li>
<li>Every Delaunay edge is created exactly once (dual to Voronoi edges)</li>
</ul>
</section>
<section id="try-it-yourself-33" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-33">Try It Yourself</h4>
<ol type="1">
<li>Plot 3–5 points on paper.</li>
<li>Imagine a line sweeping downward.</li>
<li>Draw parabolic arcs from each point (distance loci).</li>
<li>Mark intersections (Voronoi edges).</li>
<li>Connect adjacent points, Delaunay edges appear naturally.</li>
</ol>
</section>
<section id="test-cases-33" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-33">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Delaunay Triangles</th>
<th>Voronoi Cells</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3 points forming triangle</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>4 non-collinear points</td>
<td>2</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Grid points</td>
<td>many</td>
<td>grid-like cells</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-33" class="level4">
<h4 class="anchored" data-anchor-id="complexity-33">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Fortune’s Sweep Algorithm reveals the deep duality of geometry, as a moving parabola traces invisible boundaries, triangles and cells crystallize from pure distance symmetry.</p>
</section>
</section>
<section id="voronoi-diagram-fortunes-sweep" class="level3">
<h3 class="anchored" data-anchor-id="voronoi-diagram-fortunes-sweep">734 Voronoi Diagram (Fortune’s Sweep)</h3>
<p>The Voronoi Diagram partitions the plane into regions, each region consists of all points closest to a specific site. Fortune’s Sweep Line Algorithm constructs this structure in <span class="math display">\[O(n \log n)\]</span> time, using the same framework as the Delaunay sweep, since the two are duals.</p>
<section id="what-problem-are-we-solving-34" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-34">What Problem Are We Solving?</h4>
<p>Given a set of <span class="math inline">\(n\)</span> sites <span class="math display">\[
P = {p_1, p_2, \ldots, p_n}
\]</span> each at <span class="math inline">\((x_i, y_i)\)</span>, the Voronoi diagram divides the plane into cells:</p>
<p><span class="math display">\[
V(p_i) = { q \mid d(q, p_i) \le d(q, p_j), \ \forall j \ne i }
\]</span></p>
<p>Each Voronoi cell <span class="math inline">\(V(p_i)\)</span> is a convex polygon (for distinct sites). Edges are perpendicular bisectors between pairs of sites. Vertices are circumcenters of triples of sites.</p>
</section>
<section id="why-use-fortunes-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="why-use-fortunes-algorithm">Why Use Fortune’s Algorithm?</h4>
<p>Naive approach: compute all pairwise bisectors (<span class="math inline">\(O(n^2)\)</span>), then intersect them. Fortune’s method improves to <span class="math display">\[O(n \log n)\]</span> by sweeping a line and maintaining parabolic arcs that define the beach line, the evolving boundary between processed and unprocessed regions.</p>
</section>
<section id="how-does-it-work-plain-language-34" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-34">How Does It Work (Plain Language)</h4>
<p>The sweep line moves top-down (decreasing <span class="math inline">\(y\)</span>), dynamically tracing the frontier of influence for each site.</p>
<ol type="1">
<li><p>Site Events</p>
<ul>
<li>When sweep reaches a new site, insert a new parabola arc into the beach line.</li>
<li>Intersections between arcs become breakpoints, which form Voronoi edges.</li>
</ul></li>
<li><p>Circle Events</p>
<ul>
<li>When three consecutive arcs converge, the middle one disappears.</li>
<li>The convergence point is a Voronoi vertex (circumcenter of three sites).</li>
</ul></li>
<li><p>Event Queue</p>
<ul>
<li>Sorted by <span class="math inline">\(y\)</span> coordinate (priority queue).</li>
<li>Each processed event updates the beach line and outputs edges.</li>
</ul></li>
<li><p>Termination</p>
<ul>
<li>When all events processed, extend unfinished edges to bounding box.</li>
</ul></li>
</ol>
<p>The output is a full Voronoi diagram, and by duality, its Delaunay triangulation.</p>
</section>
<section id="example-walkthrough-31" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-31">Example Walkthrough</h4>
<p>Sites: <span class="math inline">\(A(2,6), B(5,5), C(3,3)\)</span></p>
<p>Steps:</p>
<ol type="1">
<li>Sweep starts at top (site A).</li>
<li>Insert A → beach line = single arc.</li>
<li>Reach B → insert new arc, two arcs meet → start Voronoi edge.</li>
<li>Reach C → new arc, more edges form.</li>
<li>Circle event where arcs converge → Voronoi vertex at circumcenter.</li>
<li>Sweep completes → edges finalized, diagram closed.</li>
</ol>
<p>Output: 3 Voronoi cells, 3 vertices, 3 Delaunay edges.</p>
</section>
<section id="beach-line-representation" class="level4">
<h4 class="anchored" data-anchor-id="beach-line-representation">Beach Line Representation</h4>
<p>The beach line is a sequence of parabolic arcs, stored in a balanced BST keyed by <span class="math inline">\(x\)</span>-order. Breakpoints between arcs trace Voronoi edges.</p>
<p>When a site is inserted, it splits an existing arc. When a circle event triggers, an arc disappears, creating a vertex.</p>
</section>
<section id="tiny-code-pseudocode-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-pseudocode-1">Tiny Code (Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> voronoi_fortune(points):</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    points.sort(key<span class="op">=</span><span class="kw">lambda</span> p: <span class="op">-</span>p[<span class="dv">1</span>])  <span class="co"># top to bottom</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    event_queue <span class="op">=</span> [(p[<span class="dv">1</span>], <span class="st">'site'</span>, p) <span class="cf">for</span> p <span class="kw">in</span> points]</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    beach_line <span class="op">=</span> []</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    voronoi_edges <span class="op">=</span> []</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> event_queue:</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>        y, typ, data <span class="op">=</span> event_queue.pop(<span class="dv">0</span>)</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> typ <span class="op">==</span> <span class="st">'site'</span>:</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>            insert_arc(beach_line, data)</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>            remove_arc(beach_line, data)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>        update_edges(beach_line, voronoi_edges)</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> voronoi_edges</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This high-level structure emphasizes the event-driven nature of the algorithm. Implementations use specialized data structures for arcs, breakpoints, and circle event scheduling.</p>
</section>
<section id="why-it-matters-34" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-34">Why It Matters</h4>
<ul>
<li>Constructs Voronoi and Delaunay simultaneously</li>
<li>Optimal <span class="math inline">\(O(n \log n)\)</span> complexity</li>
<li>Robust for large-scale geometric data</li>
<li>Foundation of spatial structures in computational geometry</li>
</ul>
<p>Applications:</p>
<ul>
<li>Nearest-neighbor search</li>
<li>Spatial partitioning in games and simulations</li>
<li>Facility location and influence maps</li>
<li>Mesh generation (via Delaunay dual)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-21" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-21">A Gentle Proof (Why It Works)</h4>
<p>Each site event adds exactly one arc → <span class="math inline">\(O(n)\)</span> site events. Each circle event removes one arc → <span class="math inline">\(O(n)\)</span> circle events. Each event processed in <span class="math inline">\(O(\log n)\)</span> (tree updates, priority queue ops).</p>
<p>Thus, total:</p>
<p><span class="math display">\[
O(n \log n)
\]</span></p>
<p>Correctness follows from geometry of parabolas:</p>
<ul>
<li>Breakpoints always move monotonically</li>
<li>Each Voronoi vertex is created exactly once</li>
<li>Beach line evolves without backtracking</li>
</ul>
</section>
<section id="try-it-yourself-34" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-34">Try It Yourself</h4>
<ol type="1">
<li>Plot 3–5 points.</li>
<li>Draw perpendicular bisectors pairwise.</li>
<li>Note intersections (Voronoi vertices).</li>
<li>Connect edges into convex polygons.</li>
<li>Compare to Fortune’s sweep behavior.</li>
</ol>
</section>
<section id="test-cases-34" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-34">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Sites</th>
<th>Voronoi Regions</th>
<th>Vertices</th>
<th>Delaunay Edges</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3 points</td>
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>4 non-collinear</td>
<td>4</td>
<td>3</td>
<td>5</td>
</tr>
<tr class="odd">
<td>Grid 3x3</td>
<td>9</td>
<td>many</td>
<td>lattice mesh</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-34" class="level4">
<h4 class="anchored" data-anchor-id="complexity-34">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Fortune’s Sweep for Voronoi Diagrams is geometry in motion, parabolas rising and falling under a moving horizon, tracing invisible borders that define proximity and structure.</p>
</section>
</section>
<section id="incremental-voronoi" class="level3">
<h3 class="anchored" data-anchor-id="incremental-voronoi">735 Incremental Voronoi</h3>
<p>The Incremental Voronoi Algorithm builds a Voronoi diagram step by step by inserting one site at a time, updating the existing diagram locally rather than recomputing from scratch. It’s conceptually simple and forms the basis of dynamic and online Voronoi systems.</p>
<section id="what-problem-are-we-solving-35" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-35">What Problem Are We Solving?</h4>
<p>We want to construct or update a Voronoi diagram for a set of points <span class="math display">\[
P = {p_1, p_2, \ldots, p_n}
\]</span> so that for each site <span class="math inline">\(p_i\)</span>, its Voronoi cell contains all points closer to <span class="math inline">\(p_i\)</span> than to any other site.</p>
<p>In static algorithms (like Fortune’s sweep), all points must be known upfront. But what if we want to add sites incrementally, one at a time, and update the diagram locally?</p>
<p>That’s exactly what this algorithm enables.</p>
</section>
<section id="how-does-it-work-plain-language-35" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-35">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Start simple: begin with a single site, its cell is the entire plane (bounded by a large box).</p></li>
<li><p>Insert next site:</p>
<ul>
<li>Locate which cell contains it.</li>
<li>Compute perpendicular bisector between new and existing site.</li>
<li>Clip existing cells using the bisector.</li>
<li>The new site’s cell is formed from regions closer to it than any others.</li>
</ul></li>
<li><p>Repeat for all sites.</p></li>
</ol>
<p>Each insertion modifies only nearby cells, not the entire diagram, this local nature is key.</p>
</section>
<section id="example-walkthrough-32" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-32">Example Walkthrough</h4>
<p>Sites: <span class="math inline">\(A(2,2)\)</span> → <span class="math inline">\(B(6,2)\)</span> → <span class="math inline">\(C(4,5)\)</span></p>
<ol type="1">
<li><p>Start with A: single cell (whole bounding box).</p></li>
<li><p>Add B:</p>
<ul>
<li>Draw perpendicular bisector between A and B.</li>
<li>Split plane vertically → two cells.</li>
</ul></li>
<li><p>Add C:</p>
<ul>
<li>Draw bisector with A and B.</li>
<li>Intersect bisectors to form three Voronoi regions.</li>
</ul></li>
</ol>
<p>Each new site carves its influence area by cutting existing cells.</p>
</section>
<section id="geometric-steps-insert-site-p" class="level4">
<h4 class="anchored" data-anchor-id="geometric-steps-insert-site-p">Geometric Steps (Insert Site <span class="math inline">\(p\)</span>)</h4>
<ol type="1">
<li>Locate containing cell: find which cell <span class="math inline">\(p\)</span> lies in.</li>
<li>Find affected cells: these are the neighbors whose regions are closer to <span class="math inline">\(p\)</span> than some part of their area.</li>
<li>Compute bisectors between <span class="math inline">\(p\)</span> and each affected site.</li>
<li>Clip and rebuild cell polygons.</li>
<li>Update adjacency graph of neighboring cells.</li>
</ol>
</section>
<section id="data-structures-1" class="level4">
<h4 class="anchored" data-anchor-id="data-structures-1">Data Structures</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Structure</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cell list</td>
<td>Polygon boundaries per site</td>
</tr>
<tr class="even">
<td>Site adjacency graph</td>
<td>For efficient neighbor lookups</td>
</tr>
<tr class="odd">
<td>Bounding box</td>
<td>For finite diagram truncation</td>
</tr>
</tbody>
</table>
<p>Optional acceleration:</p>
<ul>
<li>Delaunay triangulation: dual structure for locating cells faster</li>
<li>Spatial index (KD-tree) for cell search</li>
</ul>
</section>
<section id="tiny-code-pseudocode-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-pseudocode-2">Tiny Code (Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> incremental_voronoi(points, bbox):</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    diagram <span class="op">=</span> init_diagram(points[<span class="dv">0</span>], bbox)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points[<span class="dv">1</span>:]:</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>        cell <span class="op">=</span> locate_cell(diagram, p)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>        neighbors <span class="op">=</span> find_neighbors(cell)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> q <span class="kw">in</span> neighbors:</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>            bisector <span class="op">=</span> perpendicular_bisector(p, q)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>            clip_cells(diagram, p, q, bisector)</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>        add_cell(diagram, p)</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> diagram</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This pseudocode highlights progressive construction by bisector clipping.</p>
</section>
<section id="why-it-matters-35" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-35">Why It Matters</h4>
<ul>
<li>Simple concept, easy to visualize and implement</li>
<li>Local updates, only nearby regions change</li>
<li>Works for dynamic systems (adding/removing points)</li>
<li>Dual to incremental Delaunay triangulation</li>
</ul>
<p>Applications:</p>
<ul>
<li>Online facility location</li>
<li>Dynamic sensor coverage</li>
<li>Real-time influence mapping</li>
<li>Game AI regions (unit territories)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-22" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-22">A Gentle Proof (Why It Works)</h4>
<p>Each step maintains the Voronoi property:</p>
<ul>
<li>Every region is intersection of half-planes</li>
<li>Each insertion adds new bisectors, refining the partition</li>
<li>No recomputation of unaffected regions</li>
</ul>
<p>Time complexity depends on how efficiently we locate affected cells. Naively <span class="math inline">\(O(n^2)\)</span>, but with Delaunay dual and point location: <span class="math display">\[
O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-35" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-35">Try It Yourself</h4>
<ol type="1">
<li>Draw bounding box and one point (site).</li>
<li>Insert second point, draw perpendicular bisector.</li>
<li>Insert third, draw bisectors to all sites, clip overlapping regions.</li>
<li>Shade each Voronoi cell, check boundaries are equidistant from two sites.</li>
<li>Repeat for more points.</li>
</ol>
</section>
<section id="test-cases-35" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-35">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Sites</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1 site</td>
<td>Whole box</td>
</tr>
<tr class="even">
<td>2 sites</td>
<td>Two half-planes</td>
</tr>
<tr class="odd">
<td>3 sites</td>
<td>Three convex polygons</td>
</tr>
<tr class="even">
<td>5 sites</td>
<td>Complex polygon arrangement</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-35" class="level4">
<h4 class="anchored" data-anchor-id="complexity-35">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n^2) \text{ naive}, \quad O(n \log n) \text{ with Delaunay assist}
\]</span> <span class="math display">\[
\text{Space: } O(n)
\]</span></p>
<p>The Incremental Voronoi Algorithm grows the diagram like crystal formation, each new point carves its own region, reshaping the world around it with clean geometric cuts.</p>
</section>
</section>
<section id="bowyerwatson" class="level3">
<h3 class="anchored" data-anchor-id="bowyerwatson">736 Bowyer–Watson</h3>
<p>The Bowyer–Watson Algorithm is a simple yet powerful incremental method for building a Delaunay triangulation. Each new point is inserted one at a time, and the algorithm locally re-triangulates the region affected by that insertion, ensuring the empty-circle property remains true.</p>
<p>It is one of the most intuitive and widely used Delaunay construction methods.</p>
<section id="what-problem-are-we-solving-36" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-36">What Problem Are We Solving?</h4>
<p>We want to construct a Delaunay triangulation for a set of points <span class="math display">\[
P = {p_1, p_2, \ldots, p_n}
\]</span> such that every triangle satisfies the empty-circle property:</p>
<p><span class="math display">\[
\text{For every triangle } \triangle abc, \text{ no other point } p \in P \text{ lies inside its circumcircle.}
\]</span></p>
<p>We build the triangulation incrementally, maintaining validity after each insertion.</p>
</section>
<section id="how-does-it-work-plain-language-36" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-36">How Does It Work (Plain Language)</h4>
<p>Think of the plane as a stretchy mesh. Each time you add a point:</p>
<ol type="1">
<li>You find all triangles whose circumcircles contain the new point (the “bad triangles”).</li>
<li>You remove those triangles, they no longer satisfy the Delaunay condition.</li>
<li>The boundary of the removed region forms a polygonal cavity.</li>
<li>You connect the new point to every vertex on that boundary.</li>
<li>The result is a new triangulation that’s still Delaunay.</li>
</ol>
<p>Repeat until all points are inserted.</p>
</section>
<section id="step-by-step-example" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example">Step-by-Step Example</h4>
<p>Points: <span class="math inline">\(A(0,0), B(5,0), C(2.5,5), D(2.5,2)\)</span></p>
<ol type="1">
<li><p>Initialize with a super-triangle that encloses all points.</p></li>
<li><p>Insert <span class="math inline">\(A, B, C\)</span> → base triangle.</p></li>
<li><p>Insert <span class="math inline">\(D\)</span>:</p>
<ul>
<li>Find triangles whose circumcircles contain <span class="math inline">\(D\)</span>.</li>
<li>Remove them (forming a “hole”).</li>
<li>Reconnect <span class="math inline">\(D\)</span> to boundary vertices of the hole.</li>
</ul></li>
<li><p>Resulting triangulation satisfies Delaunay property.</p></li>
</ol>
</section>
<section id="geometric-core-the-cavity" class="level4">
<h4 class="anchored" data-anchor-id="geometric-core-the-cavity">Geometric Core: The Cavity</h4>
<p>For each new point <span class="math inline">\(p\)</span>:</p>
<ul>
<li>Find all triangles <span class="math inline">\(\triangle abc\)</span> with <span class="math display">\[p \text{ inside } \text{circumcircle}(a, b, c).\]</span></li>
<li>Remove those triangles.</li>
<li>Collect all boundary edges shared by only one bad triangle, they form the cavity polygon.</li>
<li>Connect <span class="math inline">\(p\)</span> to each boundary edge to form new triangles.</li>
</ul>
</section>
<section id="tiny-code-pseudocode-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-pseudocode-3">Tiny Code (Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bowyer_watson(points):</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    tri <span class="op">=</span> [super_triangle(points)]</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>        bad_tris <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> tri <span class="cf">if</span> in_circumcircle(p, t)]</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>        boundary <span class="op">=</span> find_boundary(bad_tris)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> bad_tris:</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>            tri.remove(t)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> edge <span class="kw">in</span> boundary:</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>            tri.append(make_triangle(edge[<span class="dv">0</span>], edge[<span class="dv">1</span>], p))</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    tri <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> tri <span class="cf">if</span> <span class="kw">not</span> shares_vertex_with_super(t)]</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tri</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Key helper:</p>
<ul>
<li><code>in_circumcircle(p, triangle)</code> tests if point lies inside circumcircle</li>
<li><code>find_boundary</code> identifies edges not shared by two removed triangles</li>
</ul>
</section>
<section id="why-it-matters-36" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-36">Why It Matters</h4>
<ul>
<li>Simple and robust, easy to implement</li>
<li>Handles incremental insertion naturally</li>
<li>Basis for many dynamic Delaunay systems</li>
<li>Dual to Incremental Voronoi (each insertion updates local cells)</li>
</ul>
<p>Applications:</p>
<ul>
<li>Mesh generation (finite elements, 2D/3D)</li>
<li>GIS terrain modeling</li>
<li>Particle simulations</li>
<li>Spatial interpolation (e.g.&nbsp;natural neighbor)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-23" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-23">A Gentle Proof (Why It Works)</h4>
<p>Each insertion removes only triangles that violate the empty-circle property, then adds new triangles that preserve it.</p>
<p>By induction:</p>
<ol type="1">
<li>Base triangulation (super-triangle) is valid.</li>
<li>Each insertion preserves local Delaunay condition.</li>
<li>Therefore, the entire triangulation remains Delaunay.</li>
</ol>
<p>Complexity:</p>
<ul>
<li>Naive search for bad triangles: <span class="math inline">\(O(n)\)</span> per insertion</li>
<li>Total: <span class="math inline">\(O(n^2)\)</span></li>
<li>With spatial indexing / point location: <span class="math display">\[O(n \log n)\]</span></li>
</ul>
</section>
<section id="try-it-yourself-36" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-36">Try It Yourself</h4>
<ol type="1">
<li>Draw 3 points → initial triangle.</li>
<li>Add a new point inside.</li>
<li>Draw circumcircles for all triangles, mark those containing the new point.</li>
<li>Remove them; connect the new point to the boundary.</li>
<li>Observe all triangles now satisfy empty-circle rule.</li>
</ol>
</section>
<section id="test-cases-36" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-36">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Triangles</th>
<th>Property</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3 points</td>
<td>1 triangle</td>
<td>trivially Delaunay</td>
</tr>
<tr class="even">
<td>4 points</td>
<td>2 triangles</td>
<td>both empty-circle valid</td>
</tr>
<tr class="odd">
<td>Random 6 points</td>
<td>multiple triangles</td>
<td>valid triangulation</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-36" class="level4">
<h4 class="anchored" data-anchor-id="complexity-36">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n^2) \text{ naive}, \quad O(n \log n) \text{ optimized}
\]</span> <span class="math display">\[
\text{Space: } O(n)
\]</span></p>
<p>The Bowyer–Watson Algorithm is like sculpting with triangles, each new point gently reshapes the mesh, carving out cavities and stitching them back with perfect geometric balance.</p>
</section>
</section>
<section id="duality-transform" class="level3">
<h3 class="anchored" data-anchor-id="duality-transform">737 Duality Transform</h3>
<p>The Duality Transform reveals the deep connection between Delaunay triangulations and Voronoi diagrams, they are geometric duals. Every Voronoi edge corresponds to a Delaunay edge, and every Voronoi vertex corresponds to a Delaunay triangle circumcenter.</p>
<p>By understanding this duality, we can construct one structure from the other, no need to compute both separately.</p>
<section id="what-problem-are-we-solving-37" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-37">What Problem Are We Solving?</h4>
<p>We often need both the Delaunay triangulation (for connectivity) and the Voronoi diagram (for spatial partitioning).</p>
<p>Rather than building each independently, we can use duality:</p>
<ul>
<li>Build Delaunay triangulation, derive Voronoi.</li>
<li>Or build Voronoi diagram, derive Delaunay.</li>
</ul>
<p>This saves computation and highlights the symmetry of geometry.</p>
</section>
<section id="dual-relationship" class="level4">
<h4 class="anchored" data-anchor-id="dual-relationship">Dual Relationship</h4>
<p>Let <span class="math inline">\(P = {p_1, p_2, \ldots, p_n}\)</span> be a set of sites in the plane.</p>
<ol type="1">
<li><p>Vertices:</p>
<ul>
<li>Each Voronoi vertex corresponds to the circumcenter of a Delaunay triangle.</li>
</ul></li>
<li><p>Edges:</p>
<ul>
<li>Each Voronoi edge is perpendicular to its dual Delaunay edge.</li>
<li>It connects circumcenters of adjacent Delaunay triangles.</li>
</ul></li>
<li><p>Faces:</p>
<ul>
<li>Each Voronoi cell corresponds to a site vertex in Delaunay.</li>
</ul></li>
</ol>
<p>So: <span class="math display">\[
\text{Voronoi(Dual)} = \text{Delaunay(Primal)}
\]</span></p>
<p>and vice versa.</p>
</section>
<section id="how-does-it-work-plain-language-37" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-37">How Does It Work (Plain Language)</h4>
<p>Start with Delaunay triangulation:</p>
<ol type="1">
<li>For each triangle, compute its circumcenter.</li>
<li>Connect circumcenters of adjacent triangles (triangles sharing an edge).</li>
<li>These connections form Voronoi edges.</li>
<li>The collection of these edges forms the Voronoi diagram.</li>
</ol>
<p>Alternatively, start with Voronoi diagram:</p>
<ol type="1">
<li>Each cell’s site becomes a vertex.</li>
<li>Connect two sites if their cells share a boundary → Delaunay edge.</li>
<li>Triangles form by linking triplets of mutually adjacent cells.</li>
</ol>
</section>
<section id="example-walkthrough-33" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-33">Example Walkthrough</h4>
<p>Sites: <span class="math inline">\(A(2,2), B(6,2), C(4,5)\)</span></p>
<ol type="1">
<li>Delaunay triangulation: triangle <span class="math inline">\(ABC\)</span>.</li>
<li>Circumcenter of <span class="math inline">\(\triangle ABC\)</span> = Voronoi vertex.</li>
<li>Draw perpendicular bisectors between pairs <span class="math inline">\((A,B), (B,C), (C,A)\)</span>.</li>
<li>These form Voronoi edges meeting at the circumcenter.</li>
</ol>
<p>Now:</p>
<ul>
<li>Voronoi edges ⟷ Delaunay edges</li>
<li>Voronoi vertex ⟷ Delaunay triangle</li>
</ul>
<p>Duality complete.</p>
</section>
<section id="algebraic-dual-point-line-transform" class="level4">
<h4 class="anchored" data-anchor-id="algebraic-dual-point-line-transform">Algebraic Dual (Point-Line Transform)</h4>
<p>In computational geometry, we often use point-line duality:</p>
<p><span class="math display">\[
(x, y) \longleftrightarrow y = mx - c
\]</span></p>
<p>or more commonly:</p>
<p><span class="math display">\[
(x, y) \mapsto y = ax - b
\]</span></p>
<p>In this sense:</p>
<ul>
<li><p>A point in primal space corresponds to a line in dual space.</p></li>
<li><p>Incidence and order are preserved:</p>
<ul>
<li>Points above/below line ↔︎ lines above/below point.</li>
</ul></li>
</ul>
<p>Used in convex hull and half-plane intersection computations.</p>
</section>
<section id="tiny-code-python-sketch-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-6">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delaunay_to_voronoi(delaunay):</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    voronoi_vertices <span class="op">=</span> [circumcenter(t) <span class="cf">for</span> t <span class="kw">in</span> delaunay.triangles]</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    voronoi_edges <span class="op">=</span> []</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> e <span class="kw">in</span> delaunay.shared_edges():</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        c1 <span class="op">=</span> circumcenter(e.tri1)</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>        c2 <span class="op">=</span> circumcenter(e.tri2)</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        voronoi_edges.append((c1, c2))</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> voronoi_vertices, voronoi_edges</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here, <code>circumcenter(triangle)</code> computes the center of the circumcircle.</p>
</section>
<section id="why-it-matters-37" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-37">Why It Matters</h4>
<ul>
<li>Unifies two core geometric structures</li>
<li>Enables conversion between triangulation and partition</li>
<li>Essential for mesh generation, pathfinding, spatial queries</li>
<li>Simplifies algorithms: compute one, get both</li>
</ul>
<p>Applications:</p>
<ul>
<li>Terrain modeling: triangulate elevation, derive regions</li>
<li>Nearest neighbor: Voronoi search</li>
<li>Computational physics: Delaunay meshes, Voronoi volumes</li>
<li>AI navigation: region adjacency via duality</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-24" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-24">A Gentle Proof (Why It Works)</h4>
<p>In a Delaunay triangulation:</p>
<ul>
<li>Each triangle satisfies empty-circle property.</li>
<li>The circumcenter of adjacent triangles is equidistant from two sites.</li>
</ul>
<p>Thus, connecting circumcenters of adjacent triangles gives edges equidistant from two sites, by definition, Voronoi edges.</p>
<p>So the dual of a Delaunay triangulation is exactly the Voronoi diagram.</p>
<p>Formally: <span class="math display">\[
\text{Delaunay}(P) = \text{Voronoi}^*(P)
\]</span></p>
</section>
<section id="try-it-yourself-37" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-37">Try It Yourself</h4>
<ol type="1">
<li>Plot 4 non-collinear points.</li>
<li>Construct Delaunay triangulation.</li>
<li>Draw circumcircles and locate circumcenters.</li>
<li>Connect circumcenters of adjacent triangles → Voronoi edges.</li>
<li>Observe perpendicularity to original Delaunay edges.</li>
</ol>
</section>
<section id="test-cases-37" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-37">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Sites</th>
<th>Delaunay Triangles</th>
<th>Voronoi Vertices</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>4</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Random 6</td>
<td>4–6</td>
<td>Many</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-37" class="level4">
<h4 class="anchored" data-anchor-id="complexity-37">Complexity</h4>
<p>If either structure is known: <span class="math display">\[
\text{Conversion Time: } O(n)
\]</span> <span class="math display">\[
\text{Space: } O(n)
\]</span></p>
<p>The Duality Transform is geometry’s mirror, each edge, face, and vertex reflected across a world of perpendiculars, revealing two sides of the same elegant truth.</p>
</section>
</section>
<section id="power-diagram-weighted-voronoi" class="level3">
<h3 class="anchored" data-anchor-id="power-diagram-weighted-voronoi">738 Power Diagram (Weighted Voronoi)</h3>
<p>A Power Diagram (also called a Laguerre–Voronoi diagram) is a generalization of the Voronoi diagram where each site has an associated weight. Instead of simple Euclidean distance, we use the power distance, which shifts or shrinks regions based on these weights.</p>
<p>This allows modeling influence zones where some points “push harder” than others, ideal for applications like additively weighted nearest neighbor and circle packing.</p>
<section id="what-problem-are-we-solving-38" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-38">What Problem Are We Solving?</h4>
<p>In a standard Voronoi diagram, each site <span class="math inline">\(p_i\)</span> owns all points <span class="math inline">\(q\)</span> closer to it than to any other site: <span class="math display">\[
V(p_i) = { q \mid d(q, p_i) \le d(q, p_j), \ \forall j \ne i }.
\]</span></p>
<p>In a Power Diagram, each site <span class="math inline">\(p_i\)</span> has a weight <span class="math inline">\(w_i\)</span>, and cells are defined by power distance: <span class="math display">\[
\pi_i(q) = | q - p_i |^2 - w_i.
\]</span></p>
<p>A point <span class="math inline">\(q\)</span> belongs to the power cell of <span class="math inline">\(p_i\)</span> if: <span class="math display">\[
\pi_i(q) \le \pi_j(q) \quad \forall j \ne i.
\]</span></p>
<p>When all weights <span class="math inline">\(w_i = 0\)</span>, we recover the classic Voronoi diagram.</p>
</section>
<section id="how-does-it-work-plain-language-38" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-38">How Does It Work (Plain Language)</h4>
<p>Think of each site as a circle (or sphere) with radius determined by its weight. Instead of pure distance, we compare power distances:</p>
<ul>
<li>Larger weights mean stronger influence (bigger circle).</li>
<li>Smaller weights mean weaker influence.</li>
</ul>
<p>A point <span class="math inline">\(q\)</span> chooses the site whose power distance is smallest.</p>
<p>This creates tilted bisectors (not perpendicular), and cells may disappear entirely if they’re dominated by neighbors.</p>
</section>
<section id="example-walkthrough-34" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-34">Example Walkthrough</h4>
<p>Sites with weights:</p>
<ul>
<li><span class="math inline">\(A(2,2), w_A = 1\)</span></li>
<li><span class="math inline">\(B(6,2), w_B = 0\)</span></li>
<li><span class="math inline">\(C(4,5), w_C = 4\)</span></li>
</ul>
<p>Compute power bisector between <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[
|q - A|^2 - w_A = |q - B|^2 - w_B
\]</span></p>
<p>Expanding and simplifying yields a linear equation, a shifted bisector: <span class="math display">\[
2(x_B - x_A)x + 2(y_B - y_A)y = (x_B^2 + y_B^2 - w_B) - (x_A^2 + y_A^2 - w_A)
\]</span></p>
<p>Thus, boundaries remain straight lines, but not centered between sites.</p>
</section>
<section id="algorithm-high-level" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-high-level">Algorithm (High-Level)</h4>
<ol type="1">
<li>Input: Sites <span class="math inline">\(p_i = (x_i, y_i)\)</span> with weights <span class="math inline">\(w_i\)</span>.</li>
<li>Compute all pairwise bisectors using power distance.</li>
<li>Intersect bisectors to form polygonal cells.</li>
<li>Clip cells to bounding box.</li>
<li>(Optional) Use dual weighted Delaunay triangulation (regular triangulation) for efficiency.</li>
</ol>
</section>
<section id="geometric-dual-regular-triangulation" class="level4">
<h4 class="anchored" data-anchor-id="geometric-dual-regular-triangulation">Geometric Dual: Regular Triangulation</h4>
<p>The dual of a power diagram is a regular triangulation, built using lifted points in 3D:</p>
<p>Map each site <span class="math inline">\((x_i, y_i, w_i)\)</span> to 3D point <span class="math inline">\((x_i, y_i, x_i^2 + y_i^2 - w_i)\)</span>.</p>
<p>The lower convex hull of these lifted points, projected back to 2D, gives the power diagram.</p>
</section>
<section id="tiny-code-python-sketch-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-7">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> power_bisector(p1, w1, p2, w2):</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    (x1, y1), (x2, y2) <span class="op">=</span> p1, p2</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (x2 <span class="op">-</span> x1)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (y2 <span class="op">-</span> y1)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> (x22 <span class="op">+</span> y22 <span class="op">-</span> w2) <span class="op">-</span> (x12 <span class="op">+</span> y12 <span class="op">-</span> w1)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a, b, c)  <span class="co"># line ax + by = c</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> power_diagram(points, weights):</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    cells <span class="op">=</span> []</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>(points):</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        cell <span class="op">=</span> bounding_box()</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j, q <span class="kw">in</span> <span class="bu">enumerate</span>(points):</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> j: <span class="cf">continue</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>            a, b, c <span class="op">=</span> power_bisector(p, weights[i], q, weights[j])</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>            cell <span class="op">=</span> halfplane_intersect(cell, a, b, c)</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>        cells.append(cell)</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cells</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each cell is built as an intersection of half-planes defined by weighted bisectors.</p>
</section>
<section id="why-it-matters-38" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-38">Why It Matters</h4>
<ul>
<li>Generalization of Voronoi for weighted influence</li>
<li>Produces regular triangulation duals</li>
<li>Supports non-uniform density modeling</li>
</ul>
<p>Applications:</p>
<ul>
<li>Physics: additively weighted fields</li>
<li>GIS: territory with varying influence</li>
<li>Computational geometry: circle packing</li>
<li>Machine learning: power diagrams for weighted clustering</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-25" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-25">A Gentle Proof (Why It Works)</h4>
<p>Each cell is defined by linear inequalities: <span class="math display">\[
\pi_i(q) \le \pi_j(q)
\]</span> which are half-planes. The intersection of these half-planes forms a convex polygon (possibly empty).</p>
<p>Thus, each cell:</p>
<ul>
<li>Is convex</li>
<li>Covers all space (union of cells)</li>
<li>Is disjoint from others</li>
</ul>
<p>Dual structure: regular triangulation, maintaining weighted Delaunay property (empty <em>power circle</em>).</p>
<p>Complexity: <span class="math display">\[
O(n \log n)
\]</span> using incremental or lifting methods.</p>
</section>
<section id="try-it-yourself-38" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-38">Try It Yourself</h4>
<ol type="1">
<li>Draw two points with different weights.</li>
<li>Compute power bisector, note it’s not equidistant.</li>
<li>Add third site, see how regions shift by weight.</li>
<li>Increase weight of one site, watch its cell expand.</li>
</ol>
</section>
<section id="test-cases-38" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-38">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Sites</th>
<th>Weights</th>
<th>Diagram</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2 equal</td>
<td>same</td>
<td>vertical bisector</td>
</tr>
<tr class="even">
<td>2 unequal</td>
<td>one large</td>
<td>shifted boundary</td>
</tr>
<tr class="odd">
<td>3 varied</td>
<td>mixed</td>
<td>tilted polygons</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-38" class="level4">
<h4 class="anchored" data-anchor-id="complexity-38">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Power Diagram bends geometry to influence, every weight warps the balance of space, redrawing the borders of proximity and power.</p>
</section>
</section>
<section id="lloyds-relaxation" class="level3">
<h3 class="anchored" data-anchor-id="lloyds-relaxation">739 Lloyd’s Relaxation</h3>
<p>Lloyd’s Relaxation (also called Lloyd’s Algorithm) is an iterative process that refines a Voronoi diagram by repeatedly moving each site to the centroid of its Voronoi cell. The result is a Centroidal Voronoi Tessellation (CVT), a diagram where each region’s site is also its center of mass.</p>
<p>It’s a geometric smoothing method that transforms irregular partitions into beautifully uniform, balanced layouts.</p>
<section id="what-problem-are-we-solving-39" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-39">What Problem Are We Solving?</h4>
<p>A standard Voronoi diagram partitions space by proximity, but cell shapes can be irregular or skewed if sites are unevenly distributed.</p>
<p>We want a balanced diagram where:</p>
<ul>
<li>Cells are compact and similar in size</li>
<li>Sites are located at cell centroids</li>
</ul>
<p>Lloyd’s relaxation solves this by iterative refinement.</p>
</section>
<section id="how-does-it-work-plain-language-39" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-39">How Does It Work (Plain Language)</h4>
<p>Start with a random set of points and a bounding region.</p>
<p>Then repeat:</p>
<ol type="1">
<li>Compute Voronoi diagram of current sites.</li>
<li>Find centroid of each Voronoi cell (average of all points in that region).</li>
<li>Move each site to its cell’s centroid.</li>
<li>Repeat until sites converge (movement is small).</li>
</ol>
<p>Over time, sites spread out evenly, forming a blue-noise distribution, ideal for sampling and meshing.</p>
</section>
<section id="step-by-step-example-1" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-1">Step-by-Step Example</h4>
<ol type="1">
<li>Initialize 10 random sites in a square.</li>
<li>Compute Voronoi diagram.</li>
<li>For each cell, compute centroid: <span class="math display">\[
c_i = \frac{1}{A_i} \int_{V_i} (x, y) , dA
\]</span></li>
<li>Replace site position <span class="math inline">\(p_i\)</span> with centroid <span class="math inline">\(c_i\)</span>.</li>
<li>Repeat 5–10 iterations.</li>
</ol>
<p>Result: smoother, more regular cells with nearly equal areas.</p>
</section>
<section id="tiny-code-python-sketch-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-8">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> Voronoi</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lloyd_relaxation(points, bounds, iterations<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>        vor <span class="op">=</span> Voronoi(points)</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        new_points <span class="op">=</span> []</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> region_index <span class="kw">in</span> vor.point_region:</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>            region <span class="op">=</span> vor.regions[region_index]</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">in</span> region <span class="kw">or</span> <span class="bu">len</span>(region) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>            polygon <span class="op">=</span> [vor.vertices[i] <span class="cf">for</span> i <span class="kw">in</span> region]</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>            centroid <span class="op">=</span> np.mean(polygon, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>            new_points.append(centroid)</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>        points <span class="op">=</span> np.array(new_points)</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> points</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This simple implementation uses Scipy’s Voronoi and computes centroids as polygon averages.</p>
</section>
<section id="why-it-matters-39" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-39">Why It Matters</h4>
<ul>
<li>Produces uniform partitions, smooth and balanced</li>
<li>Generates blue-noise distributions (useful for sampling)</li>
<li>Used in meshing, texture generation, and Poisson disk sampling</li>
<li>Converges quickly (a few iterations often suffice)</li>
</ul>
<p>Applications:</p>
<ul>
<li>Mesh generation (finite elements, simulations)</li>
<li>Sampling for graphics / procedural textures</li>
<li>Clustering (k-means is a discrete analogue)</li>
<li>Lattice design and territory optimization</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-26" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-26">A Gentle Proof (Why It Works)</h4>
<p>Each iteration reduces an energy functional:</p>
<p><span class="math display">\[
E = \sum_i \int_{V_i} | q - p_i |^2 , dq
\]</span></p>
<p>This measures total squared distance from sites to points in their regions. Moving <span class="math inline">\(p_i\)</span> to the centroid minimizes <span class="math inline">\(E_i\)</span> locally.</p>
<p>As iterations continue:</p>
<ul>
<li>Energy decreases monotonically</li>
<li>System converges to fixed point where each <span class="math inline">\(p_i\)</span> is centroid of <span class="math inline">\(V_i\)</span></li>
</ul>
<p>At convergence: <span class="math display">\[
p_i = c_i
\]</span> Each cell is a centroidal Voronoi region.</p>
</section>
<section id="try-it-yourself-39" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-39">Try It Yourself</h4>
<ol type="1">
<li>Scatter random points on paper.</li>
<li>Draw Voronoi cells.</li>
<li>Estimate centroids (visually or with grid).</li>
<li>Move points to centroids.</li>
<li>Redraw Voronoi.</li>
<li>Repeat, see pattern become uniform.</li>
</ol>
</section>
<section id="test-cases-39" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-39">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Sites</th>
<th>Iterations</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10 random</td>
<td>0</td>
<td>irregular Voronoi</td>
</tr>
<tr class="even">
<td>10 random</td>
<td>3</td>
<td>smoother, balanced</td>
</tr>
<tr class="odd">
<td>10 random</td>
<td>10</td>
<td>uniform CVT</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-39" class="level4">
<h4 class="anchored" data-anchor-id="complexity-39">Complexity</h4>
<p>Each iteration:</p>
<ul>
<li>Voronoi computation: <span class="math inline">\(O(n \log n)\)</span></li>
<li>Centroid update: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Total: <span class="math display">\[
O(k n \log n)
\]</span> for <span class="math inline">\(k\)</span> iterations.</p>
<p>Lloyd’s Relaxation polishes randomness into order, each iteration a gentle nudge toward harmony, transforming scattered points into a balanced, geometric mosaic.</p>
</section>
</section>
<section id="voronoi-nearest-neighbor" class="level3">
<h3 class="anchored" data-anchor-id="voronoi-nearest-neighbor">740 Voronoi Nearest Neighbor</h3>
<p>The Voronoi Nearest Neighbor query is a natural application of the Voronoi diagram, once the diagram is constructed, nearest-neighbor lookups become instantaneous. Each query point simply falls into a Voronoi cell, and the site defining that cell is its closest neighbor.</p>
<p>This makes Voronoi structures perfect for spatial search, proximity analysis, and geometric classification.</p>
<section id="what-problem-are-we-solving-40" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-40">What Problem Are We Solving?</h4>
<p>Given a set of sites <span class="math display">\[
P = {p_1, p_2, \ldots, p_n}
\]</span> and a query point <span class="math inline">\(q\)</span>, we want to find the nearest site: <span class="math display">\[
p^* = \arg\min_{p_i \in P} | q - p_i |.
\]</span></p>
<p>A Voronoi diagram partitions space so that every point <span class="math inline">\(q\)</span> inside a cell <span class="math inline">\(V(p_i)\)</span> satisfies: <span class="math display">\[
| q - p_i | \le | q - p_j |, \ \forall j \ne i.
\]</span></p>
<p>Thus, locating <span class="math inline">\(q\)</span>’s cell immediately reveals its nearest neighbor.</p>
</section>
<section id="how-does-it-work-plain-language-40" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-40">How Does It Work (Plain Language)</h4>
<ol type="1">
<li>Preprocess: Build Voronoi diagram from sites.</li>
<li>Query: Given a new point <span class="math inline">\(q\)</span>, determine which Voronoi cell it lies in.</li>
<li>Answer: The site that generated that cell is the nearest neighbor.</li>
</ol>
<p>This transforms nearest-neighbor search from computation (distance comparisons) into geometry (region lookup).</p>
</section>
<section id="example-walkthrough-35" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-35">Example Walkthrough</h4>
<p>Sites:</p>
<ul>
<li><span class="math inline">\(A(2,2)\)</span></li>
<li><span class="math inline">\(B(6,2)\)</span></li>
<li><span class="math inline">\(C(4,5)\)</span></li>
</ul>
<p>Construct Voronoi diagram → three convex cells.</p>
<p>Query: <span class="math inline">\(q = (5,3)\)</span></p>
<ul>
<li>Check which region contains <span class="math inline">\(q\)</span> → belongs to cell of <span class="math inline">\(B\)</span>.</li>
<li>So nearest neighbor is <span class="math inline">\(B(6,2)\)</span>.</li>
</ul>
</section>
<section id="algorithm-high-level-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-high-level-1">Algorithm (High-Level)</h4>
<ol type="1">
<li><p>Build Voronoi diagram (any method, e.g.&nbsp;Fortune’s sweep).</p></li>
<li><p>Point location:</p>
<ul>
<li>Use spatial index or planar subdivision search (e.g.&nbsp;trapezoidal map).</li>
<li>Query point <span class="math inline">\(q\)</span> → find containing polygon.</li>
</ul></li>
<li><p>Return associated site.</p></li>
</ol>
<p>Optional optimization: if many queries are expected, build a point-location data structure for <span class="math inline">\(O(\log n)\)</span> queries.</p>
</section>
<section id="tiny-code-python-sketch-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-9">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> Voronoi, KDTree</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> voronoi_nearest(points, queries):</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    vor <span class="op">=</span> Voronoi(points)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> KDTree(points)</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> q <span class="kw">in</span> queries:</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>        dist, idx <span class="op">=</span> tree.query(q)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>        result.append((q, points[idx], dist))</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here we combine Voronoi geometry (for understanding) with KD-tree (for practical speed).</p>
<p>In exact Voronoi lookup, each query uses point-location in the planar subdivision.</p>
</section>
<section id="why-it-matters-40" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-40">Why It Matters</h4>
<ul>
<li><p>Turns nearest-neighbor search into constant-time lookup (after preprocessing)</p></li>
<li><p>Enables spatial partitioning for clustering, navigation, simulation</p></li>
<li><p>Forms foundation for:</p>
<ul>
<li>Nearest facility location</li>
<li>Path planning (region transitions)</li>
<li>Interpolation (e.g.&nbsp;nearest-site assignment)</li>
<li>Density estimation, resource allocation</li>
</ul></li>
</ul>
<p>Used in:</p>
<ul>
<li>GIS (find nearest hospital, school, etc.)</li>
<li>Robotics (navigation zones)</li>
<li>Physics (Voronoi cells in particle systems)</li>
<li>ML (nearest centroid classifiers)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-27" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-27">A Gentle Proof (Why It Works)</h4>
<p>By definition, each Voronoi cell <span class="math inline">\(V(p_i)\)</span> satisfies: <span class="math display">\[
V(p_i) = { q \mid | q - p_i | \le | q - p_j | \ \forall j \ne i }.
\]</span></p>
<p>So if <span class="math inline">\(q \in V(p_i)\)</span>, then: <span class="math display">\[
| q - p_i | = \min_{p_j \in P} | q - p_j |.
\]</span></p>
<p>Therefore, locating <span class="math inline">\(q\)</span>’s cell gives the correct nearest neighbor. Efficient point location (via planar search) ensures <span class="math inline">\(O(\log n)\)</span> query time.</p>
</section>
<section id="try-it-yourself-40" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-40">Try It Yourself</h4>
<ol type="1">
<li>Draw 4 sites on paper.</li>
<li>Construct Voronoi diagram.</li>
<li>Pick a random query point.</li>
<li>See which cell contains it, that’s your nearest site.</li>
<li>Verify by computing distances manually.</li>
</ol>
</section>
<section id="test-cases-40" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-40">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Sites</th>
<th>Query</th>
<th>Nearest</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A(0,0), B(4,0)</td>
<td>(1,1)</td>
<td>A</td>
</tr>
<tr class="even">
<td>A(2,2), B(6,2), C(4,5)</td>
<td>(5,3)</td>
<td>B</td>
</tr>
<tr class="odd">
<td>Random 5 sites</td>
<td>random query</td>
<td>site of containing cell</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-40" class="level4">
<h4 class="anchored" data-anchor-id="complexity-40">Complexity</h4>
<ul>
<li>Preprocessing (Voronoi build): <span class="math inline">\(O(n \log n)\)</span></li>
<li>Query (point location): <span class="math inline">\(O(\log n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>The Voronoi Nearest Neighbor method replaces brute-force distance checks with elegant geometry, every query resolved by finding where it lives, not how far it travels.</p>
</section>
</section>
</section>
<section id="section-75.-point-in-polygon-and-polygon-triangulation" class="level1">
<h1>Section 75. Point in Polygon and Polygon Triangulation</h1>
<section id="ray-casting" class="level3">
<h3 class="anchored" data-anchor-id="ray-casting">741 Ray Casting</h3>
<p>The Ray Casting Algorithm (also known as the even–odd rule) is a simple and elegant method to determine whether a point lies inside or outside a polygon. It works by shooting an imaginary ray from the query point and counting how many times it crosses the polygon’s edges.</p>
<p>If the number of crossings is odd, the point is inside. If even, the point is outside.</p>
<section id="what-problem-are-we-solving-41" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-41">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A polygon defined by vertices <span class="math display">\[P = {v_1, v_2, \ldots, v_n}\]</span></li>
<li>A query point <span class="math display">\[q = (x_q, y_q)\]</span></li>
</ul>
<p>Determine whether <span class="math inline">\(q\)</span> lies inside, outside, or on the boundary of the polygon.</p>
<p>This test is fundamental in:</p>
<ul>
<li>Computational geometry</li>
<li>Computer graphics (hit-testing)</li>
<li>Geographic Information Systems (point-in-polygon)</li>
<li>Collision detection</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-41" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-41">How Does It Work (Plain Language)</h4>
<p>Imagine shining a light ray horizontally to the right from the query point <span class="math inline">\(q\)</span>. Each time the ray intersects a polygon edge, we flip an inside/outside flag.</p>
<ul>
<li>If ray crosses an edge odd number of times → point is inside</li>
<li>If even → point is outside</li>
</ul>
<p>Special care is needed when:</p>
<ul>
<li>The ray passes exactly through a vertex</li>
<li>The point lies exactly on an edge</li>
</ul>
</section>
<section id="step-by-step-procedure" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-procedure">Step-by-Step Procedure</h4>
<ol type="1">
<li><p>Set <code>count = 0</code>.</p></li>
<li><p>For each polygon edge <span class="math inline">\((v_i, v_{i+1})\)</span>:</p>
<ul>
<li>Check if the horizontal ray from <span class="math inline">\(q\)</span> intersects the edge.</li>
<li>If yes, increment <code>count</code>.</li>
</ul></li>
<li><p>If <code>count</code> is odd, <span class="math inline">\(q\)</span> is inside. If even, <span class="math inline">\(q\)</span> is outside.</p></li>
</ol>
<p>Edge intersection condition (for an edge between <span class="math inline">\((x_i, y_i)\)</span> and <span class="math inline">\((x_j, y_j)\)</span>):</p>
<ul>
<li>Ray intersects if: <span class="math display">\[
y_q \in [\min(y_i, y_j), \max(y_i, y_j))
\]</span> and <span class="math display">\[
x_q &lt; x_i + \frac{(y_q - y_i)(x_j - x_i)}{(y_j - y_i)}
\]</span></li>
</ul>
</section>
<section id="example-walkthrough-36" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-36">Example Walkthrough</h4>
<p>Polygon: square <span class="math display">\[
(1,1), (5,1), (5,5), (1,5)
\]</span> Query point <span class="math inline">\(q(3,3)\)</span></p>
<ul>
<li>Cast ray to the right from <span class="math inline">\((3,3)\)</span></li>
<li>Intersects left edge <span class="math inline">\((1,1)-(1,5)\)</span> once → count = 1</li>
<li>Intersects top/bottom edges? no → Odd crossings → Inside</li>
</ul>
<p>Query point <span class="math inline">\(q(6,3)\)</span></p>
<ul>
<li>No intersections → count = 0 → Outside</li>
</ul>
</section>
<section id="tiny-code-python-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> point_in_polygon(point, polygon):</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> point</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    inside <span class="op">=</span> <span class="va">False</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(polygon)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> polygon[i]</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> polygon[(i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n]</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ((y1 <span class="op">&gt;</span> y) <span class="op">!=</span> (y2 <span class="op">&gt;</span> y)):</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>            x_intersect <span class="op">=</span> x1 <span class="op">+</span> (y <span class="op">-</span> y1) <span class="op">*</span> (x2 <span class="op">-</span> x1) <span class="op">/</span> (y2 <span class="op">-</span> y1)</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> x <span class="op">&lt;</span> x_intersect:</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>                inside <span class="op">=</span> <span class="kw">not</span> inside</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> inside</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This implements the even–odd rule via a simple parity flip.</p>
</section>
<section id="why-it-matters-41" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-41">Why It Matters</h4>
<ul>
<li><p>Intuitive and easy to implement</p></li>
<li><p>Works for any simple polygon (convex or concave)</p></li>
<li><p>Foundation for:</p>
<ul>
<li>Point-in-region tests</li>
<li>Filling polygons (graphics rasterization)</li>
<li>GIS spatial joins</li>
</ul></li>
</ul>
<p>Applications:</p>
<ul>
<li>Graphics: hit detection, clipping</li>
<li>Robotics: occupancy checks</li>
<li>Mapping: geographic containment</li>
<li>Simulation: spatial inclusion tests</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-28" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-28">A Gentle Proof (Why It Works)</h4>
<p>Each time the ray crosses an edge, the point transitions from outside to inside or vice versa. Since the polygon boundary is closed, the total number of crossings determines final parity.</p>
<p>Formally: <span class="math display">\[
\text{Inside}(q) = \text{count}(q) \bmod 2
\]</span></p>
<p>Edges with shared vertices don’t double-count if handled consistently (open upper bound).</p>
</section>
<section id="try-it-yourself-41" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-41">Try It Yourself</h4>
<ol type="1">
<li>Draw any polygon on graph paper.</li>
<li>Pick a point <span class="math inline">\(q\)</span> and draw a ray to the right.</li>
<li>Count edge crossings.</li>
<li>Check parity (odd → inside, even → outside).</li>
<li>Move <span class="math inline">\(q\)</span> near edges to test special cases.</li>
</ol>
</section>
<section id="test-cases-41" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-41">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Point</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square (1,1)-(5,5)</td>
<td>(3,3)</td>
<td>Inside</td>
</tr>
<tr class="even">
<td>Square (1,1)-(5,5)</td>
<td>(6,3)</td>
<td>Outside</td>
</tr>
<tr class="odd">
<td>Triangle</td>
<td>(edge midpoint)</td>
<td>On boundary</td>
</tr>
<tr class="even">
<td>Concave polygon</td>
<td>interior notch</td>
<td>Still correct</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-41" class="level4">
<h4 class="anchored" data-anchor-id="complexity-41">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n), \quad \text{Space: } O(1)
\]</span></p>
<p>The Ray Casting Algorithm is like shining a light through geometry, each crossing flips your perspective, revealing whether the point lies within or beyond the shape’s shadow.</p>
</section>
</section>
<section id="winding-number" class="level3">
<h3 class="anchored" data-anchor-id="winding-number">742 Winding Number</h3>
<p>The Winding Number Algorithm is a robust method for the point-in-polygon test. Unlike Ray Casting, which simply counts crossings, it measures how many times the polygon winds around the query point, capturing not only inside/outside status but also orientation (clockwise vs counterclockwise).</p>
<p>If the winding number is nonzero, the point is inside; if it’s zero, it’s outside.</p>
<section id="what-problem-are-we-solving-42" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-42">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A polygon <span class="math inline">\(P = {v_1, v_2, \ldots, v_n}\)</span></li>
<li>A query point <span class="math inline">\(q = (x_q, y_q)\)</span></li>
</ul>
<p>Determine whether <span class="math inline">\(q\)</span> lies inside or outside the polygon, including concave and self-intersecting cases.</p>
<p>The winding number is defined as the total angle swept by the polygon edges around the point: <span class="math display">\[
w(q) = \frac{1}{2\pi} \sum_{i=1}^{n} \Delta\theta_i
\]</span> where <span class="math inline">\(\Delta\theta_i\)</span> is the signed angle between consecutive edges from <span class="math inline">\(q\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-42" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-42">How Does It Work (Plain Language)</h4>
<p>Imagine walking along the polygon edges and watching the query point from your path:</p>
<ul>
<li>As you traverse, the point seems to rotate around you.</li>
<li>Each turn contributes an angle to the winding sum.</li>
<li>If the total turn equals <span class="math inline">\(2\pi\)</span> (or <span class="math inline">\(-2\pi\)</span>), you’ve wrapped around the point once → inside.</li>
<li>If the total turn equals <span class="math inline">\(0\)</span>, you never circled the point → outside.</li>
</ul>
<p>This is like counting how many times you loop around the point.</p>
</section>
<section id="step-by-step-procedure-1" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-procedure-1">Step-by-Step Procedure</h4>
<ol type="1">
<li><p>Initialize <span class="math inline">\(w = 0\)</span>.</p></li>
<li><p>For each edge <span class="math inline">\((v_i, v_{i+1})\)</span>:</p>
<ul>
<li>Compute vectors: <span class="math display">\[
\mathbf{u} = v_i - q, \quad \mathbf{v} = v_{i+1} - q
\]</span></li>
<li>Compute signed angle: <span class="math display">\[
\Delta\theta = \text{atan2}(\det(\mathbf{u}, \mathbf{v}), \mathbf{u} \cdot \mathbf{v})
\]</span></li>
<li>Add to total: <span class="math inline">\(w += \Delta\theta\)</span></li>
</ul></li>
<li><p>If <span class="math inline">\(|w| &gt; \pi\)</span>, the point is inside; else, outside.</p></li>
</ol>
<p>Or equivalently: <span class="math display">\[
\text{Inside if } w / 2\pi \ne 0
\]</span></p>
</section>
<section id="example-walkthrough-37" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-37">Example Walkthrough</h4>
<p>Polygon: <span class="math inline">\((0,0), (4,0), (4,4), (0,4)\)</span> Query point <span class="math inline">\(q(2,2)\)</span></p>
<p>At each edge, compute signed turn around <span class="math inline">\(q\)</span>. Total angle sum = <span class="math inline">\(2\pi\)</span> → inside</p>
<p>Query point <span class="math inline">\(q(5,2)\)</span> Total angle sum = <span class="math inline">\(0\)</span> → outside</p>
</section>
<section id="orientation-handling" class="level4">
<h4 class="anchored" data-anchor-id="orientation-handling">Orientation Handling</h4>
<p>The sign of <span class="math inline">\(\Delta\theta\)</span> depends on polygon direction:</p>
<ul>
<li>Counterclockwise (CCW) → positive angles</li>
<li>Clockwise (CW) → negative angles</li>
</ul>
<p>Winding number can thus also reveal orientation:</p>
<ul>
<li><span class="math inline">\(+1\)</span> → inside CCW</li>
<li><span class="math inline">\(-1\)</span> → inside CW</li>
<li><span class="math inline">\(0\)</span> → outside</li>
</ul>
</section>
<section id="tiny-code-python-example-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-1">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> winding_number(point, polygon):</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    xq, yq <span class="op">=</span> point</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(polygon)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> polygon[i]</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> polygon[(i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n]</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> (x1 <span class="op">-</span> xq, y1 <span class="op">-</span> yq)</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> (x2 <span class="op">-</span> xq, y2 <span class="op">-</span> yq)</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>        det <span class="op">=</span> u[<span class="dv">0</span>]<span class="op">*</span>v[<span class="dv">1</span>] <span class="op">-</span> u[<span class="dv">1</span>]<span class="op">*</span>v[<span class="dv">0</span>]</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>        dot <span class="op">=</span> u[<span class="dv">0</span>]<span class="op">*</span>v[<span class="dv">0</span>] <span class="op">+</span> u[<span class="dv">1</span>]<span class="op">*</span>v[<span class="dv">1</span>]</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>        angle <span class="op">=</span> math.atan2(det, dot)</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>        w <span class="op">+=</span> angle</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">abs</span>(<span class="bu">round</span>(w <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> math.pi))) <span class="op">&gt;</span> <span class="dv">0</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This computes the total angle swept and checks if it’s approximately <span class="math inline">\(2\pi\)</span>.</p>
</section>
<section id="why-it-matters-42" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-42">Why It Matters</h4>
<ul>
<li>More robust than Ray Casting (handles self-intersections)</li>
<li>Works for concave and complex polygons</li>
<li>Captures orientation information</li>
<li>Used in computational geometry libraries (CGAL, GEOS, Shapely)</li>
</ul>
<p>Applications:</p>
<ul>
<li>Geospatial analysis (inside boundary detection)</li>
<li>Graphics (fill rules, even–odd vs nonzero winding)</li>
<li>Collision detection in irregular shapes</li>
<li>Vector rendering (SVG uses winding rule)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-29" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-29">A Gentle Proof (Why It Works)</h4>
<p>Each edge contributes an angle turn around <span class="math inline">\(q\)</span>. By summing all such turns, we measure net rotation. If the polygon encloses <span class="math inline">\(q\)</span>, the path wraps around once (total <span class="math inline">\(2\pi\)</span>). If <span class="math inline">\(q\)</span> is outside, turns cancel out (total <span class="math inline">\(0\)</span>).</p>
<p>Formally: <span class="math display">\[
w(q) = \frac{1}{2\pi} \sum_{i=1}^{n} \text{atan2}(\det(\mathbf{u_i}, \mathbf{v_i}), \mathbf{u_i} \cdot \mathbf{v_i})
\]</span> and <span class="math inline">\(w(q) \ne 0\)</span> iff <span class="math inline">\(q\)</span> is enclosed.</p>
</section>
<section id="try-it-yourself-42" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-42">Try It Yourself</h4>
<ol type="1">
<li>Draw a concave polygon (e.g.&nbsp;star shape).</li>
<li>Pick a point inside a concavity.</li>
<li>Ray Casting may misclassify, but Winding Number will not.</li>
<li>Compute angles visually, sum them up.</li>
<li>Note sign indicates orientation.</li>
</ol>
</section>
<section id="test-cases-42" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-42">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Point</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square (0,0)-(4,4)</td>
<td>(2,2)</td>
<td>Inside</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(5,2)</td>
<td>Outside</td>
</tr>
<tr class="odd">
<td>Star</td>
<td>center</td>
<td>Inside</td>
</tr>
<tr class="even">
<td>Star</td>
<td>tip</td>
<td>Outside</td>
</tr>
<tr class="odd">
<td>Clockwise polygon</td>
<td>(2,2)</td>
<td>Winding number = -1</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-42" class="level4">
<h4 class="anchored" data-anchor-id="complexity-42">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n), \quad \text{Space: } O(1)
\]</span></p>
<p>The Winding Number Algorithm doesn’t just ask how many times a ray crosses a boundary, it listens to the rotation of space around the point, counting full revolutions to reveal enclosure.</p>
</section>
</section>
<section id="convex-polygon-point-test" class="level3">
<h3 class="anchored" data-anchor-id="convex-polygon-point-test">743 Convex Polygon Point Test</h3>
<p>The Convex Polygon Point Test is a fast and elegant method to determine whether a point lies inside, outside, or on the boundary of a convex polygon. It relies purely on orientation tests, the cross product signs between the query point and every polygon edge.</p>
<p>Because convex polygons have a consistent “direction” of turn, this method works in linear time and with no branching complexity.</p>
<section id="what-problem-are-we-solving-43" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-43">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A convex polygon <span class="math inline">\(P = {v_1, v_2, \ldots, v_n}\)</span></li>
<li>A query point <span class="math inline">\(q = (x_q, y_q)\)</span></li>
</ul>
<p>We want to test whether <span class="math inline">\(q\)</span> lies:</p>
<ul>
<li>Inside <span class="math inline">\(P\)</span></li>
<li>On the boundary of <span class="math inline">\(P\)</span></li>
<li>Outside <span class="math inline">\(P\)</span></li>
</ul>
<p>This test is specialized for convex polygons, where all interior angles are <span class="math inline">\(\le 180^\circ\)</span> and edges are oriented consistently (clockwise or counterclockwise).</p>
</section>
<section id="how-does-it-work-plain-language-43" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-43">How Does It Work (Plain Language)</h4>
<p>In a convex polygon, all vertices turn in the same direction (say CCW). A point is inside if it is always to the same side of every edge.</p>
<p>To test this:</p>
<ol type="1">
<li>Loop through all edges <span class="math inline">\((v_i, v_{i+1})\)</span>.</li>
<li>For each edge, compute the cross product between edge vector and the vector from vertex to query point: <span class="math display">\[
\text{cross}((v_{i+1} - v_i), (q - v_i))
\]</span></li>
<li>Record the sign (positive, negative, or zero).</li>
<li>If all signs are non-negative (or non-positive) → point is inside or on boundary.</li>
<li>If signs differ → point is outside.</li>
</ol>
</section>
<section id="cross-product-test" class="level4">
<h4 class="anchored" data-anchor-id="cross-product-test">Cross Product Test</h4>
<p>For two vectors <span class="math inline">\(\mathbf{a} = (x_a, y_a)\)</span>, <span class="math inline">\(\mathbf{b} = (x_b, y_b)\)</span></p>
<p>The 2D cross product is: <span class="math display">\[
\text{cross}(\mathbf{a}, \mathbf{b}) = a_x b_y - a_y b_x
\]</span></p>
<p>In geometry:</p>
<ul>
<li><span class="math inline">\(\text{cross} &gt; 0\)</span>: <span class="math inline">\(\mathbf{b}\)</span> is to the left of <span class="math inline">\(\mathbf{a}\)</span> (CCW turn)</li>
<li><span class="math inline">\(\text{cross} &lt; 0\)</span>: <span class="math inline">\(\mathbf{b}\)</span> is to the right (CW turn)</li>
<li><span class="math inline">\(\text{cross} = 0\)</span>: points are collinear</li>
</ul>
</section>
<section id="step-by-step-example-2" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-2">Step-by-Step Example</h4>
<p>Polygon (CCW): <span class="math inline">\((0,0), (4,0), (4,4), (0,4)\)</span></p>
<p>Query point <span class="math inline">\(q(2,2)\)</span></p>
<p>Compute for each edge:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge</th>
<th>Cross product</th>
<th>Sign</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0)-(4,0)</td>
<td><span class="math inline">\((4,0) \times (2,2) = 8\)</span></td>
<td>+</td>
</tr>
<tr class="even">
<td>(4,0)-(4,4)</td>
<td><span class="math inline">\((0,4) \times (-2,2) = 8\)</span></td>
<td>+</td>
</tr>
<tr class="odd">
<td>(4,4)-(0,4)</td>
<td><span class="math inline">\((-4,0) \times (-2,-2) = 8\)</span></td>
<td>+</td>
</tr>
<tr class="even">
<td>(0,4)-(0,0)</td>
<td><span class="math inline">\((0,-4) \times (2,-2) = 8\)</span></td>
<td>+</td>
</tr>
</tbody>
</table>
<p>All positive → Inside</p>
</section>
<section id="tiny-code-python-example-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-2">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convex_point_test(point, polygon):</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    xq, yq <span class="op">=</span> point</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(polygon)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    sign <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> polygon[i]</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> polygon[(i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n]</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>        cross <span class="op">=</span> (x2 <span class="op">-</span> x1) <span class="op">*</span> (yq <span class="op">-</span> y1) <span class="op">-</span> (y2 <span class="op">-</span> y1) <span class="op">*</span> (xq <span class="op">-</span> x1)</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cross <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> sign <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>                sign <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> cross <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> sign <span class="op">*</span> cross <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="st">"Outside"</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"Inside/On Boundary"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This version detects sign changes efficiently and stops early when mismatch appears.</p>
</section>
<section id="why-it-matters-43" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-43">Why It Matters</h4>
<ul>
<li>Fast, linear time with small constant</li>
<li>Robust, handles all convex polygons</li>
<li>No need for trigonometry, angles, or intersection tests</li>
<li>Works naturally with integer coordinates</li>
</ul>
<p>Applications:</p>
<ul>
<li>Collision checks for convex shapes</li>
<li>Graphics clipping (Sutherland–Hodgman)</li>
<li>Convex hull membership tests</li>
<li>Computational geometry libraries (CGAL, Shapely)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-30" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-30">A Gentle Proof (Why It Works)</h4>
<p>In a convex polygon, all points inside must be to the same side of each edge. Orientation sign indicates which side a point is on. If signs differ, point must cross boundary → outside.</p>
<p>Thus: <span class="math display">\[
q \in P \iff \forall i, \ \text{sign}(\text{cross}(v_{i+1} - v_i, q - v_i)) = \text{constant}
\]</span></p>
<p>This follows from convexity: the polygon lies entirely within a single half-plane for each edge.</p>
</section>
<section id="try-it-yourself-43" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-43">Try It Yourself</h4>
<ol type="1">
<li>Draw a convex polygon (triangle, square, hexagon).</li>
<li>Pick a point inside, test sign of cross products.</li>
<li>Pick a point outside, note at least one flip in sign.</li>
<li>Try a point on boundary, one cross = 0, others same sign.</li>
</ol>
</section>
<section id="test-cases-43" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-43">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Point</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square (0,0)-(4,4)</td>
<td>(2,2)</td>
<td>Inside</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(5,2)</td>
<td>Outside</td>
</tr>
<tr class="odd">
<td>Triangle</td>
<td>(edge midpoint)</td>
<td>On boundary</td>
</tr>
<tr class="even">
<td>Hexagon</td>
<td>(center)</td>
<td>Inside</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-43" class="level4">
<h4 class="anchored" data-anchor-id="complexity-43">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n), \quad \text{Space: } O(1)
\]</span></p>
<p>The Convex Polygon Point Test reads geometry like a compass, always checking direction, ensuring the point lies safely within the consistent turn of a convex path.</p>
</section>
</section>
<section id="ear-clipping-triangulation" class="level3">
<h3 class="anchored" data-anchor-id="ear-clipping-triangulation">744 Ear Clipping Triangulation</h3>
<p>The Ear Clipping Algorithm is a simple, geometric way to triangulate a simple polygon (convex or concave). It works by iteratively removing “ears”, small triangles that can be safely cut off without crossing the polygon’s interior, until only one triangle remains.</p>
<p>This method is widely used in computer graphics, meshing, and geometry processing because it’s easy to implement and numerically stable.</p>
<section id="what-problem-are-we-solving-44" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-44">What Problem Are We Solving?</h4>
<p>Given a simple polygon <span class="math display">\[
P = {v_1, v_2, \ldots, v_n}
\]</span> we want to decompose it into non-overlapping triangles whose union exactly equals <span class="math inline">\(P\)</span>.</p>
<p>Triangulation is foundational for:</p>
<ul>
<li>Rendering and rasterization</li>
<li>Finite element analysis</li>
<li>Computational geometry algorithms</li>
</ul>
<p>For a polygon with <span class="math inline">\(n\)</span> vertices, every triangulation produces exactly <span class="math inline">\(n-2\)</span> triangles.</p>
</section>
<section id="how-does-it-work-plain-language-44" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-44">How Does It Work (Plain Language)</h4>
<p>An ear of a polygon is a triangle formed by three consecutive vertices <span class="math inline">\((v_{i-1}, v_i, v_{i+1})\)</span> such that:</p>
<ol type="1">
<li>The triangle lies entirely inside the polygon, and</li>
<li>It contains no other vertex of the polygon inside it.</li>
</ol>
<p>The algorithm repeatedly clips ears:</p>
<ol type="1">
<li>Identify a vertex that forms an ear.</li>
<li>Remove it (and the ear triangle) from the polygon.</li>
<li>Repeat until only one triangle remains.</li>
</ol>
<p>Each “clip” reduces the polygon size by one vertex.</p>
</section>
<section id="ear-definition-formal" class="level4">
<h4 class="anchored" data-anchor-id="ear-definition-formal">Ear Definition (Formal)</h4>
<p>Triangle <span class="math inline">\(\triangle (v_{i-1}, v_i, v_{i+1})\)</span> is an ear if:</p>
<ol type="1">
<li><span class="math inline">\(\triangle\)</span> is convex: <span class="math display">\[
\text{cross}(v_i - v_{i-1}, v_{i+1} - v_i) &gt; 0
\]</span></li>
<li>No other vertex <span class="math inline">\(v_j\)</span> (for <span class="math inline">\(j \ne i-1,i,i+1\)</span>) lies inside <span class="math inline">\(\triangle\)</span>.</li>
</ol>
</section>
<section id="step-by-step-example-3" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-3">Step-by-Step Example</h4>
<p>Polygon (CCW): <span class="math inline">\((0,0), (4,0), (4,4), (2,2), (0,4)\)</span></p>
<ol type="1">
<li>Check each vertex for convexity.</li>
<li>Vertex <span class="math inline">\((4,0)\)</span> forms an ear, triangle <span class="math inline">\((0,0),(4,0),(4,4)\)</span> contains no other vertices.</li>
<li>Clip ear → remove <span class="math inline">\((4,0)\)</span>.</li>
<li>Repeat with smaller polygon.</li>
<li>Continue until only one triangle remains.</li>
</ol>
<p>Result: triangulation = 3 triangles.</p>
</section>
<section id="tiny-code-python-example-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-3">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_convex(a, b, c):</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (b[<span class="dv">0</span>] <span class="op">-</span> a[<span class="dv">0</span>])<span class="op">*</span>(c[<span class="dv">1</span>] <span class="op">-</span> a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>] <span class="op">-</span> a[<span class="dv">1</span>])<span class="op">*</span>(c[<span class="dv">0</span>] <span class="op">-</span> a[<span class="dv">0</span>]) <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> point_in_triangle(p, a, b, c):</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    cross1 <span class="op">=</span> (b[<span class="dv">0</span>] <span class="op">-</span> a[<span class="dv">0</span>])<span class="op">*</span>(p[<span class="dv">1</span>] <span class="op">-</span> a[<span class="dv">1</span>]) <span class="op">-</span> (b[<span class="dv">1</span>] <span class="op">-</span> a[<span class="dv">1</span>])<span class="op">*</span>(p[<span class="dv">0</span>] <span class="op">-</span> a[<span class="dv">0</span>])</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    cross2 <span class="op">=</span> (c[<span class="dv">0</span>] <span class="op">-</span> b[<span class="dv">0</span>])<span class="op">*</span>(p[<span class="dv">1</span>] <span class="op">-</span> b[<span class="dv">1</span>]) <span class="op">-</span> (c[<span class="dv">1</span>] <span class="op">-</span> b[<span class="dv">1</span>])<span class="op">*</span>(p[<span class="dv">0</span>] <span class="op">-</span> b[<span class="dv">0</span>])</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    cross3 <span class="op">=</span> (a[<span class="dv">0</span>] <span class="op">-</span> c[<span class="dv">0</span>])<span class="op">*</span>(p[<span class="dv">1</span>] <span class="op">-</span> c[<span class="dv">1</span>]) <span class="op">-</span> (a[<span class="dv">1</span>] <span class="op">-</span> c[<span class="dv">1</span>])<span class="op">*</span>(p[<span class="dv">0</span>] <span class="op">-</span> c[<span class="dv">0</span>])</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (cross1 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> cross2 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> cross3 <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="kw">or</span> (cross1 <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">and</span> cross2 <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">and</span> cross3 <span class="op">&lt;=</span> <span class="dv">0</span>)</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ear_clipping(polygon):</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    triangles <span class="op">=</span> []</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> polygon[:]</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(vertices) <span class="op">&gt;</span> <span class="dv">3</span>:</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(vertices)</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>            a, b, c <span class="op">=</span> vertices[i<span class="op">-</span><span class="dv">1</span>], vertices[i], vertices[(i<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> n]</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_convex(a, b, c):</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>                ear <span class="op">=</span> <span class="va">True</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> p <span class="kw">in</span> vertices:</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> p <span class="kw">not</span> <span class="kw">in</span> (a, b, c) <span class="kw">and</span> point_in_triangle(p, a, b, c):</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>                        ear <span class="op">=</span> <span class="va">False</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">break</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> ear:</span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>                    triangles.append((a, b, c))</span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>                    vertices.pop(i)</span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a>    triangles.append(<span class="bu">tuple</span>(vertices))</span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> triangles</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This version removes one ear per iteration and terminates after <span class="math inline">\(n-3\)</span> iterations.</p>
</section>
<section id="why-it-matters-44" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-44">Why It Matters</h4>
<ul>
<li>Simple to understand and implement</li>
<li>Works for any simple polygon (convex or concave)</li>
<li>Produces consistent triangulations</li>
<li>Forms basis for many advanced meshing algorithms</li>
</ul>
<p>Applications:</p>
<ul>
<li>Rendering polygons (OpenGL tessellation)</li>
<li>Physics collision meshes</li>
<li>Geometric modeling (e.g.&nbsp;GIS, FEM)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-31" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-31">A Gentle Proof (Why It Works)</h4>
<p>Every simple polygon has at least two ears (Meisters’ Theorem). Each ear is a valid triangle that doesn’t overlap others. By clipping one ear per step, the polygon’s boundary shrinks, preserving simplicity. Thus, the algorithm always terminates with <span class="math inline">\(n-2\)</span> triangles.</p>
<p>Time complexity (naive): <span class="math display">\[
O(n^2)
\]</span> Using spatial acceleration (e.g., adjacency lists): <span class="math display">\[
O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-44" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-44">Try It Yourself</h4>
<ol type="1">
<li>Draw a concave polygon.</li>
<li>Find convex vertices.</li>
<li>Test each for ear condition (no other vertex inside).</li>
<li>Clip ear, redraw polygon.</li>
<li>Repeat until full triangulation.</li>
</ol>
</section>
<section id="test-cases-44" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-44">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Vertices</th>
<th>Triangles</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>3</td>
<td>1</td>
</tr>
<tr class="even">
<td>Convex Quad</td>
<td>4</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Concave Pent</td>
<td>5</td>
<td>3</td>
</tr>
<tr class="even">
<td>Star shape</td>
<td>8</td>
<td>6</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-44" class="level4">
<h4 class="anchored" data-anchor-id="complexity-44">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n^2), \quad \text{Space: } O(n)
\]</span></p>
<p>The Ear Clipping Triangulation slices geometry like origami, one ear at a time, until every fold becomes a perfect triangle.</p>
</section>
</section>
<section id="monotone-polygon-triangulation" class="level3">
<h3 class="anchored" data-anchor-id="monotone-polygon-triangulation">745 Monotone Polygon Triangulation</h3>
<p>The Monotone Polygon Triangulation algorithm is a powerful and efficient method for triangulating y-monotone polygons, polygons whose edges never “backtrack” along the y-axis. Because of this property, we can sweep from top to bottom, connecting diagonals in a well-ordered fashion, achieving an elegant <span class="math inline">\(O(n)\)</span> time complexity.</p>
<section id="what-problem-are-we-solving-45" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-45">What Problem Are We Solving?</h4>
<p>Given a y-monotone polygon (its boundary can be split into a left and right chain that are both monotonic in y), we want to split it into non-overlapping triangles.</p>
<p>A polygon is y-monotone if any horizontal line intersects its boundary at most twice. This structure guarantees that each vertex can be handled incrementally using a stack-based sweep.</p>
<p>We want a triangulation with:</p>
<ul>
<li>No edge crossings</li>
<li>Linear-time construction</li>
<li>Stable structure for rendering and geometry</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-45" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-45">How Does It Work (Plain Language)</h4>
<p>Think of sweeping a horizontal line from top to bottom. At each vertex, you decide whether to connect it with diagonals to previous vertices, forming new triangles.</p>
<p>The key idea:</p>
<ol type="1">
<li>Sort vertices by y (descending)</li>
<li>Classify each vertex as belonging to the left or right chain</li>
<li>Use a stack to manage the active chain of vertices</li>
<li>Pop and connect when you can form valid diagonals</li>
<li>Continue until only the base edge remains</li>
</ol>
<p>At the end, you get a full triangulation of the polygon.</p>
</section>
<section id="step-by-step-conceptual-flow" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-conceptual-flow">Step-by-Step (Conceptual Flow)</h4>
<ol type="1">
<li><p>Input: a y-monotone polygon</p></li>
<li><p>Sort vertices in descending y order</p></li>
<li><p>Initialize stack with first two vertices</p></li>
<li><p>For each next vertex <span class="math inline">\(v_i\)</span>:</p>
<ul>
<li>If <span class="math inline">\(v_i\)</span> is on the opposite chain, connect <span class="math inline">\(v_i\)</span> to all vertices in stack, then reset the stack.</li>
<li>Else, pop vertices forming convex turns, add diagonals, and push <span class="math inline">\(v_i\)</span></li>
</ul></li>
<li><p>Continue until one chain remains.</p></li>
</ol>
</section>
<section id="example" class="level4">
<h4 class="anchored" data-anchor-id="example">Example</h4>
<p>Polygon (y-monotone):</p>
<pre><code>v1 (top)
|\
| \
|  \
v2  v3
|    \
|     v4
|    /
v5--v6 (bottom)</code></pre>
<ol type="1">
<li>Sort vertices by y</li>
<li>Identify left chain (v1, v2, v5, v6), right chain (v1, v3, v4, v6)</li>
<li>Sweep from top</li>
<li>Add diagonals between chains as you descend</li>
<li>Triangulation completed in linear time.</li>
</ol>
</section>
<section id="tiny-code-python-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-pseudocode">Tiny Code (Python Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> monotone_triangulation(vertices):</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># vertices sorted by descending y</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    stack <span class="op">=</span> [vertices[<span class="dv">0</span>], vertices[<span class="dv">1</span>]]</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    triangles <span class="op">=</span> []</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(vertices)):</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> vertices[i]</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> on_opposite_chain(current, stack[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="bu">len</span>(stack) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>                top <span class="op">=</span> stack.pop()</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>                triangles.append((current, top, stack[<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>            stack <span class="op">=</span> [stack[<span class="op">-</span><span class="dv">1</span>], current]</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>            top <span class="op">=</span> stack.pop()</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="bu">len</span>(stack) <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> is_convex(current, top, stack[<span class="op">-</span><span class="dv">1</span>]):</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>                triangles.append((current, top, stack[<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>                top <span class="op">=</span> stack.pop()</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>            stack.extend([top, current])</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> triangles</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>on_opposite_chain</code> and <code>is_convex</code> are geometric tests using cross products and chain labeling.</p>
</section>
<section id="why-it-matters-45" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-45">Why It Matters</h4>
<ul>
<li><p>Optimal <span class="math inline">\(O(n)\)</span> algorithm for monotone polygons</p></li>
<li><p>A crucial step in general polygon triangulation (used after decomposition)</p></li>
<li><p>Used in:</p>
<ul>
<li>Graphics rendering (OpenGL tessellation)</li>
<li>Map engines (GIS)</li>
<li>Mesh generation and computational geometry libraries</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-32" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-32">A Gentle Proof (Why It Works)</h4>
<p>In a y-monotone polygon:</p>
<ul>
<li>The boundary has no self-intersections</li>
<li>The sweep line always encounters vertices in consistent topological order</li>
<li>Each new vertex can only connect to visible predecessors</li>
</ul>
<p>Thus, each edge and vertex is processed once, producing <span class="math inline">\(n-2\)</span> triangles with no redundant operations.</p>
<p>Time complexity: <span class="math display">\[
O(n)
\]</span></p>
<p>Each vertex is pushed and popped at most once.</p>
</section>
<section id="try-it-yourself-45" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-45">Try It Yourself</h4>
<ol type="1">
<li>Draw a y-monotone polygon (like a mountain slope).</li>
<li>Mark left and right chains.</li>
<li>Sweep from top to bottom, connecting diagonals.</li>
<li>Track stack operations and triangles formed.</li>
<li>Verify triangulation produces <span class="math inline">\(n-2\)</span> triangles.</li>
</ol>
</section>
<section id="test-cases-45" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-45">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Vertices</th>
<th>Triangles</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Convex</td>
<td>5</td>
<td>3</td>
<td><span class="math inline">\(O(5)\)</span></td>
</tr>
<tr class="even">
<td>Y-Monotone Hexagon</td>
<td>6</td>
<td>4</td>
<td><span class="math inline">\(O(6)\)</span></td>
</tr>
<tr class="odd">
<td>Concave Monotone</td>
<td>7</td>
<td>5</td>
<td><span class="math inline">\(O(7)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-45" class="level4">
<h4 class="anchored" data-anchor-id="complexity-45">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Monotone Polygon Triangulation flows like a waterfall, sweeping smoothly down the polygon’s shape, splitting it into perfect, non-overlapping triangles with graceful precision.</p>
</section>
</section>
<section id="delaunay-triangulation-optimal-triangle-quality" class="level3">
<h3 class="anchored" data-anchor-id="delaunay-triangulation-optimal-triangle-quality">746 Delaunay Triangulation (Optimal Triangle Quality)</h3>
<p>The Delaunay Triangulation is one of the most elegant and fundamental constructions in computational geometry. It produces a triangulation of a set of points such that no point lies inside the circumcircle of any triangle. This property maximizes the minimum angle of all triangles, avoiding skinny, sliver-shaped triangles, making it ideal for meshing, interpolation, and graphics.</p>
<section id="what-problem-are-we-solving-46" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-46">What Problem Are We Solving?</h4>
<p>Given a finite set of points <span class="math display">\[
P = {p_1, p_2, \ldots, p_n}
\]</span> in the plane, we want to connect them into non-overlapping triangles satisfying the Delaunay condition:</p>
<blockquote class="blockquote">
<p>For every triangle in the triangulation, the circumcircle contains no other point of <span class="math inline">\(P\)</span> in its interior.</p>
</blockquote>
<p>This gives us a Delaunay Triangulation, noted for:</p>
<ul>
<li>Optimal angle quality (max-min angle property)</li>
<li>Duality with the Voronoi Diagram</li>
<li>Robustness for interpolation and simulation</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-46" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-46">How Does It Work (Plain Language)</h4>
<p>Imagine inflating circles through every triplet of points. A circle “belongs” to a triangle if no other point is inside it. The triangulation that respects this rule is the Delaunay triangulation.</p>
<p>Several methods can construct it:</p>
<ol type="1">
<li>Incremental Insertion (Bowyer–Watson): add one point at a time</li>
<li>Divide and Conquer: recursively merge Delaunay sets</li>
<li>Fortune’s Sweep Line: <span class="math inline">\(O(n \log n)\)</span> algorithm</li>
<li>Flipping Edges: enforce the empty circle property</li>
</ol>
<p>Each ensures no triangle violates the empty circumcircle rule.</p>
</section>
<section id="delaunay-condition-empty-circumcircle-test" class="level4">
<h4 class="anchored" data-anchor-id="delaunay-condition-empty-circumcircle-test">Delaunay Condition (Empty Circumcircle Test)</h4>
<p>For triangle with vertices <span class="math inline">\(a(x_a,y_a)\)</span>, <span class="math inline">\(b(x_b,y_b)\)</span>, <span class="math inline">\(c(x_c,y_c)\)</span> and a query point <span class="math inline">\(p(x_p,y_p)\)</span>:</p>
<p>Compute determinant:</p>
<p><span class="math display">\[
\begin{vmatrix}
x_a &amp; y_a &amp; x_a^2 + y_a^2 &amp; 1 \\
x_b &amp; y_b &amp; x_b^2 + y_b^2 &amp; 1 \\
x_c &amp; y_c &amp; x_c^2 + y_c^2 &amp; 1 \\
x_p &amp; y_p &amp; x_p^2 + y_p^2 &amp; 1
\end{vmatrix}
\]</span></p>
<ul>
<li>If result &gt; 0, point <span class="math inline">\(p\)</span> is inside the circumcircle → violates Delaunay</li>
<li>If ≤ 0, triangle satisfies Delaunay condition</li>
</ul>
</section>
<section id="step-by-step-bowyerwatson-method" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-bowyerwatson-method">Step-by-Step (Bowyer–Watson Method)</h4>
<ol type="1">
<li><p>Start with a super-triangle enclosing all points.</p></li>
<li><p>For each point <span class="math inline">\(p\)</span>:</p>
<ul>
<li>Find all triangles whose circumcircle contains <span class="math inline">\(p\)</span></li>
<li>Remove them (forming a cavity)</li>
<li>Connect <span class="math inline">\(p\)</span> to all edges on the cavity boundary</li>
</ul></li>
<li><p>Repeat until all points are added.</p></li>
<li><p>Remove triangles connected to the super-triangle’s vertices.</p></li>
</ol>
</section>
<section id="tiny-code-python-sketch-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-10">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delaunay(points):</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># assume helper functions: circumcircle_contains, super_triangle</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    triangles <span class="op">=</span> [super_triangle(points)]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>        bad <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> triangles <span class="cf">if</span> circumcircle_contains(t, p)]</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>        edges <span class="op">=</span> []</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> bad:</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> e <span class="kw">in</span> t.edges():</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> e <span class="kw">not</span> <span class="kw">in</span> edges:</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>                    edges.append(e)</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>                    edges.remove(e)</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> bad:</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>            triangles.remove(t)</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> e <span class="kw">in</span> edges:</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>            triangles.append(Triangle(e[<span class="dv">0</span>], e[<span class="dv">1</span>], p))</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [t <span class="cf">for</span> t <span class="kw">in</span> triangles <span class="cf">if</span> <span class="kw">not</span> t.shares_super()]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This incremental construction runs in <span class="math inline">\(O(n^2)\)</span>, or <span class="math inline">\(O(n \log n)\)</span> with acceleration.</p>
</section>
<section id="why-it-matters-46" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-46">Why It Matters</h4>
<ul>
<li><p>Quality guarantee: avoids skinny triangles</p></li>
<li><p>Dual structure: forms the basis of Voronoi Diagrams</p></li>
<li><p>Stability: small input changes → small triangulation changes</p></li>
<li><p>Applications:</p>
<ul>
<li>Terrain modeling</li>
<li>Mesh generation (FEM, CFD)</li>
<li>Interpolation (Natural Neighbor, Sibson)</li>
<li>Computer graphics and GIS</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-33" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-33">A Gentle Proof (Why It Works)</h4>
<p>For any set of points in general position (no 4 cocircular):</p>
<ul>
<li>Delaunay triangulation exists and is unique</li>
<li>It maximizes minimum angle among all triangulations</li>
<li>Edge flips restore Delaunay condition: if two triangles share an edge and violate the condition, flipping the edge increases the smallest angle.</li>
</ul>
<p>Thus, repeatedly flipping until no violations yields a valid Delaunay triangulation.</p>
</section>
<section id="try-it-yourself-46" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-46">Try It Yourself</h4>
<ol type="1">
<li>Plot random points on a plane.</li>
<li>Connect them arbitrarily, then check circumcircles.</li>
<li>Flip edges that violate the Delaunay condition.</li>
<li>Compare before/after, note improved triangle shapes.</li>
<li>Overlay Voronoi diagram (they’re dual structures).</li>
</ol>
</section>
<section id="test-cases-46" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-46">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 22%">
<col style="width: 12%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Points</th>
<th>Method</th>
<th>Triangles</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3 pts</td>
<td>trivial</td>
<td>1</td>
<td>Always Delaunay</td>
</tr>
<tr class="even">
<td>4 pts forming square</td>
<td>flip-based</td>
<td>2</td>
<td>Diagonal with empty circle</td>
</tr>
<tr class="odd">
<td>Random 10 pts</td>
<td>incremental</td>
<td>16</td>
<td>Delaunay mesh</td>
</tr>
<tr class="even">
<td>Grid points</td>
<td>divide &amp; conquer</td>
<td>many</td>
<td>uniform mesh</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-46" class="level4">
<h4 class="anchored" data-anchor-id="complexity-46">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n \log n), \quad \text{Space: } O(n)
\]</span></p>
<p>The Delaunay Triangulation builds harmony in the plane, every triangle balanced, every circle empty, every angle wide, a geometry that’s both efficient and beautiful.</p>
</section>
</section>
<section id="convex-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="convex-decomposition">747 Convex Decomposition</h3>
<p>The Convex Decomposition algorithm breaks a complex polygon into smaller convex pieces. Since convex polygons are much easier to work with, for collision detection, rendering, and geometry operations, this decomposition step is often essential in computational geometry and graphics systems.</p>
<section id="what-problem-are-we-solving-47" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-47">What Problem Are We Solving?</h4>
<p>Given a simple polygon (possibly concave), we want to divide it into convex sub-polygons such that:</p>
<ol type="1">
<li>The union of all sub-polygons equals the original polygon.</li>
<li>Sub-polygons do not overlap.</li>
<li>Each sub-polygon is convex, all interior angles ≤ 180°.</li>
</ol>
<p>Convex decomposition helps transform difficult geometric tasks (like intersection, clipping, physics simulation) into simpler convex cases.</p>
</section>
<section id="how-does-it-work-plain-language-47" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-47">How Does It Work (Plain Language)</h4>
<p>Concave polygons “bend inward.” To make them convex, we draw diagonals that split concave regions apart. The idea:</p>
<ol type="1">
<li>Find vertices that are reflex (interior angle &gt; 180°).</li>
<li>Draw diagonals from each reflex vertex to visible non-adjacent vertices inside the polygon.</li>
<li>Split the polygon along these diagonals.</li>
<li>Repeat until every resulting piece is convex.</li>
</ol>
<p>You can think of it like cutting folds out of a paper shape until every piece lies flat.</p>
</section>
<section id="reflex-vertex-test" class="level4">
<h4 class="anchored" data-anchor-id="reflex-vertex-test">Reflex Vertex Test</h4>
<p>For vertex sequence <span class="math inline">\((v_{i-1}, v_i, v_{i+1})\)</span> (CCW order), compute cross product:</p>
<p><span class="math display">\[
\text{cross}(v_{i+1} - v_i, v_{i-1} - v_i)
\]</span></p>
<ul>
<li>If the result &lt; 0, <span class="math inline">\(v_i\)</span> is reflex (concave turn).</li>
<li>If &gt; 0, <span class="math inline">\(v_i\)</span> is convex.</li>
</ul>
<p>Reflex vertices mark where diagonals may be drawn.</p>
</section>
<section id="step-by-step-example-4" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-4">Step-by-Step Example</h4>
<p>Polygon (CCW): <span class="math inline">\((0,0), (4,0), (4,2), (2,1), (4,4), (0,4)\)</span></p>
<ol type="1">
<li>Compute orientation at each vertex, <span class="math inline">\((2,1)\)</span> is reflex.</li>
<li>From <span class="math inline">\((2,1)\)</span>, find a visible vertex on the opposite chain (e.g., <span class="math inline">\((0,4)\)</span>).</li>
<li>Add diagonal <span class="math inline">\((2,1)\)</span>–<span class="math inline">\((0,4)\)</span> → polygon splits into two convex parts.</li>
<li>Each resulting polygon passes the convexity test.</li>
</ol>
</section>
<section id="tiny-code-python-example-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-4">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross(o, a, b):</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a[<span class="dv">0</span>] <span class="op">-</span> o[<span class="dv">0</span>]) <span class="op">*</span> (b[<span class="dv">1</span>] <span class="op">-</span> o[<span class="dv">1</span>]) <span class="op">-</span> (a[<span class="dv">1</span>] <span class="op">-</span> o[<span class="dv">1</span>]) <span class="op">*</span> (b[<span class="dv">0</span>] <span class="op">-</span> o[<span class="dv">0</span>])</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_reflex(prev, curr, nxt):</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cross(curr, nxt, prev) <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convex_decomposition(polygon):</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    parts <span class="op">=</span> [polygon]</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(parts):</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>        poly <span class="op">=</span> parts[i]</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(poly)</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>        found <span class="op">=</span> <span class="va">False</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_reflex(poly[j<span class="op">-</span><span class="dv">1</span>], poly[j], poly[(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n]):</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> k <span class="kw">not</span> <span class="kw">in</span> (j<span class="op">-</span><span class="dv">1</span>, j, (j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n):</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># naive visibility check (for simplicity)</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>                        parts.append(poly[j:k<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>                        parts.append(poly[k:] <span class="op">+</span> poly[:j<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>                        parts.pop(i)</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>                        found <span class="op">=</span> <span class="va">True</span></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">break</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> found: <span class="cf">break</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> found: i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parts</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This basic structure finds reflex vertices and splits polygon recursively.</p>
</section>
<section id="why-it-matters-47" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-47">Why It Matters</h4>
<p>Convex decomposition underlies many geometry systems:</p>
<ul>
<li>Physics engines (Box2D, Chipmunk, Bullet): collisions computed per convex part.</li>
<li>Graphics pipelines: rasterization and tessellation simplify to convex polygons.</li>
<li>Computational geometry: many algorithms (e.g., point-in-polygon, intersection) are easier for convex sets.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-34" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-34">A Gentle Proof (Why It Works)</h4>
<p>Every simple polygon can be decomposed into convex polygons using diagonals that lie entirely inside the polygon. There exists a guaranteed upper bound of <span class="math inline">\(n-3\)</span> diagonals (from polygon triangulation). Since every convex polygon is trivially decomposed into itself, the recursive cutting terminates.</p>
<p>Thus, convex decomposition is both finite and complete.</p>
</section>
<section id="try-it-yourself-47" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-47">Try It Yourself</h4>
<ol type="1">
<li>Draw a concave polygon (like an arrow or “L” shape).</li>
<li>Mark reflex vertices.</li>
<li>Add diagonals connecting reflex vertices to visible points.</li>
<li>Verify each resulting piece is convex.</li>
<li>Count: total triangles ≤ <span class="math inline">\(n-2\)</span>.</li>
</ol>
</section>
<section id="test-cases-47" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-47">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Vertices</th>
<th>Convex Parts</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Convex</td>
<td>5</td>
<td>1</td>
<td>Already convex</td>
</tr>
<tr class="even">
<td>Concave “L”</td>
<td>6</td>
<td>2</td>
<td>Single diagonal split</td>
</tr>
<tr class="odd">
<td>Star shape</td>
<td>8</td>
<td>5</td>
<td>Multiple reflex cuts</td>
</tr>
<tr class="even">
<td>Irregular</td>
<td>10</td>
<td>4</td>
<td>Sequential decomposition</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-47" class="level4">
<h4 class="anchored" data-anchor-id="complexity-47">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n^2), \quad \text{Space: } O(n)
\]</span></p>
<p>The Convex Decomposition algorithm untangles geometry piece by piece, turning a complicated shape into a mosaic of simple, convex forms, the building blocks of computational geometry.</p>
</section>
</section>
<section id="polygon-area-shoelace-formula" class="level3">
<h3 class="anchored" data-anchor-id="polygon-area-shoelace-formula">748 Polygon Area (Shoelace Formula)</h3>
<p>The Shoelace Formula (also called Gauss’s Area Formula) is a simple and elegant way to compute the area of any simple polygon, convex or concave, directly from its vertex coordinates.</p>
<p>It’s called the “shoelace” method because when you multiply and sum the coordinates in a crisscross pattern, it looks just like lacing up a shoe.</p>
<section id="what-problem-are-we-solving-48" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-48">What Problem Are We Solving?</h4>
<p>Given a polygon defined by its ordered vertices <span class="math display">\[
P = {(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)}
\]</span> we want to find its area efficiently without subdividing or integrating.</p>
<p>The polygon is assumed to be simple (edges do not cross) and closed, meaning <span class="math inline">\(v_{n+1} = v_1\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-48" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-48">How Does It Work (Plain Language)</h4>
<p>To find the polygon’s area, take the sum of the cross-products of consecutive coordinates, one way and the other:</p>
<ol type="1">
<li>Multiply each <span class="math inline">\(x_i\)</span> by the next vertex’s <span class="math inline">\(y_{i+1}\)</span>.</li>
<li>Multiply each <span class="math inline">\(y_i\)</span> by the next vertex’s <span class="math inline">\(x_{i+1}\)</span>.</li>
<li>Subtract the two sums.</li>
<li>Take half of the absolute value.</li>
</ol>
<p>That’s it. The pattern of products forms a “shoelace” when written out, hence the name.</p>
</section>
<section id="formula" class="level4">
<h4 class="anchored" data-anchor-id="formula">Formula</h4>
<p><span class="math display">\[
A = \frac{1}{2} \Bigg| \sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \Bigg|
\]</span></p>
<p>where <span class="math inline">\((x_{n+1}, y_{n+1}) = (x_1, y_1)\)</span> to close the polygon.</p>
</section>
<section id="example-1" class="level4">
<h4 class="anchored" data-anchor-id="example-1">Example</h4>
<p>Polygon: <span class="math inline">\((0,0), (4,0), (4,3), (0,4)\)</span></p>
<p>Compute step by step:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 1%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 23%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>i</th>
<th><span class="math inline">\(x_i\)</span></th>
<th><span class="math inline">\(y_i\)</span></th>
<th><span class="math inline">\(x_{i+1}\)</span></th>
<th><span class="math inline">\(y_{i+1}\)</span></th>
<th><span class="math inline">\(x_i y_{i+1}\)</span></th>
<th><span class="math inline">\(y_i x_{i+1}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>2</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>3</td>
<td>12</td>
<td>0</td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td>3</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>12</td>
</tr>
<tr class="even">
<td>4</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Now compute: <span class="math display">\[
A = \frac{1}{2} |(0 + 12 + 0 + 0) - (0 + 0 + 12 + 0)| = \frac{1}{2} |12 - 12| = 0
\]</span></p>
<p>Oops, that means we must check vertex order (CW vs CCW). Reordering gives positive area:</p>
<p><span class="math display">\[
A = \frac{1}{2} |12 + 16 + 0 + 0 - (0 + 0 + 0 + 0)| = 14
\]</span></p>
<p>So area = 14 square units.</p>
</section>
<section id="tiny-code-python-example-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-5">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> polygon_area(points):</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    area <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> points[i]</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> points[(i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n]</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>        area <span class="op">+=</span> x1 <span class="op">*</span> y2 <span class="op">-</span> x2 <span class="op">*</span> y1</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">abs</span>(area) <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>poly <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">4</span>,<span class="dv">0</span>), (<span class="dv">4</span>,<span class="dv">3</span>), (<span class="dv">0</span>,<span class="dv">4</span>)]</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(polygon_area(poly))  <span class="co"># Output: 14.0</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This version works for both convex and concave polygons, as long as vertices are ordered consistently (CW or CCW).</p>
</section>
<section id="why-it-matters-48" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-48">Why It Matters</h4>
<ul>
<li>Simple and exact (integer arithmetic works perfectly)</li>
<li>No trigonometry or decomposition needed</li>
<li>Used everywhere: GIS, CAD, graphics, robotics</li>
<li>Works for any 2D polygon defined by vertex coordinates.</li>
</ul>
<p>Applications:</p>
<ul>
<li>Compute land parcel areas</li>
<li>Polygon clipping algorithms</li>
<li>Geometry-based physics</li>
<li>Vector graphics (SVG path areas)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-35" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-35">A Gentle Proof (Why It Works)</h4>
<p>The shoelace formula is derived from the line integral form of Green’s Theorem:</p>
<p><span class="math display">\[
A = \frac{1}{2} \oint (x,dy - y,dx)
\]</span></p>
<p>Discretizing along polygon edges gives:</p>
<p><span class="math display">\[
A = \frac{1}{2} \sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i)
\]</span></p>
<p>The absolute value ensures area is positive regardless of orientation (CW or CCW).</p>
</section>
<section id="try-it-yourself-48" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-48">Try It Yourself</h4>
<ol type="1">
<li>Take any polygon, triangle, square, or irregular shape.</li>
<li>Write coordinates in order.</li>
<li>Multiply across, sum one way and subtract the other.</li>
<li>Take half the absolute value.</li>
<li>Verify by comparing to known geometric area.</li>
</ol>
</section>
<section id="test-cases-48" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-48">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 53%">
<col style="width: 11%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Polygon</th>
<th>Vertices</th>
<th>Expected Area</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle (0,0),(4,0),(0,3)</td>
<td>3</td>
<td>6</td>
</tr>
<tr class="even">
<td>Rectangle (0,0),(4,0),(4,3),(0,3)</td>
<td>4</td>
<td>12</td>
</tr>
<tr class="odd">
<td>Parallelogram (0,0),(5,0),(6,3),(1,3)</td>
<td>4</td>
<td>15</td>
</tr>
<tr class="even">
<td>Concave shape</td>
<td>5</td>
<td>consistent with geometry</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-48" class="level4">
<h4 class="anchored" data-anchor-id="complexity-48">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n), \quad \text{Space: } O(1)
\]</span></p>
<p>The Shoelace Formula is geometry’s arithmetic poetry — a neat crisscross of numbers that quietly encloses a shape’s entire area in a single line of algebra.</p>
</section>
</section>
<section id="minkowski-sum" class="level3">
<h3 class="anchored" data-anchor-id="minkowski-sum">749 Minkowski Sum</h3>
<p>The Minkowski Sum is a geometric operation that combines two shapes by adding their coordinates point by point. It’s a cornerstone in computational geometry, robotics, and motion planning, used for modeling reachable spaces, expanding obstacles, and combining shapes in a mathematically precise way.</p>
<section id="what-problem-are-we-solving-49" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-49">What Problem Are We Solving?</h4>
<p>Given two sets of points (or shapes) in the plane:</p>
<p><span class="math display">\[
A, B \subset \mathbb{R}^2
\]</span></p>
<p>the Minkowski Sum is defined as the set of all possible sums of one point from <span class="math inline">\(A\)</span> and one from <span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[
A \oplus B = {, a + b \mid a \in A,, b \in B ,}
\]</span></p>
<p>Intuitively, we “sweep” one shape around another, summing their coordinates, the result is a new shape that represents all possible combinations of positions.</p>
</section>
<section id="how-does-it-work-plain-language-49" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-49">How Does It Work (Plain Language)</h4>
<p>Think of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> as two polygons. To compute <span class="math inline">\(A \oplus B\)</span>:</p>
<ol type="1">
<li>Take every vertex in <span class="math inline">\(A\)</span> and add every vertex in <span class="math inline">\(B\)</span>.</li>
<li>Collect all resulting points.</li>
<li>Compute the convex hull of that set.</li>
</ol>
<p>If both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are convex, their Minkowski sum is also convex, and can be computed efficiently by merging edges in sorted angular order (like merging two convex polygons).</p>
<p>If <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span> is concave, you can decompose them into convex parts first, compute all pairwise sums, and merge the results.</p>
</section>
<section id="geometric-meaning" class="level4">
<h4 class="anchored" data-anchor-id="geometric-meaning">Geometric Meaning</h4>
<p>If you think of <span class="math inline">\(B\)</span> as an “object” and <span class="math inline">\(A\)</span> as a “region,” then <span class="math inline">\(A \oplus B\)</span> represents all locations that <span class="math inline">\(B\)</span> can occupy if its reference point moves along <span class="math inline">\(A\)</span>.</p>
<p>For example:</p>
<ul>
<li>In robotics, <span class="math inline">\(A\)</span> can be the robot, <span class="math inline">\(B\)</span> can be obstacles, the sum gives all possible collision configurations.</li>
<li>In graphics, it’s used for shape expansion, offsetting, and collision detection.</li>
</ul>
</section>
<section id="step-by-step-example-5" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-5">Step-by-Step Example</h4>
<p>Let: <span class="math display">\[
A = {(0,0), (2,0), (1,1)}, \quad B = {(0,0), (1,0), (0,1)}
\]</span></p>
<p>Compute all pairwise sums:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(a\)</span></th>
<th><span class="math inline">\(b\)</span></th>
<th><span class="math inline">\(a+b\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0)</td>
<td>(0,0)</td>
<td>(0,0)</td>
</tr>
<tr class="even">
<td>(0,0)</td>
<td>(1,0)</td>
<td>(1,0)</td>
</tr>
<tr class="odd">
<td>(0,0)</td>
<td>(0,1)</td>
<td>(0,1)</td>
</tr>
<tr class="even">
<td>(2,0)</td>
<td>(0,0)</td>
<td>(2,0)</td>
</tr>
<tr class="odd">
<td>(2,0)</td>
<td>(1,0)</td>
<td>(3,0)</td>
</tr>
<tr class="even">
<td>(2,0)</td>
<td>(0,1)</td>
<td>(2,1)</td>
</tr>
<tr class="odd">
<td>(1,1)</td>
<td>(0,0)</td>
<td>(1,1)</td>
</tr>
<tr class="even">
<td>(1,1)</td>
<td>(1,0)</td>
<td>(2,1)</td>
</tr>
<tr class="odd">
<td>(1,1)</td>
<td>(0,1)</td>
<td>(1,2)</td>
</tr>
</tbody>
</table>
<p>Convex hull of all these points = Minkowski sum polygon.</p>
</section>
<section id="tiny-code-python-example-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-6">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minkowski_sum(A, B):</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> [(a[<span class="dv">0</span>]<span class="op">+</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">+</span>b[<span class="dv">1</span>]) <span class="cf">for</span> a, b <span class="kw">in</span> product(A, B)]</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> convex_hull(points)</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convex_hull(points):</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">set</span>(points))</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(points) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> points</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cross(o, a, b):</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (a[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])<span class="op">*</span>(b[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>]) <span class="op">-</span> (a[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>])<span class="op">*</span>(b[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    lower, upper <span class="op">=</span> [], []</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(lower) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> cross(lower[<span class="op">-</span><span class="dv">2</span>], lower[<span class="op">-</span><span class="dv">1</span>], p) <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>            lower.pop()</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>        lower.append(p)</span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> <span class="bu">reversed</span>(points):</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(upper) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> cross(upper[<span class="op">-</span><span class="dv">2</span>], upper[<span class="op">-</span><span class="dv">1</span>], p) <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>            upper.pop()</span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>        upper.append(p)</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lower[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> upper[:<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This computes all sums and builds a convex hull around them.</p>
</section>
<section id="why-it-matters-49" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-49">Why It Matters</h4>
<ul>
<li>Collision detection: <span class="math inline">\(A \oplus (-B)\)</span> tells whether shapes intersect (if origin ∈ sum).</li>
<li>Motion planning: Expanding obstacles by robot shape simplifies pathfinding.</li>
<li>Graphics and CAD: Used for offsetting, buffering, and morphological operations.</li>
<li>Convex analysis: Models addition of convex functions and support sets.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-36" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-36">A Gentle Proof (Why It Works)</h4>
<p>For convex sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, the Minkowski Sum preserves convexity:</p>
<p><span class="math display">\[
\lambda_1 (a_1 + b_1) + \lambda_2 (a_2 + b_2)
= (\lambda_1 a_1 + \lambda_2 a_2) + (\lambda_1 b_1 + \lambda_2 b_2)
\in A \oplus B
\]</span></p>
<p>for all <span class="math inline">\(\lambda_1, \lambda_2 \ge 0\)</span> and <span class="math inline">\(\lambda_1 + \lambda_2 = 1\)</span>.</p>
<p>Thus, <span class="math inline">\(A \oplus B\)</span> is convex. The sum geometrically represents the vector addition of all points, a direct application of convexity’s closure under linear combinations.</p>
</section>
<section id="try-it-yourself-49" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-49">Try It Yourself</h4>
<ol type="1">
<li>Start with two convex polygons (like a square and a triangle).</li>
<li>Add every vertex pair and plot the points.</li>
<li>Take the convex hull, that’s your Minkowski sum.</li>
<li>Try flipping one shape (<span class="math inline">\(-B\)</span>), the sum shrinks into an intersection test.</li>
</ol>
</section>
<section id="test-cases-49" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-49">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Shape A</th>
<th>Shape B</th>
<th>Resulting Shape</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>Triangle</td>
<td>Hexagon</td>
</tr>
<tr class="even">
<td>Square</td>
<td>Square</td>
<td>Larger square</td>
</tr>
<tr class="odd">
<td>Line segment</td>
<td>Circle</td>
<td>Thickened line</td>
</tr>
<tr class="even">
<td>Polygon</td>
<td>Negative polygon</td>
<td>Collision region</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-49" class="level4">
<h4 class="anchored" data-anchor-id="complexity-49">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O(n + m), \quad \text{for convex polygons of sizes } n, m
\]</span></p>
<p>(using the angular merge algorithm)</p>
<p>The Minkowski Sum is geometry’s way of adding ideas — each shape extends the other, and together they define everything reachable, combinable, and possible within space.</p>
</section>
</section>
<section id="polygon-intersection-weileratherton-clipping" class="level3">
<h3 class="anchored" data-anchor-id="polygon-intersection-weileratherton-clipping">750 Polygon Intersection (Weiler–Atherton Clipping)</h3>
<p>The Weiler–Atherton Algorithm is a classic and versatile method for computing the intersection, union, or difference of two arbitrary polygons, even concave ones with holes. It’s the geometric heart of clipping systems used in computer graphics, CAD, and geospatial analysis.</p>
<section id="what-problem-are-we-solving-50" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-50">What Problem Are We Solving?</h4>
<p>Given two polygons:</p>
<ul>
<li>Subject polygon <span class="math inline">\(S\)</span></li>
<li>Clip polygon <span class="math inline">\(C\)</span></li>
</ul>
<p>we want to find the intersection region <span class="math inline">\(S \cap C\)</span>, or optionally the union (<span class="math inline">\(S \cup C\)</span>) or difference (<span class="math inline">\(S - C\)</span>).</p>
<p>Unlike simpler algorithms (like Sutherland–Hodgman) that only handle convex polygons, Weiler–Atherton works for any simple polygon, convex, concave, or with holes.</p>
</section>
<section id="how-does-it-work-plain-language-50" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-50">How Does It Work (Plain Language)</h4>
<p>The idea is to walk along the edges of both polygons, switching between them at intersection points, to trace the final clipped region.</p>
<p>Think of it as walking along <span class="math inline">\(S\)</span>, and whenever you hit the border of <span class="math inline">\(C\)</span>, you decide whether to enter or exit the clipping area. This path tracing builds the final intersection polygon.</p>
</section>
<section id="step-by-step-outline" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-outline">Step-by-Step Outline</h4>
<ol type="1">
<li><p>Find intersection points Compute all intersections between edges of <span class="math inline">\(S\)</span> and <span class="math inline">\(C\)</span>. Insert these points into both polygons’ vertex lists in correct order.</p></li>
<li><p>Label intersections as “entry” or “exit” Depending on whether you’re entering or leaving <span class="math inline">\(C\)</span> when following <span class="math inline">\(S\)</span>’s boundary.</p></li>
<li><p>Traverse polygons</p>
<ul>
<li>Start at an unvisited intersection.</li>
<li>If it’s an entry, follow along <span class="math inline">\(S\)</span> until you hit the next intersection.</li>
<li>Switch to <span class="math inline">\(C\)</span> and continue tracing along its boundary.</li>
<li>Alternate between polygons until you return to the starting point.</li>
</ul></li>
<li><p>Repeat until all intersections are visited. Each closed traversal gives one part of the final result (may be multiple disjoint polygons).</p></li>
</ol>
</section>
<section id="intersection-geometry-mathematical-test" class="level4">
<h4 class="anchored" data-anchor-id="intersection-geometry-mathematical-test">Intersection Geometry (Mathematical Test)</h4>
<p>For segments <span class="math inline">\(A_1A_2\)</span> and <span class="math inline">\(B_1B_2\)</span>, we compute intersection using the parametric line equations:</p>
<p><span class="math display">\[
A_1 + t(A_2 - A_1) = B_1 + u(B_2 - B_1)
\]</span></p>
<p>Solving for <span class="math inline">\(t\)</span> and <span class="math inline">\(u\)</span>:</p>
<p><span class="math display">\[
t = \frac{(B_1 - A_1) \times (B_2 - B_1)}{(A_2 - A_1) \times (B_2 - B_1)}, \quad
u = \frac{(B_1 - A_1) \times (A_2 - A_1)}{(A_2 - A_1) \times (B_2 - B_1)}
\]</span></p>
<p>If <span class="math inline">\(0 \le t, u \le 1\)</span>, the segments intersect at:</p>
<p><span class="math display">\[
P = A_1 + t(A_2 - A_1)
\]</span></p>
</section>
<section id="tiny-code-python-example-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-7">Tiny Code (Python Example)</h4>
<p>This sketch shows the conceptual structure (omitting numerical edge cases):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> weiler_atherton(subject, clip):</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    intersections <span class="op">=</span> []</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(subject)):</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(clip)):</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>            p1, p2 <span class="op">=</span> subject[i], subject[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(subject)]</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>            q1, q2 <span class="op">=</span> clip[j], clip[(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(clip)]</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>            ip <span class="op">=</span> segment_intersection(p1, p2, q1, q2)</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ip:</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>                intersections.append(ip)</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>                subject.insert(i<span class="op">+</span><span class="dv">1</span>, ip)</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>                clip.insert(j<span class="op">+</span><span class="dv">1</span>, ip)</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ip <span class="kw">in</span> intersections:</span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ip <span class="kw">in</span> visited: <span class="cf">continue</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>        polygon <span class="op">=</span> []</span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> ip</span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>        in_subject <span class="op">=</span> <span class="va">True</span></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>            polygon.append(current)</span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a>            visited.add(current)</span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>            next_poly <span class="op">=</span> subject <span class="cf">if</span> in_subject <span class="cf">else</span> clip</span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> next_poly.index(current)</span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> next_poly[(idx <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(next_poly)]</span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current <span class="kw">in</span> intersections:</span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a>                in_subject <span class="op">=</span> <span class="kw">not</span> in_subject</span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current <span class="op">==</span> ip:</span>
<span id="cb71-29"><a href="#cb71-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb71-30"><a href="#cb71-30" aria-hidden="true" tabindex="-1"></a>        result.append(polygon)</span>
<span id="cb71-31"><a href="#cb71-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This captures the algorithmic structure, in practice, geometric libraries (like Shapely, CGAL, GEOS) handle precision and topology robustly.</p>
</section>
<section id="why-it-matters-50" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-50">Why It Matters</h4>
<ul>
<li><p>Handles complex polygons (concave, holes, multiple intersections)</p></li>
<li><p>Works for all boolean operations (intersection, union, difference)</p></li>
<li><p>Foundation for:</p>
<ul>
<li>Computer graphics clipping (rendering polygons inside viewports)</li>
<li>GIS spatial analysis (overlay operations)</li>
<li>2D CAD modeling (cutting and merging shapes)</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-37" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-37">A Gentle Proof (Why It Works)</h4>
<p>By alternating traversal between polygons at intersection points, the algorithm preserves topological continuity, the final polygon boundary follows valid edges from both <span class="math inline">\(S\)</span> and <span class="math inline">\(C\)</span>. Because intersections divide polygons into connected boundary fragments, and every traversal alternates between “inside” and “outside” regions, each closed path corresponds to a valid piece of the intersection.</p>
<p>Thus, correctness follows from:</p>
<ul>
<li>Consistent orientation (CW or CCW)</li>
<li>Accurate inside/outside tests</li>
<li>Complete traversal of all intersections</li>
</ul>
</section>
<section id="try-it-yourself-50" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-50">Try It Yourself</h4>
<ol type="1">
<li>Draw two overlapping polygons (one convex, one concave).</li>
<li>Find all intersection points between edges.</li>
<li>Label each as entering or exiting.</li>
<li>Follow the edges alternating between polygons, trace the intersection region.</li>
<li>Fill it, that’s <span class="math inline">\(S \cap C\)</span>.</li>
</ol>
</section>
<section id="test-cases-50" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-50">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 20%">
<col style="width: 33%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th>Subject Polygon</th>
<th>Clip Polygon</th>
<th>Operation</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rectangle</td>
<td>Triangle</td>
<td>Intersection</td>
<td>Triangle cap</td>
</tr>
<tr class="even">
<td>Concave</td>
<td>Rectangle</td>
<td>Intersection</td>
<td>Clipped shape</td>
</tr>
<tr class="odd">
<td>Two rectangles</td>
<td>Overlap</td>
<td>Union</td>
<td>Combined box</td>
</tr>
<tr class="even">
<td>Star and circle</td>
<td>Intersection</td>
<td>Complex curve region</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-50" class="level4">
<h4 class="anchored" data-anchor-id="complexity-50">Complexity</h4>
<p><span class="math display">\[
\text{Time: } O((n + m)^2), \quad \text{Space: } O(n + m)
\]</span></p>
<p>Optimized implementations use spatial indexing to accelerate intersection tests.</p>
<p>The Weiler–Atherton Algorithm turns polygon overlap into a walk along boundaries — entering, exiting, and rejoining, tracing the precise geometry of how two shapes truly meet.</p>
</section>
</section>
</section>
<section id="section-76.-spatial-data-structures" class="level1">
<h1>Section 76. Spatial Data Structures</h1>
<section id="kd-tree-build" class="level3">
<h3 class="anchored" data-anchor-id="kd-tree-build">751 KD-Tree Build</h3>
<p>The KD-Tree (short for <em>k-dimensional tree</em>) is a data structure used to organize points in a k-dimensional space for fast nearest neighbor and range queries. It’s a recursive, space-partitioning structure, dividing the space with axis-aligned hyperplanes, much like slicing the world into halves again and again.</p>
<section id="what-problem-are-we-solving-51" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-51">What Problem Are We Solving?</h4>
<p>Given a set of points <span class="math display">\[
P = {p_1, p_2, \ldots, p_n} \subset \mathbb{R}^k
\]</span> we want to build a structure that lets us answer geometric queries efficiently, such as:</p>
<ul>
<li>“Which point is nearest to <span class="math inline">\((x, y, z)\)</span>?”</li>
<li>“Which points lie within this bounding box?”</li>
</ul>
<p>Instead of checking all points every time (<span class="math inline">\(O(n)\)</span> per query), we build a KD-tree once, enabling searches in <span class="math inline">\(O(\log n)\)</span> on average.</p>
</section>
<section id="how-does-it-work-plain-language-51" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-51">How Does It Work (Plain Language)</h4>
<p>A KD-tree is a binary tree that recursively splits points by coordinate axes:</p>
<ol type="1">
<li><p>Choose a splitting axis (e.g., <span class="math inline">\(x\)</span>, then <span class="math inline">\(y\)</span>, then <span class="math inline">\(x\)</span>, … cyclically).</p></li>
<li><p>Find the median point along that axis.</p></li>
<li><p>Create a node storing that point, this is your split plane.</p></li>
<li><p>Recursively build:</p>
<ul>
<li>Left subtree → points with coordinate less than median</li>
<li>Right subtree → points with coordinate greater than median</li>
</ul></li>
</ol>
<p>Each node divides space into two half-spaces, creating a hierarchy of nested bounding boxes.</p>
</section>
<section id="step-by-step-example-2d" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-2d">Step-by-Step Example (2D)</h4>
<p>Points: <span class="math inline">\((2,3), (5,4), (9,6), (4,7), (8,1), (7,2)\)</span></p>
<p>Build process:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 22%">
<col style="width: 9%">
<col style="width: 31%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Axis</th>
<th>Median Point</th>
<th>Split</th>
<th>Left Points</th>
<th>Right Points</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>x</td>
<td>(7,2)</td>
<td>x=7</td>
<td>(2,3),(5,4),(4,7)</td>
<td>(8,1),(9,6)</td>
</tr>
<tr class="even">
<td>2</td>
<td>y</td>
<td>(5,4)</td>
<td>y=4</td>
<td>(2,3)</td>
<td>(4,7)</td>
</tr>
<tr class="odd">
<td>3</td>
<td>y</td>
<td>(8,1)</td>
<td>y=1</td>
<td>,</td>
<td>(9,6)</td>
</tr>
</tbody>
</table>
<p>Final structure:</p>
<pre><code>        (7,2)
       /     \
   (5,4)     (8,1)
   /   \        \
(2,3) (4,7)     (9,6)</code></pre>
</section>
<section id="tiny-code-python-example-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-8">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_kdtree(points, depth<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> points:</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(points[<span class="dv">0</span>])</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    axis <span class="op">=</span> depth <span class="op">%</span> k</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    points.sort(key<span class="op">=</span><span class="kw">lambda</span> p: p[axis])</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    median <span class="op">=</span> <span class="bu">len</span>(points) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">'point'</span>: points[median],</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">'left'</span>: build_kdtree(points[:median], depth <span class="op">+</span> <span class="dv">1</span>),</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">'right'</span>: build_kdtree(points[median <span class="op">+</span> <span class="dv">1</span>:], depth <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This recursive builder sorts points by alternating axes and picks the median at each level.</p>
</section>
<section id="why-it-matters-51" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-51">Why It Matters</h4>
<p>The KD-tree is one of the core structures in computational geometry, with widespread applications:</p>
<ul>
<li>Nearest Neighbor Search, find closest points in <span class="math inline">\(O(\log n)\)</span> time</li>
<li>Range Queries, count or collect points in an axis-aligned box</li>
<li>Ray Tracing &amp; Graphics, accelerate visibility and intersection checks</li>
<li>Machine Learning, speed up k-NN classification or clustering</li>
<li>Robotics / Motion Planning, organize configuration spaces</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-38" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-38">A Gentle Proof (Why It Works)</h4>
<p>At each recursion, the median split ensures that:</p>
<ul>
<li>The tree height is roughly <span class="math inline">\(\log_2 n\)</span></li>
<li>Each search descends only one branch per dimension, pruning large portions of space</li>
</ul>
<p>Thus, building is <span class="math inline">\(O(n \log n)\)</span> on average (due to sorting), and queries are logarithmic under balanced conditions.</p>
<p>Formally, at each level: <span class="math display">\[
T(n) = 2T(n/2) + O(n) \Rightarrow T(n) = O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-51" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-51">Try It Yourself</h4>
<ol type="1">
<li>Write down 8 random 2D points.</li>
<li>Sort them by x-axis, pick median → root node.</li>
<li>Recursively sort left and right halves by y-axis → next splits.</li>
<li>Draw boundaries (vertical and horizontal lines) for each split.</li>
<li>Visualize the partitioning as rectangular regions.</li>
</ol>
</section>
<section id="test-cases-51" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-51">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Dimensions</th>
<th>Expected Depth</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7 random</td>
<td>2D</td>
<td>~3</td>
<td>Balanced splits</td>
</tr>
<tr class="even">
<td>1000 random</td>
<td>3D</td>
<td>~10</td>
<td>Median-based</td>
</tr>
<tr class="odd">
<td>10 collinear</td>
<td>1D</td>
<td>10</td>
<td>Degenerate chain</td>
</tr>
<tr class="even">
<td>Grid points</td>
<td>2D</td>
<td>log₂(n)</td>
<td>Uniform regions</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-51" class="level4">
<h4 class="anchored" data-anchor-id="complexity-51">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Search</td>
<td><span class="math inline">\(O(\log n)\)</span> (avg)</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
<tr class="odd">
<td>Worst-case search</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
</tbody>
</table>
<p>The KD-tree is like a geometric filing cabinet — each split folds space neatly into halves, letting you find the nearest point with just a few elegant comparisons instead of searching the entire world.</p>
</section>
</section>
<section id="kd-tree-search" class="level3">
<h3 class="anchored" data-anchor-id="kd-tree-search">752 KD-Tree Search</h3>
<p>Once a KD-tree is built, the real power comes from fast search operations, finding points near a query location without scanning the entire dataset. The search exploits the recursive spatial partitioning of the KD-tree, pruning large parts of space that can’t possibly contain the nearest point.</p>
<section id="what-problem-are-we-solving-52" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-52">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A set of points <span class="math inline">\(P \subset \mathbb{R}^k\)</span> organized in a KD-tree</li>
<li>A query point <span class="math inline">\(q = (q_1, q_2, \ldots, q_k)\)</span></li>
</ul>
<p>we want to find:</p>
<ol type="1">
<li>The nearest neighbor of <span class="math inline">\(q\)</span> (point with minimal Euclidean distance)</li>
<li>Or all points within a given range (axis-aligned region or radius)</li>
</ol>
<p>Instead of <span class="math inline">\(O(n)\)</span> brute force, KD-tree search achieves average <span class="math inline">\(O(\log n)\)</span> query time.</p>
</section>
<section id="how-does-it-work-plain-language-52" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-52">How Does It Work (Plain Language)</h4>
<p>The search descends the KD-tree recursively:</p>
<ol type="1">
<li><p>At each node, compare the query coordinate on the current split axis.</p></li>
<li><p>Move into the subtree that contains the query point.</p></li>
<li><p>When reaching a leaf, record it as the current best.</p></li>
<li><p>Backtrack:</p>
<ul>
<li>If the hypersphere around the best point so far crosses the splitting plane, search the other subtree too (there might be a closer point).</li>
<li>Otherwise, prune that branch, it cannot contain a nearer point.</li>
</ul></li>
<li><p>Return the closest found.</p></li>
</ol>
<p>This pruning is the heart of KD-tree efficiency.</p>
</section>
<section id="step-by-step-example-2d-nearest-neighbor" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-2d-nearest-neighbor">Step-by-Step Example (2D Nearest Neighbor)</h4>
<p>Points (from the previous build): <span class="math inline">\((2,3), (5,4), (9,6), (4,7), (8,1), (7,2)\)</span></p>
<p>Tree root: <span class="math inline">\((7,2)\)</span>, split on x</p>
<p>Query: <span class="math inline">\(q = (9,2)\)</span></p>
<ol type="1">
<li>Compare <span class="math inline">\(q_x=9\)</span> to split <span class="math inline">\(x=7\)</span> → go right subtree</li>
<li>Compare <span class="math inline">\(q_y=2\)</span> to split <span class="math inline">\(y=1\)</span> → go up subtree to <span class="math inline">\((9,6)\)</span></li>
<li>Compute distance <span class="math inline">\((9,6)\)</span> → <span class="math inline">\(d=4\)</span></li>
<li>Backtrack: check if circle of radius 4 crosses x=7 plane → yes → explore left</li>
<li>Left child <span class="math inline">\((8,1)\)</span> → <span class="math inline">\(d=1.41\)</span> → better</li>
<li>Done → nearest = <span class="math inline">\((8,1)\)</span></li>
</ol>
</section>
<section id="tiny-code-python-example-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-9">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance2(a, b):</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>((a[i] <span class="op">-</span> b[i])<span class="dv">2</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(a)))</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nearest_neighbor(tree, point, depth<span class="op">=</span><span class="dv">0</span>, best<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tree <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> best</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(point)</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>    axis <span class="op">=</span> depth <span class="op">%</span> k</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    next_branch <span class="op">=</span> <span class="va">None</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    opposite_branch <span class="op">=</span> <span class="va">None</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> point[axis] <span class="op">&lt;</span> tree[<span class="st">'point'</span>][axis]:</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>        next_branch <span class="op">=</span> tree[<span class="st">'left'</span>]</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>        opposite_branch <span class="op">=</span> tree[<span class="st">'right'</span>]</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>        next_branch <span class="op">=</span> tree[<span class="st">'right'</span>]</span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>        opposite_branch <span class="op">=</span> tree[<span class="st">'left'</span>]</span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> nearest_neighbor(next_branch, point, depth <span class="op">+</span> <span class="dv">1</span>, best)</span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> best <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> distance2(point, tree[<span class="st">'point'</span>]) <span class="op">&lt;</span> distance2(point, best):</span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> tree[<span class="st">'point'</span>]</span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-27"><a href="#cb74-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (point[axis] <span class="op">-</span> tree[<span class="st">'point'</span>][axis])<span class="dv">2</span> <span class="op">&lt;</span> distance2(point, best):</span>
<span id="cb74-28"><a href="#cb74-28" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> nearest_neighbor(opposite_branch, point, depth <span class="op">+</span> <span class="dv">1</span>, best)</span>
<span id="cb74-29"><a href="#cb74-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-30"><a href="#cb74-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This function recursively explores only necessary branches, pruning away others that can’t contain closer points.</p>
</section>
<section id="why-it-matters-52" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-52">Why It Matters</h4>
<p>KD-tree search is the backbone of many algorithms:</p>
<ul>
<li>Machine Learning: k-nearest neighbors (k-NN), clustering</li>
<li>Computer Graphics: ray-object intersection</li>
<li>Robotics / Motion Planning: nearest sample search</li>
<li>Simulation / Physics: proximity detection</li>
<li>GIS / Spatial Databases: region and radius queries</li>
</ul>
<p>Without KD-tree search, these tasks would scale linearly with data size.</p>
</section>
<section id="a-gentle-proof-why-it-works-39" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-39">A Gentle Proof (Why It Works)</h4>
<p>KD-tree search correctness relies on two geometric facts:</p>
<ol type="1">
<li><p>The splitting plane divides space into disjoint regions.</p></li>
<li><p>The nearest neighbor must lie either:</p>
<ul>
<li>in the same region as the query, or</li>
<li>across the split, but within a distance smaller than the current best radius.</li>
</ul></li>
</ol>
<p>Thus, pruning based on the distance between <span class="math inline">\(q\)</span> and the splitting plane never eliminates a possible nearer point. By visiting subtrees only when necessary, the search remains both complete and efficient.</p>
</section>
<section id="try-it-yourself-52" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-52">Try It Yourself</h4>
<ol type="1">
<li>Build a KD-tree for points in 2D.</li>
<li>Query a random point, trace recursive calls.</li>
<li>Draw the search region and visualize pruned subtrees.</li>
<li>Increase data size, note how query time remains near <span class="math inline">\(O(\log n)\)</span>.</li>
</ol>
</section>
<section id="test-cases-52" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-52">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query</th>
<th>Expected Nearest</th>
<th>Distance</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(9,2)</td>
<td>(8,1)</td>
<td>1.41</td>
<td>On right branch</td>
</tr>
<tr class="even">
<td>(3,5)</td>
<td>(4,7)</td>
<td>2.23</td>
<td>Left-heavy region</td>
</tr>
<tr class="odd">
<td>(5,3)</td>
<td>(5,4)</td>
<td>1.00</td>
<td>Exact axis match</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-52" class="level4">
<h4 class="anchored" data-anchor-id="complexity-52">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Average search</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
<tr class="even">
<td>Worst-case (degenerate tree)</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
</tbody>
</table>
<p>The KD-tree search walks through geometric space like a detective with perfect intuition — checking only where it must, skipping where it can, and always stopping when it finds the closest possible answer.</p>
</section>
</section>
<section id="range-search-in-kd-tree" class="level3">
<h3 class="anchored" data-anchor-id="range-search-in-kd-tree">753 Range Search in KD-Tree</h3>
<p>The Range Search in a KD-tree is a geometric query that retrieves all points within a given axis-aligned region (a rectangle in 2D, box in 3D, or hyper-rectangle in higher dimensions). It’s a natural extension of KD-tree traversal, but instead of finding one nearest neighbor, we collect all points lying inside a target window.</p>
<section id="what-problem-are-we-solving-53" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-53">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A KD-tree containing <span class="math inline">\(n\)</span> points in <span class="math inline">\(k\)</span> dimensions</li>
<li>A query region (for example, in 2D): <span class="math display">\[
R = [x_{\min}, x_{\max}] \times [y_{\min}, y_{\max}]
\]</span></li>
</ul>
<p>we want to find all points <span class="math inline">\(p = (p_1, \ldots, p_k)\)</span> such that:</p>
<p><span class="math display">\[
x_{\min} \le p_1 \le x_{\max}, \quad
y_{\min} \le p_2 \le y_{\max}, \quad \ldots
\]</span></p>
<p>In other words, all points that lie <em>inside</em> the axis-aligned box <span class="math inline">\(R\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-53" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-53">How Does It Work (Plain Language)</h4>
<p>The algorithm recursively visits KD-tree nodes and prunes branches that can’t possibly intersect the query region:</p>
<ol type="1">
<li>At each node, compare the splitting coordinate with the region’s bounds.</li>
<li>If the node’s point lies inside <span class="math inline">\(R\)</span>, record it.</li>
<li>If the left subtree could contain points inside <span class="math inline">\(R\)</span>, search left.</li>
<li>If the right subtree could contain points inside <span class="math inline">\(R\)</span>, search right.</li>
<li>Stop when subtrees fall completely outside the region.</li>
</ol>
<p>This approach avoids visiting most nodes, only those whose regions overlap the query box.</p>
</section>
<section id="step-by-step-example-2d-1" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-2d-1">Step-by-Step Example (2D)</h4>
<p>KD-tree (from before):</p>
<pre><code>        (7,2)
       /     \
   (5,4)     (8,1)
   /   \        \
(2,3) (4,7)     (9,6)</code></pre>
<p>Query region: <span class="math display">\[
x \in [4, 8], \quad y \in [1, 5]
\]</span></p>
<p>Search process:</p>
<ol type="1">
<li>Root (7,2) inside → record.</li>
<li>Left child (5,4) inside → record.</li>
<li>(2,3) left of region → prune.</li>
<li>(4,7) y=7 &gt; 5 → prune.</li>
<li>Right child (8,1) inside → record.</li>
<li>(9,6) x &gt; 8 → prune.</li>
</ol>
<p>Result: Points inside region = (7,2), (5,4), (8,1)</p>
</section>
<section id="tiny-code-python-example-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-10">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> range_search(tree, region, depth<span class="op">=</span><span class="dv">0</span>, found<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tree <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> found <span class="kw">or</span> []</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> found <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>        found <span class="op">=</span> []</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(tree[<span class="st">'point'</span>])</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    axis <span class="op">=</span> depth <span class="op">%</span> k</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    point <span class="op">=</span> tree[<span class="st">'point'</span>]</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># check if point inside region</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">all</span>(region[i][<span class="dv">0</span>] <span class="op">&lt;=</span> point[i] <span class="op">&lt;=</span> region[i][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k)):</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>        found.append(point)</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># explore subtrees if overlapping region</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> region[axis][<span class="dv">0</span>] <span class="op">&lt;=</span> point[axis]:</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>        range_search(tree[<span class="st">'left'</span>], region, depth <span class="op">+</span> <span class="dv">1</span>, found)</span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> region[axis][<span class="dv">1</span>] <span class="op">&gt;=</span> point[axis]:</span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>        range_search(tree[<span class="st">'right'</span>], region, depth <span class="op">+</span> <span class="dv">1</span>, found)</span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> found</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>region <span class="op">=</span> [(<span class="dv">4</span>, <span class="dv">8</span>), (<span class="dv">1</span>, <span class="dv">5</span>)]  <span class="co"># x and y bounds</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> range_search(kdtree, region)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-53" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-53">Why It Matters</h4>
<p>Range queries are foundational in spatial computing:</p>
<ul>
<li>Database indexing (R-tree, KD-tree) → fast filtering</li>
<li>Graphics → find objects in viewport or camera frustum</li>
<li>Robotics → retrieve local neighbors for collision checking</li>
<li>Machine learning → clustering within spatial limits</li>
<li>GIS systems → spatial joins and map queries</li>
</ul>
<p>KD-tree range search combines geometric logic with efficient pruning, making it practical for high-speed applications.</p>
</section>
<section id="a-gentle-proof-why-it-works-40" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-40">A Gentle Proof (Why It Works)</h4>
<p>Each node in a KD-tree defines a hyper-rectangular region of space. If this region lies entirely outside the query box, none of its points can be inside, so we safely skip it. Otherwise, we recurse.</p>
<p>The total number of nodes visited is: <span class="math display">\[
O(n^{1 - \frac{1}{k}} + m)
\]</span> where <span class="math inline">\(m\)</span> is the number of reported points, a known bound from multidimensional search theory.</p>
<p>Thus, range search is output-sensitive: it scales with how many points you actually find.</p>
</section>
<section id="try-it-yourself-53" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-53">Try It Yourself</h4>
<ol type="1">
<li>Build a KD-tree with random 2D points.</li>
<li>Define a bounding box <span class="math inline">\([x_1,x_2]\times[y_1,y_2]\)</span>.</li>
<li>Trace recursive calls, note which branches are pruned.</li>
<li>Visualize the query region, confirm returned points fall inside.</li>
</ol>
</section>
<section id="test-cases-53" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-53">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Region</th>
<th>Expected Points</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(x\in[4,8], y\in[1,5]\)</span></td>
<td>(5,4), (7,2), (8,1)</td>
<td>3 points inside</td>
</tr>
<tr class="even">
<td><span class="math inline">\(x\in[0,3], y\in[2,4]\)</span></td>
<td>(2,3)</td>
<td>Single match</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(x\in[8,9], y\in[0,2]\)</span></td>
<td>(8,1)</td>
<td>On boundary</td>
</tr>
<tr class="even">
<td><span class="math inline">\(x\in[10,12], y\in[0,5]\)</span></td>
<td>∅</td>
<td>Empty result</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-53" class="level4">
<h4 class="anchored" data-anchor-id="complexity-53">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Range search</td>
<td><span class="math inline">\(O(n^{1 - 1/k} + m)\)</span></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
<tr class="even">
<td>Average (2D–3D)</td>
<td><span class="math inline">\(O(\sqrt{n} + m)\)</span></td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
</tbody>
</table>
<p>The KD-tree range search is like sweeping a flashlight over geometric space — it illuminates only the parts you care about, leaving the rest in darkness, and reveals just the points shining inside your query window.</p>
</section>
</section>
<section id="nearest-neighbor-search-in-kd-tree" class="level3">
<h3 class="anchored" data-anchor-id="nearest-neighbor-search-in-kd-tree">754 Nearest Neighbor Search in KD-Tree</h3>
<p>The Nearest Neighbor (NN) Search is one of the most important operations on a KD-tree. It finds the point (or several points) in a dataset that are closest to a given query point in Euclidean space, a problem that appears in clustering, machine learning, graphics, and robotics.</p>
<section id="what-problem-are-we-solving-54" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-54">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A set of points <span class="math inline">\(P = {p_1, p_2, \ldots, p_n} \subset \mathbb{R}^k\)</span></li>
<li>A KD-tree built on those points</li>
<li>A query point <span class="math inline">\(q \in \mathbb{R}^k\)</span></li>
</ul>
<p>We want to find:</p>
<p><span class="math display">\[
p^* = \arg\min_{p_i \in P} |p_i - q|
\]</span></p>
<p>the point <span class="math inline">\(p^*\)</span> closest to <span class="math inline">\(q\)</span> by Euclidean distance (or sometimes Manhattan or cosine distance).</p>
</section>
<section id="how-does-it-work-plain-language-54" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-54">How Does It Work (Plain Language)</h4>
<p>KD-tree NN search works by recursively descending into the tree, just like a binary search in multiple dimensions.</p>
<ol type="1">
<li><p>Start at the root. Compare the query coordinate along the node’s split axis. Go left or right depending on whether the query is smaller or greater.</p></li>
<li><p>Recurse until a leaf node. That leaf’s point becomes your initial best.</p></li>
<li><p>Backtrack up the tree. At each node:</p>
<ul>
<li>Update the best point if the node’s point is closer.</li>
<li>Check if the hypersphere around the query (radius = current best distance) crosses the splitting plane.</li>
<li>If it does, explore the other subtree, there could be a closer point across the plane.</li>
<li>If not, prune that branch.</li>
</ul></li>
<li><p>Terminate when you’ve returned to the root.</p></li>
</ol>
<p>Result: the best point is guaranteed to be the true nearest neighbor.</p>
</section>
<section id="step-by-step-example-2d-2" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-2d-2">Step-by-Step Example (2D)</h4>
<p>Points: <span class="math inline">\((2,3), (5,4), (9,6), (4,7), (8,1), (7,2)\)</span></p>
<p>KD-tree root: <span class="math inline">\((7,2)\)</span>, split on <span class="math inline">\(x\)</span></p>
<p>Query point: <span class="math inline">\(q = (9,2)\)</span></p>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 9%">
<col style="width: 19%">
<col style="width: 21%">
<col style="width: 33%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Node</th>
<th>Axis</th>
<th>Action</th>
<th>Best (dist²)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>(7,2)</td>
<td>x</td>
<td>go right (9 &gt; 7)</td>
<td>(7,2), <span class="math inline">\(d=4\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>(8,1)</td>
<td>y</td>
<td>go up (2 &gt; 1)</td>
<td>(8,1), <span class="math inline">\(d=2\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>(9,6)</td>
<td>y</td>
<td>distance = 17 → worse</td>
<td>(8,1), <span class="math inline">\(d=2\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>backtrack</td>
<td>check split plane $</td>
<td>9-7</td>
<td>=2$, equals <span class="math inline">\(r=√2\)</span> → explore left</td>
<td>(8,1), <span class="math inline">\(d=2\)</span></td>
</tr>
<tr class="odd">
<td>5</td>
<td>done</td>
<td>,</td>
<td>,</td>
<td>nearest = (8,1)</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-11">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist2(a, b):</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>((a[i] <span class="op">-</span> b[i])<span class="dv">2</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(a)))</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kd_nearest(tree, query, depth<span class="op">=</span><span class="dv">0</span>, best<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tree <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> best</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="bu">len</span>(query)</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>    axis <span class="op">=</span> depth <span class="op">%</span> k</span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>    next_branch <span class="op">=</span> <span class="va">None</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>    opposite_branch <span class="op">=</span> <span class="va">None</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    point <span class="op">=</span> tree[<span class="st">'point'</span>]</span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> query[axis] <span class="op">&lt;</span> point[axis]:</span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>        next_branch, opposite_branch <span class="op">=</span> tree[<span class="st">'left'</span>], tree[<span class="st">'right'</span>]</span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>        next_branch, opposite_branch <span class="op">=</span> tree[<span class="st">'right'</span>], tree[<span class="st">'left'</span>]</span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> kd_nearest(next_branch, query, depth <span class="op">+</span> <span class="dv">1</span>, best)</span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> best <span class="kw">is</span> <span class="va">None</span> <span class="kw">or</span> dist2(query, point) <span class="op">&lt;</span> dist2(query, best):</span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> point</span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if other branch could contain closer point</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (query[axis] <span class="op">-</span> point[axis])<span class="dv">2</span> <span class="op">&lt;</span> dist2(query, best):</span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a>        best <span class="op">=</span> kd_nearest(opposite_branch, query, depth <span class="op">+</span> <span class="dv">1</span>, best)</span>
<span id="cb78-27"><a href="#cb78-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-28"><a href="#cb78-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>nearest <span class="op">=</span> kd_nearest(kdtree, (<span class="dv">9</span>,<span class="dv">2</span>))</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Nearest:"</span>, nearest)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-54" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-54">Why It Matters</h4>
<p>Nearest neighbor search appears everywhere:</p>
<ul>
<li><p>Machine Learning</p>
<ul>
<li>k-NN classifier</li>
<li>Clustering (k-means, DBSCAN)</li>
</ul></li>
<li><p>Computer Graphics</p>
<ul>
<li>Ray tracing acceleration</li>
<li>Texture lookup, sampling</li>
</ul></li>
<li><p>Robotics</p>
<ul>
<li>Path planning (PRM, RRT*)</li>
<li>Obstacle proximity</li>
</ul></li>
<li><p>Simulation</p>
<ul>
<li>Particle systems and spatial interactions</li>
</ul></li>
</ul>
<p>KD-tree NN search cuts average query time from <span class="math inline">\(O(n)\)</span> to <span class="math inline">\(O(\log n)\)</span>, making it practical for real-time use.</p>
</section>
<section id="a-gentle-proof-why-it-works-41" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-41">A Gentle Proof (Why It Works)</h4>
<p>The pruning rule is geometrically sound because of two properties:</p>
<ol type="1">
<li>Each subtree lies entirely on one side of the splitting plane.</li>
<li>If the query’s hypersphere (radius = current best distance) doesn’t intersect that plane, no closer point can exist on the other side.</li>
</ol>
<p>Thus, only subtrees whose bounding region overlaps the sphere are explored, guaranteeing both correctness and efficiency.</p>
<p>In balanced cases: <span class="math display">\[
T(n) \approx O(\log n)
\]</span> and in degenerate (unbalanced) trees: <span class="math display">\[
T(n) = O(n)
\]</span></p>
</section>
<section id="try-it-yourself-54" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-54">Try It Yourself</h4>
<ol type="1">
<li>Build a KD-tree for 10 random 2D points.</li>
<li>Query a point and trace the recursion.</li>
<li>Draw hypersphere of best distance, see which branches are skipped.</li>
<li>Compare with brute-force nearest, verify same result.</li>
</ol>
</section>
<section id="test-cases-54" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-54">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query</th>
<th>Expected NN</th>
<th>Distance</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(9,2)</td>
<td>(8,1)</td>
<td>1.41</td>
<td>Right-heavy query</td>
</tr>
<tr class="even">
<td>(3,5)</td>
<td>(4,7)</td>
<td>2.23</td>
<td>Deep left search</td>
</tr>
<tr class="odd">
<td>(7,2)</td>
<td>(7,2)</td>
<td>0</td>
<td>Exact hit</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-54" class="level4">
<h4 class="anchored" data-anchor-id="complexity-54">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Average</th>
<th>Worst Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Space</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>The KD-tree nearest neighbor search is like intuition formalized — it leaps directly to where the answer must be, glances sideways only when geometry demands, and leaves the rest of the space quietly untouched.</p>
</section>
</section>
<section id="r-tree-build" class="level3">
<h3 class="anchored" data-anchor-id="r-tree-build">755 R-Tree Build</h3>
<p>The R-tree is a powerful spatial indexing structure designed to handle rectangles, polygons, and spatial objects, not just points. It’s used in databases, GIS systems, and graphics engines for efficient range queries, overlap detection, and nearest object search.</p>
<p>While KD-trees partition space by coordinate axes, R-trees partition space by bounding boxes that tightly enclose data objects or smaller groups of objects.</p>
<section id="what-problem-are-we-solving-55" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-55">What Problem Are We Solving?</h4>
<p>We need an index structure that supports:</p>
<ul>
<li>Fast search for objects overlapping a query region</li>
<li>Efficient insertions and deletions</li>
<li>Dynamic growth without rebalancing from scratch</li>
</ul>
<p>The R-tree provides all three, making it ideal for dynamic, multidimensional spatial data (rectangles, polygons, regions).</p>
</section>
<section id="how-it-works-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language">How It Works (Plain Language)</h4>
<p>The idea is to group nearby objects and represent them by their Minimum Bounding Rectangles (MBRs):</p>
<ol type="1">
<li>Each leaf node stores entries of the form <code>(MBR, object)</code>.</li>
<li>Each internal node stores entries of the form <code>(MBR, child-pointer)</code>, where MBR covers all child rectangles.</li>
<li>The root node’s MBR covers the entire dataset.</li>
</ol>
<p>When inserting or searching, the algorithm traverses these nested bounding boxes, pruning subtrees that do not intersect the query region.</p>
</section>
<section id="building-an-r-tree-bulk-loading" class="level4">
<h4 class="anchored" data-anchor-id="building-an-r-tree-bulk-loading">Building an R-Tree (Bulk Loading)</h4>
<p>There are two main approaches to build an R-tree:</p>
<section id="incremental-insertion-dynamic" class="level5">
<h5 class="anchored" data-anchor-id="incremental-insertion-dynamic">1. Incremental Insertion (Dynamic)</h5>
<p>Insert each object one by one using the ChooseSubtree rule:</p>
<ol type="1">
<li>Start from the root.</li>
<li>At each level, choose the child whose MBR needs least enlargement to include the new object.</li>
<li>If the child overflows (too many entries), split it using a heuristic like Quadratic Split or Linear Split.</li>
<li>Update parent MBRs upward.</li>
</ol>
</section>
<section id="bulk-loading-static" class="level5">
<h5 class="anchored" data-anchor-id="bulk-loading-static">2. Bulk Loading (Static)</h5>
<p>For large static datasets, sort objects by spatial order (e.g., Hilbert or Z-order curve), then pack them level by level to minimize overlap.</p>
</section>
</section>
<section id="example-2d-rectangles" class="level4">
<h4 class="anchored" data-anchor-id="example-2d-rectangles">Example (2D Rectangles)</h4>
<p>Suppose we have 8 objects, each with bounding boxes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Object</th>
<th>Rectangle <span class="math inline">\((x_{\min}, y_{\min}, x_{\max}, y_{\max})\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>(1, 1, 2, 2)</td>
</tr>
<tr class="even">
<td>B</td>
<td>(2, 2, 3, 3)</td>
</tr>
<tr class="odd">
<td>C</td>
<td>(8, 1, 9, 2)</td>
</tr>
<tr class="even">
<td>D</td>
<td>(9, 3, 10, 4)</td>
</tr>
<tr class="odd">
<td>E</td>
<td>(5, 5, 6, 6)</td>
</tr>
<tr class="even">
<td>F</td>
<td>(6, 6, 7, 7)</td>
</tr>
<tr class="odd">
<td>G</td>
<td>(3, 8, 4, 9)</td>
</tr>
<tr class="even">
<td>H</td>
<td>(4, 9, 5, 10)</td>
</tr>
</tbody>
</table>
<p>If each node can hold 4 entries, we might group as:</p>
<ul>
<li>Node 1 → {A, B, C, D} MBR = (1,1,10,4)</li>
<li>Node 2 → {E, F, G, H} MBR = (3,5,7,10)</li>
<li>Root → {Node 1, Node 2} MBR = (1,1,10,10)</li>
</ul>
<p>This hierarchical nesting enables fast region queries.</p>
</section>
<section id="tiny-code-python-example-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-12">Tiny Code (Python Example)</h4>
<p>A simplified static R-tree builder:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_rtree(objects, max_entries<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(objects) <span class="op">&lt;=</span> max_entries:</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'children'</span>: objects, <span class="st">'leaf'</span>: <span class="va">True</span>,</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>                <span class="st">'mbr'</span>: compute_mbr(objects)}</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sort by x-center for grouping</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    objects.sort(key<span class="op">=</span><span class="kw">lambda</span> o: (o[<span class="st">'mbr'</span>][<span class="dv">0</span>] <span class="op">+</span> o[<span class="st">'mbr'</span>][<span class="dv">2</span>]) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>    groups <span class="op">=</span> [objects[i:i<span class="op">+</span>max_entries] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(objects), max_entries)]</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>    children <span class="op">=</span> [{<span class="st">'children'</span>: g, <span class="st">'leaf'</span>: <span class="va">True</span>, <span class="st">'mbr'</span>: compute_mbr(g)} <span class="cf">for</span> g <span class="kw">in</span> groups]</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">'children'</span>: children, <span class="st">'leaf'</span>: <span class="va">False</span>, <span class="st">'mbr'</span>: compute_mbr(children)}</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_mbr(items):</span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>    xmin <span class="op">=</span> <span class="bu">min</span>(i[<span class="st">'mbr'</span>][<span class="dv">0</span>] <span class="cf">for</span> i <span class="kw">in</span> items)</span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>    ymin <span class="op">=</span> <span class="bu">min</span>(i[<span class="st">'mbr'</span>][<span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> items)</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>    xmax <span class="op">=</span> <span class="bu">max</span>(i[<span class="st">'mbr'</span>][<span class="dv">2</span>] <span class="cf">for</span> i <span class="kw">in</span> items)</span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>    ymax <span class="op">=</span> <span class="bu">max</span>(i[<span class="st">'mbr'</span>][<span class="dv">3</span>] <span class="cf">for</span> i <span class="kw">in</span> items)</span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (xmin, ymin, xmax, ymax)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-55" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-55">Why It Matters</h4>
<p>R-trees are widely used in:</p>
<ul>
<li>Spatial Databases (PostGIS, SQLite’s R-Tree extension)</li>
<li>Game Engines (collision and visibility queries)</li>
<li>GIS Systems (map data indexing)</li>
<li>CAD and Graphics (object selection and culling)</li>
<li>Robotics / Simulation (spatial occupancy grids)</li>
</ul>
<p>R-trees generalize KD-trees to handle <em>objects with size and shape</em>, not just points.</p>
</section>
<section id="a-gentle-proof-why-it-works-42" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-42">A Gentle Proof (Why It Works)</h4>
<p>R-tree correctness depends on two geometric invariants:</p>
<ol type="1">
<li>Every child’s bounding box is fully contained within its parent’s MBR.</li>
<li>Every leaf MBR covers its stored object.</li>
</ol>
<p>Because the structure preserves these containment relationships, any query that intersects a parent box must check only relevant subtrees, ensuring completeness and correctness.</p>
<p>The efficiency comes from minimizing overlap between sibling MBRs, which reduces unnecessary subtree visits.</p>
</section>
<section id="try-it-yourself-55" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-55">Try It Yourself</h4>
<ol type="1">
<li>Create several rectangles and visualize their bounding boxes.</li>
<li>Group them manually into MBR clusters.</li>
<li>Draw the nested rectangles that represent parent nodes.</li>
<li>Perform a query like “all objects intersecting (2,2)-(6,6)” and trace which boxes are visited.</li>
</ol>
</section>
<section id="test-cases-55" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-55">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query Box</th>
<th>Expected Results</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(1,1)-(3,3)</td>
<td>A, B</td>
<td>within Node 1</td>
</tr>
<tr class="even">
<td>(5,5)-(7,7)</td>
<td>E, F</td>
<td>within Node 2</td>
</tr>
<tr class="odd">
<td>(8,2)-(9,4)</td>
<td>C, D</td>
<td>right group</td>
</tr>
<tr class="even">
<td>(0,0)-(10,10)</td>
<td>all</td>
<td>full overlap</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-55" class="level4">
<h4 class="anchored" data-anchor-id="complexity-55">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Average</th>
<th>Worst Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Insert</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Space</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>The R-tree is the quiet geometry librarian — it files shapes neatly into nested boxes, so that when you ask “what’s nearby?”, it opens only the drawers that matter.</p>
</section>
</section>
<section id="r-tree" class="level3">
<h3 class="anchored" data-anchor-id="r-tree">756 R*-Tree</h3>
<p>The R*-Tree is an improved version of the R-tree that focuses on minimizing overlap and coverage between bounding boxes. By carefully choosing where and how to insert and split entries, it achieves much better performance for real-world spatial queries.</p>
<p>It is the default index in many modern spatial databases (like PostGIS and SQLite) because it handles dynamic insertions efficiently while keeping query times low.</p>
<section id="what-problem-are-we-solving-56" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-56">What Problem Are We Solving?</h4>
<p>In a standard R-tree, bounding boxes can overlap significantly. This causes search inefficiency, since a query region may need to explore multiple overlapping subtrees.</p>
<p>The R*-Tree solves this by refining two operations:</p>
<ol type="1">
<li>Insertion, tries to minimize both area and overlap increase.</li>
<li>Split, reorganizes entries to reduce future overlap.</li>
</ol>
<p>As a result, the tree maintains tighter bounding boxes and faster search times.</p>
</section>
<section id="how-it-works-plain-language-1" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-1">How It Works (Plain Language)</h4>
<p>R*-Tree adds a few enhancements on top of the regular R-tree algorithm:</p>
<ol type="1">
<li><p>ChooseSubtree</p>
<ul>
<li>Select the child whose bounding box requires the smallest <em>enlargement</em> to include the new entry.</li>
<li>If multiple choices exist, prefer the one with smaller <em>overlap area</em> and smaller <em>total area</em>.</li>
</ul></li>
<li><p>Forced Reinsert</p>
<ul>
<li>When a node overflows, instead of splitting immediately, remove a small fraction of entries (typically 30%), and reinsert them higher up in the tree.</li>
<li>This “shake-up” redistributes objects and improves spatial clustering.</li>
</ul></li>
<li><p>Split Optimization</p>
<ul>
<li>When splitting is inevitable, use heuristics to minimize overlap and perimeter rather than just area.</li>
</ul></li>
<li><p>Reinsertion Cascades</p>
<ul>
<li>Reinsertions can propagate upward, slightly increasing insert cost, but producing tighter and more balanced trees.</li>
</ul></li>
</ol>
</section>
<section id="example-2d-rectangles-1" class="level4">
<h4 class="anchored" data-anchor-id="example-2d-rectangles-1">Example (2D Rectangles)</h4>
<p>Suppose we are inserting a new rectangle <span class="math inline">\(R_{\text{new}}\)</span> into a node that already contains:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Rectangle</th>
<th>Area</th>
<th>Overlap with others</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>4</td>
<td>small</td>
</tr>
<tr class="even">
<td>B</td>
<td>6</td>
<td>large</td>
</tr>
<tr class="odd">
<td>C</td>
<td>5</td>
<td>moderate</td>
</tr>
</tbody>
</table>
<p>In a normal R-tree, we might choose A or B arbitrarily if enlargement is similar. In an R*-tree, we prefer the child that minimizes:</p>
<p><span class="math display">\[
\Delta \text{Overlap} + \Delta \text{Area}
\]</span></p>
<p>and if still tied, the one with smaller perimeter.</p>
<p>This yields spatially compact, low-overlap partitions.</p>
</section>
<section id="tiny-code-conceptual-pseudocode-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-conceptual-pseudocode-3">Tiny Code (Conceptual Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> choose_subtree(node, rect):</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="va">None</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    best_metric <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> child <span class="kw">in</span> node.children:</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>        enlargement <span class="op">=</span> area_enlargement(child.mbr, rect)</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>        overlap_increase <span class="op">=</span> overlap_delta(node.children, child, rect)</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>        metric <span class="op">=</span> (overlap_increase, enlargement, area(child.mbr))</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> metric <span class="op">&lt;</span> best_metric:</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>            best_metric <span class="op">=</span> metric</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> child</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> insert_rstar(node, rect, obj):</span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> node.is_leaf:</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>        node.entries.append((rect, obj))</span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(node.entries) <span class="op">&gt;</span> MAX_ENTRIES:</span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>            handle_overflow(node)</span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> choose_subtree(node, rect)</span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>        insert_rstar(child, rect, obj)</span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>        node.mbr <span class="op">=</span> recompute_mbr(node.entries)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-56" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-56">Why It Matters</h4>
<p>R*-Trees are used in nearly every spatial system where performance matters:</p>
<ul>
<li>Databases: PostgreSQL / PostGIS, SQLite, MySQL</li>
<li>GIS and mapping: real-time region and proximity queries</li>
<li>Computer graphics: visibility culling and collision detection</li>
<li>Simulation and robotics: spatial occupancy grids</li>
<li>Machine learning: range queries on embeddings or high-dimensional data</li>
</ul>
<p>They represent a balance between update cost and query speed that works well in both static and dynamic datasets.</p>
</section>
<section id="a-gentle-proof-why-it-works-43" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-43">A Gentle Proof (Why It Works)</h4>
<p>Let each node’s MBR be <span class="math inline">\(B_i\)</span> and the query region <span class="math inline">\(Q\)</span>. For every child node, overlap is defined as:</p>
<p><span class="math display">\[
\text{Overlap}(B_i, B_j) = \text{Area}(B_i \cap B_j)
\]</span></p>
<p>When inserting a new entry, R*-Tree tries to minimize:</p>
<p><span class="math display">\[
\Delta \text{Overlap} + \Delta \text{Area} + \lambda \times \Delta \text{Margin}
\]</span></p>
<p>for some small <span class="math inline">\(\lambda\)</span>. This heuristic empirically minimizes the expected number of nodes visited during a query.</p>
<p>Over time, the tree converges toward a balanced, low-overlap hierarchy, which is why it consistently outperforms the basic R-tree.</p>
</section>
<section id="try-it-yourself-56" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-56">Try It Yourself</h4>
<ol type="1">
<li>Insert rectangles into both an R-tree and an R*-tree.</li>
<li>Compare the bounding box overlap at each level.</li>
<li>Run a range query, count how many nodes each algorithm visits.</li>
<li>Visualize, R*-tree boxes will be more compact and disjoint.</li>
</ol>
</section>
<section id="test-cases-56" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-56">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Basic R-Tree</th>
<th>R*-Tree</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert 1000 rectangles</td>
<td>Overlap 60%</td>
<td>Overlap 20%</td>
<td>R*-Tree clusters better</td>
</tr>
<tr class="even">
<td>Query (region)</td>
<td>45 nodes visited</td>
<td>18 nodes visited</td>
<td>Faster search</td>
</tr>
<tr class="odd">
<td>Bulk load</td>
<td>Similar time</td>
<td>Slightly slower</td>
<td>But better structure</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-56" class="level4">
<h4 class="anchored" data-anchor-id="complexity-56">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Average</th>
<th>Worst Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Insert</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Space</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>The R*-Tree is the patient cartographer’s upgrade — it doesn’t just file shapes into drawers, it reorganizes them until every map edge lines up cleanly, so when you look for something, you find it fast and sure.</p>
</section>
</section>
<section id="quad-tree" class="level3">
<h3 class="anchored" data-anchor-id="quad-tree">757 Quad Tree</h3>
<p>The Quad Tree is a simple yet elegant spatial data structure used to recursively subdivide a two-dimensional space into four quadrants (or regions). It is ideal for indexing spatial data like images, terrains, game maps, and geometric objects that occupy distinct regions of the plane.</p>
<p>Unlike KD-trees that split by coordinate value, a Quad Tree splits space itself, not the data, dividing the plane into equal quadrants at each level.</p>
<section id="what-problem-are-we-solving-57" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-57">What Problem Are We Solving?</h4>
<p>We want a way to represent spatial occupancy or hierarchical subdivision efficiently for 2D data. Typical goals include:</p>
<ul>
<li>Storing and querying geometric data (points, rectangles, regions).</li>
<li>Supporting fast lookup: <em>“What’s in this area?”</em></li>
<li>Enabling hierarchical simplification or rendering (e.g., in computer graphics or GIS).</li>
</ul>
<p>Quad trees make it possible to store both sparse and dense regions efficiently by adapting their depth locally.</p>
</section>
<section id="how-it-works-plain-language-2" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-2">How It Works (Plain Language)</h4>
<p>Think of a large square region containing all your data.</p>
<ol type="1">
<li><p>Start with the root square (the whole region).</p></li>
<li><p>If the region contains more than a threshold number of points (say, 1 or 4), subdivide it into 4 equal quadrants:</p>
<ul>
<li>NW (north-west)</li>
<li>NE (north-east)</li>
<li>SW (south-west)</li>
<li>SE (south-east)</li>
</ul></li>
<li><p>Recursively repeat subdivision for each quadrant that still contains too many points.</p></li>
<li><p>Each leaf node then holds a small number of points or objects.</p></li>
</ol>
<p>This creates a tree whose structure mirrors the spatial distribution of data, deeper where it’s dense, shallower where it’s sparse.</p>
</section>
<section id="example-points-in-2d-space" class="level4">
<h4 class="anchored" data-anchor-id="example-points-in-2d-space">Example (Points in 2D Space)</h4>
<p>Suppose we have these 2D points in a 10×10 grid: <span class="math inline">\((1,1), (2,3), (8,2), (9,8), (4,6)\)</span></p>
<ul>
<li><p>The root square covers <span class="math inline">\((0,0)\)</span>–<span class="math inline">\((10,10)\)</span>.</p></li>
<li><p>It subdivides at midpoint <span class="math inline">\((5,5)\)</span>.</p>
<ul>
<li>NW: <span class="math inline">\((0,5)\)</span>–<span class="math inline">\((5,10)\)</span> → contains <span class="math inline">\((4,6)\)</span></li>
<li>NE: <span class="math inline">\((5,5)\)</span>–<span class="math inline">\((10,10)\)</span> → contains <span class="math inline">\((9,8)\)</span></li>
<li>SW: <span class="math inline">\((0,0)\)</span>–<span class="math inline">\((5,5)\)</span> → contains <span class="math inline">\((1,1), (2,3)\)</span></li>
<li>SE: <span class="math inline">\((5,0)\)</span>–<span class="math inline">\((10,5)\)</span> → contains <span class="math inline">\((8,2)\)</span></li>
</ul></li>
</ul>
<p>This hierarchical layout makes region queries intuitive and fast.</p>
</section>
<section id="tiny-code-python-example-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-13">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> QuadTree:</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, boundary, capacity<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.boundary <span class="op">=</span> boundary  <span class="co"># (x, y, w, h)</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.capacity <span class="op">=</span> capacity</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.points <span class="op">=</span> []</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.divided <span class="op">=</span> <span class="va">False</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, point):</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> point</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>        bx, by, w, h <span class="op">=</span> <span class="va">self</span>.boundary</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (bx <span class="op">&lt;=</span> x <span class="op">&lt;</span> bx <span class="op">+</span> w <span class="kw">and</span> by <span class="op">&lt;=</span> y <span class="op">&lt;</span> by <span class="op">+</span> h):</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span>  <span class="co"># out of bounds</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.points) <span class="op">&lt;</span> <span class="va">self</span>.capacity:</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.points.append(point)</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.divided:</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.subdivide()</span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">self</span>.nw.insert(point) <span class="kw">or</span> <span class="va">self</span>.ne.insert(point) <span class="kw">or</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.sw.insert(point) <span class="kw">or</span> <span class="va">self</span>.se.insert(point))</span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> subdivide(<span class="va">self</span>):</span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>        bx, by, w, h <span class="op">=</span> <span class="va">self</span>.boundary</span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>        hw, hh <span class="op">=</span> w <span class="op">/</span> <span class="dv">2</span>, h <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nw <span class="op">=</span> QuadTree((bx, by <span class="op">+</span> hh, hw, hh), <span class="va">self</span>.capacity)</span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ne <span class="op">=</span> QuadTree((bx <span class="op">+</span> hw, by <span class="op">+</span> hh, hw, hh), <span class="va">self</span>.capacity)</span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sw <span class="op">=</span> QuadTree((bx, by, hw, hh), <span class="va">self</span>.capacity)</span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.se <span class="op">=</span> QuadTree((bx <span class="op">+</span> hw, by, hw, hh), <span class="va">self</span>.capacity)</span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.divided <span class="op">=</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>qt <span class="op">=</span> QuadTree((<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>), <span class="dv">1</span>)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> [(<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">2</span>,<span class="dv">3</span>), (<span class="dv">8</span>,<span class="dv">2</span>), (<span class="dv">9</span>,<span class="dv">8</span>), (<span class="dv">4</span>,<span class="dv">6</span>)]:</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    qt.insert(p)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-57" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-57">Why It Matters</h4>
<p>Quad Trees are foundational in computer graphics, GIS, and robotics:</p>
<ul>
<li>Image processing: storing pixels or regions for compression and filtering.</li>
<li>Game engines: collision detection, visibility queries, terrain simplification.</li>
<li>Geographic data: hierarchical tiling for map rendering.</li>
<li>Robotics: occupancy grids for path planning.</li>
</ul>
<p>They adapt naturally to spatial density, storing more detail where needed.</p>
</section>
<section id="a-gentle-proof-why-it-works-44" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-44">A Gentle Proof (Why It Works)</h4>
<p>Let the dataset have <span class="math inline">\(n\)</span> points, with uniform distribution in a 2D region of area <span class="math inline">\(A\)</span>. Each subdivision reduces the area per node by a factor of 4, and the expected number of nodes is proportional to <span class="math inline">\(O(n)\)</span> if the distribution is not pathological.</p>
<p>For uniformly distributed points: <span class="math display">\[
\text{Height} \approx O(\log_4 n)
\]</span></p>
<p>And query cost for rectangular regions is: <span class="math display">\[
T(n) = O(\sqrt{n})
\]</span> in practice, since only relevant quadrants are visited.</p>
<p>The adaptive depth ensures that dense clusters are represented compactly, while sparse areas remain shallow.</p>
</section>
<section id="try-it-yourself-57" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-57">Try It Yourself</h4>
<ol type="1">
<li>Insert 20 random points into a Quad Tree and draw it (each subdivision as a smaller square).</li>
<li>Perform a query: “All points in rectangle (3,3)-(9,9)” and count nodes visited.</li>
<li>Compare with a brute-force scan.</li>
<li>Try reducing capacity to 1 or 2, see how the structure deepens.</li>
</ol>
</section>
<section id="test-cases-57" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-57">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query Rectangle</th>
<th>Expected Points</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0)-(5,5)</td>
<td>(1,1), (2,3)</td>
<td>Lower-left quadrant</td>
</tr>
<tr class="even">
<td>(5,0)-(10,5)</td>
<td>(8,2)</td>
<td>Lower-right quadrant</td>
</tr>
<tr class="odd">
<td>(5,5)-(10,10)</td>
<td>(9,8)</td>
<td>Upper-right quadrant</td>
</tr>
<tr class="even">
<td>(0,5)-(5,10)</td>
<td>(4,6)</td>
<td>Upper-left quadrant</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-57" class="level4">
<h4 class="anchored" data-anchor-id="complexity-57">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Average</th>
<th>Worst Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Search (region)</td>
<td><span class="math inline">\(O(\sqrt{n})\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Space</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>The Quad Tree is like a painter’s grid — it divides the world just enough to notice where color changes, keeping the canvas both detailed and simple to navigate.</p>
</section>
</section>
<section id="octree" class="level3">
<h3 class="anchored" data-anchor-id="octree">758 Octree</h3>
<p>The Octree is the 3D extension of the Quad Tree. Instead of dividing space into four quadrants, it divides a cube into eight octants, recursively. This simple idea scales beautifully from 2D maps to 3D worlds, perfect for graphics, physics, and spatial simulations.</p>
<p>Where a Quad Tree helps us reason about pixels and tiles, an Octree helps us reason about voxels, volumes, and objects in 3D.</p>
<section id="what-problem-are-we-solving-58" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-58">What Problem Are We Solving?</h4>
<p>We need a data structure to represent and query 3D spatial information efficiently.</p>
<p>Typical goals:</p>
<ul>
<li>Store and locate 3D points, meshes, or objects.</li>
<li>Perform collision detection or visibility culling.</li>
<li>Represent volumetric data (e.g., 3D scans, densities, occupancy grids).</li>
<li>Speed up ray tracing or rendering by hierarchical pruning.</li>
</ul>
<p>An Octree balances detail and efficiency, dividing dense regions finely while keeping sparse areas coarse.</p>
</section>
<section id="how-it-works-plain-language-3" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-3">How It Works (Plain Language)</h4>
<p>An Octree divides space recursively:</p>
<ol type="1">
<li><p>Start with a cube containing all data points or objects.</p></li>
<li><p>If a cube contains more than a threshold number of items (e.g., 4), subdivide it into 8 equal sub-cubes (octants).</p></li>
<li><p>Each node stores pointers to its children, which cover:</p>
<ul>
<li>Front-Top-Left (FTL)</li>
<li>Front-Top-Right (FTR)</li>
<li>Front-Bottom-Left (FBL)</li>
<li>Front-Bottom-Right (FBR)</li>
<li>Back-Top-Left (BTL)</li>
<li>Back-Top-Right (BTR)</li>
<li>Back-Bottom-Left (BBL)</li>
<li>Back-Bottom-Right (BBR)</li>
</ul></li>
<li><p>Recursively subdivide until each leaf cube contains few enough objects.</p></li>
</ol>
<p>This recursive space partition forms a hierarchical map of 3D space.</p>
</section>
<section id="example-points-in-3d-space" class="level4">
<h4 class="anchored" data-anchor-id="example-points-in-3d-space">Example (Points in 3D Space)</h4>
<p>Imagine these 3D points (in a cube from (0,0,0) to (8,8,8)): <span class="math inline">\((1,2,3), (7,6,1), (3,5,4), (6,7,7), (2,1,2)\)</span></p>
<p>The first subdivision occurs at the cube’s center <span class="math inline">\((4,4,4)\)</span>. Each child cube covers one of eight octants:</p>
<ul>
<li><span class="math inline">\((0,0,0)-(4,4,4)\)</span> → contains <span class="math inline">\((1,2,3), (2,1,2)\)</span></li>
<li><span class="math inline">\((4,0,0)-(8,4,4)\)</span> → contains <span class="math inline">\((7,6,1)\)</span> (later excluded due to y&gt;4)</li>
<li><span class="math inline">\((0,4,4)-(4,8,8)\)</span> → contains <span class="math inline">\((3,5,4)\)</span></li>
<li><span class="math inline">\((4,4,4)-(8,8,8)\)</span> → contains <span class="math inline">\((6,7,7)\)</span></li>
</ul>
<p>Each sub-cube subdivides only if needed, creating a locally adaptive representation.</p>
</section>
<section id="tiny-code-python-example-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-14">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Octree:</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, boundary, capacity<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.boundary <span class="op">=</span> boundary  <span class="co"># (x, y, z, size)</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.capacity <span class="op">=</span> capacity</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.points <span class="op">=</span> []</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> <span class="va">None</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, point):</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>        x, y, z <span class="op">=</span> point</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>        bx, by, bz, s <span class="op">=</span> <span class="va">self</span>.boundary</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (bx <span class="op">&lt;=</span> x <span class="op">&lt;</span> bx <span class="op">+</span> s <span class="kw">and</span> by <span class="op">&lt;=</span> y <span class="op">&lt;</span> by <span class="op">+</span> s <span class="kw">and</span> bz <span class="op">&lt;=</span> z <span class="op">&lt;</span> bz <span class="op">+</span> s):</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span>  <span class="co"># point out of bounds</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.points) <span class="op">&lt;</span> <span class="va">self</span>.capacity:</span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.points.append(point)</span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.children <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.subdivide()</span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children:</span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> child.insert(point):</span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> subdivide(<span class="va">self</span>):</span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a>        bx, by, bz, s <span class="op">=</span> <span class="va">self</span>.boundary</span>
<span id="cb84-28"><a href="#cb84-28" aria-hidden="true" tabindex="-1"></a>        hs <span class="op">=</span> s <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb84-29"><a href="#cb84-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb84-30"><a href="#cb84-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx <span class="kw">in</span> [<span class="dv">0</span>, hs]:</span>
<span id="cb84-31"><a href="#cb84-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> dy <span class="kw">in</span> [<span class="dv">0</span>, hs]:</span>
<span id="cb84-32"><a href="#cb84-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> dz <span class="kw">in</span> [<span class="dv">0</span>, hs]:</span>
<span id="cb84-33"><a href="#cb84-33" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.children.append(Octree((bx <span class="op">+</span> dx, by <span class="op">+</span> dy, bz <span class="op">+</span> dz, hs), <span class="va">self</span>.capacity))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-58" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-58">Why It Matters</h4>
<p>Octrees are a cornerstone of modern 3D computation:</p>
<ul>
<li>Computer graphics: view frustum culling, shadow mapping, ray tracing.</li>
<li>Physics engines: broad-phase collision detection.</li>
<li>3D reconstruction: storing voxelized scenes (e.g., Kinect, LiDAR).</li>
<li>GIS and simulations: volumetric data and spatial queries.</li>
<li>Robotics: occupancy mapping in 3D environments.</li>
</ul>
<p>Because Octrees adapt to data density, they dramatically reduce memory and query time in 3D problems.</p>
</section>
<section id="a-gentle-proof-why-it-works-45" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-45">A Gentle Proof (Why It Works)</h4>
<p>At each level, the cube divides into <span class="math inline">\(8\)</span> smaller cubes. If a region is uniformly filled, the height of the tree is:</p>
<p><span class="math display">\[
h = O(\log_8 n) = O(\log n)
\]</span></p>
<p>Each query visits only the cubes that overlap the query region. Thus, the expected query time is sublinear:</p>
<p><span class="math display">\[
T_{\text{query}} = O(n^{2/3})
\]</span></p>
<p>For sparse data, the number of active nodes is much smaller than <span class="math inline">\(n\)</span>, so in practice both insert and query run near <span class="math inline">\(O(\log n)\)</span>.</p>
</section>
<section id="try-it-yourself-58" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-58">Try It Yourself</h4>
<ol type="1">
<li>Insert random 3D points in a cube <span class="math inline">\((0,0,0)\)</span>–<span class="math inline">\((8,8,8)\)</span>.</li>
<li>Draw a recursive cube diagram showing which regions subdivide.</li>
<li>Query: “Which points lie within <span class="math inline">\((2,2,2)\)</span>–<span class="math inline">\((6,6,6)\)</span>?”</li>
<li>Compare with brute-force search.</li>
</ol>
</section>
<section id="test-cases-58" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-58">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query Cube</th>
<th>Expected Points</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0,0)-(4,4,4)</td>
<td>(1,2,3), (2,1,2)</td>
<td>Lower octant</td>
</tr>
<tr class="even">
<td>(4,4,4)-(8,8,8)</td>
<td>(6,7,7)</td>
<td>Upper far octant</td>
</tr>
<tr class="odd">
<td>(2,4,4)-(4,8,8)</td>
<td>(3,5,4)</td>
<td>Upper near octant</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-58" class="level4">
<h4 class="anchored" data-anchor-id="complexity-58">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Average</th>
<th>Worst Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Search (region)</td>
<td><span class="math inline">\(O(n^{2/3})\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Space</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>The Octree is the quiet architect of 3D space — it builds invisible scaffolds inside volume and light, where each cube knows just enough of its world to keep everything fast, clean, and infinite.</p>
</section>
</section>
<section id="bsp-tree-binary-space-partition-tree" class="level3">
<h3 class="anchored" data-anchor-id="bsp-tree-binary-space-partition-tree">759 BSP Tree (Binary Space Partition Tree)</h3>
<p>A BSP Tree, or <em>Binary Space Partitioning Tree</em>, is a data structure for recursively subdividing space using planes. While quadtrees and octrees divide space into fixed quadrants or cubes, BSP trees divide it by arbitrary hyperplanes, making them incredibly flexible for geometry, visibility, and rendering.</p>
<p>This structure was a major breakthrough in computer graphics and computational geometry, used in early 3D engines like <em>DOOM</em> and still powering CAD, physics, and spatial reasoning systems today.</p>
<section id="what-problem-are-we-solving-59" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-59">What Problem Are We Solving?</h4>
<p>We need a general, efficient way to:</p>
<ul>
<li>Represent and query complex 2D or 3D scenes.</li>
<li>Determine visibility (what surfaces are seen first).</li>
<li>Perform collision detection, ray tracing, or CSG (constructive solid geometry).</li>
</ul>
<p>Unlike quadtrees or octrees that assume axis-aligned splits, a BSP tree can partition space by any plane, perfectly fitting complex geometry.</p>
</section>
<section id="how-it-works-plain-language-4" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-4">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Start with a set of geometric primitives (lines, polygons, or polyhedra).</p></li>
<li><p>Pick one as the splitting plane.</p></li>
<li><p>Divide all other objects into two sets:</p>
<ul>
<li>Front set: those lying in front of the plane.</li>
<li>Back set: those behind the plane.</li>
</ul></li>
<li><p>Recursively partition each side with new planes until each region contains a small number of primitives.</p></li>
</ol>
<p>The result is a binary tree:</p>
<ul>
<li>Each internal node represents a splitting plane.</li>
<li>Each leaf node represents a convex subspace (a region of space fully divided).</li>
</ul>
</section>
<section id="example-2d-illustration" class="level4">
<h4 class="anchored" data-anchor-id="example-2d-illustration">Example (2D Illustration)</h4>
<p>Imagine you have three lines dividing a 2D plane:</p>
<ul>
<li>Line A: vertical</li>
<li>Line B: diagonal</li>
<li>Line C: horizontal</li>
</ul>
<p>Each line divides space into two half-planes. After all splits, you end up with convex regions (non-overlapping cells).</p>
<p>Each region corresponds to a leaf in the BSP tree, and traversing the tree in front-to-back order gives a correct painter’s algorithm rendering — drawing closer surfaces over farther ones.</p>
</section>
<section id="step-by-step-summary" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-summary">Step-by-Step Summary</h4>
<ol type="1">
<li><p>Choose a splitting polygon or plane (e.g., one from your object list).</p></li>
<li><p>Classify every other object as in front, behind, or intersecting the plane.</p>
<ul>
<li>If it intersects, split it along the plane.</li>
</ul></li>
<li><p>Recursively build the tree for front and back sets.</p></li>
<li><p>For visibility or ray tracing, traverse nodes in order depending on the viewer position relative to the plane.</p></li>
</ol>
</section>
<section id="tiny-code-simplified-python-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-python-pseudocode">Tiny Code (Simplified Python Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BSPNode:</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, plane, front<span class="op">=</span><span class="va">None</span>, back<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.plane <span class="op">=</span> plane</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.front <span class="op">=</span> front</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.back <span class="op">=</span> back</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_bsp(objects):</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> objects:</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    plane <span class="op">=</span> objects[<span class="dv">0</span>]  <span class="co"># pick splitting plane</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    front, back <span class="op">=</span> [], []</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> obj <span class="kw">in</span> objects[<span class="dv">1</span>:]:</span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>        side <span class="op">=</span> classify(obj, plane)</span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> side <span class="op">==</span> <span class="st">'front'</span>:</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>            front.append(obj)</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> side <span class="op">==</span> <span class="st">'back'</span>:</span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>            back.append(obj)</span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># intersecting</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>            f_part, b_part <span class="op">=</span> split(obj, plane)</span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>            front.append(f_part)</span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a>            back.append(b_part)</span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> BSPNode(plane, build_bsp(front), build_bsp(back))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>classify</code> determines which side of the plane an object lies on, and <code>split</code> divides intersecting objects along that plane.</p>
</section>
<section id="why-it-matters-59" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-59">Why It Matters</h4>
<p>BSP Trees are essential in:</p>
<ul>
<li>3D rendering engines, sorting polygons for the painter’s algorithm.</li>
<li>Game development, efficient visibility and collision queries.</li>
<li>Computational geometry, point-in-polygon and ray intersection tests.</li>
<li>CSG modeling, combining solids with boolean operations (union, intersection, difference).</li>
<li>Robotics and simulation, representing free and occupied 3D space.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-46" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-46">A Gentle Proof (Why It Works)</h4>
<p>Every splitting plane divides space into two convex subsets. Since convex regions never overlap, each point in space belongs to exactly one leaf.</p>
<p>For <span class="math inline">\(n\)</span> splitting planes, the number of convex regions formed is <span class="math inline">\(O(n^2)\)</span> in 2D and <span class="math inline">\(O(n^3)\)</span> in 3D, but queries can be answered in logarithmic time on average by traversing only relevant branches.</p>
<p>Mathematically, if <span class="math inline">\(Q\)</span> is the query point and <span class="math inline">\(P_i\)</span> are the planes, then each comparison <span class="math display">\[
\text{sign}(a_i x + b_i y + c_i z + d_i)
\]</span> guides traversal, producing a deterministic, spatially consistent partition.</p>
</section>
<section id="try-it-yourself-59" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-59">Try It Yourself</h4>
<ol type="1">
<li>Draw 3 polygons and use each as a splitting plane.</li>
<li>Color the resulting regions after each split.</li>
<li>Store them in a BSP tree (front and back).</li>
<li>Render polygons back-to-front from a given viewpoint, you’ll notice no depth sorting errors.</li>
</ol>
</section>
<section id="test-cases-59" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-59">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 9%">
<col style="width: 11%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>Scene</th>
<th>Planes</th>
<th>Regions</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple room</td>
<td>3</td>
<td>8</td>
<td>Visibility ordering</td>
</tr>
<tr class="even">
<td>Indoor map</td>
<td>20</td>
<td>200+</td>
<td>Collision and rendering</td>
</tr>
<tr class="odd">
<td>CSG model (cube ∩ sphere)</td>
<td>6</td>
<td>50+</td>
<td>Boolean modeling</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-59" class="level4">
<h4 class="anchored" data-anchor-id="complexity-59">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Average</th>
<th>Worst Case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="even">
<td>Query</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Space</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
</tbody>
</table>
<p>The BSP Tree is the geometric philosopher’s tool — it slices the world with planes of thought, sorting front from back, visible from hidden, until every region is clear, and nothing overlaps in confusion.</p>
</section>
</section>
<section id="morton-order-z-curve" class="level3">
<h3 class="anchored" data-anchor-id="morton-order-z-curve">760 Morton Order (Z-Curve)</h3>
<p>The Morton Order, also known as the Z-Order Curve, is a clever way to map multidimensional data (2D, 3D, etc.) into one dimension while preserving spatial locality. It’s not a tree by itself, but it underpins many spatial data structures, including quadtrees, octrees, and R-trees, because it allows hierarchical indexing without explicitly storing the tree.</p>
<p>It’s called “Z-order” because when visualized, the traversal path of the curve looks like a repeating Z pattern across space.</p>
<section id="what-problem-are-we-solving-60" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-60">What Problem Are We Solving?</h4>
<p>We want a way to linearize spatial data so that nearby points in space remain nearby in sorted order. That’s useful for:</p>
<ul>
<li>Sorting and indexing spatial data efficiently.</li>
<li>Bulk-loading spatial trees like R-trees or B-trees.</li>
<li>Improving cache locality and disk access in databases.</li>
<li>Building memory-efficient hierarchical structures.</li>
</ul>
<p>Morton order provides a compact and computationally cheap way to do this by using bit interleaving.</p>
</section>
<section id="how-it-works-plain-language-5" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-5">How It Works (Plain Language)</h4>
<p>Take two or three coordinates, for example, <span class="math inline">\((x, y)\)</span> in 2D or <span class="math inline">\((x, y, z)\)</span> in 3D — and interleave their bits to create a single Morton code (integer).</p>
<p>For 2D:</p>
<ol type="1">
<li>Convert <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> to binary. Example: <span class="math inline">\(x = 5 = (101)_2\)</span>, <span class="math inline">\(y = 3 = (011)_2\)</span>.</li>
<li>Interleave bits: take one bit from <span class="math inline">\(x\)</span>, one from <span class="math inline">\(y\)</span>, alternating: <span class="math inline">\(x_2 y_2 x_1 y_1 x_0 y_0\)</span>.</li>
<li>The result <span class="math inline">\((100111)_2 = 39\)</span> is the Morton code for <span class="math inline">\((5, 3)\)</span>.</li>
</ol>
<p>This number represents the Z-order position of the point.</p>
<p>When you sort points by Morton code, nearby coordinates tend to stay near each other in the sorted order — so 2D or 3D proximity translates roughly into 1D proximity.</p>
</section>
<section id="example-2d-visualization" class="level4">
<h4 class="anchored" data-anchor-id="example-2d-visualization">Example (2D Visualization)</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Point <span class="math inline">\((x, y)\)</span></th>
<th>Binary <span class="math inline">\((x, y)\)</span></th>
<th>Morton Code</th>
<th>Order</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0, 0)</td>
<td>(000, 000)</td>
<td>000000</td>
<td>0</td>
</tr>
<tr class="even">
<td>(1, 0)</td>
<td>(001, 000)</td>
<td>000001</td>
<td>1</td>
</tr>
<tr class="odd">
<td>(0, 1)</td>
<td>(000, 001)</td>
<td>000010</td>
<td>2</td>
</tr>
<tr class="even">
<td>(1, 1)</td>
<td>(001, 001)</td>
<td>000011</td>
<td>3</td>
</tr>
<tr class="odd">
<td>(2, 2)</td>
<td>(010, 010)</td>
<td>001100</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>Plotting these in 2D gives the characteristic “Z” shape, recursively repeated at each scale.</p>
</section>
<section id="tiny-code-python-example-15" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-15">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interleave_bits(x, y):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">32</span>):  <span class="co"># assuming 32-bit coordinates</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>        z <span class="op">|=</span> ((x <span class="op">&gt;&gt;</span> i) <span class="op">&amp;</span> <span class="dv">1</span>) <span class="op">&lt;&lt;</span> (<span class="dv">2</span> <span class="op">*</span> i)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>        z <span class="op">|=</span> ((y <span class="op">&gt;&gt;</span> i) <span class="op">&amp;</span> <span class="dv">1</span>) <span class="op">&lt;&lt;</span> (<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> morton_2d(points):</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(points, key<span class="op">=</span><span class="kw">lambda</span> p: interleave_bits(p[<span class="dv">0</span>], p[<span class="dv">1</span>]))</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">0</span>,<span class="dv">0</span>)]</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(morton_2d(points))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This produces the Z-order traversal of the points.</p>
</section>
<section id="why-it-matters-60" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-60">Why It Matters</h4>
<p>Morton order bridges geometry and data systems:</p>
<ul>
<li>Databases: Used for bulk-loading R-trees (called <em>packed R-trees</em>).</li>
<li>Graphics: Texture mipmapping and spatial sampling.</li>
<li>Parallel computing: Block decomposition of grids (spatial cache efficiency).</li>
<li>Numerical simulation: Adaptive mesh refinement indexing.</li>
<li>Vector databases: Fast approximate nearest neighbor grouping.</li>
</ul>
<p>Because it preserves <em>spatial locality</em> and supports <em>bitwise computation</em>, it’s much faster than sorting by Euclidean distance or using complex data structures for initial indexing.</p>
</section>
<section id="a-gentle-proof-why-it-works-47" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-47">A Gentle Proof (Why It Works)</h4>
<p>The Z-curve recursively subdivides space into quadrants (in 2D) or octants (in 3D), visiting them in a depth-first order. At each recursion level, the most significant interleaved bits determine which quadrant or octant a point belongs to.</p>
<p>For a 2D point <span class="math inline">\((x, y)\)</span>:</p>
<p><span class="math display">\[
M(x, y) = \sum_{i=0}^{b-1} \left[ (x_i \cdot 2^{2i}) + (y_i \cdot 2^{2i+1}) \right]
\]</span></p>
<p>where <span class="math inline">\(x_i, y_i\)</span> are the bits of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>This mapping preserves hierarchical proximity: if two points share their first <span class="math inline">\(k\)</span> bits in interleaved form, they lie within the same <span class="math inline">\(2^{-k}\)</span>-sized region of space.</p>
</section>
<section id="try-it-yourself-60" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-60">Try It Yourself</h4>
<ol type="1">
<li>Write down binary coordinates for 8 points <span class="math inline">\((x, y)\)</span> in a 4×4 grid.</li>
<li>Interleave their bits to get Morton codes.</li>
<li>Sort by the codes, then plot points to see the “Z” pattern.</li>
<li>Observe that nearby points share many leading bits in their codes.</li>
</ol>
</section>
<section id="test-cases-60" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-60">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\((x, y)\)</span></th>
<th>Morton Code</th>
<th>Binary</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0, 0)</td>
<td>0</td>
<td>0000</td>
<td>Start</td>
</tr>
<tr class="even">
<td>(1, 0)</td>
<td>1</td>
<td>0001</td>
<td>Right</td>
</tr>
<tr class="odd">
<td>(0, 1)</td>
<td>2</td>
<td>0010</td>
<td>Up</td>
</tr>
<tr class="even">
<td>(1, 1)</td>
<td>3</td>
<td>0011</td>
<td>Upper-right</td>
</tr>
<tr class="odd">
<td>(2, 0)</td>
<td>4</td>
<td>0100</td>
<td>Next quadrant</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-60" class="level4">
<h4 class="anchored" data-anchor-id="complexity-60">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding (2D)</td>
<td><span class="math inline">\(O(b)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Sorting</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Query locality</td>
<td><span class="math inline">\(O(1)\)</span> (approximate)</td>
<td>,</td>
</tr>
</tbody>
</table>
<p>The Morton Order (Z-Curve) is the mathematician’s compass — it traces a single line that dances through every cell of a grid, folding multidimensional worlds into a one-dimensional thread, without forgetting who’s close to whom.</p>
</section>
</section>
</section>
<section id="section-77.-rasterization-and-scanline-techniques" class="level1">
<h1>Section 77. Rasterization and Scanline Techniques</h1>
<section id="bresenhams-line-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="bresenhams-line-algorithm">761 Bresenham’s Line Algorithm</h3>
<p>The Bresenham’s Line Algorithm is a foundational algorithm in computer graphics that draws a straight line between two points using only integer arithmetic. It avoids floating-point operations, making it both fast and precise, perfect for raster displays, pixel art, and embedded systems.</p>
<p>Invented by Jack Bresenham in 1962 for early IBM plotters, it remains one of the most elegant examples of turning continuous geometry into discrete computation.</p>
<section id="what-problem-are-we-solving-61" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-61">What Problem Are We Solving?</h4>
<p>We want to draw a straight line from <span class="math inline">\((x_0, y_0)\)</span> to <span class="math inline">\((x_1, y_1)\)</span> on a pixel grid. But computers can only light up discrete pixels, not continuous values.</p>
<p>A naïve approach would compute <span class="math inline">\(y = m x + c\)</span> and round each result, but that uses slow floating-point arithmetic and accumulates rounding errors.</p>
<p>Bresenham’s algorithm solves this by using incremental integer updates and a decision variable to choose which pixel to light next.</p>
</section>
<section id="how-it-works-plain-language-6" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-6">How It Works (Plain Language)</h4>
<p>Imagine walking from one end of the line to the other, pixel by pixel. At each step, you decide:</p>
<blockquote class="blockquote">
<p>“Should I go straight east, or northeast?”</p>
</blockquote>
<p>That decision depends on how far the true line is from the midpoint between these two candidate pixels.</p>
<p>Bresenham uses a decision parameter <span class="math inline">\(d\)</span> that tracks the difference between the ideal line and the rasterized path.</p>
<p>For a line with slope <span class="math inline">\(0 \le m \le 1\)</span>, the algorithm works like this:</p>
<ol type="1">
<li><p>Start at <span class="math inline">\((x_0, y_0)\)</span></p></li>
<li><p>Compute the deltas: <span class="math display">\[
\Delta x = x_1 - x_0, \quad \Delta y = y_1 - y_0
\]</span></p></li>
<li><p>Initialize the decision parameter: <span class="math display">\[
d = 2\Delta y - \Delta x
\]</span></p></li>
<li><p>For each <span class="math inline">\(x\)</span> from <span class="math inline">\(x_0\)</span> to <span class="math inline">\(x_1\)</span>:</p>
<ul>
<li>Plot <span class="math inline">\((x, y)\)</span></li>
<li>If <span class="math inline">\(d &gt; 0\)</span>, increment <span class="math inline">\(y\)</span> and update <span class="math display">\[
d = d + 2(\Delta y - \Delta x)
\]</span></li>
<li>Else, update <span class="math display">\[
d = d + 2\Delta y
\]</span></li>
</ul></li>
</ol>
<p>This process traces the line using only additions and subtractions.</p>
</section>
<section id="example-2" class="level4">
<h4 class="anchored" data-anchor-id="example-2">Example</h4>
<p>Let’s draw a line from <span class="math inline">\((2, 2)\)</span> to <span class="math inline">\((8, 5)\)</span>.</p>
<p><span class="math display">\[
\Delta x = 6, \quad \Delta y = 3
\]</span> Initial <span class="math inline">\(d = 2\Delta y - \Delta x = 0\)</span>.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>(x, y)</th>
<th>d</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>(2, 2)</td>
<td>0</td>
<td>Plot</td>
</tr>
<tr class="even">
<td>2</td>
<td>(3, 2)</td>
<td>+6</td>
<td><span class="math inline">\(d&gt;0\)</span>, increment y → (3,3)</td>
</tr>
<tr class="odd">
<td>3</td>
<td>(4, 3)</td>
<td>-6</td>
<td><span class="math inline">\(d&lt;0\)</span>, stay</td>
</tr>
<tr class="even">
<td>4</td>
<td>(5, 3)</td>
<td>+6</td>
<td>increment y → (5,4)</td>
</tr>
<tr class="odd">
<td>5</td>
<td>(6, 4)</td>
<td>-6</td>
<td>stay</td>
</tr>
<tr class="even">
<td>6</td>
<td>(7, 4)</td>
<td>+6</td>
<td>increment y → (7,5)</td>
</tr>
<tr class="odd">
<td>7</td>
<td>(8, 5)</td>
<td>,</td>
<td>done</td>
</tr>
</tbody>
</table>
<p>Line drawn: (2,2), (3,3), (4,3), (5,4), (6,4), (7,5), (8,5).</p>
</section>
<section id="tiny-code-c-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb87"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bresenham_line<span class="op">(</span><span class="dt">int</span> x0<span class="op">,</span> <span class="dt">int</span> y0<span class="op">,</span> <span class="dt">int</span> x1<span class="op">,</span> <span class="dt">int</span> y1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dx <span class="op">=</span> abs<span class="op">(</span>x1 <span class="op">-</span> x0<span class="op">);</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dy <span class="op">=</span> abs<span class="op">(</span>y1 <span class="op">-</span> y0<span class="op">);</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sx <span class="op">=</span> <span class="op">(</span>x0 <span class="op">&lt;</span> x1<span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sy <span class="op">=</span> <span class="op">(</span>y0 <span class="op">&lt;</span> y1<span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> err <span class="op">=</span> dx <span class="op">-</span> dy<span class="op">;</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> x0<span class="op">,</span> y0<span class="op">);</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x0 <span class="op">==</span> x1 <span class="op">&amp;&amp;</span> y0 <span class="op">==</span> y1<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> e2 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> err<span class="op">;</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e2 <span class="op">&gt;</span> <span class="op">-</span>dy<span class="op">)</span> <span class="op">{</span> err <span class="op">-=</span> dy<span class="op">;</span> x0 <span class="op">+=</span> sx<span class="op">;</span> <span class="op">}</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e2 <span class="op">&lt;</span> dx<span class="op">)</span>  <span class="op">{</span> err <span class="op">+=</span> dx<span class="op">;</span> y0 <span class="op">+=</span> sy<span class="op">;</span> <span class="op">}</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This version handles all slopes and directions symmetrically.</p>
</section>
<section id="why-it-matters-61" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-61">Why It Matters</h4>
<p>Bresenham’s algorithm is one of the earliest and most influential rasterization methods. It’s still used today in:</p>
<ul>
<li>2D and 3D graphics renderers</li>
<li>CAD software</li>
<li>Printer drivers and plotters</li>
<li>Microcontrollers and display systems</li>
<li>Teaching integer arithmetic and geometry in computer science</li>
</ul>
<p>It’s not just an algorithm, it’s a bridge between geometry and computation.</p>
</section>
<section id="a-gentle-proof-why-it-works-48" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-48">A Gentle Proof (Why It Works)</h4>
<p>The true line equation is <span class="math inline">\(y = m x + b\)</span>, where <span class="math inline">\(m = \frac{\Delta y}{\Delta x}\)</span>. The midpoint between two candidate pixels differs from the true line by an error <span class="math inline">\(\varepsilon\)</span>. Bresenham tracks a scaled version of this error as <span class="math inline">\(d\)</span>, doubling it to avoid fractions:</p>
<p><span class="math display">\[
d = 2(\Delta y x - \Delta x y + C)
\]</span></p>
<p>When <span class="math inline">\(d &gt; 0\)</span>, the midpoint lies below the true line, so we step diagonally. When <span class="math inline">\(d &lt; 0\)</span>, it lies above, so we step horizontally. Because updates are constant-time integer additions, accuracy and efficiency are guaranteed.</p>
</section>
<section id="try-it-yourself-61" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-61">Try It Yourself</h4>
<ol type="1">
<li>Draw a line between <span class="math inline">\((0, 0)\)</span> and <span class="math inline">\((10, 6)\)</span> on grid paper.</li>
<li>Apply the update rules manually, you’ll see the same pattern emerge.</li>
<li>Modify the algorithm for steep slopes (<span class="math inline">\(m &gt; 1\)</span>) by swapping roles of x and y.</li>
<li>Visualize how the decision variable controls vertical steps.</li>
</ol>
</section>
<section id="test-cases-61" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-61">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>Slope</th>
<th>Pixels Drawn</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0)-(5,2)</td>
<td>0.4</td>
<td>Gentle line</td>
</tr>
<tr class="even">
<td>(0,0)-(2,5)</td>
<td>&gt;1</td>
<td>Swap roles</td>
</tr>
<tr class="odd">
<td>(2,2)-(8,5)</td>
<td>0.5</td>
<td>Classic test</td>
</tr>
<tr class="even">
<td>(5,5)-(0,0)</td>
<td>-1</td>
<td>Reverse direction</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-61" class="level4">
<h4 class="anchored" data-anchor-id="complexity-61">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Draw Line</td>
<td><span class="math inline">\(O(\Delta x + \Delta y)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The Bresenham Line Algorithm is the poet’s ruler of the pixel world — it draws with precision, one integer at a time, turning algebra into art on the digital canvas.</p>
</section>
</section>
<section id="midpoint-circle-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="midpoint-circle-algorithm">762 Midpoint Circle Algorithm</h3>
<p>The Midpoint Circle Algorithm is the circular counterpart of Bresenham’s line algorithm. It draws a perfect circle using only integer arithmetic, no trigonometry, no floating-point computation, by exploiting the circle’s symmetry and a clever midpoint decision rule.</p>
<p>This algorithm is the heart of classic raster graphics, driving everything from retro games to low-level graphics libraries and display drivers.</p>
<section id="what-problem-are-we-solving-62" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-62">What Problem Are We Solving?</h4>
<p>We want to draw a circle centered at <span class="math inline">\((x_c, y_c)\)</span> with radius <span class="math inline">\(r\)</span> on a discrete pixel grid. The equation of the circle is:</p>
<p><span class="math display">\[
x^2 + y^2 = r^2
\]</span></p>
<p>Naïvely, we could compute each <span class="math inline">\(y\)</span> from <span class="math inline">\(x\)</span> using the formula <span class="math inline">\(y = \sqrt{r^2 - x^2}\)</span>, but that requires slow square roots and floating-point arithmetic.</p>
<p>The Midpoint Circle Algorithm eliminates these with an incremental, integer-based approach.</p>
</section>
<section id="how-it-works-plain-language-7" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-7">How It Works (Plain Language)</h4>
<ol type="1">
<li>Start at the topmost point <span class="math inline">\((0, r)\)</span>.</li>
<li>Move outward along x and decide at each step whether to move south or south-east, depending on which pixel’s center is closer to the true circle.</li>
<li>Use the circle’s symmetry to draw eight points per iteration — one in each octant around the circle.</li>
</ol>
<p>The algorithm relies on a decision variable <span class="math inline">\(d\)</span> that measures how far the midpoint lies from the circle boundary.</p>
</section>
<section id="step-by-step-formulation" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-formulation">Step-by-Step Formulation</h4>
<p>At each step, we evaluate the circle function:</p>
<p><span class="math display">\[
f(x, y) = x^2 + y^2 - r^2
\]</span></p>
<p>We want to know whether the midpoint between candidate pixels is inside or outside the circle. The decision parameter is updated incrementally as we move.</p>
<ol type="1">
<li><p>Initialize: <span class="math display">\[
x = 0, \quad y = r
\]</span> <span class="math display">\[
d = 1 - r
\]</span></p></li>
<li><p>Repeat until <span class="math inline">\(x &gt; y\)</span>:</p>
<ul>
<li>Plot the eight symmetric points: <span class="math inline">\((\pm x + x_c, \pm y + y_c)\)</span> and <span class="math inline">\((\pm y + x_c, \pm x + y_c)\)</span></li>
<li>If <span class="math inline">\(d &lt; 0\)</span>, choose East (E) pixel and update <span class="math display">\[
d = d + 2x + 3
\]</span></li>
<li>Else, choose South-East (SE) pixel and update <span class="math display">\[
d = d + 2(x - y) + 5, \quad y = y - 1
\]</span></li>
<li>In both cases, increment <span class="math inline">\(x = x + 1\)</span></li>
</ul></li>
</ol>
</section>
<section id="example-3" class="level4">
<h4 class="anchored" data-anchor-id="example-3">Example</h4>
<p>Circle center <span class="math inline">\((0, 0)\)</span>, radius <span class="math inline">\(r = 5\)</span>.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>(x, y)</th>
<th>d</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>(0, 5)</td>
<td>-4</td>
<td>E → (1, 5)</td>
</tr>
<tr class="even">
<td>1</td>
<td>(1, 5)</td>
<td>-1</td>
<td>E → (2, 5)</td>
</tr>
<tr class="odd">
<td>2</td>
<td>(2, 5)</td>
<td>+4</td>
<td>SE → (3, 4)</td>
</tr>
<tr class="even">
<td>3</td>
<td>(3, 4)</td>
<td>+1</td>
<td>SE → (4, 3)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>(4, 3)</td>
<td>+7</td>
<td>SE → (5, 2)</td>
</tr>
<tr class="even">
<td>5</td>
<td>(5, 2)</td>
<td>,</td>
<td>Stop (x &gt; y)</td>
</tr>
</tbody>
</table>
<p>Plotting the eight symmetric points for each iteration completes the circle.</p>
</section>
<section id="tiny-code-c-example-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example-1">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb88"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> midpoint_circle<span class="op">(</span><span class="dt">int</span> xc<span class="op">,</span> <span class="dt">int</span> yc<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> y <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> r<span class="op">;</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x <span class="op">&lt;=</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 8 symmetric points</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) (</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) (</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) (</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>               xc <span class="op">+</span> x<span class="op">,</span> yc <span class="op">+</span> y<span class="op">,</span> xc <span class="op">-</span> x<span class="op">,</span> yc <span class="op">+</span> y<span class="op">,</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>               xc <span class="op">+</span> x<span class="op">,</span> yc <span class="op">-</span> y<span class="op">,</span> xc <span class="op">-</span> x<span class="op">,</span> yc <span class="op">-</span> y<span class="op">);</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"(</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) (</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) (</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">) (</span><span class="sc">%d</span><span class="st">,</span><span class="sc">%d</span><span class="st">)</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>               xc <span class="op">+</span> y<span class="op">,</span> yc <span class="op">+</span> x<span class="op">,</span> xc <span class="op">-</span> y<span class="op">,</span> yc <span class="op">+</span> x<span class="op">,</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>               xc <span class="op">+</span> y<span class="op">,</span> yc <span class="op">-</span> x<span class="op">,</span> xc <span class="op">-</span> y<span class="op">,</span> yc <span class="op">-</span> x<span class="op">);</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>d <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>            d <span class="op">+=</span> <span class="dv">2</span> <span class="op">*</span> x <span class="op">+</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>            d <span class="op">+=</span> <span class="dv">2</span> <span class="op">*</span> <span class="op">(</span>x <span class="op">-</span> y<span class="op">)</span> <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>            y<span class="op">--;</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>        x<span class="op">++;</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-62" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-62">Why It Matters</h4>
<p>The Midpoint Circle Algorithm is used in:</p>
<ul>
<li>Low-level graphics libraries (e.g., SDL, OpenGL rasterizer base)</li>
<li>Embedded systems and display firmware</li>
<li>Digital art and games for drawing circles and arcs</li>
<li>Geometric reasoning for symmetry and integer geometry examples</li>
</ul>
<p>It forms a perfect pair with Bresenham’s line algorithm, both based on discrete decision logic rather than continuous math.</p>
</section>
<section id="a-gentle-proof-why-it-works-49" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-49">A Gentle Proof (Why It Works)</h4>
<p>The midpoint test evaluates whether the midpoint between two pixel candidates lies inside or outside the ideal circle:</p>
<p>If <span class="math inline">\(f(x + 1, y - 0.5) &lt; 0\)</span>, the midpoint is inside → choose E. Otherwise, it’s outside → choose SE.</p>
<p>By rearranging terms, the incremental update is derived:</p>
<p><span class="math display">\[
d_{k+1} =
\begin{cases}
d_k + 2x_k + 3, &amp; \text{if } d_k &lt; 0 \\
d_k + 2(x_k - y_k) + 5, &amp; \text{if } d_k \ge 0
\end{cases}
\]</span></p>
<p>Since all terms are integers, the circle can be rasterized precisely with integer arithmetic.</p>
</section>
<section id="try-it-yourself-62" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-62">Try It Yourself</h4>
<ol type="1">
<li>Draw a circle centered at <span class="math inline">\((0,0)\)</span> with <span class="math inline">\(r=5\)</span>.</li>
<li>Compute <span class="math inline">\(d\)</span> step-by-step using the rules above.</li>
<li>Mark eight symmetric points at each iteration.</li>
<li>Compare to the mathematical circle, they align perfectly.</li>
</ol>
</section>
<section id="test-cases-62" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-62">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Center</th>
<th>Radius</th>
<th>Points Drawn</th>
<th>Symmetry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0, 0)</td>
<td>3</td>
<td>24</td>
<td>Perfect</td>
</tr>
<tr class="even">
<td>(10, 10)</td>
<td>5</td>
<td>40</td>
<td>Perfect</td>
</tr>
<tr class="odd">
<td>(0, 0)</td>
<td>10</td>
<td>80</td>
<td>Perfect</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-62" class="level4">
<h4 class="anchored" data-anchor-id="complexity-62">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Draw Circle</td>
<td><span class="math inline">\(O(r)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The Midpoint Circle Algorithm is geometry’s quiet craftsman — it draws a perfect loop with nothing but integers and symmetry, turning a pure equation into a dance of pixels on a square grid.</p>
</section>
</section>
<section id="scanline-fill" class="level3">
<h3 class="anchored" data-anchor-id="scanline-fill">763 Scanline Fill</h3>
<p>The Scanline Fill Algorithm is a classic polygon-filling technique in computer graphics. It colors the interior of a polygon efficiently, one horizontal line (or <em>scanline</em>) at a time. Rather than testing every pixel, it determines where each scanline enters and exits the polygon and fills only between those points.</p>
<p>This method forms the foundation of raster graphics, renderers, and vector-to-pixel conversions.</p>
<section id="what-problem-are-we-solving-63" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-63">What Problem Are We Solving?</h4>
<p>We need to fill the inside of a polygon, all pixels that lie within its boundary — using an efficient, deterministic process that works on a discrete grid.</p>
<p>A brute-force approach would test every pixel to see if it’s inside the polygon (using ray casting or winding rules), but that’s expensive.</p>
<p>The Scanline Fill Algorithm converts this into a row-by-row filling problem using intersection points.</p>
</section>
<section id="how-it-works-plain-language-8" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-8">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Imagine horizontal lines sweeping from top to bottom across the polygon.</p></li>
<li><p>Each scanline may intersect the polygon’s edges multiple times.</p></li>
<li><p>The rule:</p>
<ul>
<li>Fill pixels between pairs of intersections (entering and exiting the polygon).</li>
</ul></li>
</ol>
<p>Thus, each scanline becomes a simple sequence of <em>on-off</em> regions: fill between every alternate pair of x-intersections.</p>
</section>
<section id="step-by-step-procedure-2" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-procedure-2">Step-by-Step Procedure</h4>
<ol type="1">
<li><p>Build an Edge Table (ET)</p>
<ul>
<li><p>For every polygon edge, record:</p>
<ul>
<li>Minimum y (start scanline)</li>
<li>Maximum y (end scanline)</li>
<li>x-coordinate of the lower endpoint</li>
<li>Inverse slope (<span class="math inline">\(1/m\)</span>)</li>
</ul></li>
<li><p>Store these edges sorted by their minimum y.</p></li>
</ul></li>
<li><p>Initialize an Active Edge Table (AET), empty at the start.</p></li>
<li><p>For each scanline y:</p>
<ul>
<li>Add edges from the ET whose minimum y equals the current scanline.</li>
<li>Remove edges from the AET whose maximum y equals the current scanline.</li>
<li>Sort the AET by current x.</li>
<li>Fill pixels between each pair of x-intersections.</li>
<li>For each edge in AET, update its x: <span class="math display">\[
x_{\text{new}} = x_{\text{old}} + \frac{1}{m}
\]</span></li>
</ul></li>
<li><p>Repeat until the AET is empty.</p></li>
</ol>
<p>This procedure efficiently handles convex and concave polygons.</p>
</section>
<section id="example-4" class="level4">
<h4 class="anchored" data-anchor-id="example-4">Example</h4>
<p>Polygon: vertices <span class="math inline">\((2,2), (6,2), (4,6)\)</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge</th>
<th>y_min</th>
<th>y_max</th>
<th>x_at_y_min</th>
<th>1/m</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(2,2)-(6,2)</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>,</td>
</tr>
<tr class="even">
<td>(6,2)-(4,6)</td>
<td>2</td>
<td>6</td>
<td>6</td>
<td>-0.5</td>
</tr>
<tr class="odd">
<td>(4,6)-(2,2)</td>
<td>2</td>
<td>6</td>
<td>2</td>
<td>+0.5</td>
</tr>
</tbody>
</table>
<p>Scanline progression:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>y</th>
<th>Active Edges</th>
<th>x-intersections</th>
<th>Fill</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>,</td>
<td>,</td>
<td>Edge starts</td>
</tr>
<tr class="even">
<td>3</td>
<td>(2,6,-0.5), (2,6,+0.5)</td>
<td>x = 2.5, 5.5</td>
<td>Fill (3, 2.5→5.5)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>…</td>
<td>x = 3, 5</td>
<td>Fill (4, 3→5)</td>
</tr>
<tr class="even">
<td>5</td>
<td>…</td>
<td>x = 3.5, 4.5</td>
<td>Fill (5, 3.5→4.5)</td>
</tr>
<tr class="odd">
<td>6</td>
<td>,</td>
<td>,</td>
<td>Done</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-16" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-16">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> scanline_fill(polygon):</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># polygon = [(x0,y0), (x1,y1), ...]</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(polygon)</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> []</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>        x0, y0 <span class="op">=</span> polygon[i]</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> polygon[(i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n]</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> y0 <span class="op">==</span> y1:</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span>  <span class="co"># skip horizontal edges</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> y0 <span class="op">&gt;</span> y1:</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>            x0, y0, x1, y1 <span class="op">=</span> x1, y1, x0, y0</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>        inv_slope <span class="op">=</span> (x1 <span class="op">-</span> x0) <span class="op">/</span> (y1 <span class="op">-</span> y0)</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>        edges.append([y0, y1, x0, inv_slope])</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>    edges.sort(key<span class="op">=</span><span class="kw">lambda</span> e: e[<span class="dv">0</span>])</span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="bu">int</span>(edges[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> []</span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> active <span class="kw">or</span> edges:</span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add new edges</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> edges <span class="kw">and</span> edges[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> y:</span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>            active.append(edges.pop(<span class="dv">0</span>))</span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove finished edges</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>        active <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> active <span class="cf">if</span> e[<span class="dv">1</span>] <span class="op">&gt;</span> y]</span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort and find intersections</span></span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>        x_list <span class="op">=</span> [e[<span class="dv">2</span>] <span class="cf">for</span> e <span class="kw">in</span> active]</span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>        x_list.sort()</span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill between pairs</span></span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(x_list), <span class="dv">2</span>):</span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Fill line at y=</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss"> from x=</span><span class="sc">{</span>x_list[i]<span class="sc">}</span><span class="ss"> to x=</span><span class="sc">{</span>x_list[i<span class="op">+</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update x</span></span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> e <span class="kw">in</span> active:</span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>            e[<span class="dv">2</span>] <span class="op">+=</span> e[<span class="dv">3</span>]</span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>        y <span class="op">+=</span> <span class="dv">1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-63" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-63">Why It Matters</h4>
<ul>
<li>Core of polygon rasterization in 2D rendering engines.</li>
<li>Used in fill tools, graphics APIs, and hardware rasterizers.</li>
<li>Handles concave and complex polygons efficiently.</li>
<li>Demonstrates the power of incremental updates and scanline coherence in graphics.</li>
</ul>
<p>It’s the algorithm behind how your screen fills regions in vector graphics or how CAD software shades polygons.</p>
</section>
<section id="a-gentle-proof-why-it-works-50" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-50">A Gentle Proof (Why It Works)</h4>
<p>A polygon alternates between being <em>inside</em> and <em>outside</em> at every edge crossing. For each scanline, filling between every pair of intersections guarantees:</p>
<p><span class="math display">\[
\forall x \in [x_{2i}, x_{2i+1}], \ (x, y) \text{ is inside the polygon.}
\]</span></p>
<p>Since we only process active edges and update x incrementally, each operation is <span class="math inline">\(O(1)\)</span> per edge per scanline, yielding total linear complexity in the number of edges times scanlines.</p>
</section>
<section id="try-it-yourself-63" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-63">Try It Yourself</h4>
<ol type="1">
<li>Draw a triangle on grid paper.</li>
<li>For each horizontal line, mark where it enters and exits the triangle.</li>
<li>Fill between those intersections.</li>
<li>Observe how the filled region exactly matches the polygon interior.</li>
</ol>
</section>
<section id="test-cases-63" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-63">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Vertices</th>
<th>Filled Scanlines</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="even">
<td>Rectangle</td>
<td>4</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Concave L-shape</td>
<td>6</td>
<td>8</td>
</tr>
<tr class="even">
<td>Complex polygon</td>
<td>8</td>
<td>10–12</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-63" class="level4">
<h4 class="anchored" data-anchor-id="complexity-63">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Fill Polygon</td>
<td><span class="math inline">\(O(n + H)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(H\)</span> = number of scanlines in the bounding box.</p>
<p>The Scanline Fill Algorithm is like painting with a ruler — it glides across the canvas line by line, filling every space with calm precision until the whole shape glows solid.</p>
</section>
</section>
<section id="edge-table-fill" class="level3">
<h3 class="anchored" data-anchor-id="edge-table-fill">764 Edge Table Fill</h3>
<p>The Edge Table Fill Algorithm is a refined and efficient form of the scanline polygon fill. It uses an explicit Edge Table (ET) and Active Edge Table (AET) to manage polygon boundaries, enabling fast and structured filling of even complex shapes.</p>
<p>This method is often implemented inside graphics hardware and rendering libraries because it minimizes redundant work while ensuring precise polygon filling.</p>
<section id="what-problem-are-we-solving-64" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-64">What Problem Are We Solving?</h4>
<p>When filling polygons using scanlines, we need to know exactly where each scanline enters and exits the polygon. Instead of recomputing intersections every time, the Edge Table organizes edges so that updates are done incrementally as the scanline moves.</p>
<p>The Edge Table Fill Algorithm improves on basic scanline filling by storing precomputed edge data in buckets keyed by y-coordinates.</p>
</section>
<section id="how-it-works-plain-language-9" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-9">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Build an Edge Table (ET), one bucket for each scanline <span class="math inline">\(y\)</span> where edges start.</p></li>
<li><p>Build an Active Edge Table (AET), dynamic list of edges that intersect the current scanline.</p></li>
<li><p>For each scanline <span class="math inline">\(y\)</span>:</p>
<ul>
<li>Add edges from the ET that start at <span class="math inline">\(y\)</span>.</li>
<li>Remove edges that end at <span class="math inline">\(y\)</span>.</li>
<li>Sort active edges by current x.</li>
<li>Fill pixels between pairs of x-values.</li>
<li>Update x for each edge incrementally using its slope.</li>
</ul></li>
</ol>
</section>
<section id="edge-table-et-structure" class="level4">
<h4 class="anchored" data-anchor-id="edge-table-et-structure">Edge Table (ET) Structure</h4>
<p>Each edge is stored with:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Field</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>y_max</td>
<td>Scanline where the edge ends</td>
</tr>
<tr class="even">
<td>x</td>
<td>x-coordinate at y_min</td>
</tr>
<tr class="odd">
<td>1/m</td>
<td>Inverse slope (increment for each y step)</td>
</tr>
</tbody>
</table>
<p>Edges are inserted into the ET bucket corresponding to their starting y_min.</p>
</section>
<section id="step-by-step-example-6" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-6">Step-by-Step Example</h4>
<p>Consider a polygon with vertices: <span class="math inline">\((3,2), (6,5), (3,8), (1,5)\)</span></p>
<p>Compute edges:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge</th>
<th>y_min</th>
<th>y_max</th>
<th>x</th>
<th>1/m</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(3,2)-(6,5)</td>
<td>2</td>
<td>5</td>
<td>3</td>
<td>+1</td>
</tr>
<tr class="even">
<td>(6,5)-(3,8)</td>
<td>5</td>
<td>8</td>
<td>6</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>(3,8)-(1,5)</td>
<td>5</td>
<td>8</td>
<td>1</td>
<td>+1</td>
</tr>
<tr class="even">
<td>(1,5)-(3,2)</td>
<td>2</td>
<td>5</td>
<td>1</td>
<td>0.67</td>
</tr>
</tbody>
</table>
<p>ET (grouped by y_min):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>y</th>
<th>Edges</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>[(5, 3, 1), (5, 1, 0.67)]</td>
</tr>
<tr class="even">
<td>5</td>
<td>[(8, 6, -1), (8, 1, +1)]</td>
</tr>
</tbody>
</table>
<p>Then the scanline filling begins at y=2.</p>
<p>At each step:</p>
<ul>
<li>Add edges from ET[y] to AET.</li>
<li>Sort AET by x.</li>
<li>Fill between pairs.</li>
<li>Update x by <span class="math inline">\(x = x + 1/m\)</span>.</li>
</ul>
</section>
<section id="tiny-code-python-example-17" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-17">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edge_table_fill(polygon):</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    ET <span class="op">=</span> {}</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(polygon)):</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>        x0, y0 <span class="op">=</span> polygon[i]</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> polygon[(i<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(polygon)]</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> y0 <span class="op">==</span> y1:</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> y0 <span class="op">&gt;</span> y1:</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>            x0, y0, x1, y1 <span class="op">=</span> x1, y1, x0, y0</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>        inv_slope <span class="op">=</span> (x1 <span class="op">-</span> x0) <span class="op">/</span> (y1 <span class="op">-</span> y0)</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>        ET.setdefault(<span class="bu">int</span>(y0), []).append({</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>            <span class="st">'ymax'</span>: <span class="bu">int</span>(y1),</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>            <span class="st">'x'</span>: <span class="bu">float</span>(x0),</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>            <span class="st">'inv_slope'</span>: inv_slope</span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="bu">min</span>(ET.keys())</span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>    AET <span class="op">=</span> []</span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> AET <span class="kw">or</span> y <span class="kw">in</span> ET:</span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> y <span class="kw">in</span> ET:</span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a>            AET.extend(ET[y])</span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a>        AET <span class="op">=</span> [e <span class="cf">for</span> e <span class="kw">in</span> AET <span class="cf">if</span> e[<span class="st">'ymax'</span>] <span class="op">&gt;</span> y]</span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a>        AET.sort(key<span class="op">=</span><span class="kw">lambda</span> e: e[<span class="st">'x'</span>])</span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(AET), <span class="dv">2</span>):</span>
<span id="cb90-25"><a href="#cb90-25" aria-hidden="true" tabindex="-1"></a>            x1, x2 <span class="op">=</span> AET[i][<span class="st">'x'</span>], AET[i<span class="op">+</span><span class="dv">1</span>][<span class="st">'x'</span>]</span>
<span id="cb90-26"><a href="#cb90-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Fill line at y=</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">: from x=</span><span class="sc">{</span>x1<span class="sc">:.2f}</span><span class="ss"> to x=</span><span class="sc">{</span>x2<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb90-27"><a href="#cb90-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> e <span class="kw">in</span> AET:</span>
<span id="cb90-28"><a href="#cb90-28" aria-hidden="true" tabindex="-1"></a>            e[<span class="st">'x'</span>] <span class="op">+=</span> e[<span class="st">'inv_slope'</span>]</span>
<span id="cb90-29"><a href="#cb90-29" aria-hidden="true" tabindex="-1"></a>        y <span class="op">+=</span> <span class="dv">1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-64" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-64">Why It Matters</h4>
<p>The Edge Table Fill algorithm is central to polygon rasterization in:</p>
<ul>
<li>2D graphics renderers (e.g., OpenGL’s polygon pipeline)</li>
<li>CAD systems for filled vector drawings</li>
<li>Font rasterization and game graphics</li>
<li>GPU scan converters</li>
</ul>
<p>It reduces redundant computation, making it ideal for hardware or software rasterization loops.</p>
</section>
<section id="a-gentle-proof-why-it-works-51" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-51">A Gentle Proof (Why It Works)</h4>
<p>For each scanline, the AET maintains exactly the set of edges intersecting that line. Since each edge is linear, its intersection x increases by <span class="math inline">\(\frac{1}{m}\)</span> per scanline. Thus the algorithm ensures consistency:</p>
<p><span class="math display">\[
x_{y+1} = x_y + \frac{1}{m}
\]</span></p>
<p>The alternating fill rule (inside–outside) guarantees that we fill every interior pixel once and only once.</p>
</section>
<section id="try-it-yourself-64" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-64">Try It Yourself</h4>
<ol type="1">
<li>Draw a pentagon on graph paper.</li>
<li>Create a table of edges with y_min, y_max, x, and 1/m.</li>
<li>For each scanline, mark entry and exit x-values and fill between them.</li>
<li>Compare your filled area to the exact polygon, it will match perfectly.</li>
</ol>
</section>
<section id="test-cases-64" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-64">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Vertices</th>
<th>Type</th>
<th>Filled Correctly</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>3</td>
<td>Convex</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Rectangle</td>
<td>4</td>
<td>Convex</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Concave</td>
<td>6</td>
<td>Non-convex</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Star</td>
<td>10</td>
<td>Self-intersecting</td>
<td>Partial (depends on rule)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-64" class="level4">
<h4 class="anchored" data-anchor-id="complexity-64">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Fill Polygon</td>
<td><span class="math inline">\(O(n + H)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(n\)</span> is the number of edges, <span class="math inline">\(H\)</span> is the number of scanlines.</p>
<p>The Edge Table Fill Algorithm is the disciplined craftsman of polygon filling — it organizes edges like tools in a box, then works steadily scan by scan, turning abstract vertices into solid, filled forms.</p>
</section>
</section>
<section id="z-buffer-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="z-buffer-algorithm">765 Z-Buffer Algorithm</h3>
<p>The Z-Buffer Algorithm (or Depth Buffering) is the foundation of modern 3D rendering. It determines which surface of overlapping 3D objects is visible at each pixel by comparing depth (z-values).</p>
<p>This algorithm is simple, robust, and widely implemented in hardware, every GPU you use today performs a version of it billions of times per second.</p>
<section id="what-problem-are-we-solving-65" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-65">What Problem Are We Solving?</h4>
<p>When projecting 3D objects onto a 2D screen, many surfaces overlap along the same pixel column. We need to decide which one is closest to the camera, and hence visible.</p>
<p>Naïve solutions sort polygons globally, but that becomes difficult for intersecting or complex shapes. The Z-Buffer Algorithm solves this by working <em>per pixel</em>, maintaining a running record of the closest object so far.</p>
</section>
<section id="how-it-works-plain-language-10" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-10">How It Works (Plain Language)</h4>
<p>The idea is to maintain two buffers of the same size as the screen:</p>
<ol type="1">
<li>Frame Buffer (Color Buffer), stores final color of each pixel.</li>
<li>Depth Buffer (Z-Buffer), stores the z-coordinate (depth) of the nearest surface seen so far.</li>
</ol>
<p>Algorithm steps:</p>
<ol type="1">
<li><p>Initialize the Z-Buffer with a large value (e.g., infinity).</p></li>
<li><p>For each polygon:</p>
<ul>
<li><p>Compute its projection on the screen.</p></li>
<li><p>For each pixel inside the polygon:</p>
<ul>
<li><p>Compute its depth z.</p></li>
<li><p>If <span class="math inline">\(z &lt; z_{\text{buffer}}[x, y]\)</span>, update both buffers:</p>
<p><span class="math display">\[
z_{\text{buffer}}[x, y] = z
\]</span></p>
<p><span class="math display">\[
\text{frame}[x, y] = \text{polygon\_color}
\]</span></p></li>
</ul></li>
</ul></li>
<li><p>After all polygons are processed, the frame buffer contains the visible image.</p></li>
</ol>
</section>
<section id="step-by-step-example-7" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-7">Step-by-Step Example</h4>
<p>Suppose we render two triangles overlapping in screen space: Triangle A (blue) and Triangle B (red).</p>
<p>For a given pixel <span class="math inline">\((x, y)\)</span>:</p>
<ul>
<li>Triangle A has depth <span class="math inline">\(z_A = 0.45\)</span></li>
<li>Triangle B has depth <span class="math inline">\(z_B = 0.3\)</span></li>
</ul>
<p>Since <span class="math inline">\(z_B &lt; z_A\)</span>, the red pixel from Triangle B is visible.</p>
</section>
<section id="mathematical-details" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-details">Mathematical Details</h4>
<p>If the polygon is a plane given by</p>
<p><span class="math display">\[
ax + by + cz + d = 0,
\]</span></p>
<p>then we can compute <span class="math inline">\(z\)</span> for each pixel as</p>
<p><span class="math display">\[
z = -\frac{ax + by + d}{c}.
\]</span></p>
<p>During rasterization, <span class="math inline">\(z\)</span> can be incrementally interpolated across the polygon, just like color or texture coordinates.</p>
</section>
<section id="tiny-code-c-example-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example-2">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb91"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;float.h&gt;</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define WIDTH </span><span class="dv">800</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define HEIGHT </span><span class="dv">600</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> zbuffer<span class="op">[</span>HEIGHT<span class="op">][</span>WIDTH<span class="op">];</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> framebuffer<span class="op">[</span>HEIGHT<span class="op">][</span>WIDTH<span class="op">];</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Scene<span class="op">;</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> clear<span class="op">(</span>Scene<span class="op">*</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> y <span class="op">&lt;</span> HEIGHT<span class="op">;</span> y<span class="op">++)</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> WIDTH<span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>            s<span class="op">-&gt;</span>zbuffer<span class="op">[</span>y<span class="op">][</span>x<span class="op">]</span> <span class="op">=</span> FLT_MAX<span class="op">;</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>            s<span class="op">-&gt;</span>framebuffer<span class="op">[</span>y<span class="op">][</span>x<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// background color</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> plot<span class="op">(</span>Scene<span class="op">*</span> s<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">float</span> z<span class="op">,</span> <span class="dt">unsigned</span> <span class="dt">int</span> color<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>z <span class="op">&lt;</span> s<span class="op">-&gt;</span>zbuffer<span class="op">[</span>y<span class="op">][</span>x<span class="op">])</span> <span class="op">{</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>        s<span class="op">-&gt;</span>zbuffer<span class="op">[</span>y<span class="op">][</span>x<span class="op">]</span> <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        s<span class="op">-&gt;</span>framebuffer<span class="op">[</span>y<span class="op">][</span>x<span class="op">]</span> <span class="op">=</span> color<span class="op">;</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each pixel compares its new depth with the stored one, a single <code>if</code> statement ensures correct visibility.</p>
</section>
<section id="why-it-matters-65" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-65">Why It Matters</h4>
<ul>
<li>Used in all modern GPUs (OpenGL, Direct3D, Vulkan).</li>
<li>Handles arbitrary overlapping geometry without sorting.</li>
<li>Supports texture mapping, lighting, and transparency when combined with blending.</li>
<li>Provides a per-pixel accuracy model of visibility, essential for photorealistic rendering.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-52" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-52">A Gentle Proof (Why It Works)</h4>
<p>For any pixel <span class="math inline">\((x, y)\)</span>, the visible surface is the one with the minimum z among all polygons projecting onto that pixel:</p>
<p><span class="math display">\[
z_{\text{visible}}(x, y) = \min_i z_i(x, y).
\]</span></p>
<p>By checking and updating this minimum incrementally as we draw, the Z-Buffer algorithm ensures that no farther surface overwrites a nearer one.</p>
<p>Because the depth buffer is initialized to <span class="math inline">\(\infty\)</span>, every first pixel write succeeds, and every later one is conditionally replaced only if closer.</p>
</section>
<section id="try-it-yourself-65" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-65">Try It Yourself</h4>
<ol type="1">
<li>Render two overlapping rectangles with different z-values.</li>
<li>Plot them in reverse order, notice that the front one still appears in front.</li>
<li>Visualize the z-buffer, closer surfaces have smaller values (brighter if visualized inversely).</li>
</ol>
</section>
<section id="test-cases-65" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-65">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Scene</th>
<th>Expected Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Two overlapping triangles</td>
<td>Foremost visible</td>
</tr>
<tr class="even">
<td>Cube rotating in space</td>
<td>Faces correctly occluded</td>
</tr>
<tr class="odd">
<td>Multiple intersecting objects</td>
<td>Correct visibility per pixel</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-65" class="level4">
<h4 class="anchored" data-anchor-id="complexity-65">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Per pixel</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Full frame</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
</tbody>
</table>
<p>The Z-Buffer Algorithm is the quiet guardian of every rendered image — it watches every pixel’s depth, ensuring that what you see is exactly what lies closest in your virtual world.</p>
</section>
</section>
<section id="painters-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="painters-algorithm">766 Painter’s Algorithm</h3>
<p>The Painter’s Algorithm is one of the earliest and simplest methods for hidden surface removal in 3D graphics. It mimics how a painter works: by painting distant surfaces first, then closer ones over them, until the final visible image emerges.</p>
<p>Though it has been largely superseded by the Z-buffer in modern systems, it remains conceptually elegant and still useful in certain rendering pipelines and visualization tasks.</p>
<section id="what-problem-are-we-solving-66" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-66">What Problem Are We Solving?</h4>
<p>When multiple 3D polygons overlap in screen space, we need to determine which parts of each should be visible. Instead of testing each pixel’s depth (as in the Z-buffer), the Painter’s Algorithm resolves this by drawing entire polygons in sorted order by depth.</p>
<p>The painter paints the farthest wall first, then the nearer ones, so that closer surfaces naturally overwrite those behind them.</p>
</section>
<section id="how-it-works-plain-language-11" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-11">How It Works (Plain Language)</h4>
<ol type="1">
<li>Compute the average depth (z) for each polygon.</li>
<li>Sort all polygons in descending order of depth (farthest first).</li>
<li>Draw polygons one by one onto the image buffer, closer ones overwrite pixels of farther ones.</li>
</ol>
<p>This works well when objects do not intersect and their depth ordering is consistent.</p>
</section>
<section id="step-by-step-example-8" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-8">Step-by-Step Example</h4>
<p>Imagine three rectangles stacked in depth:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Average z</th>
<th>Color</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>0.9</td>
<td>Blue</td>
</tr>
<tr class="even">
<td>B</td>
<td>0.5</td>
<td>Red</td>
</tr>
<tr class="odd">
<td>C</td>
<td>0.2</td>
<td>Green</td>
</tr>
</tbody>
</table>
<p>Sort by z: A → B → C</p>
<p>Paint them in order:</p>
<ol type="1">
<li>Draw A (blue, farthest)</li>
<li>Draw B (red, mid)</li>
<li>Draw C (green, nearest)</li>
</ol>
<p>Result: The nearest (green) polygon hides parts of the others.</p>
</section>
<section id="handling-overlaps" class="level4">
<h4 class="anchored" data-anchor-id="handling-overlaps">Handling Overlaps</h4>
<p>If two polygons overlap in projection and cannot be easily depth-ordered (e.g., they intersect or cyclically overlap), then recursive subdivision or hybrid approaches are needed:</p>
<ol type="1">
<li>Split polygons along their intersection lines.</li>
<li>Reorder the resulting fragments.</li>
<li>Draw them in correct order.</li>
</ol>
<p>This ensures visibility correctness, at the cost of extra geometry computation.</p>
</section>
<section id="tiny-code-python-example-18" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-18">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.patches <span class="im">import</span> Polygon</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>polygons <span class="op">=</span> [</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'points'</span>: [(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">5</span>,<span class="dv">1</span>),(<span class="dv">3</span>,<span class="dv">4</span>)], <span class="st">'z'</span>:<span class="fl">0.8</span>, <span class="st">'color'</span>:<span class="st">'skyblue'</span>},</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'points'</span>: [(<span class="dv">2</span>,<span class="dv">2</span>),(<span class="dv">6</span>,<span class="dv">2</span>),(<span class="dv">4</span>,<span class="dv">5</span>)], <span class="st">'z'</span>:<span class="fl">0.5</span>, <span class="st">'color'</span>:<span class="st">'salmon'</span>},</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'points'</span>: [(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">7</span>,<span class="dv">3</span>),(<span class="dv">5</span>,<span class="dv">6</span>)], <span class="st">'z'</span>:<span class="fl">0.2</span>, <span class="st">'color'</span>:<span class="st">'limegreen'</span>},</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort by z (farthest first)</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>sorted_polygons <span class="op">=</span> <span class="bu">sorted</span>(polygons, key<span class="op">=</span><span class="kw">lambda</span> p: p[<span class="st">'z'</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> sorted_polygons:</span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(Polygon(p[<span class="st">'points'</span>], closed<span class="op">=</span><span class="va">True</span>, facecolor<span class="op">=</span>p[<span class="st">'color'</span>], edgecolor<span class="op">=</span><span class="st">'black'</span>))</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>,<span class="dv">8</span>)</span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="dv">0</span>,<span class="dv">7</span>)</span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a>ax.set_aspect(<span class="st">'equal'</span>)</span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This draws the polygons back-to-front, exactly like a painter layering colors on canvas.</p>
</section>
<section id="why-it-matters-66" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-66">Why It Matters</h4>
<ul>
<li>Intuitive, easy to implement.</li>
<li>Works directly with polygon-level data, no need for per-pixel depth comparisons.</li>
<li>Used in 2D rendering engines, vector graphics, and scene sorting.</li>
<li>Forms the conceptual basis for more advanced visibility algorithms.</li>
</ul>
<p>It’s often used when:</p>
<ul>
<li>Rendering order can be precomputed (no intersection).</li>
<li>You’re simulating transparent surfaces or simple orthographic scenes.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-53" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-53">A Gentle Proof (Why It Works)</h4>
<p>Let polygons <span class="math inline">\(P_1, P_2, ..., P_n\)</span> have depths <span class="math inline">\(z_1, z_2, ..., z_n\)</span>. If <span class="math inline">\(z_i &gt; z_j\)</span> for all pixels of <span class="math inline">\(P_i\)</span> behind <span class="math inline">\(P_j\)</span>, then painting in descending <span class="math inline">\(z\)</span> order ensures that:</p>
<p><span class="math display">\[
\forall (x, y): \text{color}(x, y) = \text{color of nearest visible polygon at that pixel}.
\]</span></p>
<p>This holds because later polygons overwrite earlier ones in the frame buffer.</p>
<p>However, when polygons intersect, this depth order is not transitive and fails, hence the need for subdivision or alternative algorithms like the Z-buffer.</p>
</section>
<section id="try-it-yourself-66" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-66">Try It Yourself</h4>
<ol type="1">
<li>Draw three overlapping polygons on paper.</li>
<li>Assign z-values to each and order them back-to-front.</li>
<li>“Paint” them in that order, see how near ones cover the far ones.</li>
<li>Now create intersecting shapes, observe where ordering breaks.</li>
</ol>
</section>
<section id="test-cases-66" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-66">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Scene</th>
<th>Works Correctly?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Non-overlapping polygons</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Nested polygons</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Intersecting polygons</td>
<td>No (requires subdivision)</td>
</tr>
<tr class="even">
<td>Transparent polygons</td>
<td>Yes (with alpha blending)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-66" class="level4">
<h4 class="anchored" data-anchor-id="complexity-66">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sort polygons</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Draw polygons</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span> (for frame buffer)</td>
</tr>
</tbody>
</table>
<p>The Painter’s Algorithm captures a fundamental truth of graphics: sometimes visibility is not about computation but about order — the art of laying down layers until the scene emerges, one brushstroke at a time.</p>
</section>
</section>
<section id="gouraud-shading" class="level3">
<h3 class="anchored" data-anchor-id="gouraud-shading">767 Gouraud Shading</h3>
<p>Gouraud Shading is a classic method for producing smooth color transitions across a polygon surface. Instead of assigning a single flat color to an entire face, it interpolates colors at the vertices and shades each pixel by gradually blending them.</p>
<p>It was one of the first algorithms to bring <em>smooth lighting</em> to computer graphics, fast, elegant, and easy to implement.</p>
<section id="what-problem-are-we-solving-67" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-67">What Problem Are We Solving?</h4>
<p>Flat shading gives each polygon a uniform color. This looks artificial because the boundaries between adjacent polygons are sharply visible.</p>
<p>Gouraud Shading solves this by making the color vary smoothly across the surface, simulating how light reflects gradually on curved objects.</p>
</section>
<section id="how-it-works-plain-language-12" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-12">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Compute vertex normals, the average of the normals of all faces sharing a vertex.</p></li>
<li><p>Compute vertex intensities using a lighting model (usually Lambertian reflection):</p>
<p><span class="math display">\[
I_v = k_d (L \cdot N_v) + I_{\text{ambient}}
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(L\)</span> is the light direction</li>
<li><span class="math inline">\(N_v\)</span> is the vertex normal</li>
<li><span class="math inline">\(k_d\)</span> is diffuse reflectivity</li>
</ul></li>
<li><p>For each polygon:</p>
<ul>
<li>Interpolate the vertex intensities along each scanline.</li>
<li>Fill the interior pixels by interpolating intensity horizontally.</li>
</ul></li>
</ol>
<p>This gives smooth gradients across the surface with low computational cost.</p>
</section>
<section id="mathematical-form" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-form">Mathematical Form</h4>
<p>Let vertices have intensities <span class="math inline">\(I_1, I_2, I_3\)</span>. For any interior point <span class="math inline">\((x, y)\)</span>, its intensity <span class="math inline">\(I(x, y)\)</span> is computed by barycentric interpolation:</p>
<p><span class="math display">\[
I(x, y) = \alpha I_1 + \beta I_2 + \gamma I_3
\]</span></p>
<p>where <span class="math inline">\(\alpha + \beta + \gamma = 1\)</span> and <span class="math inline">\(\alpha, \beta, \gamma\)</span> are barycentric coordinates of <span class="math inline">\((x, y)\)</span> relative to the triangle.</p>
</section>
<section id="step-by-step-example-9" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-9">Step-by-Step Example</h4>
<p>Suppose a triangle has vertex intensities:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Vertex</th>
<th>Coordinates</th>
<th>Intensity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>(1, 1)</td>
<td>0.2</td>
</tr>
<tr class="even">
<td>B</td>
<td>(5, 1)</td>
<td>0.8</td>
</tr>
<tr class="odd">
<td>C</td>
<td>(3, 4)</td>
<td>0.5</td>
</tr>
</tbody>
</table>
<p>Then every point inside the triangle blends these values smoothly, producing a gradient from dark at A to bright at B and medium at C.</p>
</section>
<section id="tiny-code-python-example-19" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-19">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> barycentric(x, y, x1, y1, x2, y2, x3, y3):</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    det <span class="op">=</span> (y2 <span class="op">-</span> y3)<span class="op">*</span>(x1 <span class="op">-</span> x3) <span class="op">+</span> (x3 <span class="op">-</span> x2)<span class="op">*</span>(y1 <span class="op">-</span> y3)</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> ((y2 <span class="op">-</span> y3)<span class="op">*</span>(x <span class="op">-</span> x3) <span class="op">+</span> (x3 <span class="op">-</span> x2)<span class="op">*</span>(y <span class="op">-</span> y3)) <span class="op">/</span> det</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> ((y3 <span class="op">-</span> y1)<span class="op">*</span>(x <span class="op">-</span> x3) <span class="op">+</span> (x1 <span class="op">-</span> x3)<span class="op">*</span>(y <span class="op">-</span> y3)) <span class="op">/</span> det</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> a <span class="op">-</span> b</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a, b, c</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="co"># triangle vertices and intensities</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>x1, y1, i1 <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="fl">0.2</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>x2, y2, i2 <span class="op">=</span> <span class="dv">5</span>, <span class="dv">1</span>, <span class="fl">0.8</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>x3, y3, i3 <span class="op">=</span> <span class="dv">3</span>, <span class="dv">4</span>, <span class="fl">0.5</span></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> np.zeros((<span class="dv">6</span>, <span class="dv">7</span>))</span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>):</span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">7</span>):</span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a>        a, b, c <span class="op">=</span> barycentric(x, y, x1, y1, x2, y2, x3, y3)</span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> b <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> c <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>            img[y, x] <span class="op">=</span> a<span class="op">*</span>i1 <span class="op">+</span> b<span class="op">*</span>i2 <span class="op">+</span> c<span class="op">*</span>i3</span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a>plt.imshow(img, origin<span class="op">=</span><span class="st">'lower'</span>, cmap<span class="op">=</span><span class="st">'inferno'</span>)</span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This demonstrates how pixel colors can be smoothly blended based on vertex light intensities.</p>
</section>
<section id="why-it-matters-67" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-67">Why It Matters</h4>
<ul>
<li>Introduced realistic shading into polygonal graphics.</li>
<li>Forms the basis for hardware lighting in OpenGL and Direct3D.</li>
<li>Efficient, all operations are linear interpolations, suitable for rasterization hardware.</li>
<li>Used in both 3D modeling software and real-time engines before Phong shading became common.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-54" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-54">A Gentle Proof (Why It Works)</h4>
<p>The intensity on a plane varies linearly if lighting is computed at the vertices and interpolated. For a triangle defined by vertices <span class="math inline">\(A, B, C\)</span>, the light intensity at any interior point satisfies:</p>
<p><span class="math display">\[
\nabla^2 I(x, y) = 0
\]</span></p>
<p>since the interpolation is linear, and therefore continuous across edges. Adjacent polygons sharing vertices have matching intensities at those vertices, giving a smooth overall appearance.</p>
</section>
<section id="try-it-yourself-67" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-67">Try It Yourself</h4>
<ol type="1">
<li>Create a triangle mesh (even a cube).</li>
<li>Compute vertex normals by averaging face normals.</li>
<li>Use the formula <span class="math inline">\(I_v = k_d (L \cdot N_v)\)</span> for each vertex.</li>
<li>Interpolate vertex intensities across each triangle and visualize the result.</li>
</ol>
<p>Try rotating the light vector, you’ll see how shading changes dynamically.</p>
</section>
<section id="test-cases-67" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-67">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Model</th>
<th>Shading Type</th>
<th>Visual Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cube (flat)</td>
<td>Flat</td>
<td>Faceted look</td>
</tr>
<tr class="even">
<td>Cube (Gouraud)</td>
<td>Smooth</td>
<td>Blended edges</td>
</tr>
<tr class="odd">
<td>Sphere</td>
<td>Gouraud</td>
<td>Soft lighting</td>
</tr>
<tr class="even">
<td>Terrain</td>
<td>Gouraud</td>
<td>Natural gradient lighting</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-67" class="level4">
<h4 class="anchored" data-anchor-id="complexity-67">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Per vertex lighting</td>
<td><span class="math inline">\(O(V)\)</span></td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
<tr class="even">
<td>Per pixel interpolation</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
</tbody>
</table>
<p>The Gouraud Shading algorithm was a key step in the evolution of realism in graphics — a bridge between geometric form and visual smoothness, where light glides softly across a surface instead of snapping from face to face.</p>
</section>
</section>
<section id="phong-shading" class="level3">
<h3 class="anchored" data-anchor-id="phong-shading">768 Phong Shading</h3>
<p>Phong Shading refines Gouraud Shading by interpolating normals instead of intensities, producing more accurate highlights and smooth lighting across curved surfaces. It was a breakthrough for realism in computer graphics, capturing glossy reflections, specular highlights, and gentle light falloff with elegance.</p>
<section id="what-problem-are-we-solving-68" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-68">What Problem Are We Solving?</h4>
<p>Gouraud Shading interpolates colors between vertices, which can miss small, bright highlights (like a shiny spot on a sphere) if they occur between vertices. Phong Shading fixes this by interpolating the surface normals per pixel, then recomputing lighting at every pixel.</p>
<p>This yields smoother, more physically accurate results, especially for curved and reflective surfaces.</p>
</section>
<section id="how-it-works-plain-language-13" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-13">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Compute vertex normals as the average of the normals of all adjacent faces.</p></li>
<li><p>For each pixel inside a polygon:</p>
<ul>
<li>Interpolate the normal vector <span class="math inline">\(N(x, y)\)</span> using barycentric interpolation.</li>
<li>Normalize it to unit length.</li>
<li>Apply the lighting equation at that pixel using <span class="math inline">\(N(x, y)\)</span>.</li>
</ul></li>
<li><p>Compute lighting (per pixel) using a standard illumination model such as Phong reflection:</p>
<p><span class="math display">\[
I(x, y) = k_a I_a + k_d (L \cdot N) I_l + k_s (R \cdot V)^n I_l
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(k_a, k_d, k_s\)</span> are ambient, diffuse, and specular coefficients</li>
<li><span class="math inline">\(L\)</span> is light direction</li>
<li><span class="math inline">\(N\)</span> is surface normal at pixel</li>
<li><span class="math inline">\(R\)</span> is reflection vector</li>
<li><span class="math inline">\(V\)</span> is view direction</li>
<li><span class="math inline">\(n\)</span> is shininess (specular exponent)</li>
</ul></li>
</ol>
</section>
<section id="step-by-step-example-10" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-10">Step-by-Step Example</h4>
<ol type="1">
<li><p>For each vertex of a triangle, store its normal vector <span class="math inline">\(N_1, N_2, N_3\)</span>.</p></li>
<li><p>For each pixel inside the triangle:</p>
<ul>
<li>Interpolate <span class="math inline">\(N(x, y)\)</span> using <span class="math display">\[
N(x, y) = \alpha N_1 + \beta N_2 + \gamma N_3
\]</span></li>
<li>Normalize: <span class="math display">\[
N'(x, y) = \frac{N(x, y)}{|N(x, y)|}
\]</span></li>
<li>Compute the illumination with the Phong model at that pixel.</li>
</ul></li>
</ol>
<p>The highlight intensity changes smoothly across the surface, producing a realistic reflection spot.</p>
</section>
<section id="tiny-code-python-example-20" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-20">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalize(v):</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v <span class="op">/</span> np.linalg.norm(v)</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> phong_shading(N, L, V, ka<span class="op">=</span><span class="fl">0.1</span>, kd<span class="op">=</span><span class="fl">0.7</span>, ks<span class="op">=</span><span class="fl">0.8</span>, n<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> normalize(N)</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> normalize(L)</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> normalize(V)</span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.dot(N, L) <span class="op">*</span> N <span class="op">-</span> L</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    I <span class="op">=</span> ka <span class="op">+</span> kd <span class="op">*</span> <span class="bu">max</span>(np.dot(N, L), <span class="dv">0</span>) <span class="op">+</span> ks <span class="op">*</span> (<span class="bu">max</span>(np.dot(R, V), <span class="dv">0</span>)  n)</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.clip(I, <span class="dv">0</span>, <span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>At each pixel, interpolate <code>N</code>, then call <code>phong_shading(N, L, V)</code> to compute its color intensity.</p>
</section>
<section id="why-it-matters-68" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-68">Why It Matters</h4>
<ul>
<li>Produces visually smooth shading and accurate specular highlights.</li>
<li>Became the foundation for per-pixel lighting in modern graphics hardware.</li>
<li>Accurately models curved surfaces without increasing polygon count.</li>
<li>Ideal for glossy, metallic, or reflective materials.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-55" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-55">A Gentle Proof (Why It Works)</h4>
<p>Lighting is a nonlinear function of surface orientation: the specular term <span class="math inline">\((R \cdot V)^n\)</span> depends strongly on the local angle. By interpolating normals, Phong Shading preserves this angular variation within each polygon.</p>
<p>Mathematically, Gouraud shading computes:</p>
<p><span class="math display">\[
I(x, y) = \alpha I_1 + \beta I_2 + \gamma I_3,
\]</span></p>
<p>whereas Phong computes:</p>
<p><span class="math display">\[
I(x, y) = f(\alpha N_1 + \beta N_2 + \gamma N_3),
\]</span></p>
<p>where <span class="math inline">\(f(N)\)</span> is the lighting function. Since lighting is nonlinear in <span class="math inline">\(N\)</span>, interpolating normals gives a more faithful approximation.</p>
</section>
<section id="try-it-yourself-68" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-68">Try It Yourself</h4>
<ol type="1">
<li><p>Render a sphere using flat shading, Gouraud shading, and Phong shading, compare results.</p></li>
<li><p>Place a single light source to one side, only Phong will capture the circular specular highlight.</p></li>
<li><p>Experiment with <span class="math inline">\(n\)</span> (shininess):</p>
<ul>
<li>Low <span class="math inline">\(n\)</span> → matte surface.</li>
<li>High <span class="math inline">\(n\)</span> → shiny reflection.</li>
</ul></li>
</ol>
</section>
<section id="test-cases-68" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-68">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Model</th>
<th>Shading Type</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cube</td>
<td>Flat</td>
<td>Faceted faces</td>
</tr>
<tr class="even">
<td>Sphere</td>
<td>Gouraud</td>
<td>Smooth, missing highlights</td>
</tr>
<tr class="odd">
<td>Sphere</td>
<td>Phong</td>
<td>Smooth with bright specular spot</td>
</tr>
<tr class="even">
<td>Car body</td>
<td>Phong</td>
<td>Realistic metal reflection</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-68" class="level4">
<h4 class="anchored" data-anchor-id="complexity-68">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Per-pixel lighting</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="even">
<td>Normal interpolation</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Phong Shading was the leap from <em>smooth color</em> to <em>smooth light</em>. By bringing per-pixel illumination, it bridged geometry and optics — making surfaces gleam, curves flow, and reflections shimmer like the real world.</p>
</section>
</section>
<section id="anti-aliasing-supersampling" class="level3">
<h3 class="anchored" data-anchor-id="anti-aliasing-supersampling">769 Anti-Aliasing (Supersampling)</h3>
<p>Anti-Aliasing smooths the jagged edges that appear when we draw diagonal or curved lines on a pixel grid. The most common approach, Supersampling Anti-Aliasing (SSAA), works by rendering the scene at a higher resolution and averaging neighboring pixels to produce smoother edges.</p>
<p>It’s a cornerstone of high-quality graphics, turning harsh stair-steps into soft, continuous shapes.</p>
<section id="what-problem-are-we-solving-69" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-69">What Problem Are We Solving?</h4>
<p>Digital images are made of square pixels, but most shapes in the real world aren’t. When we render a diagonal line or curve, pixelation creates visible aliasing, those “staircase” edges that look rough or flickery when moving.</p>
<p>Aliasing arises from undersampling, not enough pixel samples to represent fine details. Anti-aliasing fixes this by increasing sampling density or blending between regions.</p>
</section>
<section id="how-it-works-plain-language-14" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-14">How It Works (Plain Language)</h4>
<p>Supersampling takes multiple color samples for each pixel and averages them:</p>
<ol type="1">
<li>For each pixel, divide it into <span class="math inline">\(k \times k\)</span> subpixels.</li>
<li>Compute the color for each subpixel using the scene geometry and shading.</li>
<li>Average all subpixel colors to produce the final pixel color.</li>
</ol>
<p>This way, the pixel color reflects partial coverage, how much of the pixel is covered by the object versus the background.</p>
</section>
<section id="example-5" class="level4">
<h4 class="anchored" data-anchor-id="example-5">Example</h4>
<p>Imagine a black line crossing a white background diagonally. If a pixel is half-covered by the line, it will appear gray after supersampling, because the average of white (background) and black (line) subpixels is gray.</p>
<p>So instead of harsh transitions, you get smooth gradients at edges.</p>
</section>
<section id="mathematical-form-1" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-form-1">Mathematical Form</h4>
<p>If each pixel is divided into <span class="math inline">\(m\)</span> subpixels, the final color is:</p>
<p><span class="math display">\[
C_{\text{pixel}} = \frac{1}{m} \sum_{i=1}^{m} C_i
\]</span></p>
<p>where <span class="math inline">\(C_i\)</span> are the colors of each subpixel sample.</p>
<p>The higher <span class="math inline">\(m\)</span>, the smoother the image, at the cost of more computation.</p>
</section>
<section id="step-by-step-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-algorithm">Step-by-Step Algorithm</h4>
<ol type="1">
<li><p>Choose supersampling factor <span class="math inline">\(s\)</span> (e.g., 2×2, 4×4, 8×8).</p></li>
<li><p>For each pixel <span class="math inline">\((x, y)\)</span>:</p>
<ul>
<li><p>For each subpixel <span class="math inline">\((i, j)\)</span>: <span class="math display">\[
x' = x + \frac{i + 0.5}{s}, \quad y' = y + \frac{j + 0.5}{s}
\]</span></p>
<ul>
<li>Compute color <span class="math inline">\(C_{ij}\)</span> at <span class="math inline">\((x', y')\)</span>.</li>
</ul></li>
<li><p>Average: <span class="math display">\[
C(x, y) = \frac{1}{s^2} \sum_{i=0}^{s-1}\sum_{j=0}^{s-1} C_{ij}
\]</span></p></li>
</ul></li>
<li><p>Store <span class="math inline">\(C(x, y)\)</span> in the final frame buffer.</p></li>
</ol>
</section>
<section id="tiny-code-python-pseudocode-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-pseudocode-1">Tiny Code (Python Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> supersample(render_func, width, height, s<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.zeros((height, width, <span class="dv">3</span>))</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(height):</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(width):</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>            color_sum <span class="op">=</span> np.zeros(<span class="dv">3</span>)</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(s):</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(s):</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>                    x_sub <span class="op">=</span> x <span class="op">+</span> (i <span class="op">+</span> <span class="fl">0.5</span>) <span class="op">/</span> s</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>                    y_sub <span class="op">=</span> y <span class="op">+</span> (j <span class="op">+</span> <span class="fl">0.5</span>) <span class="op">/</span> s</span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>                    color_sum <span class="op">+=</span> render_func(x_sub, y_sub)</span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>            image[y, x] <span class="op">=</span> color_sum <span class="op">/</span> (s <span class="op">*</span> s)</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> image</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>render_func</code> computes the color of a subpixel, the heart of the renderer.</p>
</section>
<section id="why-it-matters-69" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-69">Why It Matters</h4>
<ul>
<li>Reduces jagged edges (spatial aliasing).</li>
<li>Improves motion smoothness when objects move (temporal aliasing).</li>
<li>Enhances overall image realism and visual comfort.</li>
<li>Still forms the conceptual foundation of modern techniques like MSAA, FXAA, and TAA.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-56" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-56">A Gentle Proof (Why It Works)</h4>
<p>Aliasing arises when we sample a continuous signal (the image) below the Nyquist rate — high-frequency details “fold” into visible artifacts.</p>
<p>Supersampling increases the effective sampling rate, and averaging acts as a low-pass filter, removing frequencies above the pixel grid’s limit.</p>
<p>Mathematically, if <span class="math inline">\(I(x, y)\)</span> is the true image intensity, the rendered pixel value becomes:</p>
<p><span class="math display">\[
I_{\text{pixel}} = \frac{1}{A} \iint_{A} I(x, y) , dx, dy
\]</span></p>
<p>which is the <em>area average</em> of the continuous image over the pixel region — a physically accurate model of how a real display emits light.</p>
</section>
<section id="try-it-yourself-69" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-69">Try It Yourself</h4>
<ol type="1">
<li>Render a black diagonal line on a white 100×100 grid.</li>
<li>Without anti-aliasing, observe the jagged edge.</li>
<li>Apply 4× supersampling (2×2 per pixel).</li>
<li>Compare, edges will appear smoother and more natural.</li>
</ol>
</section>
<section id="test-cases-69" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-69">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Image</th>
<th>Sampling</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Diagonal line</td>
<td>1×1</td>
<td>Jagged edges</td>
</tr>
<tr class="even">
<td>Diagonal line</td>
<td>2×2</td>
<td>Noticeably smoother</td>
</tr>
<tr class="odd">
<td>Circle outline</td>
<td>4×4</td>
<td>Smooth curvature</td>
</tr>
<tr class="even">
<td>Text rendering</td>
<td>8×8</td>
<td>Crisp and readable</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-69" class="level4">
<h4 class="anchored" data-anchor-id="complexity-69">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Supersampling factor <span class="math inline">\(s\)</span></td>
<td><span class="math inline">\(O(s^2)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="even">
<td>Filtering</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Supersampling Anti-Aliasing softens the hard geometry of pixels into something the eye perceives as continuous. It’s how the digital canvas learns to whisper curves, not just shout squares.</p>
</section>
</section>
<section id="scanline-polygon-clipping" class="level3">
<h3 class="anchored" data-anchor-id="scanline-polygon-clipping">770 Scanline Polygon Clipping</h3>
<p>Scanline Polygon Clipping is an efficient technique for trimming polygons to a given window or viewport using a horizontal sweep (scanline) approach. It’s used in 2D rendering pipelines to clip polygons before rasterization, keeping only the visible portion that falls inside the display region.</p>
<p>This algorithm combines geometric precision with raster efficiency, operating line-by-line rather than edge-by-edge.</p>
<section id="what-problem-are-we-solving-70" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-70">What Problem Are We Solving?</h4>
<p>When drawing polygons on the screen, only part of them may lie within the viewing window. We must clip (cut) the polygons so that pixels outside the window are not drawn.</p>
<p>Classical polygon clipping algorithms like Sutherland–Hodgman work edge-by-edge. Scanline Polygon Clipping instead operates per row (scanline), which matches how rasterization works — making it faster and easier to integrate with rendering pipelines.</p>
</section>
<section id="how-it-works-plain-language-15" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-15">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Represent the clipping region (usually a rectangle) and the polygon to be drawn.</p></li>
<li><p>Sweep a horizontal scanline from top to bottom.</p></li>
<li><p>For each scanline:</p>
<ul>
<li>Find all intersections of the polygon edges with this scanline.</li>
<li>Sort the intersection points by x-coordinate.</li>
<li>Fill pixels between each <em>pair</em> of intersections that lie inside the clipping region.</li>
</ul></li>
<li><p>Continue for all scanlines within the window bounds.</p></li>
</ol>
<p>This way, the algorithm naturally clips the polygon — since only intersections within the viewport are considered.</p>
</section>
<section id="example-6" class="level4">
<h4 class="anchored" data-anchor-id="example-6">Example</h4>
<p>Consider a triangle overlapping the edges of a 10×10 window. At scanline <span class="math inline">\(y = 5\)</span>, it may intersect polygon edges at <span class="math inline">\(x = 3\)</span> and <span class="math inline">\(x = 7\)</span>. Pixels <span class="math inline">\((4, 5)\)</span> through <span class="math inline">\((6, 5)\)</span> are filled; all others ignored.</p>
<p>At the next scanline <span class="math inline">\(y = 6\)</span>, the intersections might shift to <span class="math inline">\(x = 4\)</span> and <span class="math inline">\(x = 6\)</span>, automatically forming the clipped interior.</p>
</section>
<section id="mathematical-form-2" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-form-2">Mathematical Form</h4>
<p>For each polygon edge connecting <span class="math inline">\((x_1, y_1)\)</span> and <span class="math inline">\((x_2, y_2)\)</span>, find intersection with scanline <span class="math inline">\(y = y_s\)</span> using linear interpolation:</p>
<p><span class="math display">\[
x = x_1 + (y_s - y_1) \frac{(x_2 - x_1)}{(y_2 - y_1)}
\]</span></p>
<p>Include only intersections where <span class="math inline">\(y_s\)</span> lies within the edge’s vertical span.</p>
<p>After sorting intersections <span class="math inline">\((x_1', x_2', x_3', x_4', ...)\)</span>, fill between pairs <span class="math inline">\((x_1', x_2'), (x_3', x_4'), ...\)</span> — each pair represents an inside segment of the polygon.</p>
</section>
<section id="tiny-code-simplified-c-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-c-example">Tiny Code (Simplified C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb96"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">float</span> x1<span class="op">,</span> y1<span class="op">,</span> x2<span class="op">,</span> y2<span class="op">;</span> <span class="op">}</span> Edge<span class="op">;</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> scanline_clip<span class="op">(</span>Edge <span class="op">*</span>edges<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> ymin<span class="op">,</span> <span class="dt">int</span> ymax<span class="op">,</span> <span class="dt">int</span> width<span class="op">)</span> <span class="op">{</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> y <span class="op">=</span> ymin<span class="op">;</span> y <span class="op">&lt;=</span> ymax<span class="op">;</span> y<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> inter<span class="op">[</span><span class="dv">100</span><span class="op">];</span> <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">float</span> y1 <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>y1<span class="op">,</span> y2 <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>y2<span class="op">;</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>y <span class="op">&gt;=</span> y1 <span class="op">&amp;&amp;</span> y <span class="op">&lt;</span> y2<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>y <span class="op">&gt;=</span> y2 <span class="op">&amp;&amp;</span> y <span class="op">&lt;</span> y1<span class="op">))</span> <span class="op">{</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>                <span class="dt">float</span> x <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>x1 <span class="op">+</span> <span class="op">(</span>y <span class="op">-</span> y1<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>edges<span class="op">[</span>i<span class="op">].</span>x2 <span class="op">-</span> edges<span class="op">[</span>i<span class="op">].</span>x1<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>y2 <span class="op">-</span> y1<span class="op">);</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>                inter<span class="op">[</span>k<span class="op">++]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// sort intersections</span></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> k<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>inter<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> inter<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span> <span class="dt">float</span> t <span class="op">=</span> inter<span class="op">[</span>i<span class="op">];</span> inter<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> inter<span class="op">[</span>j<span class="op">];</span> inter<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> t<span class="op">;</span> <span class="op">}</span></span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// fill between pairs</span></span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>inter<span class="op">[</span>i<span class="op">];</span> x <span class="op">&lt;</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>inter<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">];</span> x<span class="op">++)</span></span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> x <span class="op">&lt;</span> width<span class="op">)</span> plot_pixel<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb96-22"><a href="#cb96-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb96-23"><a href="#cb96-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This example clips and fills polygons scanline by scanline.</p>
</section>
<section id="why-it-matters-70" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-70">Why It Matters</h4>
<ul>
<li>Perfectly integrates with rasterization, same scanline order.</li>
<li>Avoids complex polygon clipping math.</li>
<li>Works efficiently on hardware pipelines and software renderers alike.</li>
<li>Still used in embedded systems, 2D games, and vector graphics engines.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-57" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-57">A Gentle Proof (Why It Works)</h4>
<p>The polygon boundary alternates between “entering” and “exiting” the filled region as you move horizontally across a scanline. Thus, intersections always occur in even pairs, and filling between them reproduces exactly the polygon’s interior.</p>
<p>If clipping limits are <span class="math inline">\(x_{\min}\)</span> and <span class="math inline">\(x_{\max}\)</span>, the algorithm only fills within these bounds, so the output region is effectively:</p>
<p><span class="math display">\[
\text{clipped polygon} = P \cap [x_{\min}, x_{\max}] \times [y_{\min}, y_{\max}]
\]</span></p>
<p>ensuring precise clipping without geometric recomputation.</p>
</section>
<section id="try-it-yourself-70" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-70">Try It Yourself</h4>
<ol type="1">
<li>Draw a polygon partly outside a rectangular window.</li>
<li>Move a horizontal line from top to bottom, mark intersection points each step.</li>
<li>Connect them pairwise, the shaded region is your clipped polygon.</li>
<li>Observe how the clipping region trims edges automatically.</li>
</ol>
</section>
<section id="test-cases-70" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-70">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Window</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle inside</td>
<td>10×10</td>
<td>No change</td>
</tr>
<tr class="even">
<td>Square crossing edge</td>
<td>10×10</td>
<td>Trimmed at border</td>
</tr>
<tr class="odd">
<td>Star partially outside</td>
<td>10×10</td>
<td>Only visible interior rendered</td>
</tr>
<tr class="even">
<td>Polygon completely outside</td>
<td>10×10</td>
<td>No output</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-70" class="level4">
<h4 class="anchored" data-anchor-id="complexity-70">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Per scanline</td>
<td><span class="math inline">\(O(E)\)</span></td>
<td><span class="math inline">\(O(E)\)</span></td>
</tr>
<tr class="even">
<td>Overall</td>
<td><span class="math inline">\(O(E \times H)\)</span></td>
<td><span class="math inline">\(O(E)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(E\)</span> is the number of edges and <span class="math inline">\(H\)</span> is the height (number of scanlines).</p>
<p>Scanline Polygon Clipping brings geometry down to the level of the raster itself — a steady sweep line that reveals only what truly belongs on screen, turning polygons into visible art one row at a time.</p>
</section>
</section>
</section>
<section id="section-78.-computer-vision" class="level1">
<h1>Section 78. Computer Vision</h1>
<section id="canny-edge-detector" class="level3">
<h3 class="anchored" data-anchor-id="canny-edge-detector">771 Canny Edge Detector</h3>
<p>The Canny Edge Detector is one of the most influential algorithms in computer vision for detecting edges with precision and stability. It combines gradient analysis, noise reduction, and non-maximum suppression to extract clear, single-pixel-wide edges from complex images.</p>
<p>Developed by John F. Canny in 1986, it remains a gold standard for edge detection today.</p>
<section id="what-problem-are-we-solving-71" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-71">What Problem Are We Solving?</h4>
<p>Edges mark boundaries between objects or regions with distinct intensity changes. Detecting them is crucial for tasks like object recognition, segmentation, and shape analysis.</p>
<p>Naïve edge detection using gradients or Sobel filters often produces noisy, thick, or broken edges. Canny’s method provides:</p>
<ul>
<li>Low error (true edges detected)</li>
<li>Good localization (edges precisely positioned)</li>
<li>Minimal response (each edge detected once)</li>
</ul>
</section>
<section id="how-it-works-plain-language-16" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-16">How It Works (Plain Language)</h4>
<p>The Canny algorithm unfolds in five conceptual steps:</p>
<ol type="1">
<li><p>Noise Reduction Smooth the image using a Gaussian filter to reduce high-frequency noise: <span class="math display">\[
I_s = I * G_{\sigma}
\]</span> where <span class="math inline">\(G_{\sigma}\)</span> is a Gaussian kernel with standard deviation <span class="math inline">\(\sigma\)</span>.</p></li>
<li><p>Gradient Computation Compute intensity gradients using partial derivatives: <span class="math display">\[
G_x = \frac{\partial I_s}{\partial x}, \quad G_y = \frac{\partial I_s}{\partial y}
\]</span> Then find the gradient magnitude and direction: <span class="math display">\[
M(x, y) = \sqrt{G_x^2 + G_y^2}, \quad \theta(x, y) = \arctan\left(\frac{G_y}{G_x}\right)
\]</span></p></li>
<li><p>Non-Maximum Suppression Thin the edges by keeping only local maxima in the gradient direction. For each pixel, compare <span class="math inline">\(M(x, y)\)</span> to neighbors along <span class="math inline">\(\theta(x, y)\)</span>, keep it only if it’s larger.</p></li>
<li><p>Double Thresholding Use two thresholds <span class="math inline">\(T_{\text{high}}\)</span> and <span class="math inline">\(T_{\text{low}}\)</span> to classify pixels:</p>
<ul>
<li><span class="math inline">\(M &gt; T_{\text{high}}\)</span>: strong edge</li>
<li><span class="math inline">\(T_{\text{low}} &lt; M \leq T_{\text{high}}\)</span>: weak edge</li>
<li><span class="math inline">\(M \leq T_{\text{low}}\)</span>: non-edge</li>
</ul></li>
<li><p>Edge Tracking by Hysteresis Weak edges connected to strong edges are kept; others are discarded. This ensures continuity of real edges while filtering noise.</p></li>
</ol>
</section>
<section id="step-by-step-example-11" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-11">Step-by-Step Example</h4>
<p>For a grayscale image:</p>
<ol type="1">
<li>Smooth with a <span class="math inline">\(5 \times 5\)</span> Gaussian filter (<span class="math inline">\(\sigma = 1.0\)</span>).</li>
<li>Compute <span class="math inline">\(G_x\)</span> and <span class="math inline">\(G_y\)</span> using Sobel operators.</li>
<li>Compute gradient magnitude <span class="math inline">\(M\)</span>.</li>
<li>Suppress non-maxima, keeping only local peaks.</li>
<li>Apply thresholds (e.g., <span class="math inline">\(T_{\text{low}} = 0.1\)</span>, <span class="math inline">\(T_{\text{high}} = 0.3\)</span>).</li>
<li>Link weak edges to strong ones using connectivity.</li>
</ol>
<p>The final result: thin, continuous contours outlining real structures.</p>
</section>
<section id="tiny-code-python-example-with-numpy" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-with-numpy">Tiny Code (Python Example with NumPy)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load grayscale image</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"input.jpg"</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply Gaussian blur</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>blur <span class="op">=</span> cv2.GaussianBlur(img, (<span class="dv">5</span>, <span class="dv">5</span>), <span class="fl">1.0</span>)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute gradients</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>Gx <span class="op">=</span> cv2.Sobel(blur, cv2.CV_64F, <span class="dv">1</span>, <span class="dv">0</span>, ksize<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>Gy <span class="op">=</span> cv2.Sobel(blur, cv2.CV_64F, <span class="dv">0</span>, <span class="dv">1</span>, ksize<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>mag <span class="op">=</span> np.sqrt(Gx2 <span class="op">+</span> Gy2)</span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>angle <span class="op">=</span> np.arctan2(Gy, Gx)</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Use OpenCV's hysteresis thresholding for simplicity</span></span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> cv2.Canny(img, <span class="dv">100</span>, <span class="dv">200</span>)</span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">"edges.jpg"</span>, edges)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This captures all five stages compactly using OpenCV’s built-in pipeline.</p>
</section>
<section id="why-it-matters-71" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-71">Why It Matters</h4>
<ul>
<li>Detects edges reliably even in noisy conditions.</li>
<li>Provides subpixel precision when implemented with interpolation.</li>
<li>Balances sensitivity and noise control using Gaussian smoothing and hysteresis thresholds.</li>
<li>Forms the foundation for higher-level vision tasks like contour tracing, feature extraction, and segmentation.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-58" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-58">A Gentle Proof (Why It Works)</h4>
<p>Canny formulated edge detection as an optimization problem, seeking an operator that maximizes signal-to-noise ratio while maintaining localization and minimal response.</p>
<p>By modeling edges as intensity ramps corrupted by Gaussian noise, he derived that the optimal edge detector is based on the first derivative of a Gaussian:</p>
<p><span class="math display">\[
h(x) = -x e^{-\frac{x^2}{2\sigma^2}}
\]</span></p>
<p>Hence the algorithm’s design naturally balances smoothing (to suppress noise) and differentiation (to detect edges).</p>
</section>
<section id="try-it-yourself-71" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-71">Try It Yourself</h4>
<ol type="1">
<li><p>Apply Canny to a photo at different <span class="math inline">\(\sigma\)</span> values, observe how larger <span class="math inline">\(\sigma\)</span> blurs small details.</p></li>
<li><p>Experiment with thresholds <span class="math inline">\((T_{\text{low}}, T_{\text{high}})\)</span>.</p>
<ul>
<li>Too low: noise appears as edges.</li>
<li>Too high: real edges disappear.</li>
</ul></li>
<li><p>Compare Canny’s results to simple Sobel or Prewitt filters.</p></li>
</ol>
</section>
<section id="test-cases-71" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-71">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Image</th>
<th><span class="math inline">\(\sigma\)</span></th>
<th>Thresholds</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple shapes</td>
<td>1.0</td>
<td>(50, 150)</td>
<td>Crisp boundaries</td>
</tr>
<tr class="even">
<td>Noisy texture</td>
<td>2.0</td>
<td>(80, 200)</td>
<td>Clean edges</td>
</tr>
<tr class="odd">
<td>Face photo</td>
<td>1.2</td>
<td>(70, 180)</td>
<td>Facial contours preserved</td>
</tr>
<tr class="even">
<td>Satellite image</td>
<td>3.0</td>
<td>(100, 250)</td>
<td>Large-scale outlines</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-71" class="level4">
<h4 class="anchored" data-anchor-id="complexity-71">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Gradient computation</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="even">
<td>Non-max suppression</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Hysteresis tracking</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
</tbody>
</table>
<p>The Canny Edge Detector transformed how computers perceive structure in images — a union of calculus, probability, and geometry that finds beauty in the boundaries of things.</p>
</section>
</section>
<section id="sobel-operator" class="level3">
<h3 class="anchored" data-anchor-id="sobel-operator">772 Sobel Operator</h3>
<p>The Sobel Operator is a simple and powerful tool for edge detection and gradient estimation in images. It measures how brightness changes in both horizontal and vertical directions, producing an image where edges appear as regions of high intensity.</p>
<p>Although conceptually simple, it remains a cornerstone in computer vision and digital image processing.</p>
<section id="what-problem-are-we-solving-72" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-72">What Problem Are We Solving?</h4>
<p>Edges are where the intensity in an image changes sharply, often indicating object boundaries, textures, or features. To find them, we need a way to estimate the gradient (rate of change) of the image intensity.</p>
<p>The Sobel Operator provides a discrete approximation of this derivative using convolution masks, while also applying slight smoothing to reduce noise.</p>
</section>
<section id="how-it-works-plain-language-17" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-17">How It Works (Plain Language)</h4>
<p>The Sobel method uses two <span class="math inline">\(3 \times 3\)</span> convolution kernels to estimate gradients:</p>
<ul>
<li><p>Horizontal gradient (<span class="math inline">\(G_x\)</span>): <span class="math display">\[
G_x =
\begin{bmatrix}
-1 &amp; 0 &amp; +1 \
-2 &amp; 0 &amp; +2 \
-1 &amp; 0 &amp; +1
\end{bmatrix}
\]</span></p></li>
<li><p>Vertical gradient (<span class="math inline">\(G_y\)</span>): <span class="math display">\[
G_y =
\begin{bmatrix}
+1 &amp; +2 &amp; +1 \
0 &amp; 0 &amp; 0 \
-1 &amp; -2 &amp; -1
\end{bmatrix}
\]</span></p></li>
</ul>
<p>You convolve these kernels with the image to get the rate of intensity change in x and y directions.</p>
</section>
<section id="computing-the-gradient" class="level4">
<h4 class="anchored" data-anchor-id="computing-the-gradient">Computing the Gradient</h4>
<ol type="1">
<li>For each pixel <span class="math inline">\((x, y)\)</span>: <span class="math display">\[
G_x(x, y) = (I * K_x)(x, y), \quad G_y(x, y) = (I * K_y)(x, y)
\]</span></li>
<li>Compute gradient magnitude: <span class="math display">\[
M(x, y) = \sqrt{G_x^2 + G_y^2}
\]</span></li>
<li>Compute gradient direction: <span class="math display">\[
\theta(x, y) = \arctan\left(\frac{G_y}{G_x}\right)
\]</span></li>
</ol>
<p>High magnitude values correspond to strong edges.</p>
</section>
<section id="step-by-step-example-12" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-12">Step-by-Step Example</h4>
<p>For a small 3×3 patch of an image:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Pixel</th>
<th>Value</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr class="even">
<td>10</td>
<td>50</td>
<td>80</td>
</tr>
<tr class="odd">
<td>10</td>
<td>80</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>Convolving with <span class="math inline">\(G_x\)</span> and <span class="math inline">\(G_y\)</span> gives:</p>
<ul>
<li><span class="math inline">\(G_x = (+1)(80 - 10) + (+2)(100 - 10) = 320\)</span></li>
<li><span class="math inline">\(G_y = (+1)(10 - 10) + (+2)(10 - 80) = -140\)</span></li>
</ul>
<p>So: <span class="math display">\[
M = \sqrt{320^2 + (-140)^2} \approx 349.3
\]</span></p>
<p>A strong edge is detected there.</p>
</section>
<section id="tiny-code-python-example-21" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-21">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"input.jpg"</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute Sobel gradients</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>Gx <span class="op">=</span> cv2.Sobel(img, cv2.CV_64F, <span class="dv">1</span>, <span class="dv">0</span>, ksize<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>Gy <span class="op">=</span> cv2.Sobel(img, cv2.CV_64F, <span class="dv">0</span>, <span class="dv">1</span>, ksize<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Magnitude and angle</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>magnitude <span class="op">=</span> np.sqrt(Gx2 <span class="op">+</span> Gy2)</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a>angle <span class="op">=</span> np.arctan2(Gy, Gx)</span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">"sobel_edges.jpg"</span>, np.uint8(np.clip(magnitude, <span class="dv">0</span>, <span class="dv">255</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-72" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-72">Why It Matters</h4>
<ul>
<li>Fast and easy to implement.</li>
<li>Produces good edge maps for well-lit, low-noise images.</li>
<li>Forms a core part of many larger algorithms (e.g., Canny Edge Detector).</li>
<li>Ideal for feature extraction in robotics, medical imaging, and computer vision preprocessing.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-59" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-59">A Gentle Proof (Why It Works)</h4>
<p>The Sobel kernels are a discrete approximation of partial derivatives with a built-in smoothing effect. For an image intensity function <span class="math inline">\(I(x, y)\)</span>, the continuous derivatives are:</p>
<p><span class="math display">\[
\frac{\partial I}{\partial x} \approx I(x + 1, y) - I(x - 1, y)
\]</span></p>
<p>The central difference scheme is combined with vertical (or horizontal) weights <code>[1, 2, 1]</code> to suppress noise and emphasize central pixels, making Sobel robust to small fluctuations.</p>
</section>
<section id="try-it-yourself-72" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-72">Try It Yourself</h4>
<ol type="1">
<li>Apply Sobel filters separately for <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</li>
<li>Visualize <span class="math inline">\(G_x\)</span> (vertical edges) and <span class="math inline">\(G_y\)</span> (horizontal edges).</li>
<li>Combine magnitudes to see full edge strength.</li>
<li>Experiment with different image types, portraits, text, natural scenes.</li>
</ol>
</section>
<section id="test-cases-72" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-72">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Image</th>
<th>Kernel Size</th>
<th>Output Characteristics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Text on white background</td>
<td>3×3</td>
<td>Clear letter edges</td>
</tr>
<tr class="even">
<td>Landscape</td>
<td>3×3</td>
<td>Good object outlines</td>
</tr>
<tr class="odd">
<td>Noisy photo</td>
<td>5×5</td>
<td>Slight blurring but stable</td>
</tr>
<tr class="even">
<td>Medical X-ray</td>
<td>3×3</td>
<td>Highlights bone contours</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-72" class="level4">
<h4 class="anchored" data-anchor-id="complexity-72">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Convolution</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="even">
<td>Magnitude + Direction</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The Sobel Operator is simplicity at its sharpest — a small 3×3 window that reveals the geometry of light, turning subtle intensity changes into the edges that define form and structure.</p>
</section>
</section>
<section id="hough-transform-lines" class="level3">
<h3 class="anchored" data-anchor-id="hough-transform-lines">773 Hough Transform (Lines)</h3>
<p>The Hough Transform is a geometric algorithm that detects lines, circles, and other parametric shapes in images. It converts edge points in image space into a parameter space, where patterns become peaks, making it robust against noise and missing data.</p>
<p>For lines, it’s one of the most elegant ways to find all straight lines in an image, even when the edges are broken or scattered.</p>
<section id="what-problem-are-we-solving-73" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-73">What Problem Are We Solving?</h4>
<p>After edge detection (like Canny or Sobel), we have a set of pixels likely belonging to edges. But we still need to find continuous geometric structures, especially lines that connect these points.</p>
<p>A naive method would try to fit lines directly in the image, but that’s unstable when edges are incomplete. The Hough Transform solves this by accumulating votes in a transformed space where all possible lines can be represented.</p>
</section>
<section id="how-it-works-plain-language-18" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-18">How It Works (Plain Language)</h4>
<p>A line in Cartesian coordinates can be written as <span class="math display">\[
y = mx + b,
\]</span> but this form fails for vertical lines (<span class="math inline">\(m \to \infty\)</span>). So we use the polar form instead:</p>
<p><span class="math display">\[
\rho = x \cos \theta + y \sin \theta
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(\rho\)</span> is the perpendicular distance from the origin to the line,</li>
<li><span class="math inline">\(\theta\)</span> is the angle between the x-axis and the line’s normal.</li>
</ul>
<p>Each edge pixel <span class="math inline">\((x, y)\)</span> represents all possible lines passing through it. In parameter space <span class="math inline">\((\rho, \theta)\)</span>, that pixel corresponds to a sinusoidal curve.</p>
<p>Where multiple curves intersect → that point <span class="math inline">\((\rho, \theta)\)</span> represents a line supported by many edge pixels.</p>
</section>
<section id="step-by-step-algorithm-1" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-algorithm-1">Step-by-Step Algorithm</h4>
<ol type="1">
<li><p>Initialize an accumulator array <span class="math inline">\(A[\rho, \theta]\)</span> (all zeros).</p></li>
<li><p>For each edge pixel <span class="math inline">\((x, y)\)</span>:</p>
<ul>
<li>For each <span class="math inline">\(\theta\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(180^\circ\)</span>: <span class="math display">\[
\rho = x \cos \theta + y \sin \theta
\]</span> Increment accumulator cell <span class="math inline">\(A[\rho, \theta]\)</span>.</li>
</ul></li>
<li><p>Find all accumulator peaks where votes exceed a threshold. Each peak <span class="math inline">\((\rho_i, \theta_i)\)</span> corresponds to a detected line.</p></li>
<li><p>Convert these back into image space for visualization.</p></li>
</ol>
</section>
<section id="example-7" class="level4">
<h4 class="anchored" data-anchor-id="example-7">Example</h4>
<p>Suppose three points all lie roughly along a diagonal edge. Each of their sinusoidal curves in <span class="math inline">\((\rho, \theta)\)</span> space intersect near <span class="math inline">\((\rho = 50, \theta = 45^\circ)\)</span> — so a strong vote appears there.</p>
<p>That point corresponds to the line <span class="math display">\[
x \cos 45^\circ + y \sin 45^\circ = 50,
\]</span> or equivalently, <span class="math inline">\(y = -x + c\)</span> in image space.</p>
</section>
<section id="tiny-code-python-example-using-opencv" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-opencv">Tiny Code (Python Example using OpenCV)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Read and preprocess image</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"edges.jpg"</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Use Canny to get edge map</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> cv2.Canny(img, <span class="dv">100</span>, <span class="dv">200</span>)</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply Hough Transform</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> cv2.HoughLines(edges, <span class="dv">1</span>, np.pi<span class="op">/</span><span class="dv">180</span>, threshold<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw detected lines</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> rho, theta <span class="kw">in</span> lines[:, <span class="dv">0</span>]:</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> np.cos(theta), np.sin(theta)</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>    x0, y0 <span class="op">=</span> a <span class="op">*</span> rho, b <span class="op">*</span> rho</span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>    x1, y1 <span class="op">=</span> <span class="bu">int</span>(x0 <span class="op">+</span> <span class="dv">1000</span> <span class="op">*</span> (<span class="op">-</span>b)), <span class="bu">int</span>(y0 <span class="op">+</span> <span class="dv">1000</span> <span class="op">*</span> (a))</span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>    x2, y2 <span class="op">=</span> <span class="bu">int</span>(x0 <span class="op">-</span> <span class="dv">1000</span> <span class="op">*</span> (<span class="op">-</span>b)), <span class="bu">int</span>(y0 <span class="op">-</span> <span class="dv">1000</span> <span class="op">*</span> (a))</span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>    cv2.line(output, (x1, y1), (x2, y2), (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>), <span class="dv">2</span>)</span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">"hough_lines.jpg"</span>, output)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-73" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-73">Why It Matters</h4>
<ul>
<li><p>Detects lines, boundaries, and axes even with gaps or noise.</p></li>
<li><p>Tolerant to missing pixels, lines emerge from consensus, not continuity.</p></li>
<li><p>Foundation for many tasks:</p>
<ul>
<li>Lane detection in self-driving cars</li>
<li>Document alignment</li>
<li>Shape recognition</li>
<li>Industrial inspection</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-60" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-60">A Gentle Proof (Why It Works)</h4>
<p>Each edge pixel contributes evidence for all lines passing through it. If <span class="math inline">\(N\)</span> points lie approximately on the same line, their sinusoidal curves intersect in <span class="math inline">\((\rho, \theta)\)</span> space, producing a large vote count <span class="math inline">\(A[\rho, \theta] = N\)</span>.</p>
<p>This intersection property effectively turns collinearity in image space into concentration in parameter space, allowing detection via simple thresholding.</p>
<p>Formally: <span class="math display">\[
A(\rho, \theta) = \sum_{x, y \in \text{edges}} \delta(\rho - x \cos \theta - y \sin \theta)
\]</span></p>
<p>Peaks in <span class="math inline">\(A\)</span> correspond to dominant linear structures.</p>
</section>
<section id="try-it-yourself-73" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-73">Try It Yourself</h4>
<ol type="1">
<li>Run Canny edge detection on a simple shape (e.g., a rectangle).</li>
<li>Apply Hough Transform and visualize accumulator peaks.</li>
<li>Change the vote threshold to see how smaller or weaker lines appear/disappear.</li>
<li>Experiment with different <span class="math inline">\(\Delta \theta\)</span> resolutions for accuracy vs.&nbsp;speed.</li>
</ol>
</section>
<section id="test-cases-73" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-73">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 21%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th>Image</th>
<th>Expected Lines</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square shape</td>
<td>4</td>
<td>Detects all edges</td>
</tr>
<tr class="even">
<td>Road photo</td>
<td>2–3</td>
<td>Lane lines found</td>
</tr>
<tr class="odd">
<td>Grid pattern</td>
<td>Many</td>
<td>Regular peaks in accumulator</td>
</tr>
<tr class="even">
<td>Noisy background</td>
<td>Few</td>
<td>Only strong consistent edges survive</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-73" class="level4">
<h4 class="anchored" data-anchor-id="complexity-73">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Vote accumulation</td>
<td><span class="math inline">\(O(N \cdot K)\)</span></td>
<td><span class="math inline">\(O(R \times \Theta)\)</span></td>
</tr>
<tr class="even">
<td>Peak detection</td>
<td><span class="math inline">\(O(R \times \Theta)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>where</p>
<ul>
<li><span class="math inline">\(N\)</span> = number of edge pixels</li>
<li><span class="math inline">\(K\)</span> = number of <span class="math inline">\(\theta\)</span> values sampled</li>
</ul>
<p>The Hough Transform turns geometry into statistics — every edge pixel casts its vote, and when enough pixels agree, a line quietly emerges from the noise, crisp and certain.</p>
</section>
</section>
<section id="hough-transform-circles" class="level3">
<h3 class="anchored" data-anchor-id="hough-transform-circles">774 Hough Transform (Circles)</h3>
<p>The Hough Transform for Circles extends the line-based version of the transform to detect circular shapes. Instead of finding straight-line alignments, it finds sets of points that lie on the perimeter of possible circles. It’s especially useful when circles are partially visible or obscured by noise.</p>
<section id="what-problem-are-we-solving-74" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-74">What Problem Are We Solving?</h4>
<p>Edges give us candidate pixels for boundaries, but we often need to detect specific geometric shapes, like circles, ellipses, or arcs. Circle detection is vital in tasks such as:</p>
<ul>
<li>Detecting coins, pupils, or holes in objects</li>
<li>Recognizing road signs and circular logos</li>
<li>Locating circular patterns in microscopy or astronomy</li>
</ul>
<p>A circle is defined by its center <span class="math inline">\((a, b)\)</span> and radius <span class="math inline">\(r\)</span>. The goal is to find all <span class="math inline">\((a, b, r)\)</span> that fit enough edge points.</p>
</section>
<section id="how-it-works-plain-language-19" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-19">How It Works (Plain Language)</h4>
<p>A circle can be expressed as: <span class="math display">\[
(x - a)^2 + (y - b)^2 = r^2
\]</span></p>
<p>For each edge pixel <span class="math inline">\((x, y)\)</span>, every possible circle that passes through it satisfies this equation. Each <span class="math inline">\((x, y)\)</span> thus votes for all possible centers <span class="math inline">\((a, b)\)</span> for a given radius <span class="math inline">\(r\)</span>.</p>
<p>Where many votes accumulate → that’s the circle’s center.</p>
<p>When radius is unknown, the algorithm searches in 3D parameter space <span class="math inline">\((a, b, r)\)</span>:</p>
<ul>
<li><span class="math inline">\(a\)</span>: x-coordinate of center</li>
<li><span class="math inline">\(b\)</span>: y-coordinate of center</li>
<li><span class="math inline">\(r\)</span>: radius</li>
</ul>
</section>
<section id="step-by-step-algorithm-2" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-algorithm-2">Step-by-Step Algorithm</h4>
<ol type="1">
<li><p>Edge Detection Use Canny or Sobel to get an edge map.</p></li>
<li><p>Initialize Accumulator Create a 3D array <span class="math inline">\(A[a, b, r]\)</span> filled with zeros.</p></li>
<li><p>Voting Process For each edge pixel <span class="math inline">\((x, y)\)</span> and each candidate radius <span class="math inline">\(r\)</span>:</p>
<ul>
<li>Compute possible centers: <span class="math display">\[
a = x - r \cos \theta, \quad b = y - r \sin \theta
\]</span> for <span class="math inline">\(\theta\)</span> in <span class="math inline">\([0, 2\pi]\)</span>.</li>
<li>Increment accumulator cell <span class="math inline">\(A[a, b, r]\)</span>.</li>
</ul></li>
<li><p>Find Peaks Local maxima in <span class="math inline">\(A[a, b, r]\)</span> indicate detected circles.</p></li>
<li><p>Output Convert back to image space, draw circles with detected <span class="math inline">\((a, b, r)\)</span>.</p></li>
</ol>
</section>
<section id="example-8" class="level4">
<h4 class="anchored" data-anchor-id="example-8">Example</h4>
<p>Imagine a 100×100 image with an edge circle of radius 30 centered at (50, 50). Each edge point votes for all possible <span class="math inline">\((a, b)\)</span> centers corresponding to that radius. At <span class="math inline">\((50, 50)\)</span>, the votes align and produce a strong peak, revealing the circle’s center.</p>
</section>
<section id="tiny-code-python-example-using-opencv-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-opencv-1">Tiny Code (Python Example using OpenCV)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Read grayscale image</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">"input.jpg"</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> cv2.Canny(img, <span class="dv">100</span>, <span class="dv">200</span>)</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect circles</span></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>circles <span class="op">=</span> cv2.HoughCircles(img, cv2.HOUGH_GRADIENT, dp<span class="op">=</span><span class="fl">1.2</span>,</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>                           minDist<span class="op">=</span><span class="dv">20</span>, param1<span class="op">=</span><span class="dv">100</span>, param2<span class="op">=</span><span class="dv">30</span>,</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>                           minRadius<span class="op">=</span><span class="dv">10</span>, maxRadius<span class="op">=</span><span class="dv">80</span>)</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)</span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> circles <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a>    circles <span class="op">=</span> np.uint16(np.around(circles))</span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (x, y, r) <span class="kw">in</span> circles[<span class="dv">0</span>, :]:</span>
<span id="cb100-18"><a href="#cb100-18" aria-hidden="true" tabindex="-1"></a>        cv2.circle(output, (x, y), r, (<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">0</span>), <span class="dv">2</span>)</span>
<span id="cb100-19"><a href="#cb100-19" aria-hidden="true" tabindex="-1"></a>        cv2.circle(output, (x, y), <span class="dv">2</span>, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>), <span class="dv">3</span>)</span>
<span id="cb100-20"><a href="#cb100-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-21"><a href="#cb100-21" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">"hough_circles.jpg"</span>, output)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-74" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-74">Why It Matters</h4>
<ul>
<li>Detects circular objects even when partially visible.</li>
<li>Robust to noise and gaps in edges.</li>
<li>Handles varying radius ranges efficiently with optimized implementations (e.g., OpenCV’s <code>HOUGH_GRADIENT</code>).</li>
<li>Useful across fields, from robotics to biology to astronomy.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-61" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-61">A Gentle Proof (Why It Works)</h4>
<p>For every point <span class="math inline">\((x, y)\)</span>, the circle equation <span class="math display">\[
(x - a)^2 + (y - b)^2 = r^2
\]</span> describes a locus of possible centers <span class="math inline">\((a, b)\)</span>.</p>
<p>By accumulating votes from many points, true circle centers emerge as strong intersections in parameter space. Mathematically: <span class="math display">\[
A(a, b, r) = \sum_{x, y \in \text{edges}} \delta((x - a)^2 + (y - b)^2 - r^2)
\]</span></p>
<p>Peaks in <span class="math inline">\(A\)</span> correspond to circles supported by many edge points.</p>
</section>
<section id="try-it-yourself-74" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-74">Try It Yourself</h4>
<ol type="1">
<li>Use a simple image with one circle, test detection accuracy.</li>
<li>Add Gaussian noise, see how thresholds affect results.</li>
<li>Detect multiple circles with different radii.</li>
<li>Try on real images (coins, wheels, clock faces).</li>
</ol>
</section>
<section id="test-cases-74" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-74">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 15%">
<col style="width: 26%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Image</th>
<th>Radius Range</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Synthetic circle</td>
<td>10–50</td>
<td>Perfect detection</td>
<td>Simple edge pattern</td>
</tr>
<tr class="even">
<td>Coins photo</td>
<td>20–100</td>
<td>Multiple detections</td>
<td>Overlapping circles</td>
</tr>
<tr class="odd">
<td>Clock dial</td>
<td>30–80</td>
<td>Clean edges</td>
<td>Works even with partial arcs</td>
</tr>
<tr class="even">
<td>Noisy image</td>
<td>10–80</td>
<td>Some false positives</td>
<td>Can adjust <code>param2</code></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-74" class="level4">
<h4 class="anchored" data-anchor-id="complexity-74">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Voting</td>
<td><span class="math inline">\(O(N \cdot R)\)</span></td>
<td><span class="math inline">\(O(A \cdot B \cdot R)\)</span></td>
</tr>
<tr class="even">
<td>Peak detection</td>
<td><span class="math inline">\(O(A \cdot B \cdot R)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Where:</p>
<ul>
<li><span class="math inline">\(N\)</span> = number of edge pixels</li>
<li><span class="math inline">\(R\)</span> = number of radius values tested</li>
<li><span class="math inline">\((A, B)\)</span> = possible center coordinates</li>
</ul>
<p>The Hough Transform for Circles brings geometry to life — every pixel’s whisper of curvature accumulates into a clear voice of shape, revealing circles hidden in the noise and geometry woven through the image.</p>
</section>
</section>
<section id="harris-corner-detector" class="level3">
<h3 class="anchored" data-anchor-id="harris-corner-detector">775 Harris Corner Detector</h3>
<p>The Harris Corner Detector identifies <em>corners</em>, points where image intensity changes sharply in multiple directions. These points are ideal for tracking, matching, and recognizing patterns across frames or views. Unlike edge detectors (which respond to one direction of change), corner detectors respond to two.</p>
<section id="what-problem-are-we-solving-75" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-75">What Problem Are We Solving?</h4>
<p>Corners are stable, distinctive features, ideal landmarks for tasks like:</p>
<ul>
<li>Object recognition</li>
<li>Image stitching</li>
<li>Optical flow</li>
<li>3D reconstruction</li>
</ul>
<p>A good corner detector should be:</p>
<ol type="1">
<li>Repeatable (found under different lighting/viewing conditions)</li>
<li>Accurate (precise localization)</li>
<li>Efficient (fast to compute)</li>
</ol>
<p>The Harris Detector achieves all three using image gradients and a simple mathematical test.</p>
</section>
<section id="how-it-works-plain-language-20" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-20">How It Works (Plain Language)</h4>
<p>Consider shifting a small window around an image. If the window is flat, the pixel values barely change. If it’s along an edge, intensity changes in <em>one direction</em>. If it’s at a corner, intensity changes in <em>two directions</em>.</p>
<p>We can quantify that using local gradient information.</p>
</section>
<section id="mathematical-formulation" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-formulation">Mathematical Formulation</h4>
<ol type="1">
<li><p>For a window centered at <span class="math inline">\((x, y)\)</span>, define the change in intensity after a shift <span class="math inline">\((u, v)\)</span> as:</p>
<p><span class="math display">\[
E(u, v) = \sum_{x, y} w(x, y) [I(x + u, y + v) - I(x, y)]^2
\]</span></p>
<p>where <span class="math inline">\(w(x, y)\)</span> is a Gaussian weighting function.</p></li>
<li><p>Using a Taylor expansion for small shifts:</p>
<p><span class="math display">\[
I(x + u, y + v) \approx I(x, y) + I_x u + I_y v
\]</span></p>
<p>Substituting and simplifying gives:</p>
<p><span class="math display">\[
E(u, v) = [u \ v]
\begin{bmatrix}
A &amp; C \
C &amp; B
\end{bmatrix}
\begin{bmatrix}
u \
v
\end{bmatrix}
\]</span></p>
<p>where <span class="math inline">\(A = \sum w(x, y) I_x^2\)</span>, <span class="math inline">\(B = \sum w(x, y) I_y^2\)</span>, <span class="math inline">\(C = \sum w(x, y) I_x I_y\)</span>.</p>
<p>The <span class="math inline">\(2\times2\)</span> matrix <span class="math display">\[
M =
\begin{bmatrix}
A &amp; C \
C &amp; B
\end{bmatrix}
\]</span> is called the structure tensor or second-moment matrix.</p></li>
</ol>
</section>
<section id="corner-response-function" class="level4">
<h4 class="anchored" data-anchor-id="corner-response-function">Corner Response Function</h4>
<p>To determine if a point is flat, edge, or corner, we examine the eigenvalues <span class="math inline">\(\lambda_1, \lambda_2\)</span> of <span class="math inline">\(M\)</span>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th><span class="math inline">\(\lambda_1\)</span></th>
<th><span class="math inline">\(\lambda_2\)</span></th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Small</td>
<td>Small</td>
<td>Flat region</td>
<td></td>
</tr>
<tr class="even">
<td>Large</td>
<td>Small</td>
<td>Edge</td>
<td></td>
</tr>
<tr class="odd">
<td>Large</td>
<td>Large</td>
<td>Corner</td>
<td></td>
</tr>
</tbody>
</table>
<p>Instead of computing eigenvalues explicitly, Harris proposed a simpler function:</p>
<p><span class="math display">\[
R = \det(M) - k (\operatorname{trace}(M))^2
\]</span></p>
<p>where <span class="math inline">\(\det(M) = AB - C^2\)</span>, <span class="math inline">\(\operatorname{trace}(M) = A + B\)</span>, and <span class="math inline">\(k\)</span> is typically between <span class="math inline">\(0.04\)</span> and <span class="math inline">\(0.06\)</span>.</p>
<p>If <span class="math inline">\(R\)</span> is large and positive → corner. If <span class="math inline">\(R\)</span> is negative → edge. If <span class="math inline">\(R\)</span> is small → flat area.</p>
</section>
<section id="tiny-code-python-example-using-opencv-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-opencv-2">Tiny Code (Python Example using OpenCV)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">'input.jpg'</span>)</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>gray <span class="op">=</span> cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>gray <span class="op">=</span> np.float32(gray)</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>dst <span class="op">=</span> cv2.cornerHarris(gray, blockSize<span class="op">=</span><span class="dv">2</span>, ksize<span class="op">=</span><span class="dv">3</span>, k<span class="op">=</span><span class="fl">0.04</span>)</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>dst <span class="op">=</span> cv2.dilate(dst, <span class="va">None</span>)</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>img[dst <span class="op">&gt;</span> <span class="fl">0.01</span> <span class="op">*</span> dst.<span class="bu">max</span>()] <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>]</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">'harris_corners.jpg'</span>, img)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-75" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-75">Why It Matters</h4>
<ul>
<li>Detects stable, distinctive keypoints for matching and tracking.</li>
<li>Simple and computationally efficient.</li>
<li>Basis for modern detectors like Shi–Tomasi, FAST, and ORB.</li>
<li>Excellent for camera motion analysis, SLAM, and stereo vision.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-62" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-62">A Gentle Proof (Why It Works)</h4>
<p>At a true corner, both gradient directions carry significant information. The structure tensor <span class="math inline">\(M\)</span> captures these gradients through its eigenvalues.</p>
<p>When both <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span> are large, the local intensity function changes sharply regardless of shift direction, which is precisely what defines a corner.</p>
<p>The response <span class="math inline">\(R\)</span> measures this curvature indirectly through <span class="math inline">\(\det(M)\)</span> and <span class="math inline">\(\operatorname{trace}(M)\)</span>, avoiding expensive eigenvalue computation but preserving their geometric meaning.</p>
</section>
<section id="try-it-yourself-75" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-75">Try It Yourself</h4>
<ol type="1">
<li>Apply Harris to a chessboard image, perfect for corners.</li>
<li>Change parameter <span class="math inline">\(k\)</span> and threshold, watch how many corners are detected.</li>
<li>Try on natural images or faces, note that textured regions generate many responses.</li>
</ol>
</section>
<section id="test-cases-75" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-75">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 25%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th>Image</th>
<th>Expected Corners</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Checkerboard</td>
<td>~80</td>
<td>Clear sharp corners</td>
</tr>
<tr class="even">
<td>Road sign</td>
<td>4–8</td>
<td>Strong edges, stable corners</td>
</tr>
<tr class="odd">
<td>Natural scene</td>
<td>Many</td>
<td>Textures produce multiple responses</td>
</tr>
<tr class="even">
<td>Blurred photo</td>
<td>Few</td>
<td>Corners fade as gradients weaken</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-75" class="level4">
<h4 class="anchored" data-anchor-id="complexity-75">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Gradient computation</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="even">
<td>Tensor + response</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="odd">
<td>Non-max suppression</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The Harris Corner Detector finds where light bends the most in an image — the crossroads of brightness, where information density peaks, and where geometry and perception quietly agree that “something important is here.”</p>
</section>
</section>
<section id="fast-corner-detector" class="level3">
<h3 class="anchored" data-anchor-id="fast-corner-detector">776 FAST Corner Detector</h3>
<p>The FAST (Features from Accelerated Segment Test) corner detector is a lightning-fast alternative to the Harris detector. It skips heavy matrix math and instead uses a simple intensity comparison test around each pixel to determine if it is a corner. FAST is widely used in real-time applications such as SLAM, AR tracking, and mobile vision due to its remarkable speed and simplicity.</p>
<section id="what-problem-are-we-solving-76" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-76">What Problem Are We Solving?</h4>
<p>The Harris detector, while accurate, involves computing gradients and matrix operations for every pixel, expensive for large or real-time images. FAST instead tests whether a pixel’s neighborhood shows sharp brightness contrast in multiple directions, a hallmark of corner-like behavior, but without using derivatives.</p>
<p>The key idea:</p>
<blockquote class="blockquote">
<p>A pixel is a corner if a set of pixels around it are significantly brighter or darker than it by a certain threshold.</p>
</blockquote>
</section>
<section id="how-it-works-plain-language-21" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-21">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Consider a circle of 16 pixels around each candidate pixel <span class="math inline">\(p\)</span>. These are spaced evenly (Bresenham circle of radius 3).</p></li>
<li><p>For each neighbor pixel <span class="math inline">\(x\)</span>, compare its intensity <span class="math inline">\(I(x)\)</span> to <span class="math inline">\(I(p)\)</span>:</p>
<ul>
<li>Brighter if <span class="math inline">\(I(x) &gt; I(p) + t\)</span></li>
<li>Darker if <span class="math inline">\(I(x) &lt; I(p) - t\)</span></li>
</ul></li>
<li><p>A pixel <span class="math inline">\(p\)</span> is declared a corner if there exists a contiguous arc of <span class="math inline">\(n\)</span> pixels (usually <span class="math inline">\(n = 12\)</span> out of 16) that are all brighter or all darker than <span class="math inline">\(I(p)\)</span> by the threshold <span class="math inline">\(t\)</span>.</p></li>
<li><p>Perform non-maximum suppression to keep only the strongest corners.</p></li>
</ol>
<p>This test avoids floating-point computation entirely and is therefore ideal for embedded or real-time systems.</p>
</section>
<section id="mathematical-description" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-description">Mathematical Description</h4>
<p>Let <span class="math inline">\(I(p)\)</span> be the intensity at pixel <span class="math inline">\(p\)</span>, and <span class="math inline">\(S_{16}\)</span> be the 16 pixels around it. Then <span class="math inline">\(p\)</span> is a corner if there exists a sequence of <span class="math inline">\(n\)</span> contiguous pixels <span class="math inline">\(x_i\)</span> in <span class="math inline">\(S_{16}\)</span> satisfying</p>
<p><span class="math display">\[
I(x_i) &gt; I(p) + t \quad \forall i
\]</span> or <span class="math display">\[
I(x_i) &lt; I(p) - t \quad \forall i
\]</span></p>
<p>for a fixed threshold <span class="math inline">\(t\)</span>.</p>
</section>
<section id="step-by-step-algorithm-3" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-algorithm-3">Step-by-Step Algorithm</h4>
<ol type="1">
<li><p>Precompute the 16 circle offsets.</p></li>
<li><p>For each pixel <span class="math inline">\(p\)</span>:</p>
<ul>
<li>Compare four key pixels (1, 5, 9, 13) to quickly reject most candidates.</li>
<li>If at least three of these are all brighter or all darker, proceed to the full 16-pixel test.</li>
</ul></li>
<li><p>Mark <span class="math inline">\(p\)</span> as a corner if a contiguous segment of <span class="math inline">\(n\)</span> satisfies the intensity rule.</p></li>
<li><p>Apply non-maximum suppression to refine corner locations.</p></li>
</ol>
</section>
<section id="tiny-code-python-example-using-opencv-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-opencv-3">Tiny Code (Python Example using OpenCV)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">'input.jpg'</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize FAST detector</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>fast <span class="op">=</span> cv2.FastFeatureDetector_create(threshold<span class="op">=</span><span class="dv">30</span>, nonmaxSuppression<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect keypoints</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>kp <span class="op">=</span> fast.detect(img, <span class="va">None</span>)</span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw and save result</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>img_out <span class="op">=</span> cv2.drawKeypoints(img, kp, <span class="va">None</span>, color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>))</span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">'fast_corners.jpg'</span>, img_out)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-76" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-76">Why It Matters</h4>
<ul>
<li>Extremely fast and simple, no gradient, no matrix math.</li>
<li>Suitable for real-time tracking, mobile AR, and robot navigation.</li>
<li>Used as the base for higher-level descriptors like ORB (Oriented FAST and Rotated BRIEF).</li>
<li>Corner response is based purely on intensity contrast, making it efficient on low-power hardware.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-63" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-63">A Gentle Proof (Why It Works)</h4>
<p>A corner is where brightness changes sharply in multiple directions. The circular test simulates this by requiring a sequence of consistently brighter or darker pixels around a center. If intensity varies only in one direction, the contiguous condition fails, the pattern is an edge, not a corner.</p>
<p>The test effectively measures multi-directional contrast, approximating the same intuition as Harris but using simple integer comparisons instead of differential analysis.</p>
</section>
<section id="try-it-yourself-76" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-76">Try It Yourself</h4>
<ol type="1">
<li>Run FAST on a high-resolution image; note how quickly corners appear.</li>
<li>Increase or decrease the threshold <span class="math inline">\(t\)</span> to control sensitivity.</li>
<li>Compare results with Harris, are the corners similar in location but faster to compute?</li>
<li>Disable <code>nonmaxSuppression</code> to see the raw response map.</li>
</ol>
</section>
<section id="test-cases-76" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-76">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
<col style="width: 24%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Image</th>
<th>Threshold</th>
<th>Corners Detected</th>
<th>Observation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Checkerboard</td>
<td>30</td>
<td>~100</td>
<td>Very stable detection</td>
</tr>
<tr class="even">
<td>Textured wall</td>
<td>20</td>
<td>300–400</td>
<td>High density due to texture</td>
</tr>
<tr class="odd">
<td>Natural photo</td>
<td>40</td>
<td>60–120</td>
<td>Reduced to strong features</td>
</tr>
<tr class="even">
<td>Low contrast</td>
<td>15</td>
<td>Few</td>
<td>Fails in flat lighting</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-76" class="level4">
<h4 class="anchored" data-anchor-id="complexity-76">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pixel comparison</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Non-max suppression</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The runtime depends only on the image size, not the gradient or window size.</p>
<p>The FAST Corner Detector trades mathematical elegance for speed and practicality. It listens to the rhythm of brightness around each pixel — and when that rhythm changes sharply in many directions, it says, simply and efficiently, “here lies a corner.”</p>
</section>
</section>
<section id="sift-scale-invariant-feature-transform" class="level3">
<h3 class="anchored" data-anchor-id="sift-scale-invariant-feature-transform">777 SIFT (Scale-Invariant Feature Transform)</h3>
<p>The SIFT (Scale-Invariant Feature Transform) algorithm finds distinctive, repeatable keypoints in images, robust to scale, rotation, and illumination changes. It not only detects corners or blobs but also builds descriptors, small numeric fingerprints that allow features to be matched across different images. This makes SIFT a foundation for image stitching, 3D reconstruction, and object recognition.</p>
<section id="what-problem-are-we-solving-77" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-77">What Problem Are We Solving?</h4>
<p>A corner detector like Harris or FAST works only at a fixed scale and orientation. But in real-world vision tasks, objects appear at different sizes, angles, and lighting.</p>
<p>SIFT solves this by detecting scale- and rotation-invariant features. Its key insight: build a <em>scale space</em> and locate stable patterns (extrema) that persist across levels of image blur.</p>
</section>
<section id="how-it-works-plain-language-22" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-22">How It Works (Plain Language)</h4>
<p>The algorithm has four main stages:</p>
<ol type="1">
<li>Scale-space construction, progressively blur the image using Gaussians.</li>
<li>Keypoint detection, find local extrema across both space and scale.</li>
<li>Orientation assignment, compute gradient direction to make rotation invariant.</li>
<li>Descriptor generation, capture the local gradient pattern into a 128-dimensional vector.</li>
</ol>
<p>Each step strengthens invariance: first scale, then rotation, then illumination.</p>
</section>
<section id="scale-space-construction" class="level4">
<h4 class="anchored" data-anchor-id="scale-space-construction">1. Scale-Space Construction</h4>
<p>A <em>scale space</em> is created by repeatedly blurring the image with Gaussian filters of increasing standard deviation <span class="math inline">\(\sigma\)</span>.</p>
<p><span class="math display">\[
L(x, y, \sigma) = G(x, y, \sigma) * I(x, y)
\]</span></p>
<p>where</p>
<p><span class="math display">\[
G(x, y, \sigma) = \frac{1}{2\pi\sigma^2} e^{-(x^2 + y^2)/(2\sigma^2)}
\]</span></p>
<p>To detect stable structures, compute the Difference of Gaussians (DoG):</p>
<p><span class="math display">\[
D(x, y, \sigma) = L(x, y, k\sigma) - L(x, y, \sigma)
\]</span></p>
<p>The DoG approximates the Laplacian of Gaussian, a blob detector.</p>
</section>
<section id="keypoint-detection" class="level4">
<h4 class="anchored" data-anchor-id="keypoint-detection">2. Keypoint Detection</h4>
<p>A pixel is a keypoint if it is a local maximum or minimum in a <span class="math inline">\(3\times3\times3\)</span> neighborhood (across position and scale). This means it’s larger or smaller than its 26 neighbors in both space and scale.</p>
<p>Low-contrast and edge-like points are discarded to improve stability.</p>
</section>
<section id="orientation-assignment" class="level4">
<h4 class="anchored" data-anchor-id="orientation-assignment">3. Orientation Assignment</h4>
<p>For each keypoint, compute local image gradients:</p>
<p><span class="math display">\[
m(x, y) = \sqrt{(L_x)^2 + (L_y)^2}, \quad \theta(x, y) = \tan^{-1}(L_y / L_x)
\]</span></p>
<p>A histogram of gradient directions (0–360°) is built within a neighborhood around the keypoint. The peak of this histogram defines the keypoint’s orientation. If there are multiple strong peaks, multiple orientations are assigned.</p>
<p>This gives rotation invariance.</p>
</section>
<section id="descriptor-generation" class="level4">
<h4 class="anchored" data-anchor-id="descriptor-generation">4. Descriptor Generation</h4>
<p>For each oriented keypoint, take a <span class="math inline">\(16 \times 16\)</span> region around it, divided into <span class="math inline">\(4 \times 4\)</span> cells. For each cell, compute an 8-bin gradient orientation histogram, weighted by magnitude and Gaussian falloff.</p>
<p>This yields <span class="math inline">\(4 \times 4 \times 8 = 128\)</span> numbers, the SIFT descriptor vector.</p>
<p>Finally, normalize the descriptor to reduce lighting effects.</p>
</section>
<section id="tiny-code-python-example-using-opencv-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-opencv-4">Tiny Code (Python Example using OpenCV)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">'input.jpg'</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create SIFT detector</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>sift <span class="op">=</span> cv2.SIFT_create()</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect keypoints and descriptors</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>kp, des <span class="op">=</span> sift.detectAndCompute(img, <span class="va">None</span>)</span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw keypoints</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>img_out <span class="op">=</span> cv2.drawKeypoints(img, kp, <span class="va">None</span>, flags<span class="op">=</span>cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)</span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">'sift_features.jpg'</span>, img_out)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-77" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-77">Why It Matters</h4>
<ul>
<li>Scale- and rotation-invariant.</li>
<li>Robust to noise, lighting, and affine transformations.</li>
<li>Forms the basis of many modern feature matchers (e.g., SURF, ORB, AKAZE).</li>
<li>Critical for panoramic stitching, 3D reconstruction, and localization.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-64" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-64">A Gentle Proof (Why It Works)</h4>
<p>The Gaussian scale-space ensures that keypoints persist under changes in scale. Because the Laplacian of Gaussian is invariant to scaling, detecting extrema in the Difference of Gaussians approximates this behavior efficiently.</p>
<p>Assigning dominant gradient orientation ensures rotational invariance: <span class="math display">\[
f'(x', y') = f(R_\theta x, R_\theta y)
\]</span> The descriptor’s normalized histograms make it robust to illumination scaling: <span class="math display">\[
\frac{f'(x, y)}{||f'(x, y)||} = \frac{k f(x, y)}{||k f(x, y)||} = \frac{f(x, y)}{||f(x, y)||}
\]</span></p>
</section>
<section id="try-it-yourself-77" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-77">Try It Yourself</h4>
<ol type="1">
<li>Run SIFT on the same object at different scales, observe consistent keypoints.</li>
<li>Rotate the image 45°, check that SIFT matches corresponding points.</li>
<li>Use <code>cv2.BFMatcher()</code> to visualize matching between two images.</li>
</ol>
</section>
<section id="test-cases-77" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-77">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 21%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th>Scene</th>
<th>Expected Matches</th>
<th>Observation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Same object, different zoom</td>
<td>50–100</td>
<td>Stable matches</td>
</tr>
<tr class="even">
<td>Rotated view</td>
<td>50+</td>
<td>Keypoints preserved</td>
</tr>
<tr class="odd">
<td>Low light</td>
<td>30–60</td>
<td>Gradients still distinct</td>
</tr>
<tr class="even">
<td>Different objects</td>
<td>0</td>
<td>Descriptors reject false matches</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-77" class="level4">
<h4 class="anchored" data-anchor-id="complexity-77">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 31%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Gaussian pyramid</td>
<td><span class="math inline">\(O(W \times H \times S)\)</span></td>
<td><span class="math inline">\(O(W \times H \times S)\)</span></td>
</tr>
<tr class="even">
<td>DoG extrema detection</td>
<td><span class="math inline">\(O(W \times H \times S)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="odd">
<td>Descriptor computation</td>
<td><span class="math inline">\(O(K)\)</span></td>
<td><span class="math inline">\(O(K)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(S\)</span> = number of scales per octave, <span class="math inline">\(K\)</span> = number of keypoints.</p>
<p>The SIFT algorithm captures visual structure that survives transformation — like the bones beneath the skin of an image, unchanged when it grows, turns, or dims. It sees not pixels, but <em>patterns that persist through change</em>.</p>
</section>
</section>
<section id="surf-speeded-up-robust-features" class="level3">
<h3 class="anchored" data-anchor-id="surf-speeded-up-robust-features">778 SURF (Speeded-Up Robust Features)</h3>
<p>The SURF (Speeded-Up Robust Features) algorithm is a streamlined, faster alternative to SIFT. It retains robustness to scale, rotation, and illumination but replaces heavy Gaussian operations with box filters and integral images, making it ideal for near real-time applications like tracking and recognition.</p>
<section id="what-problem-are-we-solving-78" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-78">What Problem Are We Solving?</h4>
<p>SIFT is powerful but computationally expensive — especially the Gaussian pyramids and 128-dimensional descriptors.</p>
<p>SURF tackles this by:</p>
<ul>
<li>Using integral images for constant-time box filtering.</li>
<li>Approximating the Hessian determinant for keypoint detection.</li>
<li>Compressing descriptors for faster matching.</li>
</ul>
<p>The result: SIFT-level accuracy at a fraction of the cost.</p>
</section>
<section id="how-it-works-plain-language-23" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-23">How It Works (Plain Language)</h4>
<ol type="1">
<li>Detect interest points using an approximate Hessian matrix.</li>
<li>Assign orientation using Haar-wavelet responses.</li>
<li>Build descriptors from intensity gradients (but fewer and coarser than SIFT).</li>
</ol>
<p>Each part is designed to use integer arithmetic and fast summations via integral images.</p>
</section>
<section id="integral-image" class="level4">
<h4 class="anchored" data-anchor-id="integral-image">1. Integral Image</h4>
<p>An integral image allows fast computation of box filter sums:</p>
<p><span class="math display">\[
I_{\text{int}}(x, y) = \sum_{i \le x, j \le y} I(i, j)
\]</span></p>
<p>Any rectangular region sum can then be computed in <span class="math inline">\(O(1)\)</span> using only four array accesses.</p>
</section>
<section id="keypoint-detection-hessian-approximation" class="level4">
<h4 class="anchored" data-anchor-id="keypoint-detection-hessian-approximation">2. Keypoint Detection (Hessian Approximation)</h4>
<p>SURF uses the Hessian determinant to find blob-like regions:</p>
<p><span class="math display">\[
H(x, y, \sigma) =
\begin{bmatrix}
L_{xx}(x, y, \sigma) &amp; L_{xy}(x, y, \sigma) \
L_{xy}(x, y, \sigma) &amp; L_{yy}(x, y, \sigma)
\end{bmatrix}
\]</span></p>
<p>and computes the determinant:</p>
<p><span class="math display">\[
\det(H) = L_{xx} L_{yy} - (0.9L_{xy})^2
\]</span></p>
<p>where derivatives are approximated with box filters of different sizes. Local maxima across space and scale are retained as keypoints.</p>
</section>
<section id="orientation-assignment-1" class="level4">
<h4 class="anchored" data-anchor-id="orientation-assignment-1">3. Orientation Assignment</h4>
<p>For each keypoint, compute Haar wavelet responses in <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> directions within a circular region. A sliding orientation window (typically <span class="math inline">\(60^\circ\)</span> wide) finds the dominant direction.</p>
<p>This ensures rotation invariance.</p>
</section>
<section id="descriptor-generation-1" class="level4">
<h4 class="anchored" data-anchor-id="descriptor-generation-1">4. Descriptor Generation</h4>
<p>The area around each keypoint is divided into a <span class="math inline">\(4 \times 4\)</span> grid. For each cell, compute four features based on Haar responses:</p>
<p><span class="math display">\[
(v_x, v_y, |v_x|, |v_y|)
\]</span></p>
<p>These are concatenated into a 64-dimensional descriptor (vs 128 in SIFT).</p>
<p>For better matching, the descriptor is normalized:</p>
<p><span class="math display">\[
\hat{v} = \frac{v}{||v||}
\]</span></p>
</section>
<section id="tiny-code-python-example-using-opencv-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-opencv-5">Tiny Code (Python Example using OpenCV)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">'input.jpg'</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize SURF (may require nonfree module)</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>surf <span class="op">=</span> cv2.xfeatures2d.SURF_create(hessianThreshold<span class="op">=</span><span class="dv">400</span>)</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect keypoints and descriptors</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>kp, des <span class="op">=</span> surf.detectAndCompute(img, <span class="va">None</span>)</span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw and save results</span></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a>img_out <span class="op">=</span> cv2.drawKeypoints(img, kp, <span class="va">None</span>, (<span class="dv">255</span>,<span class="dv">0</span>,<span class="dv">0</span>), <span class="dv">4</span>)</span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">'surf_features.jpg'</span>, img_out)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-78" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-78">Why It Matters</h4>
<ul>
<li>Faster than SIFT, robust to blur, scale, and rotation.</li>
<li>Works well for object recognition, registration, and tracking.</li>
<li>Reduced descriptor dimensionality (64) enables faster matching.</li>
<li>Can run efficiently on mobile and embedded hardware.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-65" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-65">A Gentle Proof (Why It Works)</h4>
<p>The determinant of the Hessian captures local curvature — strong positive curvature in both directions indicates a blob or corner-like structure. Using integral images ensures that even large-scale filters can be computed in constant time:</p>
<p><span class="math display">\[
\text{BoxSum}(x_1, y_1, x_2, y_2) =
I_{\text{int}}(x_2, y_2) - I_{\text{int}}(x_2, y_1) - I_{\text{int}}(x_1, y_2) + I_{\text{int}}(x_1, y_1)
\]</span></p>
<p>Thus SURF’s speedup comes directly from mathematical simplification — replacing convolution with difference-of-box sums without losing the geometric essence of the features.</p>
</section>
<section id="try-it-yourself-78" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-78">Try It Yourself</h4>
<ol type="1">
<li>Compare SURF and SIFT keypoints on the same image.</li>
<li>Adjust <code>hessianThreshold</code>, higher values yield fewer but more stable keypoints.</li>
<li>Test on rotated or scaled versions of the image to verify invariance.</li>
</ol>
</section>
<section id="test-cases-78" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-78">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 22%">
<col style="width: 11%">
<col style="width: 17%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Image</th>
<th>Detector Threshold</th>
<th>Keypoints</th>
<th>Descriptor Dim</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Checkerboard</td>
<td>400</td>
<td>80</td>
<td>64</td>
<td>Stable grid corners</td>
</tr>
<tr class="even">
<td>Landscape</td>
<td>300</td>
<td>400</td>
<td>64</td>
<td>Rich texture</td>
</tr>
<tr class="odd">
<td>Rotated object</td>
<td>400</td>
<td>70</td>
<td>64</td>
<td>Orientation preserved</td>
</tr>
<tr class="even">
<td>Noisy image</td>
<td>200</td>
<td>200</td>
<td>64</td>
<td>Still detects stable blobs</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-78" class="level4">
<h4 class="anchored" data-anchor-id="complexity-78">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Integral image</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
<tr class="even">
<td>Hessian response</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Descriptor</td>
<td><span class="math inline">\(O(K)\)</span></td>
<td><span class="math inline">\(O(K)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(K\)</span> is the number of detected keypoints.</p>
<p>The SURF algorithm captures the essence of SIFT in half the time — a feat of mathematical efficiency, turning the elegance of continuous Gaussian space into a set of fast, discrete filters that see the world sharply and swiftly.</p>
</section>
</section>
<section id="orb-oriented-fast-and-rotated-brief" class="level3">
<h3 class="anchored" data-anchor-id="orb-oriented-fast-and-rotated-brief">779 ORB (Oriented FAST and Rotated BRIEF)</h3>
<p>The ORB (Oriented FAST and Rotated BRIEF) algorithm combines the speed of FAST with the descriptive power of BRIEF — producing a lightweight yet highly effective feature detector and descriptor. It’s designed for real-time vision tasks like SLAM, AR tracking, and image matching, and is fully open and patent-free, unlike SIFT or SURF.</p>
<section id="what-problem-are-we-solving-79" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-79">What Problem Are We Solving?</h4>
<p>SIFT and SURF are powerful but computationally expensive and historically patented. FAST is extremely fast but lacks orientation or descriptors. BRIEF is compact but not rotation invariant.</p>
<p>ORB unifies all three goals:</p>
<ul>
<li>FAST keypoints</li>
<li>Rotation invariance</li>
<li>Binary descriptors (for fast matching)</li>
</ul>
<p>All in one efficient pipeline.</p>
</section>
<section id="how-it-works-plain-language-24" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-24">How It Works (Plain Language)</h4>
<ol type="1">
<li>Detect corners using FAST.</li>
<li>Assign orientation to each keypoint based on image moments.</li>
<li>Compute a rotated BRIEF descriptor around the keypoint.</li>
<li>Use binary Hamming distance for matching.</li>
</ol>
<p>It’s both rotation- and scale-invariant, compact, and lightning fast.</p>
</section>
<section id="keypoint-detection-fast" class="level4">
<h4 class="anchored" data-anchor-id="keypoint-detection-fast">1. Keypoint Detection (FAST)</h4>
<p>ORB starts with the FAST detector to find candidate corners.</p>
<p>For each pixel <span class="math inline">\(p\)</span> and its circular neighborhood <span class="math inline">\(S_{16}\)</span>:</p>
<ul>
<li>If at least 12 contiguous pixels in <span class="math inline">\(S_{16}\)</span> are all brighter or darker than <span class="math inline">\(p\)</span> by a threshold <span class="math inline">\(t\)</span>, then <span class="math inline">\(p\)</span> is a corner.</li>
</ul>
<p>To improve stability, ORB applies FAST on a Gaussian pyramid, capturing features across multiple scales.</p>
</section>
<section id="orientation-assignment-2" class="level4">
<h4 class="anchored" data-anchor-id="orientation-assignment-2">2. Orientation Assignment</h4>
<p>Each keypoint is given an orientation using intensity moments:</p>
<p><span class="math display">\[
m_{pq} = \sum_x \sum_y x^p y^q I(x, y)
\]</span></p>
<p>The centroid of the patch is:</p>
<p><span class="math display">\[
C = \left( \frac{m_{10}}{m_{00}}, \frac{m_{01}}{m_{00}} \right)
\]</span></p>
<p>and the orientation is given by:</p>
<p><span class="math display">\[
\theta = \tan^{-1}\left(\frac{m_{01}}{m_{10}}\right)
\]</span></p>
<p>This ensures the descriptor can be aligned to the dominant direction.</p>
</section>
<section id="descriptor-generation-rotated-brief" class="level4">
<h4 class="anchored" data-anchor-id="descriptor-generation-rotated-brief">3. Descriptor Generation (Rotated BRIEF)</h4>
<p>BRIEF (Binary Robust Independent Elementary Features) builds a binary string from pairwise intensity comparisons in a patch.</p>
<p>For <span class="math inline">\(n\)</span> random pairs of pixels <span class="math inline">\((p_i, q_i)\)</span> in a patch around the keypoint:</p>
<p><span class="math display">\[
\tau(p_i, q_i) =
\begin{cases}
1, &amp; \text{if } I(p_i) &lt; I(q_i) \\
0, &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>The descriptor is the concatenation of these bits, typically 256 bits long.</p>
<p>In ORB, this sampling pattern is rotated by the keypoint’s orientation <span class="math inline">\(\theta\)</span>, giving rotation invariance.</p>
</section>
<section id="matching-hamming-distance" class="level4">
<h4 class="anchored" data-anchor-id="matching-hamming-distance">4. Matching (Hamming Distance)</h4>
<p>ORB descriptors are binary strings, so feature matching uses Hamming distance — the number of differing bits between two descriptors.</p>
<p>This makes matching incredibly fast with bitwise XOR operations.</p>
</section>
<section id="tiny-code-python-example-using-opencv-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-opencv-6">Tiny Code (Python Example using OpenCV)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> cv2.imread(<span class="st">'input.jpg'</span>, cv2.IMREAD_GRAYSCALE)</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize ORB</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>orb <span class="op">=</span> cv2.ORB_create(nfeatures<span class="op">=</span><span class="dv">500</span>)</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect keypoints and descriptors</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>kp, des <span class="op">=</span> orb.detectAndCompute(img, <span class="va">None</span>)</span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw results</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>img_out <span class="op">=</span> cv2.drawKeypoints(img, kp, <span class="va">None</span>, color<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>))</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>cv2.imwrite(<span class="st">'orb_features.jpg'</span>, img_out)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-79" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-79">Why It Matters</h4>
<ul>
<li>Fast like FAST, descriptive like SIFT, compact like BRIEF.</li>
<li>Binary descriptors make matching up to 10× faster than SIFT/SURF.</li>
<li>Fully free and open-source, ideal for commercial use.</li>
<li>Core component in SLAM, robotics, and mobile computer vision.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-66" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-66">A Gentle Proof (Why It Works)</h4>
<p>The orientation step ensures rotational invariance. Let <span class="math inline">\(I'(x, y)\)</span> be a rotated version of <span class="math inline">\(I(x, y)\)</span> by angle <span class="math inline">\(\theta\)</span>. Then the centroid-based orientation guarantees that:</p>
<p><span class="math display">\[
BRIEF'(p_i, q_i) = BRIEF(R_{-\theta} p_i, R_{-\theta} q_i)
\]</span></p>
<p>meaning the same keypoint produces the same binary descriptor after rotation.</p>
<p>Hamming distance is a metric for binary vectors, so matching remains efficient and robust even under moderate illumination changes.</p>
</section>
<section id="try-it-yourself-79" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-79">Try It Yourself</h4>
<ol type="1">
<li>Detect ORB keypoints on two rotated versions of the same image.</li>
<li>Use <code>cv2.BFMatcher(cv2.NORM_HAMMING)</code> to match features.</li>
<li>Compare speed with SIFT, notice how fast ORB runs.</li>
<li>Increase <code>nfeatures</code> and test the tradeoff between accuracy and runtime.</li>
</ol>
</section>
<section id="test-cases-79" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-79">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 11%">
<col style="width: 21%">
<col style="width: 17%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Scene</th>
<th>Keypoints</th>
<th>Descriptor Length</th>
<th>Matching Speed</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Checkerboard</td>
<td>~500</td>
<td>256 bits</td>
<td>Fast</td>
<td>Stable grid corners</td>
</tr>
<tr class="even">
<td>Rotated object</td>
<td>~400</td>
<td>256 bits</td>
<td>Fast</td>
<td>Rotation preserved</td>
</tr>
<tr class="odd">
<td>Low contrast</td>
<td>~200</td>
<td>256 bits</td>
<td>Fast</td>
<td>Contrast affects FAST</td>
</tr>
<tr class="even">
<td>Real-time video</td>
<td>300–1000</td>
<td>256 bits</td>
<td>Real-time</td>
<td>Works on embedded devices</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-79" class="level4">
<h4 class="anchored" data-anchor-id="complexity-79">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FAST detection</td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>BRIEF descriptor</td>
<td><span class="math inline">\(O(K)\)</span></td>
<td><span class="math inline">\(O(K)\)</span></td>
</tr>
<tr class="odd">
<td>Matching (Hamming)</td>
<td><span class="math inline">\(O(K \log K)\)</span></td>
<td><span class="math inline">\(O(K)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(K\)</span> = number of keypoints.</p>
<p>The ORB algorithm is the street-smart hybrid of computer vision — it knows SIFT’s elegance, BRIEF’s thrift, and FAST’s hustle. Quick on its feet, rotation-aware, and bitwise efficient, it captures structure with speed that even hardware loves.</p>
</section>
</section>
<section id="ransac-random-sample-consensus" class="level3">
<h3 class="anchored" data-anchor-id="ransac-random-sample-consensus">780 RANSAC (Random Sample Consensus)</h3>
<p>The RANSAC (Random Sample Consensus) algorithm is a robust method for estimating models from data that contain outliers. It repeatedly fits models to random subsets of points and selects the one that best explains the majority of data. In computer vision, RANSAC is a backbone of feature matching, homography estimation, and motion tracking, it finds structure amid noise.</p>
<section id="what-problem-are-we-solving-80" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-80">What Problem Are We Solving?</h4>
<p>Real-world data is messy. When matching points between two images, some correspondences are wrong, these are outliers. If you run standard least-squares fitting, even a few bad matches can ruin your model.</p>
<p>RANSAC solves this by embracing randomness: it tests many small subsets, trusting consensus rather than precision from any single sample.</p>
</section>
<section id="how-it-works-plain-language-25" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-25">How It Works (Plain Language)</h4>
<p>RANSAC’s idea is simple:</p>
<ol type="1">
<li>Randomly pick a minimal subset of data points.</li>
<li>Fit a model to this subset.</li>
<li>Count how many other points agree with this model within a tolerance, these are inliers.</li>
<li>Keep the model with the largest inlier set.</li>
<li>Optionally, refit the model using all inliers for precision.</li>
</ol>
<p>You don’t need all the data, just enough agreement.</p>
</section>
<section id="mathematical-overview" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-overview">Mathematical Overview</h4>
<p>Let:</p>
<ul>
<li><span class="math inline">\(N\)</span> = total number of data points</li>
<li><span class="math inline">\(s\)</span> = number of points needed to fit the model (e.g.&nbsp;<span class="math inline">\(s=2\)</span> for a line, <span class="math inline">\(s=4\)</span> for a homography)</li>
<li><span class="math inline">\(p\)</span> = probability that at least one random sample is free of outliers</li>
<li><span class="math inline">\(\epsilon\)</span> = fraction of outliers</li>
</ul>
<p>Then the required number of iterations <span class="math inline">\(k\)</span> is:</p>
<p><span class="math display">\[
k = \frac{\log(1 - p)}{\log(1 - (1 - \epsilon)^s)}
\]</span></p>
<p>This tells us how many random samples to test for a given confidence.</p>
</section>
<section id="example-line-fitting" class="level4">
<h4 class="anchored" data-anchor-id="example-line-fitting">Example: Line Fitting</h4>
<p>Given 2D points, we want to find the best line <span class="math inline">\(y = mx + c\)</span>.</p>
<ol type="1">
<li>Randomly select two points.</li>
<li>Compute slope <span class="math inline">\(m\)</span> and intercept <span class="math inline">\(c\)</span>.</li>
<li>Count how many other points lie within distance <span class="math inline">\(d\)</span> of this line:</li>
</ol>
<p><span class="math display">\[
\text{error}(x_i, y_i) = \frac{|y_i - (mx_i + c)|}{\sqrt{1 + m^2}}
\]</span></p>
<ol start="4" type="1">
<li>The line with the largest number of inliers is chosen as the best.</li>
</ol>
</section>
<section id="tiny-code-python-example-22" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-22">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ransac_line(points, n_iter<span class="op">=</span><span class="dv">1000</span>, threshold<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    best_m, best_c, best_inliers <span class="op">=</span> <span class="va">None</span>, <span class="va">None</span>, []</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_iter):</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>        sample <span class="op">=</span> random.sample(points, <span class="dv">2</span>)</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>        (x1, y1), (x2, y2) <span class="op">=</span> sample</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x2 <span class="op">==</span> x1:</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> (y2 <span class="op">-</span> y1) <span class="op">/</span> (x2 <span class="op">-</span> x1)</span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> y1 <span class="op">-</span> m <span class="op">*</span> x1</span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>        inliers <span class="op">=</span> []</span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (x, y) <span class="kw">in</span> points:</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>            err <span class="op">=</span> <span class="bu">abs</span>(y <span class="op">-</span> (m<span class="op">*</span>x <span class="op">+</span> c)) <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">+</span> m2)</span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> err <span class="op">&lt;</span> threshold:</span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>                inliers.append((x, y))</span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(inliers) <span class="op">&gt;</span> <span class="bu">len</span>(best_inliers):</span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a>            best_inliers <span class="op">=</span> inliers</span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a>            best_m, best_c <span class="op">=</span> m, c</span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_m, best_c, best_inliers</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-80" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-80">Why It Matters</h4>
<ul>
<li>Robust to outliers, works even if 50–80% of the data is bad.</li>
<li>Model-agnostic, can fit lines, planes, fundamental matrices, homographies, etc.</li>
<li>Simple and flexible, only needs a model-fitting routine and an error metric.</li>
</ul>
<p>Used everywhere from:</p>
<ul>
<li>Image stitching (homography estimation)</li>
<li>Stereo vision (epipolar geometry)</li>
<li>3D reconstruction</li>
<li>Motion estimation in robotics</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-67" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-67">A Gentle Proof (Why It Works)</h4>
<p>Each random subset has a probability <span class="math inline">\((1 - \epsilon)^s\)</span> of containing only inliers. After <span class="math inline">\(k\)</span> iterations, the probability that no sample is pure is <span class="math inline">\((1 - (1 - \epsilon)^s)^k\)</span>. Setting this equal to <span class="math inline">\(1 - p\)</span> gives the iteration formula above.</p>
<p>Thus, after enough random trials, RANSAC almost certainly finds a model supported by the majority — without being swayed by the minority of outliers.</p>
</section>
<section id="try-it-yourself-80" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-80">Try It Yourself</h4>
<ol type="1">
<li>Generate a noisy dataset with 20% outliers and fit a line using RANSAC.</li>
<li>Compare with least-squares, notice how RANSAC stays stable.</li>
<li>Apply to feature matching between two photos using <code>cv2.findHomography(..., cv2.RANSAC)</code>.</li>
</ol>
</section>
<section id="test-cases-80" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-80">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 14%">
<col style="width: 25%">
<col style="width: 12%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>Data</th>
<th>Outlier Ratio</th>
<th>Model</th>
<th>Inlier Rate</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line points + noise</td>
<td>20%</td>
<td><span class="math inline">\(y = mx + c\)</span></td>
<td>95%</td>
<td>Perfect recovery</td>
</tr>
<tr class="even">
<td>Plane in 3D</td>
<td>40%</td>
<td><span class="math inline">\(ax + by + cz + d = 0\)</span></td>
<td>90%</td>
<td>Robust to bad data</td>
</tr>
<tr class="odd">
<td>Homography</td>
<td>50%</td>
<td>3×3 matrix</td>
<td>85%</td>
<td>Used in image stitching</td>
</tr>
<tr class="even">
<td>Random noise</td>
<td>90%</td>
<td>N/A</td>
<td>Low</td>
<td>Cannot converge</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-80" class="level4">
<h4 class="anchored" data-anchor-id="complexity-80">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sampling &amp; fitting</td>
<td><span class="math inline">\(O(k \cdot s)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Inlier counting</td>
<td><span class="math inline">\(O(kN)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Overall: <span class="math inline">\(O(kN)\)</span>, where <span class="math inline">\(k\)</span> depends on desired confidence and outlier ratio.</p>
<p>The RANSAC algorithm is the skeptic’s way of seeing truth — it ignores the crowd, listens to a few honest voices, and keeps sampling until consensus reveals the right line through the noise.</p>
</section>
</section>
</section>
<section id="section-79.-pathfinding-in-space" class="level1">
<h1>Section 79. Pathfinding in Space</h1>
<section id="a-search" class="level3">
<h3 class="anchored" data-anchor-id="a-search">781 A* Search</h3>
<p>The A* (A-star) algorithm is one of the most elegant and efficient pathfinding algorithms ever designed. It finds the shortest path between a start and goal node in a graph while minimizing total cost. Used everywhere from navigation systems and robotics to games and AI planning, A* balances greedy search and uniform cost search through a clever use of heuristics.</p>
<section id="what-problem-are-we-solving-81" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-81">What Problem Are We Solving?</h4>
<p>Given a set of connected nodes (or a grid map) with movement costs between them, we want the shortest, least-cost path from a start point to a goal point.</p>
<p>Unlike Dijkstra’s algorithm, which explores in all directions, A* uses a heuristic to guide the search toward the goal, much faster and still guaranteed to find the optimal path (under certain conditions).</p>
</section>
<section id="how-it-works-plain-language-26" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-26">How It Works (Plain Language)</h4>
<p>A* keeps two key quantities for each node:</p>
<ul>
<li><span class="math inline">\(g(n)\)</span>, cost from start to this node</li>
<li><span class="math inline">\(h(n)\)</span>, estimated cost from this node to the goal (the heuristic)</li>
<li><span class="math inline">\(f(n) = g(n) + h(n)\)</span>, total estimated cost through this node</li>
</ul>
<p>It expands the node with the lowest <span class="math inline">\(f(n)\)</span> until the goal is reached. The heuristic keeps the search focused; <span class="math inline">\(g\)</span> ensures optimality.</p>
</section>
<section id="step-by-step-algorithm-4" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-algorithm-4">Step-by-Step Algorithm</h4>
<ol type="1">
<li><p>Initialize two sets:</p>
<ul>
<li>Open list, nodes to be evaluated (start node initially)</li>
<li>Closed list, nodes already evaluated</li>
</ul></li>
<li><p>For the current node:</p>
<ul>
<li>Compute <span class="math inline">\(f(n) = g(n) + h(n)\)</span></li>
<li>Choose the node with lowest <span class="math inline">\(f(n)\)</span> in the open list</li>
<li>Move it to the closed list</li>
</ul></li>
<li><p>For each neighbor:</p>
<ul>
<li><p>Compute tentative <span class="math inline">\(g_{new} = g(\text{current}) + \text{cost(current, neighbor)}\)</span></p></li>
<li><p>If neighbor not in open list or <span class="math inline">\(g_{new}\)</span> is smaller, update it:</p>
<ul>
<li><span class="math inline">\(g(\text{neighbor}) = g_{new}\)</span></li>
<li><span class="math inline">\(f(\text{neighbor}) = g_{new} + h(\text{neighbor})\)</span></li>
<li>Set parent to current</li>
</ul></li>
</ul></li>
<li><p>Stop when goal node is selected for expansion.</p></li>
</ol>
</section>
<section id="heuristic-examples" class="level4">
<h4 class="anchored" data-anchor-id="heuristic-examples">Heuristic Examples</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 52%">
<col style="width: 9%">
<col style="width: 0%">
<col style="width: 8%">
<col style="width: 0%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Heuristic Function <span class="math inline">\(h(n)\)</span></th>
<th>Property</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Grid (4-neighbor)</td>
<td>Manhattan distance $</td>
<td>x_1 - x_2</td>
<td>+</td>
<td>y_1 - y_2</td>
<td>$</td>
<td>Admissible</td>
</tr>
<tr class="even">
<td>Grid (8-neighbor)</td>
<td>Euclidean distance <span class="math inline">\(\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\)</span></td>
<td>Admissible</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Weighted graph</td>
<td>Minimum edge weight × remaining nodes</td>
<td>Admissible</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>A heuristic is admissible if it never overestimates the true cost to the goal. If it’s also consistent, A* guarantees optimality without revisiting nodes.</p>
</section>
<section id="tiny-code-python-example-23" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-23">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> a_star(start, goal, neighbors, heuristic):</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    open_set <span class="op">=</span> [(<span class="dv">0</span>, start)]</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    came_from <span class="op">=</span> {}</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> open_set:</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>        _, current <span class="op">=</span> heapq.heappop(open_set)</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current <span class="op">==</span> goal:</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> current <span class="kw">in</span> came_from:</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>                path.append(current)</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>                current <span class="op">=</span> came_from[current]</span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> next_node, cost <span class="kw">in</span> neighbors(current):</span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>            new_g <span class="op">=</span> g[current] <span class="op">+</span> cost</span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> next_node <span class="kw">not</span> <span class="kw">in</span> g <span class="kw">or</span> new_g <span class="op">&lt;</span> g[next_node]:</span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a>                g[next_node] <span class="op">=</span> new_g</span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> new_g <span class="op">+</span> heuristic(next_node, goal)</span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(open_set, (f, next_node))</span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>                came_from[next_node] <span class="op">=</span> current</span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-81" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-81">Why It Matters</h4>
<ul>
<li><p>Optimal and complete (with admissible heuristics)</p></li>
<li><p>Efficient, explores only promising paths</p></li>
<li><p>Widely used in:</p>
<ul>
<li>GPS navigation</li>
<li>Video game AI (NPC movement)</li>
<li>Robot motion planning</li>
<li>Graph-based optimization problems</li>
</ul></li>
</ul>
<p>A* is a beautiful example of how a simple idea, combining real cost and estimated cost, produces deep practical power.</p>
</section>
<section id="a-gentle-proof-why-it-works-68" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-68">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(f(n) = g(n) + h(n)\)</span>. If <span class="math inline">\(h(n)\)</span> never overestimates the true distance to the goal, then the first time the goal node is selected for expansion, the path found must have the minimum cost.</p>
<p>Formally, for admissible <span class="math inline">\(h\)</span>:</p>
<p><span class="math display">\[
h(n) \le h^*(n)
\]</span></p>
<p>where <span class="math inline">\(h^*(n)\)</span> is the true cost to goal. Thus <span class="math inline">\(f(n)\)</span> is always a lower bound on the total cost through <span class="math inline">\(n\)</span>, and A* never misses the globally optimal path.</p>
</section>
<section id="try-it-yourself-81" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-81">Try It Yourself</h4>
<ol type="1">
<li>Implement A* on a 2D grid, mark walls as obstacles.</li>
<li>Try different heuristics (Manhattan, Euclidean, zero).</li>
<li>Compare to Dijkstra, notice how A* expands fewer nodes.</li>
<li>Visualize the open/closed lists, it’s like watching reasoning unfold on a map.</li>
</ol>
</section>
<section id="test-cases-81" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-81">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Grid Size</th>
<th>Obstacles</th>
<th>Heuristic</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5×5</td>
<td>None</td>
<td>Manhattan</td>
<td>Straight path</td>
</tr>
<tr class="even">
<td>10×10</td>
<td>Random 20%</td>
<td>Manhattan</td>
<td>Detour path found</td>
</tr>
<tr class="odd">
<td>50×50</td>
<td>Maze</td>
<td>Euclidean</td>
<td>Efficient shortest path</td>
</tr>
<tr class="even">
<td>100×100</td>
<td>30%</td>
<td>Zero (Dijkstra)</td>
<td>Slower but same path</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-81" class="level4">
<h4 class="anchored" data-anchor-id="complexity-81">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 55%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th>Meaning</th>
<th>Typical Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Time</td>
<td><span class="math inline">\(O(E)\)</span> worst case, usually much less</td>
<td>Depends on heuristic</td>
</tr>
<tr class="even">
<td>Space</td>
<td><span class="math inline">\(O(V)\)</span></td>
<td>Store open + closed sets</td>
</tr>
</tbody>
</table>
<p>With an admissible heuristic, A* can approach linear time in sparse maps, remarkably efficient for a general optimal search.</p>
<p>The A* algorithm walks the line between foresight and discipline — it doesn’t wander aimlessly like Dijkstra, nor does it leap blindly like Greedy Best-First. It <em>plans</em>, balancing knowledge of the road traveled and intuition of the road ahead.</p>
</section>
</section>
<section id="dijkstra-for-grid" class="level3">
<h3 class="anchored" data-anchor-id="dijkstra-for-grid">782 Dijkstra for Grid</h3>
<p>Dijkstra’s algorithm is the classic foundation of shortest-path computation. In its grid-based version, it systematically explores all reachable nodes in order of increasing cost, guaranteeing the shortest route to every destination. While A* adds a heuristic, Dijkstra operates purely on accumulated distance, making it the gold standard for unbiased, optimal pathfinding when no goal direction or heuristic is known.</p>
<section id="what-problem-are-we-solving-82" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-82">What Problem Are We Solving?</h4>
<p>Given a 2D grid (or any weighted graph), each cell has edges to its neighbors with movement cost <span class="math inline">\(w \ge 0\)</span>. We want to find the minimum total cost path from a source to all other nodes — or to a specific goal if one exists.</p>
<p>Dijkstra ensures that once a node’s cost is finalized, no shorter path to it can ever exist.</p>
</section>
<section id="how-it-works-plain-language-27" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-27">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Assign distance <span class="math inline">\(d = 0\)</span> to the start cell and <span class="math inline">\(∞\)</span> to all others.</p></li>
<li><p>Place the start in a priority queue.</p></li>
<li><p>Repeatedly pop the node with the lowest current cost.</p></li>
<li><p>For each neighbor, compute tentative distance:</p>
<p><span class="math display">\[
d_{new} = d_{current} + w(current, neighbor)
\]</span></p>
<p>If <span class="math inline">\(d_{new}\)</span> is smaller, update the neighbor’s distance and reinsert it into the queue.</p></li>
<li><p>Continue until all nodes are processed or the goal is reached.</p></li>
</ol>
<p>Each node is “relaxed” exactly once, ensuring efficiency and optimality.</p>
</section>
<section id="example-4-neighbor-grid" class="level4">
<h4 class="anchored" data-anchor-id="example-4-neighbor-grid">Example (4-neighbor grid)</h4>
<p>Consider a grid where moving horizontally or vertically costs 1:</p>
<p><span class="math display">\[
\text{Start} = (0, 0), \quad \text{Goal} = (3, 3)
\]</span></p>
<p>After each expansion, the wavefront of known minimal distances expands outward:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Frontier Cells</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>(0,0)</td>
<td>0</td>
</tr>
<tr class="even">
<td>2</td>
<td>(0,1), (1,0)</td>
<td>1</td>
</tr>
<tr class="odd">
<td>3</td>
<td>(0,2), (1,1), (2,0)</td>
<td>2</td>
</tr>
<tr class="even">
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="odd">
<td>6</td>
<td>(3,3)</td>
<td>6</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-24" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-24">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra_grid(start, goal, grid):</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, start)]</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>    came_from <span class="op">=</span> {}</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> neighbors(cell):</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> cell</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>)]:</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>            nx, ny <span class="op">=</span> x<span class="op">+</span>dx, y<span class="op">+</span>dy</span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> cols <span class="kw">and</span> grid[nx][ny] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">yield</span> (nx, ny), <span class="dv">1</span>  <span class="co"># cost 1</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>        d, current <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current <span class="op">==</span> goal:</span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (nxt, cost) <span class="kw">in</span> neighbors(current):</span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>            new_d <span class="op">=</span> d <span class="op">+</span> cost</span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> new_d <span class="op">&lt;</span> dist.get(nxt, <span class="bu">float</span>(<span class="st">'inf'</span>)):</span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>                dist[nxt] <span class="op">=</span> new_d</span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>                came_from[nxt] <span class="op">=</span> current</span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (new_d, nxt))</span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist, came_from</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-82" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-82">Why It Matters</h4>
<ul>
<li>Optimal and complete, always finds the shortest path.</li>
<li>Foundation for modern algorithms like A*, Bellman–Ford, and Floyd–Warshall.</li>
<li>Versatile, works for grids, networks, and weighted graphs.</li>
<li>Deterministic, explores all equally good paths without heuristic bias.</li>
</ul>
<p>Used in:</p>
<ul>
<li>Network routing (e.g., OSPF, BGP)</li>
<li>Game AI for exploration zones</li>
<li>Path planning for autonomous robots</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-69" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-69">A Gentle Proof (Why It Works)</h4>
<p>The key invariant: when a node <span class="math inline">\(u\)</span> is removed from the priority queue, its shortest path distance <span class="math inline">\(d(u)\)</span> is final.</p>
<p>Proof sketch: If there were a shorter path to <span class="math inline">\(u\)</span>, some intermediate node <span class="math inline">\(v\)</span> on that path would have a smaller tentative distance, so <span class="math inline">\(v\)</span> would have been extracted before <span class="math inline">\(u\)</span>. Thus, <span class="math inline">\(d(u)\)</span> cannot be improved afterward.</p>
<p>This guarantees optimality with non-negative edge weights.</p>
</section>
<section id="try-it-yourself-82" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-82">Try It Yourself</h4>
<ol type="1">
<li>Run Dijkstra on a grid with different obstacle patterns.</li>
<li>Modify edge weights to simulate terrain (e.g., grass = 1, mud = 3).</li>
<li>Compare explored nodes with A<em>, notice how Dijkstra expands evenly, while A</em> focuses toward the goal.</li>
<li>Implement an 8-direction version and measure the path difference.</li>
</ol>
</section>
<section id="test-cases-82" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-82">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 16%">
<col style="width: 26%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>Grid</th>
<th>Obstacle %</th>
<th>Cost Metric</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5×5</td>
<td>0</td>
<td>Uniform</td>
<td>Straight line</td>
</tr>
<tr class="even">
<td>10×10</td>
<td>20</td>
<td>Uniform</td>
<td>Detour found</td>
</tr>
<tr class="odd">
<td>10×10</td>
<td>0</td>
<td>Variable weights</td>
<td>Follows low-cost path</td>
</tr>
<tr class="even">
<td>100×100</td>
<td>30</td>
<td>Uniform</td>
<td>Expands all reachable cells</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-82" class="level4">
<h4 class="anchored" data-anchor-id="complexity-82">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 45%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Priority queue operations</td>
<td><span class="math inline">\(O((V + E)\log V)\)</span></td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
<tr class="even">
<td>Grid traversal</td>
<td><span class="math inline">\(O(W \times H \log (W \times H))\)</span></td>
<td><span class="math inline">\(O(W \times H)\)</span></td>
</tr>
</tbody>
</table>
<p>In uniform-cost grids, it behaves like a breadth-first search with weighted precision.</p>
<p>The Dijkstra algorithm is the calm and methodical explorer of the algorithmic world — it walks outward in perfect order, considering every possible road until all are measured, guaranteeing that every destination receives the shortest, fairest path possible.</p>
</section>
</section>
<section id="theta-any-angle-pathfinding" class="level3">
<h3 class="anchored" data-anchor-id="theta-any-angle-pathfinding">783 Theta* (Any-Angle Pathfinding)</h3>
<p>Theta* is an extension of A* that allows any-angle movement on grids, producing paths that look more natural and shorter than those constrained to 4 or 8 directions. It bridges the gap between discrete grid search and continuous geometric optimization, making it a favorite for robotics, drone navigation, and games where agents move freely through open space.</p>
<section id="what-problem-are-we-solving-83" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-83">What Problem Are We Solving?</h4>
<p>In classic A<em>, movement is limited to grid directions (up, down, diagonal). Even if the optimal geometric path is straight, A</em> produces jagged “staircase” routes.</p>
<p>Theta* removes this restriction by checking line-of-sight between nodes: if the current node’s parent can directly see a successor, it connects them without following grid edges, yielding a smoother, shorter path.</p>
</section>
<section id="how-it-works-plain-language-28" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-28">How It Works (Plain Language)</h4>
<p>Theta* works like A* but modifies how parent connections are made.</p>
<p>For each neighbor <code>s'</code> of the current node <code>s</code>:</p>
<ol type="1">
<li><p>Check if <code>parent(s)</code> has line-of-sight to <code>s'</code>.</p>
<ul>
<li>If yes, set <span class="math display">\[
g(s') = g(parent(s)) + \text{dist}(parent(s), s')
\]</span> and <span class="math display">\[
parent(s') = parent(s)
\]</span></li>
</ul></li>
<li><p>Otherwise, behave like standard A*: <span class="math display">\[
g(s') = g(s) + \text{dist}(s, s')
\]</span> and <span class="math display">\[
parent(s') = s
\]</span></p></li>
<li><p>Update the priority queue with <span class="math display">\[
f(s') = g(s') + h(s')
\]</span></p></li>
</ol>
<p>This simple geometric relaxation gives near-optimal continuous paths without increasing asymptotic complexity.</p>
</section>
<section id="tiny-code-python-example-25" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-25">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq, math</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> line_of_sight(grid, a, b):</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bresenham-style line check</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    x0, y0 <span class="op">=</span> a</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>    x1, y1 <span class="op">=</span> b</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>    dx, dy <span class="op">=</span> <span class="bu">abs</span>(x1<span class="op">-</span>x0), <span class="bu">abs</span>(y1<span class="op">-</span>y0)</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    sx, sy <span class="op">=</span> (<span class="dv">1</span> <span class="cf">if</span> x1 <span class="op">&gt;</span> x0 <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>), (<span class="dv">1</span> <span class="cf">if</span> y1 <span class="op">&gt;</span> y0 <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>    err <span class="op">=</span> dx <span class="op">-</span> dy</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> grid[x0][y0] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x0, y0) <span class="op">==</span> (x1, y1):</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>        e2 <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>err</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> e2 <span class="op">&gt;</span> <span class="op">-</span>dy: err <span class="op">-=</span> dy<span class="op">;</span> x0 <span class="op">+=</span> sx</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> e2 <span class="op">&lt;</span> dx: err <span class="op">+=</span> dx<span class="op">;</span> y0 <span class="op">+=</span> sy</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> theta_star(grid, start, goal, heuristic):</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> {start: start}</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>    open_set <span class="op">=</span> [(heuristic(start, goal), start)]</span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dist(a, b): <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> open_set:</span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>        _, s <span class="op">=</span> heapq.heappop(open_set)</span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s <span class="op">==</span> goal:</span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> s <span class="op">!=</span> parent[s]:</span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>                path.append(s)</span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> parent[s]</span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true" tabindex="-1"></a>            path.append(start)</span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]:</span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> dy <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]:</span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dx <span class="op">==</span> dy <span class="op">==</span> <span class="dv">0</span>: <span class="cf">continue</span></span>
<span id="cb109-39"><a href="#cb109-39" aria-hidden="true" tabindex="-1"></a>                s2 <span class="op">=</span> (s[<span class="dv">0</span>]<span class="op">+</span>dx, s[<span class="dv">1</span>]<span class="op">+</span>dy)</span>
<span id="cb109-40"><a href="#cb109-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> (<span class="dv">0</span> <span class="op">&lt;=</span> s2[<span class="dv">0</span>] <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> s2[<span class="dv">1</span>] <span class="op">&lt;</span> cols): <span class="cf">continue</span></span>
<span id="cb109-41"><a href="#cb109-41" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> grid[s2[<span class="dv">0</span>]][s2[<span class="dv">1</span>]] <span class="op">==</span> <span class="dv">1</span>: <span class="cf">continue</span></span>
<span id="cb109-42"><a href="#cb109-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> line_of_sight(grid, parent[s], s2):</span>
<span id="cb109-43"><a href="#cb109-43" aria-hidden="true" tabindex="-1"></a>                    new_g <span class="op">=</span> g[parent[s]] <span class="op">+</span> dist(parent[s], s2)</span>
<span id="cb109-44"><a href="#cb109-44" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> new_g <span class="op">&lt;</span> g.get(s2, <span class="bu">float</span>(<span class="st">'inf'</span>)):</span>
<span id="cb109-45"><a href="#cb109-45" aria-hidden="true" tabindex="-1"></a>                        g[s2] <span class="op">=</span> new_g</span>
<span id="cb109-46"><a href="#cb109-46" aria-hidden="true" tabindex="-1"></a>                        parent[s2] <span class="op">=</span> parent[s]</span>
<span id="cb109-47"><a href="#cb109-47" aria-hidden="true" tabindex="-1"></a>                        f <span class="op">=</span> new_g <span class="op">+</span> heuristic(s2, goal)</span>
<span id="cb109-48"><a href="#cb109-48" aria-hidden="true" tabindex="-1"></a>                        heapq.heappush(open_set, (f, s2))</span>
<span id="cb109-49"><a href="#cb109-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb109-50"><a href="#cb109-50" aria-hidden="true" tabindex="-1"></a>                    new_g <span class="op">=</span> g[s] <span class="op">+</span> dist(s, s2)</span>
<span id="cb109-51"><a href="#cb109-51" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> new_g <span class="op">&lt;</span> g.get(s2, <span class="bu">float</span>(<span class="st">'inf'</span>)):</span>
<span id="cb109-52"><a href="#cb109-52" aria-hidden="true" tabindex="-1"></a>                        g[s2] <span class="op">=</span> new_g</span>
<span id="cb109-53"><a href="#cb109-53" aria-hidden="true" tabindex="-1"></a>                        parent[s2] <span class="op">=</span> s</span>
<span id="cb109-54"><a href="#cb109-54" aria-hidden="true" tabindex="-1"></a>                        f <span class="op">=</span> new_g <span class="op">+</span> heuristic(s2, goal)</span>
<span id="cb109-55"><a href="#cb109-55" aria-hidden="true" tabindex="-1"></a>                        heapq.heappush(open_set, (f, s2))</span>
<span id="cb109-56"><a href="#cb109-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-83" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-83">Why It Matters</h4>
<ul>
<li>Produces smooth, realistic paths for agents and robots.</li>
<li>Closer to Euclidean shortest paths than grid-based A*.</li>
<li>Retains admissibility if the heuristic is consistent and the grid has uniform costs.</li>
<li>Works well in open fields, drone navigation, autonomous driving, and RTS games.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-70" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-70">A Gentle Proof (Why It Works)</h4>
<p>Theta* modifies A*’s parent linkage to reduce path length: If <code>parent(s)</code> and <code>s'</code> have line-of-sight, then</p>
<p><span class="math display">\[
g'(s') = g(parent(s)) + d(parent(s), s')
\]</span></p>
<p>is always ≤</p>
<p><span class="math display">\[
g(s) + d(s, s')
\]</span></p>
<p>since the direct connection is shorter or equal. Thus, Theta* never overestimates cost, it preserves A*’s optimality under Euclidean distance and obstacle-free visibility assumptions.</p>
</section>
<section id="try-it-yourself-83" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-83">Try It Yourself</h4>
<ol type="1">
<li>Run Theta* on a grid with few obstacles.</li>
<li>Compare the path to A<em>: Theta</em> produces gentle diagonals instead of jagged corners.</li>
<li>Increase obstacle density, watch how paths adapt smoothly.</li>
<li>Try different heuristics (Manhattan vs Euclidean).</li>
</ol>
</section>
<section id="test-cases-83" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-83">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 21%">
<col style="width: 27%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>Map Type</th>
<th>A* Path Length</th>
<th>Theta* Path Length</th>
<th>Visual Smoothness</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Open grid</td>
<td>28.0</td>
<td>26.8</td>
<td>Smooth</td>
</tr>
<tr class="even">
<td>Sparse obstacles</td>
<td>33.2</td>
<td>30.9</td>
<td>Natural arcs</td>
</tr>
<tr class="odd">
<td>Maze-like</td>
<td>52.5</td>
<td>52.5</td>
<td>Equal (blocked)</td>
</tr>
<tr class="even">
<td>Random field</td>
<td>41.7</td>
<td>38.2</td>
<td>Cleaner motion</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-83" class="level4">
<h4 class="anchored" data-anchor-id="complexity-83">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search</td>
<td><span class="math inline">\(O(E \log V)\)</span></td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
<tr class="even">
<td>Line-of-sight checks</td>
<td><span class="math inline">\(O(L)\)</span> average per expansion</td>
<td></td>
</tr>
</tbody>
</table>
<p>Theta* runs close to A*’s complexity but trades a small overhead for smoother paths and fewer turns.</p>
<p>Theta* is the geometry-aware evolution of A<em>: it looks not just at costs but also </em>visibility*, weaving direct lines where others see only squares — turning jagged motion into elegant, continuous travel.</p>
</section>
</section>
<section id="jump-point-search-grid-acceleration" class="level3">
<h3 class="anchored" data-anchor-id="jump-point-search-grid-acceleration">784 Jump Point Search (Grid Acceleration)</h3>
<p>Jump Point Search (JPS) is an optimization of A* specifically for uniform-cost grids. It prunes away redundant nodes by “jumping” in straight lines until a significant decision point (a jump point) is reached. The result is the same optimal path as A*, but found much faster, often several times faster, with fewer node expansions.</p>
<section id="what-problem-are-we-solving-84" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-84">What Problem Are We Solving?</h4>
<p>A* on a uniform grid expands many unnecessary nodes: when moving straight in an open area, A* explores each cell one by one. But if all costs are equal, we don’t need to stop at every cell — only when something <em>changes</em> (an obstacle or forced turn).</p>
<p>JPS speeds things up by skipping over these “uninteresting” cells while maintaining full optimality.</p>
</section>
<section id="how-it-works-plain-language-29" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-29">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Start from the current node and move along a direction <span class="math inline">\((dx, dy)\)</span>.</p></li>
<li><p>Continue jumping in that direction until:</p>
<ul>
<li>You hit an obstacle, or</li>
<li>You find a forced neighbor (a node with an obstacle beside it that forces a turn), or</li>
<li>You reach the goal.</li>
</ul></li>
<li><p>Each jump point is treated as a node in A*.</p></li>
<li><p>Recursively apply jumps in possible directions from each jump point.</p></li>
</ol>
<p>This greatly reduces the number of nodes considered while preserving correctness.</p>
</section>
<section id="tiny-code-simplified-python-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-python-version">Tiny Code (Simplified Python Version)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jump(grid, x, y, dx, dy, goal):</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="dv">0</span> <span class="op">&lt;=</span> x <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> y <span class="op">&lt;</span> cols <span class="kw">and</span> grid[x][y] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x, y) <span class="op">==</span> goal:</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (x, y)</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forced neighbors</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dx <span class="op">!=</span> <span class="dv">0</span> <span class="kw">and</span> dy <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (grid[x <span class="op">-</span> dx][y <span class="op">+</span> dy] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> grid[x <span class="op">-</span> dx][y] <span class="op">==</span> <span class="dv">0</span>) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>               (grid[x <span class="op">+</span> dx][y <span class="op">-</span> dy] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> grid[x][y <span class="op">-</span> dy] <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (x, y)</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dx <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (grid[x <span class="op">+</span> dx][y <span class="op">+</span> <span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> grid[x][y <span class="op">+</span> <span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>               (grid[x <span class="op">+</span> dx][y <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> grid[x][y <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (x, y)</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dy <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (grid[x <span class="op">+</span> <span class="dv">1</span>][y <span class="op">+</span> dy] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> grid[x <span class="op">+</span> <span class="dv">1</span>][y] <span class="op">==</span> <span class="dv">0</span>) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>               (grid[x <span class="op">-</span> <span class="dv">1</span>][y <span class="op">+</span> dy] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> grid[x <span class="op">-</span> <span class="dv">1</span>][y] <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (x, y)</span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+=</span> dx</span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>        y <span class="op">+=</span> dy</span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heuristic(a, b):</span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">abs</span>(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>]) <span class="op">+</span> <span class="bu">abs</span>(a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jump_point_search(grid, start, goal):</span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a>    open_set <span class="op">=</span> [(<span class="dv">0</span>, start)]</span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb110-31"><a href="#cb110-31" aria-hidden="true" tabindex="-1"></a>    came_from <span class="op">=</span> {}</span>
<span id="cb110-32"><a href="#cb110-32" aria-hidden="true" tabindex="-1"></a>    directions <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)]</span>
<span id="cb110-33"><a href="#cb110-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-34"><a href="#cb110-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> open_set:</span>
<span id="cb110-35"><a href="#cb110-35" aria-hidden="true" tabindex="-1"></a>        _, current <span class="op">=</span> heapq.heappop(open_set)</span>
<span id="cb110-36"><a href="#cb110-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current <span class="op">==</span> goal:</span>
<span id="cb110-37"><a href="#cb110-37" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> [current]</span>
<span id="cb110-38"><a href="#cb110-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> current <span class="kw">in</span> came_from:</span>
<span id="cb110-39"><a href="#cb110-39" aria-hidden="true" tabindex="-1"></a>                current <span class="op">=</span> came_from[current]</span>
<span id="cb110-40"><a href="#cb110-40" aria-hidden="true" tabindex="-1"></a>                path.append(current)</span>
<span id="cb110-41"><a href="#cb110-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb110-42"><a href="#cb110-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx, dy <span class="kw">in</span> directions:</span>
<span id="cb110-43"><a href="#cb110-43" aria-hidden="true" tabindex="-1"></a>            jp <span class="op">=</span> jump(grid, current[<span class="dv">0</span>]<span class="op">+</span>dx, current[<span class="dv">1</span>]<span class="op">+</span>dy, dx, dy, goal)</span>
<span id="cb110-44"><a href="#cb110-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> jp: <span class="cf">continue</span></span>
<span id="cb110-45"><a href="#cb110-45" aria-hidden="true" tabindex="-1"></a>            new_g <span class="op">=</span> g[current] <span class="op">+</span> heuristic(current, jp)</span>
<span id="cb110-46"><a href="#cb110-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> new_g <span class="op">&lt;</span> g.get(jp, <span class="bu">float</span>(<span class="st">'inf'</span>)):</span>
<span id="cb110-47"><a href="#cb110-47" aria-hidden="true" tabindex="-1"></a>                g[jp] <span class="op">=</span> new_g</span>
<span id="cb110-48"><a href="#cb110-48" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> new_g <span class="op">+</span> heuristic(jp, goal)</span>
<span id="cb110-49"><a href="#cb110-49" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(open_set, (f, jp))</span>
<span id="cb110-50"><a href="#cb110-50" aria-hidden="true" tabindex="-1"></a>                came_from[jp] <span class="op">=</span> current</span>
<span id="cb110-51"><a href="#cb110-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-84" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-84">Why It Matters</h4>
<ul>
<li>Produces the exact same optimal paths as A*, but visits far fewer nodes.</li>
<li>Excellent for large open grids or navigation meshes.</li>
<li>Retains A*’s optimality and completeness.</li>
</ul>
<p>Applications include:</p>
<ul>
<li>Game AI pathfinding (especially real-time movement)</li>
<li>Simulation and robotics in uniform environments</li>
<li>Large-scale map routing</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-71" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-71">A Gentle Proof (Why It Works)</h4>
<p>Every path found by JPS corresponds to a valid A* path. The key observation: if moving straight doesn’t reveal any new neighbors or forced choices, then intermediate nodes contribute no additional optimal paths.</p>
<p>Formally, pruning these nodes preserves all shortest paths, because they can be reconstructed by linear interpolation between jump points. Thus, JPS is path-equivalent to A* under uniform cost.</p>
</section>
<section id="try-it-yourself-84" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-84">Try It Yourself</h4>
<ol type="1">
<li><p>Run A* and JPS on an open 100×100 grid.</p>
<ul>
<li>Compare node expansions and time.</li>
</ul></li>
<li><p>Add random obstacles and see how the number of jumps changes.</p></li>
<li><p>Visualize jump points, they appear at corners and turning spots.</p></li>
<li><p>Measure speedup: JPS often reduces expansions by 5×–20×.</p></li>
</ol>
</section>
<section id="test-cases-84" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-84">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 20%">
<col style="width: 22%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Grid Type</th>
<th>A* Expansions</th>
<th>JPS Expansions</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>50×50 open</td>
<td>2500</td>
<td>180</td>
<td>13.9×</td>
</tr>
<tr class="even">
<td>100×100 open</td>
<td>10,000</td>
<td>450</td>
<td>22×</td>
</tr>
<tr class="odd">
<td>100×100 20% obstacles</td>
<td>7,200</td>
<td>900</td>
<td>8×</td>
</tr>
<tr class="even">
<td>Maze</td>
<td>4,800</td>
<td>4,700</td>
<td>1× (same as A*)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-84" class="level4">
<h4 class="anchored" data-anchor-id="complexity-84">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Term</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Average case</td>
<td><span class="math inline">\(O(k \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Worst case</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>JPS’s performance gain depends heavily on obstacle layout — the fewer obstacles, the greater the acceleration.</p>
<p>Jump Point Search is a masterclass in search pruning — it sees that straight paths are already optimal, skipping the monotony of uniform exploration, and leaping forward only when a true decision must be made.</p>
</section>
</section>
<section id="rapidly-exploring-random-tree-rrt" class="level3">
<h3 class="anchored" data-anchor-id="rapidly-exploring-random-tree-rrt">785 Rapidly-Exploring Random Tree (RRT)</h3>
<p>The Rapidly-Exploring Random Tree (RRT) algorithm is a cornerstone of motion planning in robotics and autonomous navigation. It builds a tree by sampling random points in space and connecting them to the nearest known node that can reach them without collision. RRTs are particularly useful in high-dimensional, continuous configuration spaces where grid-based algorithms are inefficient.</p>
<section id="what-problem-are-we-solving-85" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-85">What Problem Are We Solving?</h4>
<p>When planning motion for a robot, vehicle, or arm, the configuration space may be continuous and complex. Instead of discretizing space into cells, RRT samples random configurations and incrementally explores reachable regions, eventually finding a valid path from the start to the goal.</p>
</section>
<section id="how-it-works-plain-language-30" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-30">How It Works (Plain Language)</h4>
<ol type="1">
<li>Start with a tree <code>T</code> initialized at the start position.</li>
<li>Sample a random point <code>x_rand</code> in configuration space.</li>
<li>Find the nearest node <code>x_near</code> in the existing tree.</li>
<li>Move a small step from <code>x_near</code> toward <code>x_rand</code> to get <code>x_new</code>.</li>
<li>If the segment between them is collision-free, add <code>x_new</code> to the tree with <code>x_near</code> as its parent.</li>
<li>Repeat until the goal is reached or a maximum number of samples is reached.</li>
</ol>
<p>Over time, the tree spreads rapidly into unexplored areas — hence the name <em>rapidly-exploring</em>.</p>
</section>
<section id="tiny-code-python-example-26" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-26">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random, math</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(a, b):</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> steer(a, b, step):</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> distance(a, b)</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> d <span class="op">&lt;</span> step:</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> b</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a[<span class="dv">0</span>] <span class="op">+</span> step<span class="op">*</span>(b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">/</span>d, a[<span class="dv">1</span>] <span class="op">+</span> step<span class="op">*</span>(b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">/</span>d)</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rrt(start, goal, is_free, step<span class="op">=</span><span class="fl">1.0</span>, max_iter<span class="op">=</span><span class="dv">5000</span>, goal_bias<span class="op">=</span><span class="fl">0.05</span>):</span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>        x_rand <span class="op">=</span> goal <span class="cf">if</span> random.random() <span class="op">&lt;</span> goal_bias <span class="cf">else</span> (random.uniform(<span class="dv">0</span>,<span class="dv">100</span>), random.uniform(<span class="dv">0</span>,<span class="dv">100</span>))</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a>        x_near <span class="op">=</span> <span class="bu">min</span>(tree.keys(), key<span class="op">=</span><span class="kw">lambda</span> p: distance(p, x_rand))</span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a>        x_new <span class="op">=</span> steer(x_near, x_rand, step)</span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_free(x_near, x_new):</span>
<span id="cb111-19"><a href="#cb111-19" aria-hidden="true" tabindex="-1"></a>            tree[x_new] <span class="op">=</span> x_near</span>
<span id="cb111-20"><a href="#cb111-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> distance(x_new, goal) <span class="op">&lt;</span> step:</span>
<span id="cb111-21"><a href="#cb111-21" aria-hidden="true" tabindex="-1"></a>                tree[goal] <span class="op">=</span> x_new</span>
<span id="cb111-22"><a href="#cb111-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> tree</span>
<span id="cb111-23"><a href="#cb111-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tree</span>
<span id="cb111-24"><a href="#cb111-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-25"><a href="#cb111-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reconstruct(tree, goal):</span>
<span id="cb111-26"><a href="#cb111-26" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [goal]</span>
<span id="cb111-27"><a href="#cb111-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> tree[path[<span class="op">-</span><span class="dv">1</span>]] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb111-28"><a href="#cb111-28" aria-hidden="true" tabindex="-1"></a>        path.append(tree[path[<span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb111-29"><a href="#cb111-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>is_free(a, b)</code> is a collision-checking function that ensures motion between points is valid.</p>
</section>
<section id="why-it-matters-85" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-85">Why It Matters</h4>
<ul>
<li><p>Scalable to high dimensions: works in spaces where grids or Dijkstra become infeasible.</p></li>
<li><p>Probabilistic completeness: if a solution exists, the probability of finding it approaches 1 as samples increase.</p></li>
<li><p>Foundation for RRT* and PRM algorithms.</p></li>
<li><p>Common in:</p>
<ul>
<li>Autonomous drone and car navigation</li>
<li>Robotic arm motion planning</li>
<li>Game and simulation environments</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-72" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-72">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(X_{\text{free}}\)</span> be the obstacle-free region of configuration space. At each iteration, RRT samples uniformly from <span class="math inline">\(X_{\text{free}}\)</span>. Since <span class="math inline">\(X_{\text{free}}\)</span> is bounded and has non-zero measure, every region has a positive probability of being sampled.</p>
<p>The tree’s nearest-neighbor expansion ensures that new nodes always move closer to unexplored areas. Thus, as the number of iterations grows, the probability that the tree reaches the goal region tends to 1 — probabilistic completeness.</p>
</section>
<section id="try-it-yourself-85" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-85">Try It Yourself</h4>
<ol type="1">
<li>Simulate RRT on a 2D grid with circular obstacles.</li>
<li>Visualize how the tree expands, it “fans out” from the start into free space.</li>
<li>Add more obstacles and observe how branches naturally grow around them.</li>
<li>Adjust <code>step</code> and <code>goal_bias</code> for smoother or faster convergence.</li>
</ol>
</section>
<section id="test-cases-85" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-85">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 14%">
<col style="width: 25%">
<col style="width: 18%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Scenario</th>
<th>Space</th>
<th>Obstacles</th>
<th>Success Rate</th>
<th>Avg. Path Length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Empty space</td>
<td>2D</td>
<td>0%</td>
<td>100%</td>
<td>140</td>
</tr>
<tr class="even">
<td>20% blocked</td>
<td>2D</td>
<td>random</td>
<td>90%</td>
<td>165</td>
</tr>
<tr class="odd">
<td>Maze</td>
<td>2D</td>
<td>narrow corridors</td>
<td>75%</td>
<td>210</td>
</tr>
<tr class="even">
<td>3D space</td>
<td>spherical</td>
<td>30%</td>
<td>85%</td>
<td>190</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-85" class="level4">
<h4 class="anchored" data-anchor-id="complexity-85">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 56%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nearest-neighbor search</td>
<td><span class="math inline">\(O(N)\)</span> (naive), <span class="math inline">\(O(\log N)\)</span> (KD-tree)</td>
<td><span class="math inline">\(O(N)\)</span></td>
</tr>
<tr class="even">
<td>Total iterations</td>
<td><span class="math inline">\(O(N \log N)\)</span> expected</td>
<td><span class="math inline">\(O(N)\)</span></td>
</tr>
</tbody>
</table>
<p>RRT is the adventurous explorer of motion planning: instead of mapping every inch of the world, it sends out probing branches that reach deeper into the unknown until one of them finds a path home.</p>
</section>
</section>
<section id="rapidly-exploring-random-tree-star-rrt" class="level3">
<h3 class="anchored" data-anchor-id="rapidly-exploring-random-tree-star-rrt">786 Rapidly-Exploring Random Tree Star (RRT*)</h3>
<p>RRT* is the optimal variant of the classic Rapidly-Exploring Random Tree (RRT). While RRT quickly finds a valid path, it does not guarantee that the path is the <em>shortest</em>. RRT* improves upon it by gradually refining the tree — rewiring nearby nodes to minimize total path cost and converge toward the optimal solution over time.</p>
<section id="what-problem-are-we-solving-86" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-86">What Problem Are We Solving?</h4>
<p>RRT is fast and complete but <em>suboptimal</em>: its paths can be jagged or longer than necessary. In motion planning, optimality matters, whether for energy, safety, or aesthetics.</p>
<p>RRT* keeps RRT’s exploratory nature but adds a rewiring step that locally improves paths. As sampling continues, the path cost monotonically decreases and converges to the optimal path length.</p>
</section>
<section id="how-it-works-plain-language-31" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-31">How It Works (Plain Language)</h4>
<p>Each iteration performs three main steps:</p>
<ol type="1">
<li><p>Sample and extend: Pick a random point <code>x_rand</code>, find the nearest node <code>x_nearest</code>, and steer toward it to create <code>x_new</code> (as in RRT).</p></li>
<li><p>Choose best parent: Find all nodes within a radius <span class="math inline">\(r_n\)</span> of <code>x_new</code>. Among them, pick the node that gives the lowest total cost to reach <code>x_new</code>.</p></li>
<li><p>Rewire: For every neighbor <code>x_near</code> within <span class="math inline">\(r_n\)</span>, check if going through <code>x_new</code> provides a shorter path. If so, update <code>x_near</code>’s parent to <code>x_new</code>.</p></li>
</ol>
<p>This continuous refinement makes RRT* <em>asymptotically optimal</em>: as the number of samples grows, the solution converges to the global optimum.</p>
</section>
<section id="tiny-code-python-example-27" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-27">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random, math</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(a, b):</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> steer(a, b, step):</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> distance(a, b)</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> d <span class="op">&lt;</span> step:</span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> b</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a[<span class="dv">0</span>] <span class="op">+</span> step<span class="op">*</span>(b[<span class="dv">0</span>]<span class="op">-</span>a[<span class="dv">0</span>])<span class="op">/</span>d, a[<span class="dv">1</span>] <span class="op">+</span> step<span class="op">*</span>(b[<span class="dv">1</span>]<span class="op">-</span>a[<span class="dv">1</span>])<span class="op">/</span>d)</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rrt_star(start, goal, is_free, step<span class="op">=</span><span class="fl">1.0</span>, max_iter<span class="op">=</span><span class="dv">5000</span>, radius<span class="op">=</span><span class="fl">5.0</span>):</span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>        x_rand <span class="op">=</span> (random.uniform(<span class="dv">0</span>,<span class="dv">100</span>), random.uniform(<span class="dv">0</span>,<span class="dv">100</span>))</span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>        x_nearest <span class="op">=</span> <span class="bu">min</span>(tree.keys(), key<span class="op">=</span><span class="kw">lambda</span> p: distance(p, x_rand))</span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>        x_new <span class="op">=</span> steer(x_nearest, x_rand, step)</span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> is_free(x_nearest, x_new): </span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find nearby nodes</span></span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>        neighbors <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> tree <span class="cf">if</span> distance(p, x_new) <span class="op">&lt;</span> radius <span class="kw">and</span> is_free(p, x_new)]</span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Choose best parent</span></span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>        x_parent <span class="op">=</span> <span class="bu">min</span>(neighbors <span class="op">+</span> [x_nearest], key<span class="op">=</span><span class="kw">lambda</span> p: cost[p] <span class="op">+</span> distance(p, x_new))</span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>        tree[x_new] <span class="op">=</span> x_parent</span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a>        cost[x_new] <span class="op">=</span> cost[x_parent] <span class="op">+</span> distance(x_parent, x_new)</span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rewire</span></span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> p <span class="kw">in</span> neighbors:</span>
<span id="cb112-29"><a href="#cb112-29" aria-hidden="true" tabindex="-1"></a>            new_cost <span class="op">=</span> cost[x_new] <span class="op">+</span> distance(x_new, p)</span>
<span id="cb112-30"><a href="#cb112-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> new_cost <span class="op">&lt;</span> cost[p] <span class="kw">and</span> is_free(x_new, p):</span>
<span id="cb112-31"><a href="#cb112-31" aria-hidden="true" tabindex="-1"></a>                tree[p] <span class="op">=</span> x_new</span>
<span id="cb112-32"><a href="#cb112-32" aria-hidden="true" tabindex="-1"></a>                cost[p] <span class="op">=</span> new_cost</span>
<span id="cb112-33"><a href="#cb112-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check for goal</span></span>
<span id="cb112-34"><a href="#cb112-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> distance(x_new, goal) <span class="op">&lt;</span> step:</span>
<span id="cb112-35"><a href="#cb112-35" aria-hidden="true" tabindex="-1"></a>            tree[goal] <span class="op">=</span> x_new</span>
<span id="cb112-36"><a href="#cb112-36" aria-hidden="true" tabindex="-1"></a>            cost[goal] <span class="op">=</span> cost[x_new] <span class="op">+</span> distance(x_new, goal)</span>
<span id="cb112-37"><a href="#cb112-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> tree, cost</span>
<span id="cb112-38"><a href="#cb112-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tree, cost</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-86" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-86">Why It Matters</h4>
<ul>
<li><p>Asymptotically optimal: path quality improves as samples increase.</p></li>
<li><p>Retains probabilistic completeness like RRT.</p></li>
<li><p>Produces smooth, efficient, and safe trajectories.</p></li>
<li><p>Used in:</p>
<ul>
<li>Autonomous vehicle path planning</li>
<li>UAV navigation</li>
<li>Robotic manipulators</li>
<li>High-dimensional configuration spaces</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-73" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-73">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(c^*\)</span> be the optimal path cost between start and goal. RRT* ensures that as the number of samples <span class="math inline">\(n \to \infty\)</span>:</p>
<p><span class="math display">\[
P(\text{cost}(RRT^*) \to c^*) = 1
\]</span></p>
<p>because:</p>
<ul>
<li>The sampling distribution is uniform over free space.</li>
<li>Each rewire locally minimizes the cost function.</li>
<li>The connection radius <span class="math inline">\(r_n \sim (\log n / n)^{1/d}\)</span> ensures with high probability that all nearby nodes can eventually connect.</li>
</ul>
<p>Hence, the algorithm converges to the optimal solution almost surely.</p>
</section>
<section id="try-it-yourself-86" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-86">Try It Yourself</h4>
<ol type="1">
<li>Run both RRT and RRT* on the same obstacle map.</li>
<li>Visualize the difference: RRT*’s tree looks denser and smoother.</li>
<li>Observe how the total path cost decreases as iterations increase.</li>
<li>Adjust the radius parameter to balance exploration and refinement.</li>
</ol>
</section>
<section id="test-cases-86" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-86">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Scenario</th>
<th>RRT Path Length</th>
<th>RRT* Path Length</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Empty space</td>
<td>140</td>
<td>123</td>
<td>12% shorter</td>
</tr>
<tr class="even">
<td>Sparse obstacles</td>
<td>165</td>
<td>142</td>
<td>14% shorter</td>
</tr>
<tr class="odd">
<td>Maze corridor</td>
<td>210</td>
<td>198</td>
<td>6% shorter</td>
</tr>
<tr class="even">
<td>3D environment</td>
<td>190</td>
<td>172</td>
<td>9% shorter</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-86" class="level4">
<h4 class="anchored" data-anchor-id="complexity-86">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nearest neighbor search</td>
<td><span class="math inline">\(O(\log N)\)</span> (KD-tree)</td>
<td><span class="math inline">\(O(N)\)</span></td>
</tr>
<tr class="even">
<td>Rewiring per iteration</td>
<td><span class="math inline">\(O(\log N)\)</span> average</td>
<td><span class="math inline">\(O(N)\)</span></td>
</tr>
<tr class="odd">
<td>Total iterations</td>
<td><span class="math inline">\(O(N \log N)\)</span></td>
<td><span class="math inline">\(O(N)\)</span></td>
</tr>
</tbody>
</table>
<p>RRT* is the refined dreamer among planners — it starts with quick guesses like its ancestor RRT, then pauses to reconsider, rewiring its path until every step moves not just forward, but better.</p>
</section>
</section>
<section id="probabilistic-roadmap-prm" class="level3">
<h3 class="anchored" data-anchor-id="probabilistic-roadmap-prm">787 Probabilistic Roadmap (PRM)</h3>
<p>The Probabilistic Roadmap (PRM) algorithm is a two-phase motion planning method used for multi-query pathfinding in high-dimensional continuous spaces. Instead of exploring from a single start point like RRT, PRM samples many random points first, connects them into a graph (roadmap), and then uses standard graph search (like Dijkstra or A*) to find paths between any two configurations.</p>
<section id="what-problem-are-we-solving-87" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-87">What Problem Are We Solving?</h4>
<p>For robots or systems that need to perform many queries in the same environment, such as navigating between different destinations — it is inefficient to rebuild a tree from scratch each time (like RRT). PRM solves this by precomputing a roadmap of feasible connections through the free configuration space. Once built, queries can be answered quickly.</p>
</section>
<section id="how-it-works-plain-language-32" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-32">How It Works (Plain Language)</h4>
<p>PRM consists of two phases:</p>
<ol type="1">
<li><p>Learning phase (Roadmap Construction):</p>
<ul>
<li>Randomly sample <span class="math inline">\(N\)</span> points (configurations) in the free space.</li>
<li>Discard points that collide with obstacles.</li>
<li>For each valid point, connect it to its <span class="math inline">\(k\)</span> nearest neighbors if a straight-line connection between them is collision-free.</li>
<li>Store these nodes and edges as a graph (the roadmap).</li>
</ul></li>
<li><p>Query phase (Path Search):</p>
<ul>
<li>Connect the start and goal points to nearby roadmap nodes.</li>
<li>Use a graph search algorithm (like Dijkstra or A*) to find the shortest path on the roadmap.</li>
</ul></li>
</ol>
<p>Over time, the roadmap becomes denser, increasing the likelihood of finding optimal paths.</p>
</section>
<section id="tiny-code-python-example-28" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-28">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random, math, heapq</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(a, b):</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_free(a, b):</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Placeholder collision checker (always free)</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_prm(num_samples<span class="op">=</span><span class="dv">100</span>, k<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> [(random.uniform(<span class="dv">0</span>,<span class="dv">100</span>), random.uniform(<span class="dv">0</span>,<span class="dv">100</span>)) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_samples)]</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> {p: [] <span class="cf">for</span> p <span class="kw">in</span> points}</span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>        neighbors <span class="op">=</span> <span class="bu">sorted</span>(points, key<span class="op">=</span><span class="kw">lambda</span> q: distance(p, q))[<span class="dv">1</span>:k<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> q <span class="kw">in</span> neighbors:</span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_free(p, q):</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>                edges[p].append(q)</span>
<span id="cb113-18"><a href="#cb113-18" aria-hidden="true" tabindex="-1"></a>                edges[q].append(p)</span>
<span id="cb113-19"><a href="#cb113-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> points, edges</span>
<span id="cb113-20"><a href="#cb113-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-21"><a href="#cb113-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra(edges, start, goal):</span>
<span id="cb113-22"><a href="#cb113-22" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> {p: <span class="bu">float</span>(<span class="st">'inf'</span>) <span class="cf">for</span> p <span class="kw">in</span> edges}</span>
<span id="cb113-23"><a href="#cb113-23" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> {p: <span class="va">None</span> <span class="cf">for</span> p <span class="kw">in</span> edges}</span>
<span id="cb113-24"><a href="#cb113-24" aria-hidden="true" tabindex="-1"></a>    dist[start] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb113-25"><a href="#cb113-25" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, start)]</span>
<span id="cb113-26"><a href="#cb113-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb113-27"><a href="#cb113-27" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb113-28"><a href="#cb113-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> goal:</span>
<span id="cb113-29"><a href="#cb113-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb113-30"><a href="#cb113-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> edges[u]:</span>
<span id="cb113-31"><a href="#cb113-31" aria-hidden="true" tabindex="-1"></a>            alt <span class="op">=</span> d <span class="op">+</span> distance(u, v)</span>
<span id="cb113-32"><a href="#cb113-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> alt <span class="op">&lt;</span> dist[v]:</span>
<span id="cb113-33"><a href="#cb113-33" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> alt</span>
<span id="cb113-34"><a href="#cb113-34" aria-hidden="true" tabindex="-1"></a>                prev[v] <span class="op">=</span> u</span>
<span id="cb113-35"><a href="#cb113-35" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (alt, v))</span>
<span id="cb113-36"><a href="#cb113-36" aria-hidden="true" tabindex="-1"></a>    path, u <span class="op">=</span> [], goal</span>
<span id="cb113-37"><a href="#cb113-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> u:</span>
<span id="cb113-38"><a href="#cb113-38" aria-hidden="true" tabindex="-1"></a>        path.append(u)</span>
<span id="cb113-39"><a href="#cb113-39" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> prev[u]</span>
<span id="cb113-40"><a href="#cb113-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-87" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-87">Why It Matters</h4>
<ul>
<li><p>Ideal for multi-query motion planning.</p></li>
<li><p>Probabilistically complete: as the number of samples increases, the probability of finding a path (if one exists) approaches 1.</p></li>
<li><p>Common in:</p>
<ul>
<li>Mobile robot navigation</li>
<li>Autonomous vehicle route maps</li>
<li>High-dimensional robotic arm planning</li>
<li>Virtual environments and games</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-74" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-74">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(X_{\text{free}}\)</span> be the free space of configurations. Uniform random sampling ensures that as the number of samples <span class="math inline">\(n \to \infty\)</span>, the set of samples becomes dense in <span class="math inline">\(X_{\text{free}}\)</span>.</p>
<p>If the connection radius <span class="math inline">\(r_n\)</span> satisfies:</p>
<p><span class="math display">\[
r_n \ge c \left( \frac{\log n}{n} \right)^{1/d}
\]</span></p>
<p>(where <span class="math inline">\(d\)</span> is the dimension of space), then with high probability the roadmap graph becomes connected.</p>
<p>Thus, any two configurations in the same free-space component can be connected by a path through the roadmap, making PRM <em>probabilistically complete</em>.</p>
</section>
<section id="try-it-yourself-87" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-87">Try It Yourself</h4>
<ol type="1">
<li>Build a PRM with 100 random points and connect each to 5 nearest neighbors.</li>
<li>Add circular obstacles, observe how the roadmap avoids them.</li>
<li>Query multiple start-goal pairs using the same roadmap.</li>
<li>Measure path quality as sample size increases.</li>
</ol>
</section>
<section id="test-cases-87" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-87">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 20%">
<col style="width: 19%">
<col style="width: 25%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Samples</th>
<th>Neighbors (k)</th>
<th>Connectivity</th>
<th>Avg. Path Length</th>
<th>Query Time (ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>50</td>
<td>3</td>
<td>80%</td>
<td>160</td>
<td>0.8</td>
</tr>
<tr class="even">
<td>100</td>
<td>5</td>
<td>95%</td>
<td>140</td>
<td>1.2</td>
</tr>
<tr class="odd">
<td>200</td>
<td>8</td>
<td>99%</td>
<td>125</td>
<td>1.5</td>
</tr>
<tr class="even">
<td>500</td>
<td>10</td>
<td>100%</td>
<td>118</td>
<td>2.0</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-87" class="level4">
<h4 class="anchored" data-anchor-id="complexity-87">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sampling</td>
<td><span class="math inline">\(O(N)\)</span></td>
<td><span class="math inline">\(O(N)\)</span></td>
</tr>
<tr class="even">
<td>Nearest neighbor search</td>
<td><span class="math inline">\(O(N \log N)\)</span></td>
<td><span class="math inline">\(O(N)\)</span></td>
</tr>
<tr class="odd">
<td>Path query (A*)</td>
<td><span class="math inline">\(O(E \log V)\)</span></td>
<td><span class="math inline">\(O(V + E)\)</span></td>
</tr>
</tbody>
</table>
<p>PRM is the cartographer of motion planning — it first surveys the terrain with scattered landmarks, links the reachable ones into a living map, and lets travelers chart their course swiftly through its probabilistic roads.</p>
</section>
</section>
<section id="visibility-graph" class="level3">
<h3 class="anchored" data-anchor-id="visibility-graph">788 Visibility Graph</h3>
<p>The Visibility Graph algorithm is a classical geometric method for shortest path planning in a 2D environment with polygonal obstacles. It connects all pairs of points (vertices) that can “see” each other directly, meaning the straight line between them does not intersect any obstacle. Then, it applies a shortest-path algorithm like Dijkstra or A* on this graph to find the optimal route.</p>
<section id="what-problem-are-we-solving-88" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-88">What Problem Are We Solving?</h4>
<p>Imagine a robot navigating a room with walls or obstacles. We want the shortest collision-free path between a start and a goal point. Unlike grid-based or sampling methods, the Visibility Graph gives an exact geometric path, often touching the corners of obstacles.</p>
</section>
<section id="how-it-works-plain-language-33" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-33">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Collect all vertices of obstacles, plus the start and goal points.</p></li>
<li><p>For each pair of vertices <span class="math inline">\((v_i, v_j)\)</span>:</p>
<ul>
<li>Draw a segment between them.</li>
<li>If the segment does not intersect any obstacle edges, they are <em>visible</em>.</li>
<li>Add an edge <span class="math inline">\((v_i, v_j)\)</span> to the graph, weighted by Euclidean distance.</li>
</ul></li>
<li><p>Run a shortest-path algorithm (Dijkstra or A*) between start and goal.</p></li>
<li><p>The resulting path follows obstacle corners where visibility changes.</p></li>
</ol>
<p>This produces the optimal path (in Euclidean distance) within the polygonal world.</p>
</section>
<section id="tiny-code-python-example-29" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-29">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, itertools, heapq</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(a, b):</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(a, b, c, d):</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Basic line segment intersection test</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ccw(p, q, r):</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (r[<span class="dv">1</span>]<span class="op">-</span>p[<span class="dv">1</span>])<span class="op">*</span>(q[<span class="dv">0</span>]<span class="op">-</span>p[<span class="dv">0</span>]) <span class="op">&gt;</span> (q[<span class="dv">1</span>]<span class="op">-</span>p[<span class="dv">1</span>])<span class="op">*</span>(r[<span class="dv">0</span>]<span class="op">-</span>p[<span class="dv">0</span>])</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (ccw(a,c,d) <span class="op">!=</span> ccw(b,c,d)) <span class="kw">and</span> (ccw(a,b,c) <span class="op">!=</span> ccw(a,b,d))</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_visibility_graph(points, obstacles):</span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> {p: [] <span class="cf">for</span> p <span class="kw">in</span> points}</span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p, q <span class="kw">in</span> itertools.combinations(points, <span class="dv">2</span>):</span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">any</span>(intersect(p, q, o[i], o[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(o)]) <span class="cf">for</span> o <span class="kw">in</span> obstacles <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(o))):</span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>            edges[p].append((q, distance(p,q)))</span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>            edges[q].append((p, distance(p,q)))</span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> edges</span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra(graph, start, goal):</span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> {v: <span class="bu">float</span>(<span class="st">'inf'</span>) <span class="cf">for</span> v <span class="kw">in</span> graph}</span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> {v: <span class="va">None</span> <span class="cf">for</span> v <span class="kw">in</span> graph}</span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a>    dist[start] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, start)]</span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb114-26"><a href="#cb114-26" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb114-27"><a href="#cb114-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> goal: <span class="cf">break</span></span>
<span id="cb114-28"><a href="#cb114-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb114-29"><a href="#cb114-29" aria-hidden="true" tabindex="-1"></a>            alt <span class="op">=</span> d <span class="op">+</span> w</span>
<span id="cb114-30"><a href="#cb114-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> alt <span class="op">&lt;</span> dist[v]:</span>
<span id="cb114-31"><a href="#cb114-31" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> alt</span>
<span id="cb114-32"><a href="#cb114-32" aria-hidden="true" tabindex="-1"></a>                prev[v] <span class="op">=</span> u</span>
<span id="cb114-33"><a href="#cb114-33" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (alt, v))</span>
<span id="cb114-34"><a href="#cb114-34" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> []</span>
<span id="cb114-35"><a href="#cb114-35" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> goal</span>
<span id="cb114-36"><a href="#cb114-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> u <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb114-37"><a href="#cb114-37" aria-hidden="true" tabindex="-1"></a>        path.append(u)</span>
<span id="cb114-38"><a href="#cb114-38" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> prev[u]</span>
<span id="cb114-39"><a href="#cb114-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-88" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-88">Why It Matters</h4>
<ul>
<li><p>Produces exact shortest paths in polygonal environments.</p></li>
<li><p>Relies purely on geometry, no discretization or random sampling.</p></li>
<li><p>Common in:</p>
<ul>
<li>Robotics (path planning around obstacles)</li>
<li>Video games (navigation meshes and pathfinding)</li>
<li>Computational geometry teaching and testing</li>
<li>Architectural layout and urban planning tools</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-75" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-75">A Gentle Proof (Why It Works)</h4>
<p>If all obstacles are polygonal and motion is allowed along straight lines between visible vertices, then any optimal path can be represented as a sequence of visible vertices (start → corner → corner → goal).</p>
<p>Formally, between two consecutive tangential contacts with obstacles, the path must be a straight segment; otherwise, it can be shortened.</p>
<p>Thus, the shortest obstacle-avoiding path exists within the visibility graph’s edges.</p>
</section>
<section id="try-it-yourself-88" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-88">Try It Yourself</h4>
<ol type="1">
<li>Create a map with polygonal obstacles (rectangles, triangles, etc.).</li>
<li>Plot the visibility graph, edges connecting visible vertices.</li>
<li>Observe that the shortest path “hugs” obstacle corners.</li>
<li>Compare the result with grid-based A*, you’ll see how geometric methods give exact minimal paths.</li>
</ol>
</section>
<section id="test-cases-88" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-88">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 13%">
<col style="width: 12%">
<col style="width: 33%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th>Scenario</th>
<th>Obstacles</th>
<th>Vertices</th>
<th>Path Type</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Empty plane</td>
<td>0</td>
<td>2</td>
<td>Straight line</td>
<td>Optimal</td>
</tr>
<tr class="even">
<td>One rectangle</td>
<td>4</td>
<td>6</td>
<td>Tangential corner path</td>
<td>Optimal</td>
</tr>
<tr class="odd">
<td>Maze walls</td>
<td>12</td>
<td>20</td>
<td>Multi-corner path</td>
<td>Optimal</td>
</tr>
<tr class="even">
<td>Triangular obstacles</td>
<td>9</td>
<td>15</td>
<td>Mixed edges</td>
<td>Optimal</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-88" class="level4">
<h4 class="anchored" data-anchor-id="complexity-88">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Edge visibility checks</td>
<td><span class="math inline">\(O(V^2 E)\)</span></td>
<td><span class="math inline">\(O(V^2)\)</span></td>
</tr>
<tr class="even">
<td>Shortest path (Dijkstra)</td>
<td><span class="math inline">\(O(V^2)\)</span></td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
</tbody>
</table>
<p>Here <span class="math inline">\(V\)</span> is the number of vertices and <span class="math inline">\(E\)</span> the number of obstacle edges.</p>
<p>The Visibility Graph is the geometric purist of motion planners — it trusts straight lines and clear sight, tracing paths that just graze the edges of obstacles, as if geometry itself whispered the way forward.</p>
</section>
</section>
<section id="potential-field-pathfinding" class="level3">
<h3 class="anchored" data-anchor-id="potential-field-pathfinding">789 Potential Field Pathfinding</h3>
<p>Potential Field Pathfinding treats navigation as a problem of physics. The robot moves under the influence of an artificial potential field: the goal attracts it like gravity, and obstacles repel it like electric charges. This approach transforms planning into a continuous optimization problem where motion naturally flows downhill in potential energy.</p>
<section id="what-problem-are-we-solving-89" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-89">What Problem Are We Solving?</h4>
<p>Pathfinding in cluttered spaces can be tricky. Classical algorithms like A* work on discrete grids, but many real environments are continuous. Potential fields provide a smooth, real-valued framework for navigation, intuitive, lightweight, and reactive.</p>
<p>The challenge? Avoiding local minima, where the robot gets stuck in a valley of forces before reaching the goal.</p>
</section>
<section id="how-it-works-plain-language-34" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-34">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Define a potential function over space:</p>
<ul>
<li><p>Attractive potential toward the goal: <span class="math display">\[
U_{att}(x) = \frac{1}{2} k_{att} , |x - x_{goal}|^2
\]</span></p></li>
<li><p>Repulsive potential away from obstacles: <span class="math display">\[
U_{rep}(x) =
\begin{cases}
\frac{1}{2} k_{rep} \left(\frac{1}{d(x)} - \frac{1}{d_0}\right)^2, &amp; d(x) &lt; d_0 \\
0, &amp; d(x) \ge d_0
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(d(x)\)</span> is the distance to the nearest obstacle and <span class="math inline">\(d_0\)</span> is the influence radius.</p></li>
</ul></li>
<li><p>Compute the resultant force (negative gradient of potential): <span class="math display">\[
F(x) = -\nabla U(x) = F_{att}(x) + F_{rep}(x)
\]</span></p></li>
<li><p>Move the robot a small step in the direction of the force until it reaches the goal (or gets trapped).</p></li>
</ol>
</section>
<section id="tiny-code-python-example-30" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-30">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> attractive_force(pos, goal, k_att<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>k_att <span class="op">*</span> (pos <span class="op">-</span> goal)</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> repulsive_force(pos, obstacles, k_rep<span class="op">=</span><span class="fl">100.0</span>, d0<span class="op">=</span><span class="fl">5.0</span>):</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> np.zeros(<span class="dv">2</span>)</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> obs <span class="kw">in</span> obstacles:</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> pos <span class="op">-</span> obs</span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> np.linalg.norm(diff)</span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&lt;</span> d0 <span class="kw">and</span> d <span class="op">&gt;</span> <span class="fl">1e-6</span>:</span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> k_rep <span class="op">*</span> ((<span class="dv">1</span><span class="op">/</span>d <span class="op">-</span> <span class="dv">1</span><span class="op">/</span>d0) <span class="op">/</span> d3) <span class="op">*</span> diff</span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total</span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> potential_field_path(start, goal, obstacles, step<span class="op">=</span><span class="fl">0.5</span>, max_iter<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> np.array(start, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>    goal <span class="op">=</span> np.array(goal, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [<span class="bu">tuple</span>(pos)]</span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>        F_att <span class="op">=</span> attractive_force(pos, goal)</span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>        F_rep <span class="op">=</span> repulsive_force(pos, obstacles)</span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>        F <span class="op">=</span> F_att <span class="op">+</span> F_rep</span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">+=</span> step <span class="op">*</span> F <span class="op">/</span> np.linalg.norm(F)</span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>        path.append(<span class="bu">tuple</span>(pos))</span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.linalg.norm(pos <span class="op">-</span> goal) <span class="op">&lt;</span> <span class="fl">1.0</span>:</span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-89" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-89">Why It Matters</h4>
<ul>
<li><p>Continuous-space pathfinding: works directly in <span class="math inline">\(\mathbb{R}^2\)</span> or <span class="math inline">\(\mathbb{R}^3\)</span>.</p></li>
<li><p>Computationally light: no grid or graph construction.</p></li>
<li><p>Reactive: adapts to changes in obstacles dynamically.</p></li>
<li><p>Used in:</p>
<ul>
<li>Autonomous drones and robots</li>
<li>Crowd simulation</li>
<li>Local motion control systems</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-76" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-76">A Gentle Proof (Why It Works)</h4>
<p>The total potential function <span class="math display">\[
U(x) = U_{att}(x) + U_{rep}(x)
\]</span> is differentiable except at obstacle boundaries. At any point, the direction of steepest descent <span class="math inline">\(-\nabla U(x)\)</span> points toward the nearest minimum of <span class="math inline">\(U(x)\)</span>. If <span class="math inline">\(U\)</span> is convex (no local minima besides the goal), the gradient descent path converges to the goal configuration.</p>
<p>However, in nonconvex environments, multiple minima may exist. Hybrid methods (like adding random perturbations or combining with A*) can escape these traps.</p>
</section>
<section id="try-it-yourself-89" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-89">Try It Yourself</h4>
<ol type="1">
<li>Define a 2D map with circular obstacles.</li>
<li>Visualize the potential field as a heatmap.</li>
<li>Trace how the path slides smoothly toward the goal.</li>
<li>Introduce a narrow passage, observe how tuning <span class="math inline">\(k_{rep}\)</span> affects avoidance.</li>
<li>Combine with A* for global + local planning.</li>
</ol>
</section>
<section id="test-cases-89" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-89">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
<col style="width: 43%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Environment</th>
<th>Obstacles</th>
<th>Behavior</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Empty space</td>
<td>0</td>
<td>Direct path</td>
<td>Reaches goal</td>
</tr>
<tr class="even">
<td>One obstacle</td>
<td>1</td>
<td>Smooth curve around obstacle</td>
<td>Success</td>
</tr>
<tr class="odd">
<td>Two obstacles</td>
<td>2</td>
<td>Avoids both</td>
<td>Success</td>
</tr>
<tr class="even">
<td>Narrow gap</td>
<td>2 close</td>
<td>Local minimum possible</td>
<td>Partial success</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-89" class="level4">
<h4 class="anchored" data-anchor-id="complexity-89">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Force computation per step</td>
<td><span class="math inline">\(O(N_{obstacles})\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Total iterations</td>
<td><span class="math inline">\(O(T)\)</span></td>
<td><span class="math inline">\(O(T)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(T\)</span> is the number of movement steps.</p>
<p>Potential Field Pathfinding is like navigating by invisible gravity — every point in space whispers a direction, the goal pulls gently, the walls push firmly, and the traveler learns the shape of the world through motion itself.</p>
</section>
</section>
<section id="bug-algorithms" class="level3">
<h3 class="anchored" data-anchor-id="bug-algorithms">790 Bug Algorithms</h3>
<p>Bug Algorithms are a family of simple reactive pathfinding methods for mobile robots that use only local sensing, no maps, no global planning, just a feel for where the goal lies and whether an obstacle is blocking the way. They’re ideal for minimalist robots or real-world navigation where uncertainty is high.</p>
<section id="what-problem-are-we-solving-90" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-90">What Problem Are We Solving?</h4>
<p>When a robot moves toward a goal but encounters obstacles it didn’t anticipate, it needs a way to recover without a global map. Traditional planners like A* or RRT assume full knowledge of the environment. Bug algorithms, by contrast, make decisions on the fly, using only what the robot can sense.</p>
</section>
<section id="how-it-works-plain-language-35" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-35">How It Works (Plain Language)</h4>
<p>All Bug algorithms share two phases:</p>
<ol type="1">
<li>Move toward the goal in a straight line until hitting an obstacle.</li>
<li>Follow the obstacle’s boundary until a better route to the goal becomes available.</li>
</ol>
<p>Different versions define “better route” differently:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>Variant</th>
<th>Strategy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bug1</td>
<td>Trace the entire obstacle, find the closest point to the goal, then leave.</td>
</tr>
<tr class="even">
<td>Bug2</td>
<td>Follow the obstacle until the line to the goal is clear again.</td>
</tr>
<tr class="odd">
<td>TangentBug</td>
<td>Use range sensors to estimate visibility and switch paths intelligently.</td>
</tr>
</tbody>
</table>
</section>
<section id="example-bug2-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="example-bug2-algorithm">Example: Bug2 Algorithm</h4>
<ol type="1">
<li>Start at <span class="math inline">\(S\)</span>, move toward goal <span class="math inline">\(G\)</span> along the line <span class="math inline">\(SG\)</span>.</li>
<li>If an obstacle is hit, follow its boundary while measuring distance to <span class="math inline">\(G\)</span>.</li>
<li>When the direct line to <span class="math inline">\(G\)</span> becomes visible again, leave the obstacle and continue.</li>
<li>Stop when <span class="math inline">\(G\)</span> is reached or no progress can be made.</li>
</ol>
<p>This uses <em>only</em> local sensing and position awareness relative to the goal.</p>
</section>
<section id="tiny-code-python-example-31" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-31">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(a, b):</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bug2(start, goal, obstacles, step<span class="op">=</span><span class="fl">1.0</span>, max_iter<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> <span class="bu">list</span>(start)</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> [<span class="bu">tuple</span>(pos)]</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Direct motion toward goal</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>        dir_vec <span class="op">=</span> [goal[<span class="dv">0</span>]<span class="op">-</span>pos[<span class="dv">0</span>], goal[<span class="dv">1</span>]<span class="op">-</span>pos[<span class="dv">1</span>]]</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">=</span> math.hypot(<span class="op">*</span>dir_vec)</span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist <span class="op">&lt;</span> <span class="fl">1.0</span>:</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>            path.append(<span class="bu">tuple</span>(goal))</span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>        dir_vec <span class="op">=</span> [dir_vec[<span class="dv">0</span>]<span class="op">/</span>dist, dir_vec[<span class="dv">1</span>]<span class="op">/</span>dist]</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>        next_pos <span class="op">=</span> [pos[<span class="dv">0</span>]<span class="op">+</span>step<span class="op">*</span>dir_vec[<span class="dv">0</span>], pos[<span class="dv">1</span>]<span class="op">+</span>step<span class="op">*</span>dir_vec[<span class="dv">1</span>]]</span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simple obstacle check</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>        hit <span class="op">=</span> <span class="bu">any</span>(distance(next_pos, o) <span class="op">&lt;</span> <span class="fl">2.0</span> <span class="cf">for</span> o <span class="kw">in</span> obstacles)</span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> hit:</span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Follow boundary (simplified)</span></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>            next_pos[<span class="dv">0</span>] <span class="op">+=</span> step <span class="op">*</span> dir_vec[<span class="dv">1</span>]</span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a>            next_pos[<span class="dv">1</span>] <span class="op">-=</span> step <span class="op">*</span> dir_vec[<span class="dv">0</span>]</span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> next_pos</span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a>        path.append(<span class="bu">tuple</span>(pos))</span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-90" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-90">Why It Matters</h4>
<ul>
<li><p>Requires only local sensing, no precomputed map.</p></li>
<li><p>Works in unknown or dynamic environments.</p></li>
<li><p>Computationally cheap and robust to sensor noise.</p></li>
<li><p>Commonly used in:</p>
<ul>
<li>Low-cost autonomous robots</li>
<li>Simple drones or rovers</li>
<li>Embedded microcontroller systems</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-77" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-77">A Gentle Proof (Why It Works)</h4>
<p>Bug algorithms guarantee goal reachability if:</p>
<ul>
<li>The robot can detect when it reaches the goal, and</li>
<li>The environment is bounded with finite obstacles.</li>
</ul>
<p>Because each boundary is followed deterministically and revisited positions are avoided, the path length is bounded and the robot will either:</p>
<ol type="1">
<li>Reach the goal, or</li>
<li>Prove that no path exists (after exploring all obstacles).</li>
</ol>
<p>In formal terms, Bug2 achieves <em>completeness</em> under sensor constraints.</p>
</section>
<section id="try-it-yourself-90" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-90">Try It Yourself</h4>
<ol type="1">
<li>Place a circular obstacle between start and goal.</li>
<li>Simulate Bug2, watch the robot hit the obstacle, trace its edge, then resume toward the goal.</li>
<li>Add more obstacles, note how path complexity grows.</li>
<li>Compare with A* or RRT, Bug2 paths are longer but computed instantly.</li>
</ol>
</section>
<section id="test-cases-90" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-90">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 17%">
<col style="width: 31%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Environment</th>
<th>Obstacles</th>
<th>Result</th>
<th>Path Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Empty space</td>
<td>0</td>
<td>Straight line</td>
<td>Direct</td>
</tr>
<tr class="even">
<td>Single obstacle</td>
<td>1</td>
<td>Wraps around</td>
<td>Success</td>
</tr>
<tr class="odd">
<td>Multiple obstacles</td>
<td>3</td>
<td>Sequential avoidance</td>
<td>Success</td>
</tr>
<tr class="even">
<td>Enclosed goal</td>
<td>1 enclosing</td>
<td>No path</td>
<td>Detects failure</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-90" class="level4">
<h4 class="anchored" data-anchor-id="complexity-90">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Local sensing and update</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Total path traversal</td>
<td><span class="math inline">\(O(L)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(L\)</span> is the total obstacle boundary length encountered.</p>
<p>Bug algorithms are the wanderers of robotics — they don’t see the whole map, only what lies before them, yet through patience and persistence, they find their way home.</p>
</section>
</section>
</section>
<section id="section-80.-computational-geometry-variants-and-applications" class="level1">
<h1>Section 80. Computational Geometry Variants and Applications</h1>
<section id="convex-polygon-intersection" class="level3">
<h3 class="anchored" data-anchor-id="convex-polygon-intersection">791 Convex Polygon Intersection</h3>
<p>The Convex Polygon Intersection algorithm computes the region formed by the overlap of two convex polygons. Since convex polygons have no internal concavities, the intersection itself is also convex and can be efficiently found by geometric clipping or incremental edge traversal.</p>
<section id="what-problem-are-we-solving-91" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-91">What Problem Are We Solving?</h4>
<p>Given two convex polygons ( P ) and ( Q ), we want to find their intersection polygon ( R = P Q ). This is fundamental in computational geometry, computer graphics (clipping), and collision detection.</p>
<p>Convexity guarantees that:</p>
<ul>
<li>Every line segment between two points inside a polygon remains inside it.</li>
<li>Intersection can be computed in linear time with respect to the number of edges.</li>
</ul>
</section>
<section id="how-it-works-plain-language-36" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-36">How It Works (Plain Language)</h4>
<p>There are two common approaches:</p>
<ol type="1">
<li>Half-plane Intersection (Sutherland–Hodgman): Clip one polygon against each edge of the other.</li>
</ol>
<ul>
<li>Start with all vertices of ( P ).</li>
<li>For each edge of ( Q ), keep only points inside that half-plane.</li>
<li>The result after all edges is ( P Q ).</li>
</ul>
<ol start="2" type="1">
<li>Edge Traversal (Divide and Walk): Walk around both polygons simultaneously, advancing edges by comparing angles, and collect intersection and inclusion points.</li>
</ol>
<p>Both rely on convexity: at most two intersections per edge pair, and edges stay ordered by angle.</p>
</section>
<section id="mathematical-core" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-core">Mathematical Core</h4>
<p>For each directed edge of polygon ( Q ), represented as ( (q_i, q_{i+1}) ), define a half-plane: <span class="math display">\[
H_i = { x \in \mathbb{R}^2 : (q_{i+1} - q_i) \times (x - q_i) \ge 0 }
\]</span></p>
<p>Then, the intersection polygon is: <span class="math display">\[
P \cap Q = P \cap \bigcap_i H_i
\]</span></p>
<p>Each clipping step reduces ( P ) by cutting away parts outside the current half-plane.</p>
</section>
<section id="tiny-code-python-example-32" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-32">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross(o, a, b):</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])<span class="op">*</span>(b[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>]) <span class="op">-</span> (a[<span class="dv">1</span>]<span class="op">-</span>o[<span class="dv">1</span>])<span class="op">*</span>(b[<span class="dv">0</span>]<span class="op">-</span>o[<span class="dv">0</span>])</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(p1, p2, q1, q2):</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>    A1, B1 <span class="op">=</span> p2[<span class="dv">1</span>]<span class="op">-</span>p1[<span class="dv">1</span>], p1[<span class="dv">0</span>]<span class="op">-</span>p2[<span class="dv">0</span>]</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>    C1 <span class="op">=</span> A1<span class="op">*</span>p1[<span class="dv">0</span>] <span class="op">+</span> B1<span class="op">*</span>p1[<span class="dv">1</span>]</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>    A2, B2 <span class="op">=</span> q2[<span class="dv">1</span>]<span class="op">-</span>q1[<span class="dv">1</span>], q1[<span class="dv">0</span>]<span class="op">-</span>q2[<span class="dv">0</span>]</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>    C2 <span class="op">=</span> A2<span class="op">*</span>q1[<span class="dv">0</span>] <span class="op">+</span> B2<span class="op">*</span>q1[<span class="dv">1</span>]</span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>    det <span class="op">=</span> A1<span class="op">*</span>B2 <span class="op">-</span> A2<span class="op">*</span>B1</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">abs</span>(det) <span class="op">&lt;</span> <span class="fl">1e-9</span>:</span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ((B2<span class="op">*</span>C1 <span class="op">-</span> B1<span class="op">*</span>C2)<span class="op">/</span>det, (A1<span class="op">*</span>C2 <span class="op">-</span> A2<span class="op">*</span>C1)<span class="op">/</span>det)</span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clip_polygon(poly, edge_start, edge_end):</span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>    new_poly <span class="op">=</span> []</span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(poly)):</span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a>        curr, nxt <span class="op">=</span> poly[i], poly[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(poly)]</span>
<span id="cb117-18"><a href="#cb117-18" aria-hidden="true" tabindex="-1"></a>        inside_curr <span class="op">=</span> cross(edge_start, edge_end, curr) <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb117-19"><a href="#cb117-19" aria-hidden="true" tabindex="-1"></a>        inside_next <span class="op">=</span> cross(edge_start, edge_end, nxt) <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb117-20"><a href="#cb117-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> inside_curr <span class="kw">and</span> inside_next:</span>
<span id="cb117-21"><a href="#cb117-21" aria-hidden="true" tabindex="-1"></a>            new_poly.append(nxt)</span>
<span id="cb117-22"><a href="#cb117-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> inside_curr <span class="kw">and</span> <span class="kw">not</span> inside_next:</span>
<span id="cb117-23"><a href="#cb117-23" aria-hidden="true" tabindex="-1"></a>            new_poly.append(intersect(curr, nxt, edge_start, edge_end))</span>
<span id="cb117-24"><a href="#cb117-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="kw">not</span> inside_curr <span class="kw">and</span> inside_next:</span>
<span id="cb117-25"><a href="#cb117-25" aria-hidden="true" tabindex="-1"></a>            new_poly.append(intersect(curr, nxt, edge_start, edge_end))</span>
<span id="cb117-26"><a href="#cb117-26" aria-hidden="true" tabindex="-1"></a>            new_poly.append(nxt)</span>
<span id="cb117-27"><a href="#cb117-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [p <span class="cf">for</span> p <span class="kw">in</span> new_poly <span class="cf">if</span> p]</span>
<span id="cb117-28"><a href="#cb117-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-29"><a href="#cb117-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convex_intersection(P, Q):</span>
<span id="cb117-30"><a href="#cb117-30" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> P</span>
<span id="cb117-31"><a href="#cb117-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Q)):</span>
<span id="cb117-32"><a href="#cb117-32" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> clip_polygon(result, Q[i], Q[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span><span class="bu">len</span>(Q)])</span>
<span id="cb117-33"><a href="#cb117-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> result:</span>
<span id="cb117-34"><a href="#cb117-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb117-35"><a href="#cb117-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-91" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-91">Why It Matters</h4>
<ul>
<li>Core operation in polygon clipping (used in rendering pipelines).</li>
<li>Basis for collision detection between convex objects.</li>
<li>Applied in computational geometry, GIS, and physics engines.</li>
<li>Serves as a building block for more complex geometric algorithms (e.g., Minkowski sums, SAT).</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-78" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-78">A Gentle Proof (Why It Works)</h4>
<p>Each edge of polygon ( Q ) defines a linear inequality describing its interior. Intersecting ( P ) with one half-plane maintains convexity. Successively applying all constraints from ( Q ) preserves both convexity and boundedness.</p>
<p>Since each clipping step removes vertices linearly, the total complexity is ( O(n + m) ) for polygons with ( n ) and ( m ) vertices.</p>
</section>
<section id="try-it-yourself-91" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-91">Try It Yourself</h4>
<ol type="1">
<li>Create two convex polygons ( P ) and ( Q ).</li>
<li>Use the clipping code to compute ( P Q ).</li>
<li>Visualize them, the resulting shape is always convex.</li>
<li>Experiment with disjoint, tangent, and fully-contained configurations.</li>
</ol>
</section>
<section id="test-cases-91" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-91">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon P</th>
<th>Polygon Q</th>
<th>Intersection Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Overlapping triangles</td>
<td>Quadrilateral</td>
<td>Convex quadrilateral</td>
</tr>
<tr class="even">
<td>Square inside square</td>
<td>Offset</td>
<td>Smaller convex polygon</td>
</tr>
<tr class="odd">
<td>Disjoint</td>
<td>Far apart</td>
<td>Empty</td>
</tr>
<tr class="even">
<td>Touching edge</td>
<td>Adjacent</td>
<td>Line segment</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-91" class="level4">
<h4 class="anchored" data-anchor-id="complexity-91">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Clipping</td>
<td><span class="math inline">\(O(n + m)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Half-plane tests</td>
<td><span class="math inline">\(O(n)\)</span> per edge</td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Convex polygon intersection is the architect of geometric overlap — cutting shapes not by brute force, but by logic, tracing the quiet frontier where two convex worlds meet and share common ground.</p>
</section>
</section>
<section id="minkowski-sum-1" class="level3">
<h3 class="anchored" data-anchor-id="minkowski-sum-1">792 Minkowski Sum</h3>
<p>The Minkowski Sum is a fundamental geometric operation that combines two sets of points by vector addition. In computational geometry, it is often used to model shape expansion, collision detection, and path planning, for example, growing one object by the shape of another.</p>
<section id="what-problem-are-we-solving-92" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-92">What Problem Are We Solving?</h4>
<p>Suppose we have two convex shapes, ( A ) and ( B ). We want a new shape <span class="math inline">\(A \oplus B\)</span> that represents all possible sums of one point from each shape.</p>
<p>Formally, this captures how much space one object would occupy if it “slides around” another — a key idea in motion planning and collision geometry.</p>
</section>
<section id="how-it-works-plain-language-37" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-37">How It Works (Plain Language)</h4>
<p>Given two sets <span class="math inline">\(A, B \subset \mathbb{R}^2\)</span>: <span class="math display">\[
A \oplus B = { a + b \mid a \in A, b \in B }
\]</span></p>
<p>In other words, take every point in ( A ) and translate it by every point in ( B ), then take the union of all those translations.</p>
<p>When ( A ) and ( B ) are convex polygons, the Minkowski sum is also convex. Its boundary can be constructed efficiently by merging edges in order of their angles.</p>
</section>
<section id="geometric-intuition" class="level4">
<h4 class="anchored" data-anchor-id="geometric-intuition">Geometric Intuition</h4>
<ul>
<li>Adding a circle to a polygon “rounds” its corners (used in configuration space expansion).</li>
<li>Adding a robot shape to obstacles effectively grows obstacles by the robot’s size — reducing path planning to a point navigation problem in the expanded space.</li>
</ul>
</section>
<section id="mathematical-form-3" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-form-3">Mathematical Form</h4>
<p>If ( A ) and ( B ) are convex polygons with vertices <span class="math inline">\(A = (a_1, \dots, a_n)\)</span> and <span class="math inline">\(B = (b_1, \dots, b_m)\)</span>, and both listed in counterclockwise order, then the Minkowski sum polygon can be computed by edge-wise merging:</p>
<p><span class="math display">\[
A \oplus B = \text{conv}{ a_i + b_j }
\]</span></p>
</section>
<section id="tiny-code-python-example-33" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-33">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cross(a, b):</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a[<span class="dv">0</span>]<span class="op">*</span>b[<span class="dv">1</span>] <span class="op">-</span> a[<span class="dv">1</span>]<span class="op">*</span>b[<span class="dv">0</span>]</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minkowski_sum(A, B):</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># assume convex, CCW ordered</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(A), <span class="bu">len</span>(B)</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> n <span class="kw">or</span> j <span class="op">&lt;</span> m:</span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>        result.append((A[i <span class="op">%</span> n][<span class="dv">0</span>] <span class="op">+</span> B[j <span class="op">%</span> m][<span class="dv">0</span>],</span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>                       A[i <span class="op">%</span> n][<span class="dv">1</span>] <span class="op">+</span> B[j <span class="op">%</span> m][<span class="dv">1</span>]))</span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>        crossA <span class="op">=</span> cross((A[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n][<span class="dv">0</span>]<span class="op">-</span>A[i<span class="op">%</span>n][<span class="dv">0</span>], A[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n][<span class="dv">1</span>]<span class="op">-</span>A[i<span class="op">%</span>n][<span class="dv">1</span>]),</span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>                       (B[(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>m][<span class="dv">0</span>]<span class="op">-</span>B[j<span class="op">%</span>m][<span class="dv">0</span>], B[(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>m][<span class="dv">1</span>]<span class="op">-</span>B[j<span class="op">%</span>m][<span class="dv">1</span>]))</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> crossA <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> crossA <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-92" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-92">Why It Matters</h4>
<ul>
<li><p>Collision detection: Two convex shapes ( A ) and ( B ) intersect if and only if <span class="math inline">\((A \oplus (-B))\)</span> contains the origin.</p></li>
<li><p>Motion planning: Expanding obstacles by the robot’s shape simplifies pathfinding.</p></li>
<li><p>Computational geometry: Used to build configuration spaces and approximate complex shape interactions.</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-79" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-79">A Gentle Proof (Why It Works)</h4>
<p>For convex polygons, the Minkowski sum can be obtained by adding their support functions: <span class="math display">\[
h_{A \oplus B}(u) = h_A(u) + h_B(u)
\]</span> where <span class="math inline">\(h_S(u) = \max_{x \in S} u \cdot x\)</span> gives the farthest extent of shape ( S ) along direction ( u ). The boundary of <span class="math inline">\(A \oplus B\)</span> is formed by combining the edges of ( A ) and ( B ) in ascending angular order, preserving convexity.</p>
<p>This yields an <span class="math inline">\(O(n + m)\)</span> construction algorithm.</p>
</section>
<section id="try-it-yourself-92" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-92">Try It Yourself</h4>
<ol type="1">
<li>Start with two convex polygons (e.g., triangle and square).</li>
<li>Compute their Minkowski sum, the result should “blend” their shapes.</li>
<li>Add a small circle shape to see how corners become rounded.</li>
<li>Visualize how this process enlarges one shape by another’s geometry.</li>
</ol>
</section>
<section id="test-cases-92" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-92">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 23%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Shape A</th>
<th>Shape B</th>
<th>Resulting Shape</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>Square</td>
<td>Hexagonal shape</td>
<td>Convex</td>
</tr>
<tr class="even">
<td>Rectangle</td>
<td>Circle</td>
<td>Rounded rectangle</td>
<td>Used in robot planning</td>
</tr>
<tr class="odd">
<td>Two squares</td>
<td>Same orientation</td>
<td>Larger square</td>
<td>Scaled up</td>
</tr>
<tr class="even">
<td>Irregular convex</td>
<td>Small polygon</td>
<td>Smoothed edges</td>
<td>Convex preserved</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-92" class="level4">
<h4 class="anchored" data-anchor-id="complexity-92">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Edge merging</td>
<td><span class="math inline">\(O(n + m)\)</span></td>
<td><span class="math inline">\(O(n + m)\)</span></td>
</tr>
<tr class="even">
<td>Convex hull cleanup</td>
<td><span class="math inline">\(O((n + m)\log(n+m))\)</span></td>
<td><span class="math inline">\(O(n + m)\)</span></td>
</tr>
</tbody>
</table>
<p>The Minkowski Sum is geometry’s combinatorial melody — every point in one shape sings in harmony with every point in another, producing a new, unified figure that reveals how objects truly meet in space.</p>
</section>
</section>
<section id="rotating-calipers-1" class="level3">
<h3 class="anchored" data-anchor-id="rotating-calipers-1">793 Rotating Calipers</h3>
<p>The Rotating Calipers technique is a geometric method used to solve a variety of convex polygon problems efficiently. It gets its name from the mental image of a pair of calipers rotating around a convex shape, always touching it at two parallel supporting lines.</p>
<p>This method allows for elegant linear-time computation of geometric quantities like width, diameter, minimum bounding box, or farthest point pairs.</p>
<section id="what-problem-are-we-solving-93" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-93">What Problem Are We Solving?</h4>
<p>Given a convex polygon, we often need to compute geometric measures such as:</p>
<ul>
<li>The diameter (largest distance between two vertices).</li>
<li>The width (minimum distance between two parallel lines enclosing the polygon).</li>
<li>The smallest enclosing rectangle (minimum-area bounding box).</li>
</ul>
<p>A naive approach would check all pairs of points, <span class="math inline">\(O(n^2)\)</span> work. Rotating calipers do it in linear time, leveraging convexity and geometry.</p>
</section>
<section id="how-it-works-plain-language-38" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-38">How It Works (Plain Language)</h4>
<ol type="1">
<li>Start with the convex polygon vertices in counterclockwise order.</li>
<li>Identify an initial pair of antipodal points, points lying on parallel supporting lines.</li>
<li>Rotate a pair of calipers around the polygon’s edges, maintaining contact at antipodal vertices.</li>
<li>For each edge direction, compute the relevant measurement (distance, width, etc.).</li>
<li>Record the minimum or maximum value as needed.</li>
</ol>
<p>Because each edge and vertex is visited at most once, total time is ( O(n) ).</p>
</section>
<section id="example-finding-the-diameter-of-a-convex-polygon" class="level4">
<h4 class="anchored" data-anchor-id="example-finding-the-diameter-of-a-convex-polygon">Example: Finding the Diameter of a Convex Polygon</h4>
<p>The diameter is the longest distance between any two points on the convex hull.</p>
<ol type="1">
<li>Compute the convex hull of the points (if not already convex).</li>
<li>Initialize two pointers at antipodal points.</li>
<li>For each vertex ( i ), move the opposite vertex ( j ) while the area (or cross product) increases: <span class="math display">\[
|(P_{i+1} - P_i) \times (P_{j+1} - P_i)| &gt; |(P_{i+1} - P_i) \times (P_j - P_i)|
\]</span></li>
<li>Record the maximum distance <span class="math inline">\(d = | P_i - P_j |\)</span>.</li>
</ol>
</section>
<section id="tiny-code-python-example-34" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-34">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(a, b):</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rotating_calipers(points):</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># points: list of convex hull vertices in CCW order</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>    max_dist <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>        next_i <span class="op">=</span> (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n</span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">abs</span>((points[next_i][<span class="dv">0</span>]<span class="op">-</span>points[i][<span class="dv">0</span>]) <span class="op">*</span> </span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a>                  (points[(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n][<span class="dv">1</span>]<span class="op">-</span>points[i][<span class="dv">1</span>]) <span class="op">-</span> </span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a>                  (points[next_i][<span class="dv">1</span>]<span class="op">-</span>points[i][<span class="dv">1</span>]) <span class="op">*</span> </span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>                  (points[(j<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n][<span class="dv">0</span>]<span class="op">-</span>points[i][<span class="dv">0</span>])) <span class="op">&gt;</span> <span class="bu">abs</span>(</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>                  (points[next_i][<span class="dv">0</span>]<span class="op">-</span>points[i][<span class="dv">0</span>]) <span class="op">*</span> </span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>                  (points[j][<span class="dv">1</span>]<span class="op">-</span>points[i][<span class="dv">1</span>]) <span class="op">-</span> </span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>                  (points[next_i][<span class="dv">1</span>]<span class="op">-</span>points[i][<span class="dv">1</span>]) <span class="op">*</span> </span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>                  (points[j][<span class="dv">0</span>]<span class="op">-</span>points[i][<span class="dv">0</span>])):</span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> (j <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> n</span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>        max_dist <span class="op">=</span> <span class="bu">max</span>(max_dist, distance(points[i], points[j]))</span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_dist</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-93" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-93">Why It Matters</h4>
<ul>
<li><p>Efficient: Only ( O(n) ) time for problems that naïvely take <span class="math inline">\(O(n^2)\)</span>.</p></li>
<li><p>Versatile: Works for multiple geometry tasks, distance, width, bounding boxes.</p></li>
<li><p>Geometrically intuitive: Mimics physical measurement around shapes.</p></li>
<li><p>Used in:</p>
<ul>
<li>Collision detection and bounding boxes</li>
<li>Shape analysis and convex geometry</li>
<li>Robotics and computational geometry education</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-80" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-80">A Gentle Proof (Why It Works)</h4>
<p>For a convex polygon, every direction of rotation corresponds to a unique pair of support lines. Each line contacts one vertex or edge of the polygon. As the polygon rotates by 180°, each vertex becomes a support point exactly once.</p>
<p>Thus, the total number of steps equals the number of vertices, and the maximum distance or minimum width must occur at one of these antipodal pairs.</p>
<p>This is a direct geometric consequence of convexity and the support function <span class="math inline">\(h_P(u) = \max_{x \in P} (u \cdot x)\)</span>.</p>
</section>
<section id="try-it-yourself-93" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-93">Try It Yourself</h4>
<ol type="1">
<li><p>Generate a convex polygon (e.g., a hexagon).</p></li>
<li><p>Apply rotating calipers to compute:</p>
<ul>
<li>Maximum distance (diameter).</li>
<li>Minimum distance between parallel sides (width).</li>
<li>Smallest bounding rectangle area.</li>
</ul></li>
<li><p>Visualize the calipers rotating, they always stay tangent to opposite sides.</p></li>
</ol>
</section>
<section id="test-cases-93" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-93">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Polygon</th>
<th>Vertices</th>
<th>Quantity</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square</td>
<td>4</td>
<td>Diameter</td>
<td>√2 × side length</td>
</tr>
<tr class="even">
<td>Rectangle</td>
<td>4</td>
<td>Width</td>
<td>Shorter side</td>
</tr>
<tr class="odd">
<td>Triangle</td>
<td>3</td>
<td>Diameter</td>
<td>Longest edge</td>
</tr>
<tr class="even">
<td>Hexagon</td>
<td>6</td>
<td>Bounding box</td>
<td>Matches symmetry</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-93" class="level4">
<h4 class="anchored" data-anchor-id="complexity-93">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Edge traversal</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Convex hull preprocessing</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>The Rotating Calipers technique is geometry’s compass in motion — gliding gracefully around convex shapes, measuring distances and widths in perfect rotational harmony.</p>
</section>
</section>
<section id="half-plane-intersection" class="level3">
<h3 class="anchored" data-anchor-id="half-plane-intersection">794 Half-Plane Intersection</h3>
<p>The Half-Plane Intersection algorithm finds the common region that satisfies a collection of linear inequalities, each representing a half-plane in the plane. This is a core geometric operation for computational geometry, linear programming, and visibility computations, defining convex regions efficiently.</p>
<section id="what-problem-are-we-solving-94" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-94">What Problem Are We Solving?</h4>
<p>Given a set of lines in the plane, each defining a half-plane (the region on one side of a line), find the intersection polygon of all those half-planes.</p>
<p>Each half-plane can be written as a linear inequality: <span class="math display">\[
a_i x + b_i y + c_i \le 0
\]</span> The intersection of these regions forms a convex polygon (possibly empty or unbounded).</p>
<p>Applications include:</p>
<ul>
<li>Linear feasibility regions</li>
<li>Visibility polygons</li>
<li>Clipping convex shapes</li>
<li>Solving small 2D linear programs geometrically</li>
</ul>
</section>
<section id="how-it-works-plain-language-39" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-39">How It Works (Plain Language)</h4>
<ol type="1">
<li>Represent each half-plane by its boundary line and a direction (the “inside”).</li>
<li>Sort all half-planes by the angle of their boundary line.</li>
<li>Process them one by one, maintaining the current intersection polygon (or deque).</li>
<li>Whenever adding a new half-plane, clip the current polygon by that half-plane.</li>
<li>The result after processing all half-planes is the intersection region.</li>
</ol>
<p>The convexity of half-planes guarantees that their intersection is convex.</p>
</section>
<section id="mathematical-form-4" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-form-4">Mathematical Form</h4>
<p>A half-plane is defined by the inequality: <span class="math display">\[
a_i x + b_i y + c_i \le 0
\]</span></p>
<p>The intersection region is: <span class="math display">\[
R = \bigcap_{i=1}^n { (x, y) : a_i x + b_i y + c_i \le 0 }
\]</span></p>
<p>Each boundary line divides the plane into two parts; we iteratively eliminate the “outside” portion.</p>
</section>
<section id="tiny-code-python-example-35" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-35">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>EPS <span class="op">=</span> <span class="fl">1e-9</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(L1, L2):</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    a1, b1, c1 <span class="op">=</span> L1</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    a2, b2, c2 <span class="op">=</span> L2</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    det <span class="op">=</span> a1<span class="op">*</span>b2 <span class="op">-</span> a2<span class="op">*</span>b1</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">abs</span>(det) <span class="op">&lt;</span> EPS:</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> (b1<span class="op">*</span>c2 <span class="op">-</span> b2<span class="op">*</span>c1) <span class="op">/</span> det</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> (c1<span class="op">*</span>a2 <span class="op">-</span> c2<span class="op">*</span>a1) <span class="op">/</span> det</span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x, y)</span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inside(point, line):</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    a, b, c <span class="op">=</span> line</span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">*</span>point[<span class="dv">0</span>] <span class="op">+</span> b<span class="op">*</span>point[<span class="dv">1</span>] <span class="op">+</span> c <span class="op">&lt;=</span> EPS</span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clip_polygon(poly, line):</span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(poly)</span>
<span id="cb120-22"><a href="#cb120-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb120-23"><a href="#cb120-23" aria-hidden="true" tabindex="-1"></a>        curr, nxt <span class="op">=</span> poly[i], poly[(i<span class="op">+</span><span class="dv">1</span>)<span class="op">%</span>n]</span>
<span id="cb120-24"><a href="#cb120-24" aria-hidden="true" tabindex="-1"></a>        inside_curr <span class="op">=</span> inside(curr, line)</span>
<span id="cb120-25"><a href="#cb120-25" aria-hidden="true" tabindex="-1"></a>        inside_next <span class="op">=</span> inside(nxt, line)</span>
<span id="cb120-26"><a href="#cb120-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> inside_curr <span class="kw">and</span> inside_next:</span>
<span id="cb120-27"><a href="#cb120-27" aria-hidden="true" tabindex="-1"></a>            result.append(nxt)</span>
<span id="cb120-28"><a href="#cb120-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> inside_curr <span class="kw">and</span> <span class="kw">not</span> inside_next:</span>
<span id="cb120-29"><a href="#cb120-29" aria-hidden="true" tabindex="-1"></a>            result.append(intersect((nxt[<span class="dv">0</span>]<span class="op">-</span>curr[<span class="dv">0</span>], nxt[<span class="dv">1</span>]<span class="op">-</span>curr[<span class="dv">1</span>], <span class="dv">0</span>), line))</span>
<span id="cb120-30"><a href="#cb120-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="kw">not</span> inside_curr <span class="kw">and</span> inside_next:</span>
<span id="cb120-31"><a href="#cb120-31" aria-hidden="true" tabindex="-1"></a>            result.append(intersect((nxt[<span class="dv">0</span>]<span class="op">-</span>curr[<span class="dv">0</span>], nxt[<span class="dv">1</span>]<span class="op">-</span>curr[<span class="dv">1</span>], <span class="dv">0</span>), line))</span>
<span id="cb120-32"><a href="#cb120-32" aria-hidden="true" tabindex="-1"></a>            result.append(nxt)</span>
<span id="cb120-33"><a href="#cb120-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [p <span class="cf">for</span> p <span class="kw">in</span> result <span class="cf">if</span> p]</span>
<span id="cb120-34"><a href="#cb120-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-35"><a href="#cb120-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> half_plane_intersection(lines, bound_box<span class="op">=</span><span class="dv">10000</span>):</span>
<span id="cb120-36"><a href="#cb120-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Start with a large square region</span></span>
<span id="cb120-37"><a href="#cb120-37" aria-hidden="true" tabindex="-1"></a>    poly <span class="op">=</span> [(<span class="op">-</span>bound_box,<span class="op">-</span>bound_box), (bound_box,<span class="op">-</span>bound_box),</span>
<span id="cb120-38"><a href="#cb120-38" aria-hidden="true" tabindex="-1"></a>            (bound_box,bound_box), (<span class="op">-</span>bound_box,bound_box)]</span>
<span id="cb120-39"><a href="#cb120-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb120-40"><a href="#cb120-40" aria-hidden="true" tabindex="-1"></a>        poly <span class="op">=</span> clip_polygon(poly, line)</span>
<span id="cb120-41"><a href="#cb120-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> poly:</span>
<span id="cb120-42"><a href="#cb120-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb120-43"><a href="#cb120-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> poly</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-94" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-94">Why It Matters</h4>
<ul>
<li>Computational geometry core: underlies convex clipping and linear feasibility.</li>
<li>Linear programming visualization: geometric version of simplex.</li>
<li>Graphics and vision: used in clipping, shadow casting, and visibility.</li>
<li>Path planning and robotics: defines safe navigation zones.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-81" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-81">A Gentle Proof (Why It Works)</h4>
<p>Each half-plane corresponds to a linear constraint in <span class="math inline">\(\mathbb{R}^2\)</span>. The intersection of convex sets is convex, so the result must also be convex.</p>
<p>The iterative clipping procedure successively applies intersections: <span class="math display">\[
P_{k+1} = P_k \cap H_{k+1}
\]</span> At every step, the polygon remains convex and shrinks monotonically (or becomes empty).</p>
<p>The final polygon <span class="math inline">\(P_n\)</span> satisfies all constraints simultaneously.</p>
</section>
<section id="try-it-yourself-94" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-94">Try It Yourself</h4>
<ol type="1">
<li><p>Represent constraints like:</p>
<ul>
<li><span class="math inline">\(x \ge 0\)</span></li>
<li><span class="math inline">\(y \ge 0\)</span></li>
<li><span class="math inline">\(x + y \le 5\)</span></li>
</ul></li>
<li><p>Convert them to line coefficients and pass to <code>half_plane_intersection()</code>.</p></li>
<li><p>Plot the resulting polygon, it will be the triangle bounded by those inequalities.</p></li>
</ol>
<p>Try adding or removing constraints to see how the feasible region changes.</p>
</section>
<section id="test-cases-94" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-94">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 46%">
<col style="width: 25%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Constraints</th>
<th>Resulting Shape</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3 inequalities forming a triangle</td>
<td>Finite convex polygon</td>
<td>Feasible</td>
</tr>
<tr class="even">
<td>Parallel constraints facing each other</td>
<td>Infinite strip</td>
<td>Unbounded</td>
</tr>
<tr class="odd">
<td>Inconsistent inequalities</td>
<td>Empty set</td>
<td>No intersection</td>
</tr>
<tr class="even">
<td>Rectangle constraints</td>
<td>Square</td>
<td>Simple bounded polygon</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-94" class="level4">
<h4 class="anchored" data-anchor-id="complexity-94">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Polygon clipping</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Incremental update</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>Half-Plane Intersection is geometry’s language of constraints — each line a rule, each half-plane a promise, and their intersection, the elegant shape of all that is possible.</p>
</section>
</section>
<section id="line-arrangement" class="level3">
<h3 class="anchored" data-anchor-id="line-arrangement">795 Line Arrangement</h3>
<p>A Line Arrangement is the subdivision of the plane formed by a set of lines. It is one of the most fundamental constructions in computational geometry, used to study the combinatorial complexity of planar structures and to build algorithms for point location, visibility, and geometric optimization.</p>
<section id="what-problem-are-we-solving-95" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-95">What Problem Are We Solving?</h4>
<p>Given ( n ) lines in the plane, we want to find how they divide the plane into regions, called faces, along with their edges and vertices.</p>
<p>For example:</p>
<ul>
<li>2 lines divide the plane into 4 regions.</li>
<li>3 lines (no parallels, no 3 lines meeting at one point) divide the plane into 7 regions.</li>
<li>In general, ( n ) lines divide the plane into <span class="math display">\[
\frac{n(n+1)}{2} + 1
\]</span> regions at most.</li>
</ul>
<p>Applications include:</p>
<ul>
<li>Computing intersections and visibility maps</li>
<li>Motion planning and path decomposition</li>
<li>Constructing trapezoidal maps for point location</li>
<li>Studying combinatorial geometry and duality</li>
</ul>
</section>
<section id="how-it-works-plain-language-40" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-40">How It Works (Plain Language)</h4>
<p>A line arrangement is constructed incrementally:</p>
<ol type="1">
<li>Start with an empty plane (1 region).</li>
<li>Add one line at a time.</li>
<li>Each new line intersects all previous lines, splitting some regions into two.</li>
</ol>
<p>If the lines are in general position (no parallels, no 3 concurrent lines), the number of new regions formed by the ( k )-th line is ( k ).</p>
<p>Hence, the total number of regions after ( n ) lines is: <span class="math display">\[
R(n) = 1 + \sum_{k=1}^{n} k = 1 + \frac{n(n+1)}{2}
\]</span></p>
</section>
<section id="geometric-structure" class="level4">
<h4 class="anchored" data-anchor-id="geometric-structure">Geometric Structure</h4>
<p>Each arrangement divides the plane into:</p>
<ul>
<li>Vertices (intersection points of lines)</li>
<li>Edges (line segments between intersections)</li>
<li>Faces (regions bounded by edges)</li>
</ul>
<p>The total numbers satisfy Euler’s planar formula: <span class="math display">\[
V - E + F = 1 + C
\]</span> where ( C ) is the number of connected components (for lines, ( C = 1 )).</p>
</section>
<section id="tiny-code-python-example-36" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-36">Tiny Code (Python Example)</h4>
<p>This snippet constructs intersections and counts faces for small inputs.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> intersect(l1, l2):</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    (a1,b1,c1), (a2,b2,c2) <span class="op">=</span> l1, l2</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    det <span class="op">=</span> a1<span class="op">*</span>b2 <span class="op">-</span> a2<span class="op">*</span>b1</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">abs</span>(det) <span class="op">&lt;</span> <span class="fl">1e-9</span>:</span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> (b1<span class="op">*</span>c2 <span class="op">-</span> b2<span class="op">*</span>c1) <span class="op">/</span> det</span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> (c1<span class="op">*</span>a2 <span class="op">-</span> c2<span class="op">*</span>a1) <span class="op">/</span> det</span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x, y)</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> line_arrangement(lines):</span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> []</span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (l1, l2) <span class="kw">in</span> itertools.combinations(lines, <span class="dv">2</span>):</span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> intersect(l1, l2)</span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p:</span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>            points.append(p)</span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(points), <span class="bu">len</span>(lines), <span class="dv">1</span> <span class="op">+</span> <span class="bu">len</span>(points) <span class="op">+</span> <span class="bu">len</span>(lines)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> [(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>)]</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(line_arrangement(lines))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-95" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-95">Why It Matters</h4>
<ul>
<li>Combinatorial geometry: helps bound the complexity of geometric structures.</li>
<li>Point location: foundation for efficient spatial queries.</li>
<li>Motion planning: subdivides space into navigable regions.</li>
<li>Algorithm design: leads to data structures like the trapezoidal map and arrangements in dual space.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-82" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-82">A Gentle Proof (Why It Works)</h4>
<p>When adding the ( k )-th line:</p>
<ul>
<li>It can intersect all previous ( k - 1 ) lines in distinct points.</li>
<li>These intersections divide the new line into ( k ) segments.</li>
<li>Each segment cuts through one region, creating exactly ( k ) new regions.</li>
</ul>
<p>Thus: <span class="math display">\[
R(n) = R(n-1) + n
\]</span> with ( R(0) = 1 ). By summation: <span class="math display">\[
R(n) = 1 + \frac{n(n+1)}{2}
\]</span> This argument relies only on general position, no parallel or coincident lines.</p>
</section>
<section id="try-it-yourself-95" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-95">Try It Yourself</h4>
<ol type="1">
<li>Draw 1, 2, 3, and 4 lines in general position.</li>
<li>Count regions, you’ll get 2, 4, 7, 11.</li>
<li>Verify the recurrence ( R(n) = R(n-1) + n ).</li>
<li>Try making lines parallel or concurrent, the count will drop.</li>
</ol>
</section>
<section id="test-cases-95" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-95">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Lines (n)</th>
<th>Max Regions</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>Divides plane in half</td>
</tr>
<tr class="even">
<td>2</td>
<td>4</td>
<td>Crossed lines</td>
</tr>
<tr class="odd">
<td>3</td>
<td>7</td>
<td>No parallels, no concurrency</td>
</tr>
<tr class="even">
<td>4</td>
<td>11</td>
<td>Adds 4 new regions</td>
</tr>
<tr class="odd">
<td>5</td>
<td>16</td>
<td>Continues quadratic growth</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-95" class="level4">
<h4 class="anchored" data-anchor-id="complexity-95">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Intersection computation</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="even">
<td>Incremental arrangement</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
</tbody>
</table>
<p>The Line Arrangement is geometry’s combinatorial playground — each new line adds complexity, intersections, and order, turning a simple plane into a lattice of relationships and regions.</p>
</section>
</section>
<section id="point-location-trapezoidal-map" class="level3">
<h3 class="anchored" data-anchor-id="point-location-trapezoidal-map">796 Point Location (Trapezoidal Map)</h3>
<p>The Point Location problem asks: given a planar subdivision (for example, a collection of non-intersecting line segments that divide the plane into regions), determine which region contains a given point. The Trapezoidal Map method solves this efficiently using geometry and randomization.</p>
<section id="what-problem-are-we-solving-96" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-96">What Problem Are We Solving?</h4>
<p>Given a set of non-intersecting line segments, preprocess them so we can answer queries of the form:</p>
<blockquote class="blockquote">
<p>For a point <span class="math inline">\((x, y)\)</span>, which face (region) of the subdivision contains it?</p>
</blockquote>
<p>Applications include:</p>
<ul>
<li>Finding where a point lies in a planar map or mesh</li>
<li>Ray tracing and visibility problems</li>
<li>Geographic Information Systems (GIS)</li>
<li>Computational geometry algorithms using planar subdivisions</li>
</ul>
</section>
<section id="how-it-works-plain-language-41" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-41">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Build a trapezoidal decomposition: Extend a vertical line upward and downward from each endpoint until it hits another segment or infinity. These lines partition the plane into trapezoids (possibly unbounded).</p></li>
<li><p>Build a search structure (DAG): Store the trapezoids and their adjacency in a directed acyclic graph. Each internal node represents a test (is the point to the left/right of a segment or above/below a vertex?). Each leaf corresponds to one trapezoid.</p></li>
<li><p>Query: To locate a point, traverse the DAG using the geometric tests until reaching a leaf, that leaf’s trapezoid contains the point.</p></li>
</ol>
<p>This structure allows <span class="math inline">\(O(\log n)\)</span> expected query time after <span class="math inline">\(O(n \log n)\)</span> expected preprocessing.</p>
</section>
<section id="mathematical-sketch" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-sketch">Mathematical Sketch</h4>
<p>For each segment set <span class="math inline">\(S\)</span>:</p>
<ul>
<li><p>Build vertical extensions at endpoints → set of vertical slabs.</p></li>
<li><p>Each trapezoid bounded by at most four edges:</p>
<ul>
<li>top and bottom by input segments</li>
<li>left and right by vertical lines</li>
</ul></li>
</ul>
<p>The total number of trapezoids is linear in <span class="math inline">\(n\)</span>.</p>
</section>
<section id="tiny-code-python-example-simplified" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-simplified">Tiny Code (Python Example, Simplified)</h4>
<p>Below is a conceptual skeleton; real implementations use geometric libraries.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> bisect</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TrapezoidMap:</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, segments):</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.segments <span class="op">=</span> <span class="bu">sorted</span>(segments, key<span class="op">=</span><span class="kw">lambda</span> s: <span class="bu">min</span>(s[<span class="dv">0</span>][<span class="dv">0</span>], s[<span class="dv">1</span>][<span class="dv">0</span>]))</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x_coords <span class="op">=</span> <span class="bu">sorted</span>({x <span class="cf">for</span> seg <span class="kw">in</span> segments <span class="cf">for</span> (x, _) <span class="kw">in</span> seg})</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trapezoids <span class="op">=</span> <span class="va">self</span>._build_trapezoids()</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _build_trapezoids(<span class="va">self</span>):</span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>        traps <span class="op">=</span> []</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(<span class="va">self</span>.x_coords)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>            x1, x2 <span class="op">=</span> <span class="va">self</span>.x_coords[i], <span class="va">self</span>.x_coords[i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>            traps.append(((x1, x2), <span class="va">None</span>))</span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> traps</span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> locate_point(<span class="va">self</span>, x):</span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> bisect.bisect_right(<span class="va">self</span>.x_coords, x) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.trapezoids[<span class="bu">max</span>(<span class="dv">0</span>, <span class="bu">min</span>(i, <span class="bu">len</span>(<span class="va">self</span>.trapezoids)<span class="op">-</span><span class="dv">1</span>))]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This toy version partitions the x-axis into trapezoids; real versions include y-bounds and adjacency.</p>
</section>
<section id="why-it-matters-96" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-96">Why It Matters</h4>
<ul>
<li>Fast queries: expected <span class="math inline">\(O(\log n)\)</span> point-location.</li>
<li>Scalable structure: linear space in the number of segments.</li>
<li>Broad utility: building block for Voronoi diagrams, visibility, and polygon clipping.</li>
<li>Elegant randomization: randomized incremental construction keeps it simple and robust.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-83" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-83">A Gentle Proof (Why It Works)</h4>
<p>In the randomized incremental construction:</p>
<ol type="1">
<li>Each new segment interacts with only <span class="math inline">\(O(1)\)</span> trapezoids in expectation.</li>
<li>The structure maintains expected <span class="math inline">\(O(n)\)</span> trapezoids and <span class="math inline">\(O(n)\)</span> nodes in the DAG.</li>
<li>Searching requires only <span class="math inline">\(O(\log n)\)</span> decisions on average.</li>
</ol>
<p>Thus, the expected performance bounds are: <span class="math display">\[
\text{Preprocessing: } O(n \log n), \quad \text{Query: } O(\log n)
\]</span></p>
</section>
<section id="try-it-yourself-96" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-96">Try It Yourself</h4>
<ol type="1">
<li>Draw a few line segments without intersections.</li>
<li>Extend vertical lines from endpoints to form trapezoids.</li>
<li>Pick random points and trace which trapezoid they fall in.</li>
<li>Observe how queries become simple comparisons of coordinates.</li>
</ol>
</section>
<section id="test-cases-96" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-96">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input Segments</th>
<th>Query Point</th>
<th>Output Region</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Horizontal line y = 1</td>
<td>(0, 0)</td>
<td>Below segment</td>
</tr>
<tr class="even">
<td>Two crossing diagonals</td>
<td>(1, 1)</td>
<td>Intersection region</td>
</tr>
<tr class="odd">
<td>Polygon edges</td>
<td>(2, 3)</td>
<td>Inside polygon</td>
</tr>
<tr class="even">
<td>Empty set</td>
<td>(x, y)</td>
<td>Unbounded region</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-96" class="level4">
<h4 class="anchored" data-anchor-id="complexity-96">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Expected Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build structure</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Point query</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The Trapezoidal Map turns geometry into logic — each segment defines a rule, each trapezoid a case, and every query finds its home through elegant spatial reasoning.</p>
</section>
</section>
<section id="voronoi-nearest-facility" class="level3">
<h3 class="anchored" data-anchor-id="voronoi-nearest-facility">797 Voronoi Nearest Facility</h3>
<p>The Voronoi Nearest Facility algorithm assigns every point in the plane to its nearest facility among a given set of sites. The resulting structure, called a Voronoi diagram, partitions space into cells, each representing the region of points closest to a specific facility.</p>
<section id="what-problem-are-we-solving-97" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-97">What Problem Are We Solving?</h4>
<p>Given a set of <span class="math inline">\(n\)</span> facilities (points) <span class="math inline">\(S = {p_1, p_2, \dots, p_n}\)</span>, and a query point <span class="math inline">\(q\)</span>, we want to find the facility <span class="math inline">\(p_i\)</span> minimizing the distance: <span class="math display">\[
d(q, p_i) = \min_{1 \le i \le n} \sqrt{(x_q - x_i)^2 + (y_q - y_i)^2}
\]</span></p>
<p>The Voronoi region of a facility <span class="math inline">\(p_i\)</span> is the set of all points closer to <span class="math inline">\(p_i\)</span> than to any other facility: <span class="math display">\[
V(p_i) = { q \in \mathbb{R}^2 \mid d(q, p_i) \le d(q, p_j), , \forall j \ne i }
\]</span></p>
</section>
<section id="how-it-works-plain-language-42" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-42">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Compute the Voronoi diagram for the given facilities, a planar partition of the space.</p></li>
<li><p>Each cell corresponds to one facility and contains all points for which that facility is the nearest.</p></li>
<li><p>To answer a nearest-facility query:</p>
<ul>
<li>Locate which cell the query point lies in.</li>
<li>The cell’s generator point is the nearest facility.</li>
</ul></li>
</ol>
<p>Efficient data structures allow <span class="math inline">\(O(\log n)\)</span> query time after <span class="math inline">\(O(n \log n)\)</span> preprocessing.</p>
</section>
<section id="mathematical-geometry" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-geometry">Mathematical Geometry</h4>
<p>The boundary between two facilities <span class="math inline">\(p_i\)</span> and <span class="math inline">\(p_j\)</span> is the perpendicular bisector of the segment joining them: <span class="math display">\[
(x - x_i)^2 + (y - y_i)^2 = (x - x_j)^2 + (y - y_j)^2
\]</span> Simplifying gives: <span class="math display">\[
2(x_j - x_i)x + 2(y_j - y_i)y = (x_j^2 + y_j^2) - (x_i^2 + y_i^2)
\]</span></p>
<p>Each pair contributes a bisector line, and their intersections define Voronoi vertices.</p>
</section>
<section id="tiny-code-python-example-37" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-37">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> Voronoi, voronoi_plot_2d</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">5</span>,<span class="dv">2</span>), (<span class="dv">3</span>,<span class="dv">5</span>), (<span class="dv">7</span>,<span class="dv">7</span>)]</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>vor <span class="op">=</span> Voronoi(points)</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> voronoi_plot_2d(vor)</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>plt.plot([p[<span class="dv">0</span>] <span class="cf">for</span> p <span class="kw">in</span> points], [p[<span class="dv">1</span>] <span class="cf">for</span> p <span class="kw">in</span> points], <span class="st">'ro'</span>)</span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>To locate a point’s nearest facility:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nearest_facility(points, q):</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> np.array(points)</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    dists <span class="op">=</span> np.linalg.norm(points <span class="op">-</span> np.array(q), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.argmin(dists)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-97" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-97">Why It Matters</h4>
<ul>
<li>Location optimization: Assign customers to nearest warehouses or service centers.</li>
<li>Computational geometry: Core primitive in spatial analysis and meshing.</li>
<li>GIS and logistics: Used in region partitioning and demand modeling.</li>
<li>Robotics and coverage: Useful in territory planning, clustering, and sensor distribution.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-84" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-84">A Gentle Proof (Why It Works)</h4>
<p>Every boundary in the Voronoi diagram is defined by equidistant points between two facilities. The plane is partitioned such that each location belongs to the region of the closest site.</p>
<p>Convexity holds because: <span class="math display">\[
V(p_i) = \bigcap_{j \ne i} { q : d(q, p_i) \le d(q, p_j) }
\]</span> and each inequality defines a half-plane, so their intersection is convex.</p>
<p>Thus, every Voronoi region is convex, and every query has a unique nearest facility.</p>
</section>
<section id="try-it-yourself-97" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-97">Try It Yourself</h4>
<ol type="1">
<li>Place three facilities on a grid.</li>
<li>Draw perpendicular bisectors between every pair.</li>
<li>Each intersection defines a Voronoi vertex.</li>
<li>Pick any random point, check which region it falls into. That facility is its nearest neighbor.</li>
</ol>
</section>
<section id="test-cases-97" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-97">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Facilities</th>
<th>Query Point</th>
<th>Nearest</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0), (5,0)</td>
<td>(2,1)</td>
<td>(0,0)</td>
</tr>
<tr class="even">
<td>(1,1), (4,4), (7,1)</td>
<td>(3,3)</td>
<td>(4,4)</td>
</tr>
<tr class="odd">
<td>(2,2), (6,6)</td>
<td>(5,3)</td>
<td>(6,6)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-97" class="level4">
<h4 class="anchored" data-anchor-id="complexity-97">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build Voronoi diagram</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Query nearest facility</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The Voronoi Nearest Facility algorithm captures a simple yet profound truth: each place on the map belongs to the facility it loves most — the one that stands closest, by pure geometric destiny.</p>
</section>
</section>
<section id="delaunay-mesh-generation" class="level3">
<h3 class="anchored" data-anchor-id="delaunay-mesh-generation">798 Delaunay Mesh Generation</h3>
<p>Delaunay Mesh Generation creates high-quality triangular meshes from a set of points, optimizing for numerical stability and smoothness. It’s a cornerstone in computational geometry, finite element methods (FEM), and computer graphics.</p>
<section id="what-problem-are-we-solving-98" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-98">What Problem Are We Solving?</h4>
<p>Given a set of points <span class="math inline">\(P = {p_1, p_2, \dots, p_n}\)</span>, we want to construct a triangulation (a division into triangles) such that:</p>
<ol type="1">
<li>No point lies inside the circumcircle of any triangle.</li>
<li>Triangles are as “well-shaped” as possible, avoiding skinny, degenerate shapes.</li>
</ol>
<p>This is known as the Delaunay Triangulation.</p>
</section>
<section id="how-it-works-plain-language-43" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-43">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Start with a bounding triangle that contains all points.</p></li>
<li><p>Insert points one by one:</p>
<ul>
<li>For each new point, find all triangles whose circumcircle contains it.</li>
<li>Remove those triangles, forming a polygonal hole.</li>
<li>Connect the new point to the vertices of the hole to form new triangles.</li>
</ul></li>
<li><p>Remove any triangle connected to the bounding vertices.</p></li>
</ol>
<p>The result is a triangulation maximizing the minimum angle among all triangles.</p>
</section>
<section id="mathematical-criterion" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-criterion">Mathematical Criterion</h4>
<p>For any triangle <span class="math inline">\(\triangle ABC\)</span> with circumcircle passing through points <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span>, a fourth point <span class="math inline">\(D\)</span> violates the Delaunay condition if it lies inside that circle.</p>
<p>This can be tested via determinant:</p>
<p><span class="math display">\[
\begin{vmatrix}
x_A &amp; y_A &amp; x_A^2 + y_A^2 &amp; 1 \\
x_B &amp; y_B &amp; x_B^2 + y_B^2 &amp; 1 \\
x_C &amp; y_C &amp; x_C^2 + y_C^2 &amp; 1 \\
x_D &amp; y_D &amp; x_D^2 + y_D^2 &amp; 1
\end{vmatrix} &gt; 0
\]</span></p>
<p>If the determinant is positive, <span class="math inline">\(D\)</span> lies inside the circumcircle — hence, the triangulation must be flipped to restore the Delaunay property.</p>
</section>
<section id="tiny-code-python-example-38" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-38">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> Delaunay</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> np.random.rand(<span class="dv">10</span>, <span class="dv">2</span>)</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>tri <span class="op">=</span> Delaunay(points)</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>plt.triplot(points[:,<span class="dv">0</span>], points[:,<span class="dv">1</span>], tri.simplices)</span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>plt.plot(points[:,<span class="dv">0</span>], points[:,<span class="dv">1</span>], <span class="st">'o'</span>)</span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This snippet generates a 2D Delaunay triangulation and plots it.</p>
</section>
<section id="why-it-matters-98" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-98">Why It Matters</h4>
<ul>
<li>Finite Element Analysis (FEA): provides well-conditioned meshes for simulations.</li>
<li>Terrain and surface modeling: builds smooth, non-overlapping triangulations.</li>
<li>Computer graphics: used in tessellation, shading, and 3D modeling.</li>
<li>Scientific computing: enables stable numerical interpolation.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-85" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-85">A Gentle Proof (Why It Works)</h4>
<p>Delaunay triangulation maximizes the minimum angle among all triangulations of <span class="math inline">\(P\)</span>. This avoids thin, elongated triangles that cause instability.</p>
<p>Key geometric duality:</p>
<ul>
<li>The Delaunay Triangulation is the dual of the Voronoi Diagram.</li>
<li>Each Delaunay edge connects points whose Voronoi cells share a boundary.</li>
</ul>
<p>Thus, constructing one automatically defines the other.</p>
</section>
<section id="try-it-yourself-98" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-98">Try It Yourself</h4>
<ol type="1">
<li>Plot a few random points on paper.</li>
<li>Draw their circumcircles and find intersections that don’t contain any other points.</li>
<li>Connect those points, you’ve built a Delaunay triangulation manually.</li>
<li>Now perturb one point slightly, notice how the structure adjusts while staying valid.</li>
</ol>
</section>
<section id="test-cases-98" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-98">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input Points</th>
<th>Resulting Triangles</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4 corner points</td>
<td>2 triangles</td>
<td>Simple square split</td>
</tr>
<tr class="even">
<td>Random 5 points</td>
<td>5–6 triangles</td>
<td>Depends on convex hull</td>
</tr>
<tr class="odd">
<td>10 random points</td>
<td>≈ 2n triangles</td>
<td>Typical planar density</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-98" class="level4">
<h4 class="anchored" data-anchor-id="complexity-98">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Expected Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build triangulation</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Point insertion</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Edge flip</td>
<td><span class="math inline">\(O(1)\)</span> amortized</td>
<td>,</td>
</tr>
</tbody>
</table>
</section>
<section id="variants-and-extensions" class="level4">
<h4 class="anchored" data-anchor-id="variants-and-extensions">Variants and Extensions</h4>
<ul>
<li>Constrained Delaunay Triangulation (CDT): preserves specific edges.</li>
<li>3D Delaunay Tetrahedralization: extends to spatial meshes.</li>
<li>Adaptive refinement: improves triangle quality by inserting new points.</li>
<li>Anisotropic Delaunay: accounts for directional metrics.</li>
</ul>
<p>The Delaunay mesh is where geometry meets stability — a network of triangles that knows how to stay balanced, elegant, and efficient.</p>
</section>
</section>
<section id="smallest-enclosing-circle-welzls-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="smallest-enclosing-circle-welzls-algorithm">799 Smallest Enclosing Circle (Welzl’s Algorithm)</h3>
<p>The Smallest Enclosing Circle problem finds the smallest possible circle that contains all given points in a plane. It is also known as the Minimum Enclosing Circle or Bounding Circle problem.</p>
<section id="what-problem-are-we-solving-99" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-99">What Problem Are We Solving?</h4>
<p>Given a set of points <span class="math inline">\(P = {p_1, p_2, \dots, p_n}\)</span> in 2D space, find the circle with minimum radius <span class="math inline">\(r\)</span> and center <span class="math inline">\(c = (x, y)\)</span> such that:</p>
<p><span class="math display">\[
\forall p_i \in P, \quad |p_i - c| \le r
\]</span></p>
<p>This circle “wraps” all the points as tightly as possible, like stretching a rubber band around them and fitting the smallest possible circle.</p>
</section>
<section id="how-it-works-plain-language-44" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-44">How It Works (Plain Language)</h4>
<p>The Welzl algorithm solves this efficiently using randomized incremental construction:</p>
<ol type="1">
<li><p>Shuffle the points randomly.</p></li>
<li><p>Build the enclosing circle incrementally:</p>
<ul>
<li><p>Start with no points, where the circle is undefined.</p></li>
<li><p>For each new point:</p>
<ul>
<li>If the point is inside the current circle, do nothing.</li>
<li>If it lies outside, rebuild the circle so that it includes this new point.</li>
</ul></li>
</ul></li>
<li><p>The circle can be defined by:</p>
<ul>
<li>Two points (when they are the diameter), or</li>
<li>Three points (when they define a unique circle through all).</li>
</ul></li>
</ol>
<p>Expected time complexity: O(n).</p>
</section>
<section id="geometric-construction" class="level4">
<h4 class="anchored" data-anchor-id="geometric-construction">Geometric Construction</h4>
<ol type="1">
<li><p>Two points (A, B): The circle’s center is the midpoint, radius is half the distance: <span class="math display">\[
c = \frac{A + B}{2}, \quad r = \frac{|A - B|}{2}
\]</span></p></li>
<li><p>Three points (A, B, C): The circle is the unique one passing through all three. Using perpendicular bisectors:</p>
<p><span class="math display">\[
\begin{aligned}
D &amp;= 2(A_x(B_y - C_y) + B_x(C_y - A_y) + C_x(A_y - B_y)) \
U_x &amp;= \frac{(A_x^2 + A_y^2)(B_y - C_y) + (B_x^2 + B_y^2)(C_y - A_y) + (C_x^2 + C_y^2)(A_y - B_y)}{D} \
U_y &amp;= \frac{(A_x^2 + A_y^2)(C_x - B_x) + (B_x^2 + B_y^2)(A_x - C_x) + (C_x^2 + C_y^2)(B_x - A_x)}{D}
\end{aligned}
\]</span></p>
<p>The circle’s center is <span class="math inline">\((U_x, U_y)\)</span>, radius <span class="math inline">\(r = |A - U|\)</span>.</p></li>
</ol>
</section>
<section id="tiny-code-python-example-39" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-39">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math, random</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dist(a, b):</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.hypot(a[<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>], a[<span class="dv">1</span>]<span class="op">-</span>b[<span class="dv">1</span>])</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circle_two_points(a, b):</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>    center <span class="op">=</span> ((a[<span class="dv">0</span>]<span class="op">+</span>b[<span class="dv">0</span>])<span class="op">/</span><span class="dv">2</span>, (a[<span class="dv">1</span>]<span class="op">+</span>b[<span class="dv">1</span>])<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> dist(a, b)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> center, radius</span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circle_three_points(a, b, c):</span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>    ax, ay <span class="op">=</span> a<span class="op">;</span> bx, by <span class="op">=</span> b<span class="op">;</span> cx, cy <span class="op">=</span> c</span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>(ax<span class="op">*</span>(by<span class="op">-</span>cy) <span class="op">+</span> bx<span class="op">*</span>(cy<span class="op">-</span>ay) <span class="op">+</span> cx<span class="op">*</span>(ay<span class="op">-</span>by))</span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    ux <span class="op">=</span> ((ax2<span class="op">+</span>ay2)<span class="op">*</span>(by<span class="op">-</span>cy) <span class="op">+</span> (bx2<span class="op">+</span>by2)<span class="op">*</span>(cy<span class="op">-</span>ay) <span class="op">+</span> (cx2<span class="op">+</span>cy2)<span class="op">*</span>(ay<span class="op">-</span>by)) <span class="op">/</span> d</span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>    uy <span class="op">=</span> ((ax2<span class="op">+</span>ay2)<span class="op">*</span>(cx<span class="op">-</span>bx) <span class="op">+</span> (bx2<span class="op">+</span>by2)<span class="op">*</span>(ax<span class="op">-</span>cx) <span class="op">+</span> (cx2<span class="op">+</span>cy2)<span class="op">*</span>(bx<span class="op">-</span>ax)) <span class="op">/</span> d</span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a>    center <span class="op">=</span> (ux, uy)</span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> dist(center, a)</span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> center, radius</span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> welzl(points):</span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a>    random.shuffle(points)</span>
<span id="cb127-22"><a href="#cb127-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> mec(pts, boundary):</span>
<span id="cb127-23"><a href="#cb127-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> pts <span class="kw">or</span> <span class="bu">len</span>(boundary) <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb127-24"><a href="#cb127-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(boundary) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb127-25"><a href="#cb127-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> ((<span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">0</span>)</span>
<span id="cb127-26"><a href="#cb127-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(boundary) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb127-27"><a href="#cb127-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (boundary[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb127-28"><a href="#cb127-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(boundary) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb127-29"><a href="#cb127-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> circle_two_points(<span class="op">*</span>boundary)</span>
<span id="cb127-30"><a href="#cb127-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> circle_three_points(<span class="op">*</span>boundary)</span>
<span id="cb127-31"><a href="#cb127-31" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> pts.pop()</span>
<span id="cb127-32"><a href="#cb127-32" aria-hidden="true" tabindex="-1"></a>        c, r <span class="op">=</span> mec(pts, boundary)</span>
<span id="cb127-33"><a href="#cb127-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist(c, p) <span class="op">&lt;=</span> r:</span>
<span id="cb127-34"><a href="#cb127-34" aria-hidden="true" tabindex="-1"></a>            pts.append(p)</span>
<span id="cb127-35"><a href="#cb127-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> c, r</span>
<span id="cb127-36"><a href="#cb127-36" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> mec(pts, boundary <span class="op">+</span> [p])</span>
<span id="cb127-37"><a href="#cb127-37" aria-hidden="true" tabindex="-1"></a>        pts.append(p)</span>
<span id="cb127-38"><a href="#cb127-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> res</span>
<span id="cb127-39"><a href="#cb127-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mec(points[:], [])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-99" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-99">Why It Matters</h4>
<ul>
<li>Geometric bounding: Used in collision detection and bounding volume hierarchies.</li>
<li>Clustering and spatial statistics: Encloses points tightly for area estimation.</li>
<li>Graphics and robotics: Simplifies shape approximations.</li>
<li>Data visualization: Computes compact enclosing shapes.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-86" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-86">A Gentle Proof (Why It Works)</h4>
<p>At most three points define the minimal enclosing circle:</p>
<ul>
<li>One point → circle of radius 0.</li>
<li>Two points → smallest circle with that segment as diameter.</li>
<li>Three points → smallest circle passing through them.</li>
</ul>
<p>By random insertion, each point has a small probability of requiring a rebuild, leading to expected O(n) time complexity.</p>
</section>
<section id="try-it-yourself-99" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-99">Try It Yourself</h4>
<ol type="1">
<li>Choose a few points and sketch them on graph paper.</li>
<li>Find the pair of farthest points, draw the circle through them.</li>
<li>Add another point outside, adjust the circle to include it.</li>
<li>Observe when three points define the exact smallest circle.</li>
</ol>
</section>
<section id="test-cases-99" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-99">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input Points</th>
<th>Smallest Enclosing Circle (center, radius)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0), (1,0)</td>
<td>((0.5, 0), 0.5)</td>
</tr>
<tr class="even">
<td>(0,0), (0,2), (2,0)</td>
<td>((1,1), √2)</td>
</tr>
<tr class="odd">
<td>(1,1), (2,2), (3,1)</td>
<td>((2,1.5), √1.25)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-99" class="level4">
<h4 class="anchored" data-anchor-id="complexity-99">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Expected Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build Circle</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verify</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>The Welzl algorithm reveals a simple truth in geometry: the smallest circle that embraces all points is never fragile — it’s perfectly balanced, defined by the few that reach its edge.</p>
</section>
</section>
<section id="collision-detection-separating-axis-theorem" class="level3">
<h3 class="anchored" data-anchor-id="collision-detection-separating-axis-theorem">800 Collision Detection (Separating Axis Theorem)</h3>
<p>The Separating Axis Theorem (SAT) is a fundamental geometric principle for detecting whether two convex shapes are intersecting. It provides both a proof of intersection and a way to compute minimal separating distance when they do not overlap.</p>
<section id="what-problem-are-we-solving-100" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-100">What Problem Are We Solving?</h4>
<p>Given two convex polygons (or convex polyhedra in 3D), determine whether they collide, meaning their interiors overlap, or are disjoint.</p>
<p>For convex shapes <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, the Separating Axis Theorem states:</p>
<blockquote class="blockquote">
<p>Two convex shapes do not intersect if and only if there exists a line (axis) along which their projections do not overlap.</p>
</blockquote>
<p>That line is called the separating axis.</p>
</section>
<section id="how-it-works-plain-language-45" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-45">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>For each edge of both polygons:</p>
<ul>
<li>Compute the normal vector (perpendicular to the edge).</li>
<li>Treat that normal as a potential separating axis.</li>
</ul></li>
<li><p>Project both polygons onto the axis: <span class="math display">\[
\text{projection} = [\min(v \cdot n), \max(v \cdot n)]
\]</span> where <span class="math inline">\(v\)</span> is a vertex and <span class="math inline">\(n\)</span> is the unit normal.</p></li>
<li><p>If there exists an axis where the projections do not overlap, then the polygons are not colliding.</p></li>
<li><p>If all projections overlap, the polygons intersect.</p></li>
</ol>
</section>
<section id="mathematical-test" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-test">Mathematical Test</h4>
<p>For a given axis <span class="math inline">\(n\)</span>:</p>
<p><span class="math display">\[
A_{\text{min}} = \min_{a \in A}(a \cdot n), \quad A_{\text{max}} = \max_{a \in A}(a \cdot n)
\]</span> <span class="math display">\[
B_{\text{min}} = \min_{b \in B}(b \cdot n), \quad B_{\text{max}} = \max_{b \in B}(b \cdot n)
\]</span></p>
<p>If <span class="math display">\[
A_{\text{max}} &lt; B_{\text{min}} \quad \text{or} \quad B_{\text{max}} &lt; A_{\text{min}}
\]</span> then a separating axis exists → no collision.</p>
<p>Otherwise, projections overlap → collision.</p>
</section>
<section id="tiny-code-python-example-40" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-40">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> project(polygon, axis):</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    dots <span class="op">=</span> [np.dot(v, axis) <span class="cf">for</span> v <span class="kw">in</span> polygon]</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(dots), <span class="bu">max</span>(dots)</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> overlap(a_proj, b_proj):</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">not</span> (a_proj[<span class="dv">1</span>] <span class="op">&lt;</span> b_proj[<span class="dv">0</span>] <span class="kw">or</span> b_proj[<span class="dv">1</span>] <span class="op">&lt;</span> a_proj[<span class="dv">0</span>])</span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sat_collision(polygon_a, polygon_b):</span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>    polygons <span class="op">=</span> [polygon_a, polygon_b]</span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> poly <span class="kw">in</span> polygons:</span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(poly)):</span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>            p1, p2 <span class="op">=</span> poly[i], poly[(i<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> <span class="bu">len</span>(poly)]</span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>            edge <span class="op">=</span> np.subtract(p2, p1)</span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a>            axis <span class="op">=</span> np.array([<span class="op">-</span>edge[<span class="dv">1</span>], edge[<span class="dv">0</span>]])  <span class="co"># perpendicular normal</span></span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a>            axis <span class="op">=</span> axis <span class="op">/</span> np.linalg.norm(axis)</span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> overlap(project(polygon_a, axis), project(polygon_b, axis)):</span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb128-20"><a href="#cb128-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-100" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-100">Why It Matters</h4>
<ul>
<li>Physics engines: Core for detecting collisions between objects in 2D and 3D.</li>
<li>Game development: Efficient for convex polygons, bounding boxes, and polyhedra.</li>
<li>Robotics: Used in motion planning and obstacle avoidance.</li>
<li>CAD systems: Helps test intersections between parts or surfaces.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-87" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-87">A Gentle Proof (Why It Works)</h4>
<p>Each convex polygon can be described as the intersection of half-planes. If two convex sets do not intersect, there must exist at least one hyperplane that separates them completely.</p>
<p>Projecting onto the normal vectors of all edges covers all potential separating directions. If no separation is found, the sets overlap.</p>
<p>This follows directly from the Hyperplane Separation Theorem in convex geometry.</p>
</section>
<section id="try-it-yourself-100" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-100">Try It Yourself</h4>
<ol type="1">
<li>Draw two rectangles or convex polygons on paper.</li>
<li>Compute normals for each edge.</li>
<li>Project both polygons onto each normal and compare intervals.</li>
<li>If you find one axis with no overlap, that’s your separating axis.</li>
</ol>
</section>
<section id="test-cases-100" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-100">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Shape A</th>
<th>Shape B</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Overlapping squares</td>
<td>Shifted by less than width</td>
<td>Collision</td>
</tr>
<tr class="even">
<td>Non-overlapping squares</td>
<td>Shifted by more than width</td>
<td>No collision</td>
</tr>
<tr class="odd">
<td>Triangle vs rectangle</td>
<td>Touching edge</td>
<td>Collision</td>
</tr>
<tr class="even">
<td>Triangle vs rectangle</td>
<td>Fully separated</td>
<td>No collision</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-100" class="level4">
<h4 class="anchored" data-anchor-id="complexity-100">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Collision test (2D convex)</td>
<td><span class="math inline">\(O(n + m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Collision test (3D convex polyhedra)</td>
<td><span class="math inline">\(O(n + m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the number of edges (or faces).</p>
</section>
<section id="extensions" class="level4">
<h4 class="anchored" data-anchor-id="extensions">Extensions</h4>
<ul>
<li>3D version: Use face normals and cross-products of edges as axes.</li>
<li>GJK algorithm: A faster alternative for arbitrary convex shapes.</li>
<li>EPA (Expanding Polytope Algorithm): Finds penetration depth after collision.</li>
<li>Broad-phase detection: Combine SAT with bounding volumes for efficiency.</li>
</ul>
<p>The Separating Axis Theorem captures the essence of collision logic — to find contact, we only need to look for space between. If no space exists, the objects are already meeting.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../books/en-us/list-7.html" class="pagination-link" aria-label="Chapter 7. Strings and Text Algorithms">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Chapter 7. Strings and Text Algorithms</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../books/en-us/list-9.html" class="pagination-link" aria-label="Chapter 9. Systems, Databases and Distributed Algorithms">
        <span class="nav-page-text"><span class="chapter-title">Chapter 9. Systems, Databases and Distributed Algorithms</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Chapter 4. Graph Algorithms – The Little Book of Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../books/en-us/list-5.html" rel="next">
<link href="../../books/en-us/list-3.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-27c261d06b905028a18691de25d09dde.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../books/en-us/list-4.html"><span class="chapter-title">Chapter 4. Graph Algorithms</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">The Little Book of Algorithms</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Content</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/cheatsheet.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Cheatsheet</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/book.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/plan.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Plan</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-1.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 1. Foundations of Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-2.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 2. Sorting and searching</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-3.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 3. Data Structure in Action</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-4.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Chapter 4. Graph Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-5.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 5. Dynamic Programming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-6.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 6. Mathematics for Algorithms</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#section-31.-traversals" id="toc-section-31.-traversals" class="nav-link active" data-scroll-target="#section-31.-traversals">Section 31. Traversals</a>
  <ul class="collapse">
  <li><a href="#depth-first-search-recursive" id="toc-depth-first-search-recursive" class="nav-link" data-scroll-target="#depth-first-search-recursive">301 Depth-First Search (Recursive)</a></li>
  <li><a href="#depth-first-search-iterative" id="toc-depth-first-search-iterative" class="nav-link" data-scroll-target="#depth-first-search-iterative">302 Depth-First Search (Iterative)</a></li>
  <li><a href="#breadth-first-search-queue" id="toc-breadth-first-search-queue" class="nav-link" data-scroll-target="#breadth-first-search-queue">303 Breadth-First Search (Queue)</a></li>
  <li><a href="#iterative-deepening-dfs" id="toc-iterative-deepening-dfs" class="nav-link" data-scroll-target="#iterative-deepening-dfs">304 Iterative Deepening DFS</a></li>
  <li><a href="#bidirectional-bfs" id="toc-bidirectional-bfs" class="nav-link" data-scroll-target="#bidirectional-bfs">305 Bidirectional BFS</a></li>
  <li><a href="#dfs-on-grid" id="toc-dfs-on-grid" class="nav-link" data-scroll-target="#dfs-on-grid">306 DFS on Grid</a></li>
  <li><a href="#bfs-on-grid" id="toc-bfs-on-grid" class="nav-link" data-scroll-target="#bfs-on-grid">307 BFS on Grid</a></li>
  <li><a href="#multi-source-bfs" id="toc-multi-source-bfs" class="nav-link" data-scroll-target="#multi-source-bfs">308 Multi-Source BFS</a></li>
  <li><a href="#topological-sort-dfs-based" id="toc-topological-sort-dfs-based" class="nav-link" data-scroll-target="#topological-sort-dfs-based">309 Topological Sort (DFS-based)</a></li>
  <li><a href="#topological-sort-kahns-algorithm" id="toc-topological-sort-kahns-algorithm" class="nav-link" data-scroll-target="#topological-sort-kahns-algorithm">310 Topological Sort (Kahn’s Algorithm)</a></li>
  </ul></li>
  <li><a href="#section-32.-strongly-connected-components" id="toc-section-32.-strongly-connected-components" class="nav-link" data-scroll-target="#section-32.-strongly-connected-components">Section 32. Strongly Connected Components</a>
  <ul class="collapse">
  <li><a href="#kosarajus-algorithm" id="toc-kosarajus-algorithm" class="nav-link" data-scroll-target="#kosarajus-algorithm">311 Kosaraju’s Algorithm</a></li>
  <li><a href="#tarjans-algorithm" id="toc-tarjans-algorithm" class="nav-link" data-scroll-target="#tarjans-algorithm">312 Tarjan’s Algorithm</a></li>
  <li><a href="#gabows-algorithm" id="toc-gabows-algorithm" class="nav-link" data-scroll-target="#gabows-algorithm">313 Gabow’s Algorithm</a></li>
  <li><a href="#scc-dag-construction" id="toc-scc-dag-construction" class="nav-link" data-scroll-target="#scc-dag-construction">314 SCC DAG Construction</a></li>
  <li><a href="#scc-online-merge" id="toc-scc-online-merge" class="nav-link" data-scroll-target="#scc-online-merge">315 SCC Online Merge</a></li>
  <li><a href="#component-label-propagation" id="toc-component-label-propagation" class="nav-link" data-scroll-target="#component-label-propagation">316 Component Label Propagation</a></li>
  <li><a href="#path-based-scc" id="toc-path-based-scc" class="nav-link" data-scroll-target="#path-based-scc">317 Path-Based SCC</a></li>
  <li><a href="#kosaraju-parallel-version" id="toc-kosaraju-parallel-version" class="nav-link" data-scroll-target="#kosaraju-parallel-version">318 Kosaraju Parallel Version</a></li>
  <li><a href="#dynamic-scc-maintenance" id="toc-dynamic-scc-maintenance" class="nav-link" data-scroll-target="#dynamic-scc-maintenance">319 Dynamic SCC Maintenance</a></li>
  <li><a href="#scc-for-weighted-graph" id="toc-scc-for-weighted-graph" class="nav-link" data-scroll-target="#scc-for-weighted-graph">320 SCC for Weighted Graph</a></li>
  </ul></li>
  <li><a href="#section-33.-shortest-paths" id="toc-section-33.-shortest-paths" class="nav-link" data-scroll-target="#section-33.-shortest-paths">Section 33. Shortest Paths</a>
  <ul class="collapse">
  <li><a href="#dijkstra-binary-heap" id="toc-dijkstra-binary-heap" class="nav-link" data-scroll-target="#dijkstra-binary-heap">321 Dijkstra (Binary Heap)</a></li>
  <li><a href="#dijkstra-fibonacci-heap" id="toc-dijkstra-fibonacci-heap" class="nav-link" data-scroll-target="#dijkstra-fibonacci-heap">322 Dijkstra (Fibonacci Heap)</a></li>
  <li><a href="#bellmanford" id="toc-bellmanford" class="nav-link" data-scroll-target="#bellmanford">323 Bellman–Ford</a></li>
  <li><a href="#spfa-queue-optimization" id="toc-spfa-queue-optimization" class="nav-link" data-scroll-target="#spfa-queue-optimization">324 SPFA (Queue Optimization)</a></li>
  <li><a href="#a-search" id="toc-a-search" class="nav-link" data-scroll-target="#a-search">325 A* Search</a></li>
  <li><a href="#floydwarshall" id="toc-floydwarshall" class="nav-link" data-scroll-target="#floydwarshall">326 Floyd–Warshall</a></li>
  <li><a href="#johnsons-algorithm" id="toc-johnsons-algorithm" class="nav-link" data-scroll-target="#johnsons-algorithm">327 Johnson’s Algorithm</a></li>
  <li><a href="#bfs" id="toc-bfs" class="nav-link" data-scroll-target="#bfs">328 0–1 BFS</a></li>
  <li><a href="#dials-algorithm" id="toc-dials-algorithm" class="nav-link" data-scroll-target="#dials-algorithm">329 Dial’s Algorithm</a></li>
  <li><a href="#multi-source-dijkstra" id="toc-multi-source-dijkstra" class="nav-link" data-scroll-target="#multi-source-dijkstra">330 Multi-Source Dijkstra</a></li>
  </ul></li>
  <li><a href="#section-34.-shortest-path-variants" id="toc-section-34.-shortest-path-variants" class="nav-link" data-scroll-target="#section-34.-shortest-path-variants">Section 34. Shortest Path Variants</a>
  <ul class="collapse">
  <li><a href="#bfs-1" id="toc-bfs-1" class="nav-link" data-scroll-target="#bfs-1">331 0–1 BFS</a></li>
  <li><a href="#bidirectional-dijkstra" id="toc-bidirectional-dijkstra" class="nav-link" data-scroll-target="#bidirectional-dijkstra">332 Bidirectional Dijkstra</a></li>
  <li><a href="#a-with-euclidean-heuristic" id="toc-a-with-euclidean-heuristic" class="nav-link" data-scroll-target="#a-with-euclidean-heuristic">333 A* with Euclidean Heuristic</a></li>
  <li><a href="#alt-algorithm-a-landmarks-triangle-inequality" id="toc-alt-algorithm-a-landmarks-triangle-inequality" class="nav-link" data-scroll-target="#alt-algorithm-a-landmarks-triangle-inequality">334 ALT Algorithm (A* Landmarks + Triangle Inequality)</a></li>
  <li><a href="#contraction-hierarchies" id="toc-contraction-hierarchies" class="nav-link" data-scroll-target="#contraction-hierarchies">335 Contraction Hierarchies</a></li>
  <li><a href="#ch-query-algorithm-shortcut-based-routing" id="toc-ch-query-algorithm-shortcut-based-routing" class="nav-link" data-scroll-target="#ch-query-algorithm-shortcut-based-routing">336 CH Query Algorithm (Shortcut-Based Routing)</a></li>
  <li><a href="#bellmanford-queue-variant-early-termination-spfa" id="toc-bellmanford-queue-variant-early-termination-spfa" class="nav-link" data-scroll-target="#bellmanford-queue-variant-early-termination-spfa">337 Bellman–Ford Queue Variant (Early Termination SPFA)</a></li>
  <li><a href="#dijkstra-with-early-stop" id="toc-dijkstra-with-early-stop" class="nav-link" data-scroll-target="#dijkstra-with-early-stop">338 Dijkstra with Early Stop</a></li>
  <li><a href="#goal-directed-search" id="toc-goal-directed-search" class="nav-link" data-scroll-target="#goal-directed-search">339 Goal-Directed Search</a></li>
  <li><a href="#yens-k-shortest-paths" id="toc-yens-k-shortest-paths" class="nav-link" data-scroll-target="#yens-k-shortest-paths">340 Yen’s K Shortest Paths</a></li>
  </ul></li>
  <li><a href="#section-35.-minimum-spanning-trees" id="toc-section-35.-minimum-spanning-trees" class="nav-link" data-scroll-target="#section-35.-minimum-spanning-trees">Section 35. Minimum Spanning Trees</a>
  <ul class="collapse">
  <li><a href="#kruskals-algorithm" id="toc-kruskals-algorithm" class="nav-link" data-scroll-target="#kruskals-algorithm">341 Kruskal’s Algorithm</a></li>
  <li><a href="#prims-algorithm-heap" id="toc-prims-algorithm-heap" class="nav-link" data-scroll-target="#prims-algorithm-heap">342 Prim’s Algorithm (Heap)</a></li>
  <li><a href="#prims-algorithm-adjacency-matrix" id="toc-prims-algorithm-adjacency-matrix" class="nav-link" data-scroll-target="#prims-algorithm-adjacency-matrix">343 Prim’s Algorithm (Adjacency Matrix)</a></li>
  <li><a href="#borůvkas-algorithm" id="toc-borůvkas-algorithm" class="nav-link" data-scroll-target="#borůvkas-algorithm">344 Borůvka’s Algorithm</a></li>
  <li><a href="#reverse-delete-mst" id="toc-reverse-delete-mst" class="nav-link" data-scroll-target="#reverse-delete-mst">345 Reverse-Delete MST</a></li>
  <li><a href="#mst-via-dijkstra-trick" id="toc-mst-via-dijkstra-trick" class="nav-link" data-scroll-target="#mst-via-dijkstra-trick">346 MST via Dijkstra Trick</a></li>
  <li><a href="#dynamic-mst-maintenance" id="toc-dynamic-mst-maintenance" class="nav-link" data-scroll-target="#dynamic-mst-maintenance">347 Dynamic MST Maintenance</a></li>
  <li><a href="#minimum-bottleneck-spanning-tree" id="toc-minimum-bottleneck-spanning-tree" class="nav-link" data-scroll-target="#minimum-bottleneck-spanning-tree">348 Minimum Bottleneck Spanning Tree</a></li>
  <li><a href="#manhattan-mst" id="toc-manhattan-mst" class="nav-link" data-scroll-target="#manhattan-mst">349 Manhattan MST</a></li>
  <li><a href="#euclidean-mst-kruskal-geometry" id="toc-euclidean-mst-kruskal-geometry" class="nav-link" data-scroll-target="#euclidean-mst-kruskal-geometry">350 Euclidean MST (Kruskal + Geometry)</a></li>
  </ul></li>
  <li><a href="#section-36.-flows" id="toc-section-36.-flows" class="nav-link" data-scroll-target="#section-36.-flows">Section 36. Flows</a>
  <ul class="collapse">
  <li><a href="#fordfulkerson" id="toc-fordfulkerson" class="nav-link" data-scroll-target="#fordfulkerson">351 Ford–Fulkerson</a></li>
  <li><a href="#edmondskarp" id="toc-edmondskarp" class="nav-link" data-scroll-target="#edmondskarp">352 Edmonds–Karp</a></li>
  <li><a href="#dinics-algorithm" id="toc-dinics-algorithm" class="nav-link" data-scroll-target="#dinics-algorithm">353 Dinic’s Algorithm</a></li>
  <li><a href="#pushrelabel" id="toc-pushrelabel" class="nav-link" data-scroll-target="#pushrelabel">354 Push–Relabel</a></li>
  <li><a href="#capacity-scaling" id="toc-capacity-scaling" class="nav-link" data-scroll-target="#capacity-scaling">355 Capacity Scaling</a></li>
  <li><a href="#cost-scaling" id="toc-cost-scaling" class="nav-link" data-scroll-target="#cost-scaling">356 Cost Scaling</a></li>
  <li><a href="#min-cost-max-flow-bellman-ford" id="toc-min-cost-max-flow-bellman-ford" class="nav-link" data-scroll-target="#min-cost-max-flow-bellman-ford">357 Min-Cost Max-Flow (Bellman-Ford)</a></li>
  <li><a href="#min-cost-max-flow-spfa" id="toc-min-cost-max-flow-spfa" class="nav-link" data-scroll-target="#min-cost-max-flow-spfa">358 Min-Cost Max-Flow (SPFA)</a></li>
  <li><a href="#circulation-with-demands" id="toc-circulation-with-demands" class="nav-link" data-scroll-target="#circulation-with-demands">359 Circulation with Demands</a></li>
  <li><a href="#successive-shortest-path" id="toc-successive-shortest-path" class="nav-link" data-scroll-target="#successive-shortest-path">360 Successive Shortest Path</a></li>
  </ul></li>
  <li><a href="#section-37.-cuts" id="toc-section-37.-cuts" class="nav-link" data-scroll-target="#section-37.-cuts">Section 37. Cuts</a>
  <ul class="collapse">
  <li><a href="#stoerwagner-minimum-cut" id="toc-stoerwagner-minimum-cut" class="nav-link" data-scroll-target="#stoerwagner-minimum-cut">361 Stoer–Wagner Minimum Cut</a></li>
  <li><a href="#kargers-randomized-cut" id="toc-kargers-randomized-cut" class="nav-link" data-scroll-target="#kargers-randomized-cut">362 Karger’s Randomized Cut</a></li>
  <li><a href="#kargerstein-minimum-cut" id="toc-kargerstein-minimum-cut" class="nav-link" data-scroll-target="#kargerstein-minimum-cut">363 Karger–Stein Minimum Cut</a></li>
  <li><a href="#gomoryhu-tree" id="toc-gomoryhu-tree" class="nav-link" data-scroll-target="#gomoryhu-tree">364 Gomory–Hu Tree</a></li>
  <li><a href="#max-flow-min-cut-theorem" id="toc-max-flow-min-cut-theorem" class="nav-link" data-scroll-target="#max-flow-min-cut-theorem">365 Max-Flow Min-Cut Theorem</a></li>
  <li><a href="#stoerwagner-repeated-phase" id="toc-stoerwagner-repeated-phase" class="nav-link" data-scroll-target="#stoerwagner-repeated-phase">366 Stoer–Wagner Repeated Phase</a></li>
  <li><a href="#dynamic-min-cut" id="toc-dynamic-min-cut" class="nav-link" data-scroll-target="#dynamic-min-cut">367 Dynamic Min Cut</a></li>
  <li><a href="#minimum-st-cut-edmondskarp" id="toc-minimum-st-cut-edmondskarp" class="nav-link" data-scroll-target="#minimum-st-cut-edmondskarp">368 Minimum s–t Cut (Edmonds–Karp)</a></li>
  <li><a href="#approximate-min-cut" id="toc-approximate-min-cut" class="nav-link" data-scroll-target="#approximate-min-cut">369 Approximate Min Cut</a></li>
  <li><a href="#min-k-cut" id="toc-min-k-cut" class="nav-link" data-scroll-target="#min-k-cut">370 Min k-Cut</a></li>
  </ul></li>
  <li><a href="#section-38.-matchings" id="toc-section-38.-matchings" class="nav-link" data-scroll-target="#section-38.-matchings">Section 38. Matchings</a>
  <ul class="collapse">
  <li><a href="#bipartite-matching-dfs" id="toc-bipartite-matching-dfs" class="nav-link" data-scroll-target="#bipartite-matching-dfs">371 Bipartite Matching (DFS)</a></li>
  <li><a href="#hopcroftkarp" id="toc-hopcroftkarp" class="nav-link" data-scroll-target="#hopcroftkarp">372 Hopcroft–Karp</a></li>
  <li><a href="#hungarian-algorithm" id="toc-hungarian-algorithm" class="nav-link" data-scroll-target="#hungarian-algorithm">373 Hungarian Algorithm</a></li>
  <li><a href="#kuhnmunkres-max-weight-matching" id="toc-kuhnmunkres-max-weight-matching" class="nav-link" data-scroll-target="#kuhnmunkres-max-weight-matching">374 Kuhn–Munkres (Max-Weight Matching)</a></li>
  <li><a href="#blossom-algorithm" id="toc-blossom-algorithm" class="nav-link" data-scroll-target="#blossom-algorithm">375 Blossom Algorithm</a></li>
  <li><a href="#edmonds-blossom-shrinking" id="toc-edmonds-blossom-shrinking" class="nav-link" data-scroll-target="#edmonds-blossom-shrinking">376 Edmonds’ Blossom Shrinking</a></li>
  <li><a href="#greedy-matching" id="toc-greedy-matching" class="nav-link" data-scroll-target="#greedy-matching">377 Greedy Matching</a></li>
  <li><a href="#stable-marriage-galeshapley" id="toc-stable-marriage-galeshapley" class="nav-link" data-scroll-target="#stable-marriage-galeshapley">378 Stable Marriage (Gale–Shapley)</a></li>
  <li><a href="#weighted-b-matching" id="toc-weighted-b-matching" class="nav-link" data-scroll-target="#weighted-b-matching">379 Weighted b-Matching</a></li>
  <li><a href="#maximal-matching" id="toc-maximal-matching" class="nav-link" data-scroll-target="#maximal-matching">380 Maximal Matching</a></li>
  </ul></li>
  <li><a href="#section-39.-tree-algorithms" id="toc-section-39.-tree-algorithms" class="nav-link" data-scroll-target="#section-39.-tree-algorithms">Section 39. Tree Algorithms</a>
  <ul class="collapse">
  <li><a href="#euler-tour-lca" id="toc-euler-tour-lca" class="nav-link" data-scroll-target="#euler-tour-lca">381 Euler Tour LCA</a></li>
  <li><a href="#binary-lifting-lca" id="toc-binary-lifting-lca" class="nav-link" data-scroll-target="#binary-lifting-lca">382 Binary Lifting LCA</a></li>
  <li><a href="#tarjans-lca-offline-dsu" id="toc-tarjans-lca-offline-dsu" class="nav-link" data-scroll-target="#tarjans-lca-offline-dsu">383 Tarjan’s LCA (Offline DSU)</a></li>
  <li><a href="#heavy-light-decomposition" id="toc-heavy-light-decomposition" class="nav-link" data-scroll-target="#heavy-light-decomposition">384 Heavy-Light Decomposition</a></li>
  <li><a href="#centroid-decomposition" id="toc-centroid-decomposition" class="nav-link" data-scroll-target="#centroid-decomposition">385 Centroid Decomposition</a></li>
  <li><a href="#tree-diameter-dfs-twice" id="toc-tree-diameter-dfs-twice" class="nav-link" data-scroll-target="#tree-diameter-dfs-twice">386 Tree Diameter (DFS Twice)</a></li>
  <li><a href="#tree-dp-subtree-based-optimization" id="toc-tree-dp-subtree-based-optimization" class="nav-link" data-scroll-target="#tree-dp-subtree-based-optimization">387 Tree DP (Subtree-Based Optimization)</a></li>
  <li><a href="#rerooting-dp-compute-all-roots-answers" id="toc-rerooting-dp-compute-all-roots-answers" class="nav-link" data-scroll-target="#rerooting-dp-compute-all-roots-answers">388 Rerooting DP (Compute All Roots’ Answers)</a></li>
  <li><a href="#binary-search-on-tree-edge-weight-constraints" id="toc-binary-search-on-tree-edge-weight-constraints" class="nav-link" data-scroll-target="#binary-search-on-tree-edge-weight-constraints">389 Binary Search on Tree (Edge Weight Constraints)</a></li>
  <li><a href="#virtual-tree-query-subset-construction" id="toc-virtual-tree-query-subset-construction" class="nav-link" data-scroll-target="#virtual-tree-query-subset-construction">390 Virtual Tree (Query Subset Construction)</a></li>
  </ul></li>
  <li><a href="#section-40.-advanced-graph-algorithms-and-tricks" id="toc-section-40.-advanced-graph-algorithms-and-tricks" class="nav-link" data-scroll-target="#section-40.-advanced-graph-algorithms-and-tricks">Section 40. Advanced Graph Algorithms and Tricks</a>
  <ul class="collapse">
  <li><a href="#topological-dp-dynamic-programming-on-dag" id="toc-topological-dp-dynamic-programming-on-dag" class="nav-link" data-scroll-target="#topological-dp-dynamic-programming-on-dag">391 Topological DP (Dynamic Programming on DAG)</a></li>
  <li><a href="#scc-condensed-graph-dp-dynamic-programming-on-meta-graph" id="toc-scc-condensed-graph-dp-dynamic-programming-on-meta-graph" class="nav-link" data-scroll-target="#scc-condensed-graph-dp-dynamic-programming-on-meta-graph">392 SCC Condensed Graph DP (Dynamic Programming on Meta-Graph)</a></li>
  <li><a href="#eulerian-path" id="toc-eulerian-path" class="nav-link" data-scroll-target="#eulerian-path">393 Eulerian Path</a></li>
  <li><a href="#hamiltonian-path" id="toc-hamiltonian-path" class="nav-link" data-scroll-target="#hamiltonian-path">394 Hamiltonian Path</a></li>
  <li><a href="#chinese-postman-problem-route-inspection" id="toc-chinese-postman-problem-route-inspection" class="nav-link" data-scroll-target="#chinese-postman-problem-route-inspection">395 Chinese Postman Problem (Route Inspection)</a></li>
  <li><a href="#hierholzers-algorithm" id="toc-hierholzers-algorithm" class="nav-link" data-scroll-target="#hierholzers-algorithm">396 Hierholzer’s Algorithm</a></li>
  <li><a href="#johnsons-cycle-finding-algorithm" id="toc-johnsons-cycle-finding-algorithm" class="nav-link" data-scroll-target="#johnsons-cycle-finding-algorithm">397 Johnson’s Cycle Finding Algorithm</a></li>
  <li><a href="#transitive-closure-floydwarshall" id="toc-transitive-closure-floydwarshall" class="nav-link" data-scroll-target="#transitive-closure-floydwarshall">398 Transitive Closure (Floyd–Warshall)</a></li>
  <li><a href="#graph-coloring-backtracking" id="toc-graph-coloring-backtracking" class="nav-link" data-scroll-target="#graph-coloring-backtracking">399 Graph Coloring (Backtracking)</a></li>
  <li><a href="#articulation-points-bridges" id="toc-articulation-points-bridges" class="nav-link" data-scroll-target="#articulation-points-bridges">400 Articulation Points &amp; Bridges</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Chapter 4. Graph Algorithms</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="section-31.-traversals" class="level2">
<h2 class="anchored" data-anchor-id="section-31.-traversals">Section 31. Traversals</h2>
<section id="depth-first-search-recursive" class="level3">
<h3 class="anchored" data-anchor-id="depth-first-search-recursive">301 Depth-First Search (Recursive)</h3>
<p>Depth-First Search (DFS) is the classic way to explore a graph deeply before backtracking. You pick a starting node, walk as far as possible along one path, and only when you hit a dead end do you turn back. It’s the “go deep first, ask questions later” of graph algorithms.</p>
<section id="what-problem-are-we-solving" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving">What Problem Are We Solving?</h4>
<p>DFS helps us visit every vertex and edge in a connected component systematically. It’s the foundation for exploring graphs, detecting cycles, classifying edges, and building more complex algorithms like topological sort, strongly connected components, and articulation point detection.</p>
<p>We want an algorithm that:</p>
<ul>
<li>Explores all reachable vertices from a start node</li>
<li>Avoids revisiting nodes</li>
<li>Records traversal order</li>
</ul>
<p>Example: You have a maze. DFS is the explorer that picks a path, goes as far as it can, and only turns back when stuck.</p>
</section>
<section id="how-does-it-work-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language">How Does It Work (Plain Language)?</h4>
<p>Think of DFS like a curious traveler: always dive deeper whenever you see a new path. When you can’t go further, step back one level and continue exploring.</p>
<p>We use recursion to model this behavior naturally, each recursive call represents entering a new node, and returning means backtracking.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 45%">
<col style="width: 20%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Current Node</th>
<th>Action</th>
<th>Stack (Call Path)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A</td>
<td>Visit A</td>
<td>[A]</td>
</tr>
<tr class="even">
<td>2</td>
<td>B</td>
<td>Visit B (A→B)</td>
<td>[A, B]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>D</td>
<td>Visit D (B→D)</td>
<td>[A, B, D]</td>
</tr>
<tr class="even">
<td>4</td>
<td>D has no unvisited neighbors</td>
<td>Backtrack</td>
<td>[A, B]</td>
</tr>
<tr class="odd">
<td>5</td>
<td>B’s next neighbor C</td>
<td>Visit C</td>
<td>[A, B, C]</td>
</tr>
<tr class="even">
<td>6</td>
<td>C done</td>
<td>Backtrack</td>
<td>[A, B] → [A]</td>
</tr>
<tr class="odd">
<td>7</td>
<td>A’s remaining neighbors</td>
<td>Visit next</td>
<td>[…]</td>
</tr>
</tbody>
</table>
<p>When recursion unwinds, we’ve explored the whole reachable graph.</p>
</section>
<section id="tiny-code-easy-versions" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions">Tiny Code (Easy Versions)</h4>
<p>C (Adjacency List Example)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> visited<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            dfs<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"DFS starting from vertex 0:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Adjacency List)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">2</span>],</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">0</span>, <span class="dv">3</span>],</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [<span class="dv">3</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(v):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    visited.add(v)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(v, end<span class="op">=</span><span class="st">" "</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            dfs(u)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>dfs(<span class="dv">0</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters">Why It Matters</h4>
<ul>
<li>Core for graph exploration and reachability</li>
<li>Forms the basis of topological sort, SCC, bridges, and cycles</li>
<li>Simple recursive structure reveals natural hierarchy of a graph</li>
<li>Helps understand backtracking and stack-based thinking</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works">A Gentle Proof (Why It Works)</h4>
<p>Each vertex is visited exactly once:</p>
<ul>
<li>When a node is first discovered, it’s marked <code>visited</code></li>
<li>The recursion ensures all its neighbors are explored</li>
<li>Once all children are done, the function returns (backtrack)</li>
</ul>
<p>So every vertex <code>v</code> triggers one call <code>dfs(v)</code>, giving O(V + E) time (each edge explored once).</p>
</section>
<section id="try-it-yourself" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself">Try It Yourself</h4>
<ol type="1">
<li>Draw a small graph (A–B–C–D) and trace DFS.</li>
<li>Modify to print entry and exit times.</li>
<li>Track parent nodes to build DFS tree.</li>
<li>Add detection for back edges (cycle test).</li>
<li>Compare with BFS traversal order.</li>
</ol>
</section>
<section id="test-cases" class="level4">
<h4 class="anchored" data-anchor-id="test-cases">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 6%">
<col style="width: 18%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Start</th>
<th>Expected Order</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A–B–C–D chain</td>
<td>A</td>
<td>A B C D</td>
<td>Straight path</td>
</tr>
<tr class="even">
<td>Triangle (A–B–C–A)</td>
<td>A</td>
<td>A B C</td>
<td>Visits all, stops at visited A</td>
</tr>
<tr class="odd">
<td>Disconnected {A–B}, {C–D}</td>
<td>A</td>
<td>A B</td>
<td>Only reachable component</td>
</tr>
<tr class="even">
<td>Directed A→B→C</td>
<td>A</td>
<td>A B C</td>
<td>Linear chain</td>
</tr>
<tr class="odd">
<td>Tree root 0</td>
<td>0</td>
<td>0 1 3 4 2 5</td>
<td>Depends on adjacency order</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity" class="level4">
<h4 class="anchored" data-anchor-id="complexity">Complexity</h4>
<ul>
<li>Time: O(V + E)</li>
<li>Space: O(V) (recursion stack + visited)</li>
</ul>
<p>DFS is your first lens into graph structure, recursive, elegant, and revealing hidden pathways one stack frame at a time.</p>
</section>
</section>
<section id="depth-first-search-iterative" class="level3">
<h3 class="anchored" data-anchor-id="depth-first-search-iterative">302 Depth-First Search (Iterative)</h3>
<p>Depth-First Search can run without recursion too. Instead of leaning on the call stack, we build our own stack explicitly. It’s the same journey, diving deep before backtracking, just with manual control over what’s next.</p>
<section id="what-problem-are-we-solving-1" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-1">What Problem Are We Solving?</h4>
<p>Recursion is elegant but not always practical. Some graphs are deep, and recursive DFS can overflow the call stack. The iterative version solves that by using a stack data structure directly, mirroring the same traversal order.</p>
<p>We want an algorithm that:</p>
<ul>
<li>Works even when recursion is too deep</li>
<li>Explicitly manages visited nodes and stack</li>
<li>Produces the same traversal as recursive DFS</li>
</ul>
<p>Example: Think of it like keeping your own to-do list of unexplored paths, each time you go deeper, you add new destinations on top of the stack.</p>
</section>
<section id="how-does-it-work-plain-language-1" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-1">How Does It Work (Plain Language)?</h4>
<p>We maintain a stack:</p>
<ol type="1">
<li>Start from a node <code>s</code>, push it on the stack.</li>
<li>Pop the top node <code>v</code>.</li>
<li>If <code>v</code> is unvisited, mark and process it.</li>
<li>Push all unvisited neighbors of <code>v</code> onto the stack.</li>
<li>Repeat until the stack is empty.</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Stack (Top → Bottom)</th>
<th>Action</th>
<th>Visited</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[A]</td>
<td>Start, pop A</td>
<td>{A}</td>
</tr>
<tr class="even">
<td>2</td>
<td>[B, C]</td>
<td>Push neighbors of A</td>
<td>{A}</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[C, B]</td>
<td>Pop B, visit B</td>
<td>{A, B}</td>
</tr>
<tr class="even">
<td>4</td>
<td>[C, D]</td>
<td>Push neighbors of B</td>
<td>{A, B}</td>
</tr>
<tr class="odd">
<td>5</td>
<td>[D, C]</td>
<td>Pop D, visit D</td>
<td>{A, B, D}</td>
</tr>
<tr class="even">
<td>6</td>
<td>[C]</td>
<td>Continue</td>
<td>{A, B, D}</td>
</tr>
<tr class="odd">
<td>7</td>
<td>[ ]</td>
<td>Pop C, visit C</td>
<td>{A, B, C, D}</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-1">Tiny Code (Easy Versions)</h4>
<p>C (Adjacency Matrix Example)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> visited<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stack<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> top <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> push<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span> stack<span class="op">[++</span>top<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span> <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> pop<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> stack<span class="op">[</span>top<span class="op">--];</span> <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_empty<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> top <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs_iterative<span class="op">(</span><span class="dt">int</span> start<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    push<span class="op">(</span>start<span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>is_empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> pop<span class="op">();</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> u <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> u<span class="op">--)</span> <span class="op">{</span> <span class="co">// reverse for consistent order</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                    push<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Iterative DFS from 0:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    dfs_iterative<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Using List as Stack)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">2</span>],</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">0</span>, <span class="dv">3</span>],</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [<span class="dv">3</span>]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>stack <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> stack:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> stack.pop()</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        visited.add(v)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(v, end<span class="op">=</span><span class="st">" "</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">reversed</span>(graph[v]):  <span class="co"># reversed for DFS-like order</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                stack.append(u)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-1" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-1">Why It Matters</h4>
<ul>
<li>Avoids recursion limits and stack overflow</li>
<li>Clear control over traversal order</li>
<li>Good for systems with limited call stack</li>
<li>Builds understanding of explicit stack simulation</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-1" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-1">A Gentle Proof (Why It Works)</h4>
<p>The stack mimics recursion: Each vertex <code>v</code> is processed once when popped, and its neighbors are pushed. Every edge is examined exactly once. So total operations = O(V + E), same as recursive DFS.</p>
<p>Each push = one recursive call; each pop = one return.</p>
</section>
<section id="try-it-yourself-1" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-1">Try It Yourself</h4>
<ol type="1">
<li>Trace iterative DFS on a small graph.</li>
<li>Compare the order with the recursive version.</li>
<li>Experiment with neighbor push order, see how output changes.</li>
<li>Add discovery and finishing times.</li>
<li>Convert to iterative topological sort by pushing finishing order to a second stack.</li>
</ol>
</section>
<section id="test-cases-1" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-1">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 6%">
<col style="width: 27%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Start</th>
<th>Order (One Possible)</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–1–2 chain</td>
<td>0</td>
<td>0 1 2</td>
<td>Simple path</td>
</tr>
<tr class="even">
<td>0→1, 0→2, 1→3</td>
<td>0</td>
<td>0 1 3 2</td>
<td>Depends on neighbor order</td>
</tr>
<tr class="odd">
<td>Cycle 0→1→2→0</td>
<td>0</td>
<td>0 1 2</td>
<td>No repeats</td>
</tr>
<tr class="even">
<td>Disconnected</td>
<td>0</td>
<td>0 1 2</td>
<td>Only connected part</td>
</tr>
<tr class="odd">
<td>Complete graph (4 nodes)</td>
<td>0</td>
<td>0 1 2 3</td>
<td>Visits all once</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-1" class="level4">
<h4 class="anchored" data-anchor-id="complexity-1">Complexity</h4>
<ul>
<li>Time: O(V + E)</li>
<li>Space: O(V) for stack and visited array</li>
</ul>
<p>Iterative DFS is your manual-gear version of recursion, same depth, same discovery, just no surprises from the call stack.</p>
</section>
</section>
<section id="breadth-first-search-queue" class="level3">
<h3 class="anchored" data-anchor-id="breadth-first-search-queue">303 Breadth-First Search (Queue)</h3>
<p>Breadth-First Search (BFS) is the explorer that moves level by level, radiating outward from the start. Instead of diving deep like DFS, BFS keeps things fair, it visits all neighbors before going deeper.</p>
<section id="what-problem-are-we-solving-2" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-2">What Problem Are We Solving?</h4>
<p>We want a way to:</p>
<ul>
<li>Explore all reachable vertices in a graph</li>
<li>Discover the shortest path in unweighted graphs</li>
<li>Process nodes in increasing distance order</li>
</ul>
<p>BFS is perfect when:</p>
<ul>
<li>Edges all have equal weight (like 1)</li>
<li>You need the fewest steps to reach a goal</li>
<li>You’re finding connected components, levels, or distances</li>
</ul>
<p>Example: Imagine spreading a rumor. Each person tells all their friends before the next wave begins, that’s BFS in action.</p>
</section>
<section id="how-does-it-work-plain-language-2" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-2">How Does It Work (Plain Language)?</h4>
<p>BFS uses a queue, a first-in, first-out line.</p>
<ol type="1">
<li><p>Start from a node <code>s</code></p></li>
<li><p>Mark it visited and enqueue it</p></li>
<li><p>While queue not empty:</p>
<ul>
<li>Dequeue front node <code>v</code></li>
<li>Visit <code>v</code></li>
<li>Enqueue all unvisited neighbors of <code>v</code></li>
</ul></li>
</ol>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 29%">
<col style="width: 26%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Queue (Front → Back)</th>
<th>Visited</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[A]</td>
<td>{A}</td>
<td>Start</td>
</tr>
<tr class="even">
<td>2</td>
<td>[B, C]</td>
<td>{A, B, C}</td>
<td>A’s neighbors</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[C, D, E]</td>
<td>{A, B, C, D, E}</td>
<td>Visit B, add its neighbors</td>
</tr>
<tr class="even">
<td>4</td>
<td>[D, E, F]</td>
<td>{A, B, C, D, E, F}</td>
<td>Visit C, add neighbors</td>
</tr>
<tr class="odd">
<td>5</td>
<td>[E, F]</td>
<td>{A…F}</td>
<td>Continue until empty</td>
</tr>
</tbody>
</table>
<p>The order you dequeue = level order traversal.</p>
</section>
<section id="tiny-code-easy-versions-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-2">Tiny Code (Easy Versions)</h4>
<p>C (Adjacency Matrix Example)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> visited<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> queue<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> front <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> rear <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> enqueue<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span> queue<span class="op">[</span>rear<span class="op">++]</span> <span class="op">=</span> v<span class="op">;</span> <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dequeue<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> queue<span class="op">[</span>front<span class="op">++];</span> <span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_empty<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> front <span class="op">==</span> rear<span class="op">;</span> <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bfs<span class="op">(</span><span class="dt">int</span> start<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>start<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    enqueue<span class="op">(</span>start<span class="op">);</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>is_empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> dequeue<span class="op">();</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                visited<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                enqueue<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"BFS starting from vertex 0:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    bfs<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Adjacency List)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">3</span>, <span class="dv">4</span>],</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">5</span>],</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [],</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: [],</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: []</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>queue <span class="op">=</span> deque([<span class="dv">0</span>])</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>visited.add(<span class="dv">0</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> queue:</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> queue.popleft()</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(v, end<span class="op">=</span><span class="st">" "</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            visited.add(u)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            queue.append(u)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-2" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-2">Why It Matters</h4>
<ul>
<li>Finds shortest paths in unweighted graphs</li>
<li>Guarantees level order visitation</li>
<li>Core for algorithms like 0–1 BFS, SPFA, and Dijkstra’s</li>
<li>Excellent for layer-based exploration and distance labeling</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-2" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-2">A Gentle Proof (Why It Works)</h4>
<p>Each vertex is visited exactly once:</p>
<ul>
<li>It’s enqueued when discovered</li>
<li>It’s dequeued once for processing</li>
<li>Each edge is checked once</li>
</ul>
<p>If all edges have weight 1, BFS discovers vertices in increasing distance order, proving shortest-path correctness.</p>
<p>Time complexity:</p>
<ul>
<li>Visiting each vertex: O(V)</li>
<li>Scanning each edge: O(E) → Total: O(V + E)</li>
</ul>
</section>
<section id="try-it-yourself-2" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-2">Try It Yourself</h4>
<ol type="1">
<li>Draw a small unweighted graph and run BFS by hand.</li>
<li>Record levels (distance from start).</li>
<li>Track parent of each vertex, reconstruct shortest path.</li>
<li>Try BFS on a tree, compare with level-order traversal.</li>
<li>Experiment on disconnected graphs, note what gets missed.</li>
</ol>
</section>
<section id="test-cases-2" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-2">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Start</th>
<th>Order</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–1–2 chain</td>
<td>0</td>
<td>0 1 2</td>
<td>[0,1,2]</td>
</tr>
<tr class="even">
<td>Triangle 0–1–2</td>
<td>0</td>
<td>0 1 2</td>
<td>[0,1,1]</td>
</tr>
<tr class="odd">
<td>Star 0→{1,2,3}</td>
<td>0</td>
<td>0 1 2 3</td>
<td>[0,1,1,1]</td>
</tr>
<tr class="even">
<td>Grid 2×2</td>
<td>0</td>
<td>0 1 2 3</td>
<td>Layered</td>
</tr>
<tr class="odd">
<td>Disconnected</td>
<td>0</td>
<td>0 1</td>
<td>Only component of 0</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-2" class="level4">
<h4 class="anchored" data-anchor-id="complexity-2">Complexity</h4>
<ul>
<li>Time: O(V + E)</li>
<li>Space: O(V) for queue and visited set</li>
</ul>
<p>BFS is your wavefront explorer, fair, systematic, and always shortest when edges are equal.</p>
</section>
</section>
<section id="iterative-deepening-dfs" class="level3">
<h3 class="anchored" data-anchor-id="iterative-deepening-dfs">304 Iterative Deepening DFS</h3>
<p>Iterative Deepening Depth-First Search (IDDFS) blends the depth control of BFS with the space efficiency of DFS. It repeatedly performs DFS with increasing depth limits, uncovering nodes level by level, but through deep-first exploration each time.</p>
<section id="what-problem-are-we-solving-3" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-3">What Problem Are We Solving?</h4>
<p>Pure DFS may wander too deep, missing nearer solutions. Pure BFS finds shortest paths but consumes large memory.</p>
<p>We need a search that:</p>
<ul>
<li>Finds shallowest solution like BFS</li>
<li>Uses O(depth) memory like DFS</li>
<li>Works in infinite or very large search spaces</li>
</ul>
<p>That’s where IDDFS shines, it performs a DFS up to a limit, then restarts with a deeper limit, repeating until the goal is found.</p>
<p>Example: Think of a diver who explores deeper with each dive, 1 meter, 2 meters, 3 meters, always sweeping from the surface down.</p>
</section>
<section id="how-does-it-work-plain-language-3" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-3">How Does It Work (Plain Language)?</h4>
<p>Each iteration increases the depth limit by one. At each stage, we perform a DFS that stops when depth exceeds the current limit.</p>
<ol type="1">
<li>Set limit = 0</li>
<li>Run DFS with depth limit = 0</li>
<li>If not found, increase limit and repeat</li>
<li>Continue until goal found or all explored</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Iteration</th>
<th>Depth Limit</th>
<th>Nodes Explored</th>
<th>Found Goal?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>Start node</td>
<td>No</td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td>Start + neighbors</td>
<td>No</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2</td>
<td>+ deeper nodes</td>
<td>Possibly</td>
</tr>
<tr class="even">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Although nodes are revisited, total cost remains efficient, like BFS’s layer-wise discovery.</p>
</section>
<section id="tiny-code-easy-versions-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-3">Tiny Code (Easy Versions)</h4>
<p>C (Depth-Limited DFS)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> found <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dls<span class="op">(</span><span class="dt">int</span> v<span class="op">,</span> <span class="dt">int</span> depth<span class="op">,</span> <span class="dt">int</span> limit<span class="op">,</span> <span class="dt">bool</span> visited<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>depth <span class="op">==</span> limit<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            dls<span class="op">(</span>u<span class="op">,</span> depth <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> limit<span class="op">,</span> visited<span class="op">);</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iddfs<span class="op">(</span><span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> max_depth<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> limit <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> limit <span class="op">&lt;=</span> max_depth<span class="op">;</span> limit<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> visited<span class="op">[</span>MAX<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Depth limit </span><span class="sc">%d</span><span class="st">: "</span><span class="op">,</span> limit<span class="op">);</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        dls<span class="op">(</span>start<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> limit<span class="op">,</span> visited<span class="op">);</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    iddfs<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Adjacency List + Depth Limit)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">3</span>],</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">4</span>],</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [],</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: []</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dls(v, depth, limit, visited):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    visited.add(v)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(v, end<span class="op">=</span><span class="st">" "</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth <span class="op">==</span> limit:</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            dls(u, depth <span class="op">+</span> <span class="dv">1</span>, limit, visited)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iddfs(start, max_depth):</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> limit <span class="kw">in</span> <span class="bu">range</span>(max_depth <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Depth limit </span><span class="sc">{</span>limit<span class="sc">}</span><span class="ss">:"</span>, end<span class="op">=</span><span class="st">" "</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        dls(start, <span class="dv">0</span>, limit, visited)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>iddfs(<span class="dv">0</span>, <span class="dv">3</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-3" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-3">Why It Matters</h4>
<ul>
<li>Combines advantages of BFS and DFS</li>
<li>Finds optimal solution in unweighted graphs</li>
<li>Uses linear space</li>
<li>Ideal for state-space search (AI, puzzles)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-3" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-3">A Gentle Proof (Why It Works)</h4>
<p>BFS guarantees shortest path; DFS uses less space. IDDFS repeats DFS with increasing limits, ensuring that:</p>
<ul>
<li>All nodes at depth <code>d</code> are visited before depth <code>d+1</code></li>
<li>Space = O(d)</li>
<li>Time ≈ O(b^d), similar to BFS in order</li>
</ul>
<p>Redundant work (revisiting nodes) is small compared to total nodes in deeper layers.</p>
</section>
<section id="try-it-yourself-3" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-3">Try It Yourself</h4>
<ol type="1">
<li>Run IDDFS on a tree; observe repeated shallow visits.</li>
<li>Count nodes visited per iteration.</li>
<li>Compare total visits with BFS.</li>
<li>Modify depth limit mid-run, what happens?</li>
<li>Use IDDFS to find a goal node at depth 3.</li>
</ol>
</section>
<section id="test-cases-3" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-3">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Goal</th>
<th>Max Depth</th>
<th>Found At</th>
<th>Order Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1→2→3</td>
<td>3</td>
<td>3</td>
<td>Depth 3</td>
<td>0 1 2 3</td>
</tr>
<tr class="even">
<td>0→{1,2}, 1→3</td>
<td>3</td>
<td>3</td>
<td>Depth 2</td>
<td>0 1 3</td>
</tr>
<tr class="odd">
<td>Star 0→{1,2,3}</td>
<td>3</td>
<td>1</td>
<td>Depth 1</td>
<td>0 1 2 3</td>
</tr>
<tr class="even">
<td>0→1→2→Goal</td>
<td>Goal=2</td>
<td>2</td>
<td>Depth 2</td>
<td>0 1 2</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-3" class="level4">
<h4 class="anchored" data-anchor-id="complexity-3">Complexity</h4>
<ul>
<li>Time: O(b^d) (like BFS)</li>
<li>Space: O(d) (like DFS)</li>
</ul>
<p>Iterative Deepening DFS is the patient climber, revisiting familiar ground, going deeper each time, ensuring no shallow treasure is missed.</p>
</section>
</section>
<section id="bidirectional-bfs" class="level3">
<h3 class="anchored" data-anchor-id="bidirectional-bfs">305 Bidirectional BFS</h3>
<p>Bidirectional BFS is the meet-in-the-middle version of BFS. Instead of starting from one end and exploring everything outward, we launch two BFS waves, one from the source and one from the target, and stop when they collide in the middle. It’s like digging a tunnel from both sides of a mountain to meet halfway.</p>
<section id="what-problem-are-we-solving-4" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-4">What Problem Are We Solving?</h4>
<p>Standard BFS explores the entire search space outward from the start until it reaches the goal, great for small graphs, but expensive when the graph is huge.</p>
<p>Bidirectional BFS cuts that exploration dramatically by searching both directions at once, halving the effective search depth.</p>
<p>We want an algorithm that:</p>
<ul>
<li>Finds the shortest path in an unweighted graph</li>
<li>Explores fewer nodes than single-source BFS</li>
<li>Stops as soon as the two waves meet</li>
</ul>
<p>Example: You’re finding the shortest route between two cities. Instead of exploring from one city across the whole map, you also send scouts from the destination. They meet somewhere, the midpoint of the shortest path.</p>
</section>
<section id="how-does-it-work-plain-language-4" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-4">How Does It Work (Plain Language)?</h4>
<p>Run two BFS searches simultaneously, one forward, one backward. At each step, expand the smaller frontier first to balance work. Stop when any node appears in both visited sets.</p>
<ol type="1">
<li>Start BFS from <code>source</code> and <code>target</code></li>
<li>Maintain two queues and two visited sets</li>
<li>Alternate expansions</li>
<li>When visited sets overlap, meeting point found</li>
<li>Combine paths for the final route</li>
</ol>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 21%">
<col style="width: 22%">
<col style="width: 19%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Forward Queue</th>
<th>Backward Queue</th>
<th>Intersection</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[S]</td>
<td>[T]</td>
<td>∅</td>
<td>Start</td>
</tr>
<tr class="even">
<td>2</td>
<td>[S1, S2]</td>
<td>[T1, T2]</td>
<td>∅</td>
<td>Expand both</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[S2, S3]</td>
<td>[T1, S2]</td>
<td>S2</td>
<td>Found meeting node</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-4">Tiny Code (Easy Versions)</h4>
<p>C (Simplified Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bfs_step<span class="op">(</span><span class="dt">bool</span> visited<span class="op">[],</span> <span class="dt">int</span> queue<span class="op">[],</span> <span class="dt">int</span> <span class="op">*</span>front<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>rear<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> <span class="op">*</span>rear <span class="op">-</span> <span class="op">*</span>front<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>size<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> queue<span class="op">[(*</span>front<span class="op">)++];</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                visited<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                queue<span class="op">[(*</span>rear<span class="op">)++]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> intersect<span class="op">(</span><span class="dt">bool</span> a<span class="op">[],</span> <span class="dt">bool</span> b<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>a<span class="op">[</span>i<span class="op">]</span> <span class="op">&amp;&amp;</span> b<span class="op">[</span>i<span class="op">])</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bidir_bfs<span class="op">(</span><span class="dt">int</span> src<span class="op">,</span> <span class="dt">int</span> dest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> vis_s<span class="op">[</span>MAX<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="kw">false</span><span class="op">},</span> vis_t<span class="op">[</span>MAX<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> qs<span class="op">[</span>MAX<span class="op">],</span> qt<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fs <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> rs <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> ft <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> rt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    qs<span class="op">[</span>rs<span class="op">++]</span> <span class="op">=</span> src<span class="op">;</span> vis_s<span class="op">[</span>src<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    qt<span class="op">[</span>rt<span class="op">++]</span> <span class="op">=</span> dest<span class="op">;</span> vis_t<span class="op">[</span>dest<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>fs <span class="op">&lt;</span> rs <span class="op">&amp;&amp;</span> ft <span class="op">&lt;</span> rt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>bfs_step<span class="op">(</span>vis_s<span class="op">,</span> qs<span class="op">,</span> <span class="op">&amp;</span>fs<span class="op">,</span> <span class="op">&amp;</span>rs<span class="op">))</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>intersect<span class="op">(</span>vis_s<span class="op">,</span> vis_t<span class="op">))</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>bfs_step<span class="op">(</span>vis_t<span class="op">,</span> qt<span class="op">,</span> <span class="op">&amp;</span>ft<span class="op">,</span> <span class="op">&amp;</span>rt<span class="op">))</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>intersect<span class="op">(</span>vis_s<span class="op">,</span> vis_t<span class="op">))</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> src <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> dest <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>bidir_bfs<span class="op">(</span>src<span class="op">,</span> dest<span class="op">))</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Path found</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"No path</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Readable Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">3</span>],</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">4</span>],</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [<span class="dv">5</span>],</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: [<span class="dv">5</span>],</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: []</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bidirectional_bfs(src, dest):</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> src <span class="op">==</span> dest:</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    q1, q2 <span class="op">=</span> deque([src]), deque([dest])</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    visited1, visited2 <span class="op">=</span> {src}, {dest}</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q1 <span class="kw">and</span> q2:</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Expand forward</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(q1)):</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> q1.popleft()</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> u <span class="kw">in</span> visited2:</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited1:</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>                    visited1.add(u)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>                    q1.append(u)</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Expand backward</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(q2)):</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> q2.popleft()</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> u <span class="kw">in</span> visited1:</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited2:</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>                    visited2.add(u)</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>                    q2.append(u)</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(bidirectional_bfs(<span class="dv">0</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-4" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-4">Why It Matters</h4>
<ul>
<li>Faster shortest-path search on large graphs</li>
<li>Reduces explored nodes from O(b^d) to roughly O(b^(d/2))</li>
<li>Excellent for pathfinding in maps, puzzles, or networks</li>
<li>Demonstrates search symmetry and frontier balancing</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-4" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-4">A Gentle Proof (Why It Works)</h4>
<p>If the shortest path length is <code>d</code>, BFS explores O(b^d) nodes, but Bidirectional BFS explores 2×O(b^(d/2)) nodes — a huge savings since b^(d/2) ≪ b^d.</p>
<p>Each side guarantees the frontier grows level by level, and intersection ensures meeting at the middle of the shortest path.</p>
</section>
<section id="try-it-yourself-4" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-4">Try It Yourself</h4>
<ol type="1">
<li>Trace bidirectional BFS on a 5-node chain (0→1→2→3→4).</li>
<li>Count nodes visited by single BFS vs bidirectional BFS.</li>
<li>Add print statements to see where the waves meet.</li>
<li>Modify to reconstruct the path.</li>
<li>Compare performance on branching graphs.</li>
</ol>
</section>
<section id="test-cases-4" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-4">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Source</th>
<th>Target</th>
<th>Found?</th>
<th>Meeting Node</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–1–2–3–4</td>
<td>0</td>
<td>4</td>
<td>✅</td>
<td>2</td>
</tr>
<tr class="even">
<td>0→1, 1→2, 2→3</td>
<td>0</td>
<td>3</td>
<td>✅</td>
<td>1 or 2</td>
</tr>
<tr class="odd">
<td>0→1, 2→3 (disconnected)</td>
<td>0</td>
<td>3</td>
<td>❌</td>
<td>–</td>
</tr>
<tr class="even">
<td>Triangle 0–1–2–0</td>
<td>0</td>
<td>2</td>
<td>✅</td>
<td>0 or 2</td>
</tr>
<tr class="odd">
<td>Star 0→{1,2,3,4}</td>
<td>1</td>
<td>2</td>
<td>✅</td>
<td>0</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-4" class="level4">
<h4 class="anchored" data-anchor-id="complexity-4">Complexity</h4>
<ul>
<li>Time: O(b^(d/2))</li>
<li>Space: O(b^(d/2))</li>
<li>Optimality: Finds shortest path in unweighted graphs</li>
</ul>
<p>Bidirectional BFS is the bridge builder, starting from both shores, racing toward the meeting point in the middle.</p>
</section>
</section>
<section id="dfs-on-grid" class="level3">
<h3 class="anchored" data-anchor-id="dfs-on-grid">306 DFS on Grid</h3>
<p>DFS on a grid is your go-to for exploring 2D maps, mazes, or islands. It works just like DFS on graphs, but here, each cell is a node and its up/down/left/right neighbors form the edges. Perfect for connected component detection, region labeling, or maze solving.</p>
<section id="what-problem-are-we-solving-5" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-5">What Problem Are We Solving?</h4>
<p>We want to explore or mark all connected cells in a grid, often used for:</p>
<ul>
<li>Counting islands in a binary matrix</li>
<li>Flood-fill algorithms (coloring regions)</li>
<li>Maze traversal (finding a path through walls)</li>
<li>Connectivity detection in 2D maps</li>
</ul>
<p>Example: Think of a painter pouring ink into one cell, DFS shows how the ink spreads to fill the entire connected region.</p>
</section>
<section id="how-does-it-work-plain-language-5" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-5">How Does It Work (Plain Language)?</h4>
<p>DFS starts from a given cell, visits it, and recursively explores all valid, unvisited neighbors.</p>
<p>We check 4 directions (or 8 if diagonals count). Each neighbor is:</p>
<ul>
<li>Within bounds</li>
<li>Not yet visited</li>
<li>Satisfies the condition (e.g., same color, value = 1)</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Current Cell</th>
<th>Action</th>
<th>Stack (Call Path)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>(0,0)</td>
<td>Visit</td>
<td>[(0,0)]</td>
</tr>
<tr class="even">
<td>2</td>
<td>(0,1)</td>
<td>Move right</td>
<td>[(0,0),(0,1)]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>(1,1)</td>
<td>Move down</td>
<td>[(0,0),(0,1),(1,1)]</td>
</tr>
<tr class="even">
<td>4</td>
<td>(1,1) has no new neighbors</td>
<td>Backtrack</td>
<td>[(0,0),(0,1)]</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Continue</td>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<p>The traversal ends when all reachable cells are visited.</p>
</section>
<section id="tiny-code-easy-versions-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-5">Tiny Code (Easy Versions)</h4>
<p>C (DFS for Island Counting)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> grid<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> visited<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dx<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dy<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>x<span class="op">][</span>y<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> nx <span class="op">=</span> x <span class="op">+</span> dx<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ny <span class="op">=</span> y <span class="op">+</span> dy<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nx <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> nx <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> ny <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> ny <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>            grid<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">])</span> <span class="op">{</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            dfs<span class="op">(</span>nx<span class="op">,</span> ny<span class="op">);</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter grid size (n m): "</span><span class="op">);</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter grid (0/1):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>                dfs<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Number of islands: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> count<span class="op">);</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Flood Fill)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> [</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>n, m <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> [[<span class="va">False</span>]<span class="op">*</span>m <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(x, y):</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> x <span class="op">&gt;=</span> n <span class="kw">or</span> y <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> y <span class="op">&gt;=</span> m:</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> grid[x][y] <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> visited[x][y]:</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    visited[x][y] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]:</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        dfs(x <span class="op">+</span> dx, y <span class="op">+</span> dy)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> grid[i][j] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> <span class="kw">not</span> visited[i][j]:</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            dfs(i, j)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of islands:"</span>, count)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-5" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-5">Why It Matters</h4>
<ul>
<li>Core tool for grid exploration and region labeling</li>
<li>Forms the heart of island problems, maze solvers, and map connectivity</li>
<li>Demonstrates DFS behavior in real-world layouts</li>
<li>Easy visualization and debugging on 2D arrays</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-5" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-5">A Gentle Proof (Why It Works)</h4>
<p>Each cell is visited exactly once, marked <code>visited</code> upon entry. Recursive calls spread to all valid neighbors. So total time = proportional to number of cells and edges (neighbors).</p>
<p>If grid has size <code>n × m</code>, and each cell checks 4 neighbors:</p>
<ul>
<li>Time: O(n × m)</li>
<li>Space: O(n × m) visited + recursion depth (≤ n × m)</li>
</ul>
<p>DFS guarantees every reachable cell is visited exactly once, forming connected components.</p>
</section>
<section id="try-it-yourself-5" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-5">Try It Yourself</h4>
<ol type="1">
<li>Change movement to 8 directions (include diagonals).</li>
<li>Modify to flood-fill a color (e.g., replace all 1s with 2s).</li>
<li>Count components in a matrix of characters (‘X’, ‘O’).</li>
<li>Visualize traversal order in a printed grid.</li>
<li>Compare with BFS on the same grid.</li>
</ol>
</section>
<section id="test-cases-5" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-5">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Grid</th>
<th>Expected</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[1,0,0],[0,1,0],[0,0,1]]</td>
<td>3</td>
<td>Diagonal not connected</td>
</tr>
<tr class="even">
<td>[[1,1,0],[1,0,0],[0,0,1]]</td>
<td>2</td>
<td>Two clusters</td>
</tr>
<tr class="odd">
<td>[[1,1,1],[1,1,1],[1,1,1]]</td>
<td>1</td>
<td>One big island</td>
</tr>
<tr class="even">
<td>[[0,0,0],[0,0,0]]</td>
<td>0</td>
<td>No land</td>
</tr>
<tr class="odd">
<td>[[1,0,1],[0,1,0],[1,0,1]]</td>
<td>5</td>
<td>Many singles</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-5" class="level4">
<h4 class="anchored" data-anchor-id="complexity-5">Complexity</h4>
<ul>
<li>Time: O(n × m)</li>
<li>Space: O(n × m) (visited) or O(depth) recursion stack</li>
</ul>
<p>DFS on grid is your map explorer, sweeping through every reachable patch, one cell at a time.</p>
</section>
</section>
<section id="bfs-on-grid" class="level3">
<h3 class="anchored" data-anchor-id="bfs-on-grid">307 BFS on Grid</h3>
<p>BFS on a grid explores cells level by level, making it perfect for shortest paths in unweighted grids, minimum steps in mazes, and distance labeling from a source. Each cell is a node and edges connect to neighbors such as up, down, left, right.</p>
<section id="what-problem-are-we-solving-6" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-6">What Problem Are We Solving?</h4>
<p>We want to:</p>
<ul>
<li>Find the shortest path from a start cell to a goal cell when each move costs the same</li>
<li>Compute a distance map from a source to all reachable cells</li>
<li>Handle obstacles cleanly and avoid revisiting</li>
</ul>
<p>Example: Given a maze as a 0 or 1 grid, where 0 is free and 1 is wall, BFS finds the fewest moves from start to target.</p>
</section>
<section id="how-does-it-work-plain-language-6" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-6">How Does It Work (Plain Language)?</h4>
<p>Use a queue. Start from the source, push it with distance 0, and expand in waves. At each step, pop the front cell, try its neighbors, mark unseen neighbors visited, and record their distance as current distance + 1.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 26%">
<col style="width: 15%">
<col style="width: 19%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Queue (front to back)</th>
<th>Current Cell</th>
<th>Action</th>
<th>Distance Updated</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[(sx, sy)]</td>
<td>(sx, sy)</td>
<td>Start</td>
<td>dist[sx][sy] = 0</td>
</tr>
<tr class="even">
<td>2</td>
<td>[(n1), (n2)]</td>
<td>(n1)</td>
<td>Visit neighbors</td>
<td>dist[n1] = 1</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[(n2), (n3), (n4)]</td>
<td>(n2)</td>
<td>Continue</td>
<td>dist[n2] = 1</td>
</tr>
<tr class="even">
<td>4</td>
<td>[…]</td>
<td>…</td>
<td>Wave expands</td>
<td>dist[next] = dist[cur] + 1</td>
</tr>
</tbody>
</table>
<p>The first time you reach the goal, the recorded distance is minimal.</p>
</section>
<section id="tiny-code-easy-versions-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-6">Tiny Code (Easy Versions)</h4>
<p>C (Shortest Path on a 0 or 1 Grid)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">200</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> grid<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span>         <span class="co">// 0 free, 1 wall</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> distv<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span>        <span class="co">// distance map</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> vis<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> qx<span class="op">[</span>MAX<span class="op">*</span>MAX<span class="op">],</span> qy<span class="op">[</span>MAX<span class="op">*</span>MAX<span class="op">];</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> front <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> rear <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dx<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dy<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> enqueue<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span> qx<span class="op">[</span>rear<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span> qy<span class="op">[</span>rear<span class="op">]</span> <span class="op">=</span> y<span class="op">;</span> rear<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dequeue<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>x<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>y<span class="op">)</span> <span class="op">{</span> <span class="op">*</span>x <span class="op">=</span> qx<span class="op">[</span>front<span class="op">];</span> <span class="op">*</span>y <span class="op">=</span> qy<span class="op">[</span>front<span class="op">];</span> front<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> empty<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> front <span class="op">==</span> rear<span class="op">;</span> <span class="op">}</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> bfs<span class="op">(</span><span class="dt">int</span> sx<span class="op">,</span> <span class="dt">int</span> sy<span class="op">,</span> <span class="dt">int</span> tx<span class="op">,</span> <span class="dt">int</span> ty<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            vis<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>            distv<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>sx<span class="op">][</span>sy<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    distv<span class="op">[</span>sx<span class="op">][</span>sy<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    enqueue<span class="op">(</span>sx<span class="op">,</span> sy<span class="op">);</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>        dequeue<span class="op">(&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> tx <span class="op">&amp;&amp;</span> y <span class="op">==</span> ty<span class="op">)</span> <span class="cf">return</span> distv<span class="op">[</span>x<span class="op">][</span>y<span class="op">];</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> nx <span class="op">=</span> x <span class="op">+</span> dx<span class="op">[</span>k<span class="op">],</span> ny <span class="op">=</span> y <span class="op">+</span> dy<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nx <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> nx <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> ny <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> ny <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>                <span class="op">!</span>vis<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">&amp;&amp;</span> grid<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>                vis<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>                distv<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">=</span> distv<span class="op">[</span>x<span class="op">][</span>y<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>                enqueue<span class="op">(</span>nx<span class="op">,</span> ny<span class="op">);</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="co">// unreachable</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter n m: "</span><span class="op">);</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter grid (0 free, 1 wall):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sx<span class="op">,</span> sy<span class="op">,</span> tx<span class="op">,</span> ty<span class="op">;</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter start sx sy and target tx ty: "</span><span class="op">);</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>sx<span class="op">,</span> <span class="op">&amp;</span>sy<span class="op">,</span> <span class="op">&amp;</span>tx<span class="op">,</span> <span class="op">&amp;</span>ty<span class="op">);</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> bfs<span class="op">(</span>sx<span class="op">,</span> sy<span class="op">,</span> tx<span class="op">,</span> ty<span class="op">);</span></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>d <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"Shortest distance: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> d<span class="op">);</span></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> printf<span class="op">(</span><span class="st">"No path</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Distance Map and Path Reconstruction)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> [</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>],</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>],</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>n, m <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs_grid(sx, sy, tx, ty):</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>m <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [[<span class="va">None</span>]<span class="op">*</span>m <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque()</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    q.append((sx, sy))</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    dist[sx][sy] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">1</span>)]:</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span>  <span class="co"># only to show directions exist</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> q.popleft()</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x, y) <span class="op">==</span> (tx, ty):</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">1</span>)]:</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>            nx, ny <span class="op">=</span> x <span class="op">+</span> dx, y <span class="op">+</span> dy</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> n <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> m <span class="kw">and</span> grid[nx][ny] <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> dist[nx][ny] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>                dist[nx][ny] <span class="op">=</span> dist[x][y] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>                parent[nx][ny] <span class="op">=</span> (x, y)</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>                q.append((nx, ny))</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct path if reachable</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dist[tx][ty] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dist, []</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> []</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    cur <span class="op">=</span> (tx, ty)</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> cur:</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>        path.append(cur)</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>        cur <span class="op">=</span> parent[cur[<span class="dv">0</span>]][cur[<span class="dv">1</span>]]</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>    path.reverse()</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist, path</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>dist, path <span class="op">=</span> bfs_grid(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Distance to target:"</span>, dist[<span class="dv">3</span>][<span class="dv">3</span>])</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Path:"</span>, path)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-6" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-6">Why It Matters</h4>
<ul>
<li>Guarantees shortest path in unweighted grids</li>
<li>Produces a full distance transform useful for many tasks</li>
<li>Robust and simple for maze solvers and robotics navigation</li>
<li>Natural stepping stone to 0 1 BFS and Dijkstra</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-6" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-6">A Gentle Proof (Why It Works)</h4>
<p>BFS processes cells by nondecreasing distance from the source. When a cell is first dequeued, the stored distance equals the minimum number of moves needed to reach it. Each free neighbor is discovered with distance plus one. Therefore the first time the goal is reached, that distance is minimal.</p>
<ul>
<li>Each cell enters the queue at most once</li>
<li>Each edge between neighboring cells is considered once</li>
</ul>
<p>Hence total work is linear in the number of cells and neighbor checks.</p>
</section>
<section id="try-it-yourself-6" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-6">Try It Yourself</h4>
<ol type="1">
<li>Add 8 directional moves and compare paths with 4 directional moves.</li>
<li>Add teleporters by connecting listed cell pairs as edges.</li>
<li>Convert to multi source BFS by enqueuing several starts with distance 0.</li>
<li>Block some cells and verify that BFS never steps through walls.</li>
<li>Record parents and print the maze with the path marked.</li>
</ol>
</section>
<section id="test-cases-6" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-6">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 24%">
<col style="width: 7%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Grid</th>
<th>Start</th>
<th>Target</th>
<th>Expected</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2 x 2 all free</td>
<td>(0,0)</td>
<td>(1,1)</td>
<td>Distance 2 via right then down</td>
</tr>
<tr class="even">
<td>3 x 3 with center wall</td>
<td>(0,0)</td>
<td>(2,2)</td>
<td>Distance 4 around the wall</td>
</tr>
<tr class="odd">
<td>Line 1 x 5 all free</td>
<td>(0,0)</td>
<td>(0,4)</td>
<td>Distance 4</td>
</tr>
<tr class="even">
<td>Blocked target</td>
<td>(0,0)</td>
<td>(1,1)</td>
<td>No path</td>
</tr>
<tr class="odd">
<td>Multi source wave</td>
<td>{all corner starts}</td>
<td>center</td>
<td>Minimum among corners</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-6" class="level4">
<h4 class="anchored" data-anchor-id="complexity-6">Complexity</h4>
<ul>
<li>Time: O(n × m)</li>
<li>Space: O(n × m) for visited or distance map and queue</li>
</ul>
<p>BFS on grid is the wavefront that sweeps a map evenly, giving you the fewest steps from start to goal with clean, level by level logic.</p>
</section>
</section>
<section id="multi-source-bfs" class="level3">
<h3 class="anchored" data-anchor-id="multi-source-bfs">308 Multi-Source BFS</h3>
<p>Multi-Source BFS is the wavefront BFS that starts not from one node but from many sources at once. It’s perfect when several starting points all spread out simultaneously, like multiple fires burning through a forest, or signals radiating from several transmitters.</p>
<section id="what-problem-are-we-solving-7" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-7">What Problem Are We Solving?</h4>
<p>We need to find minimum distances from multiple starting nodes, not just one. This is useful when:</p>
<ul>
<li>There are several sources of influence (e.g.&nbsp;infections, signals, fires)</li>
<li>You want the nearest source for each node</li>
<li>You need simultaneous propagation (e.g.&nbsp;multi-start shortest path)</li>
</ul>
<p>Examples:</p>
<ul>
<li>Spread of rumors from multiple people</li>
<li>Flooding time from multiple water sources</li>
<li>Minimum distance to nearest hospital or supply center</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-7" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-7">How Does It Work (Plain Language)?</h4>
<p>We treat all sources as level 0 and push them into the queue at once. Then BFS proceeds normally, each node is assigned a distance equal to the shortest path from any source.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 37%">
<col style="width: 32%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Queue (Front → Back)</th>
<th>Action</th>
<th>Distance Updated</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[S1, S2, S3]</td>
<td>Initialize all sources</td>
<td>dist[S*] = 0</td>
</tr>
<tr class="even">
<td>2</td>
<td>[Neighbors of S1, S2, S3]</td>
<td>Wave expands</td>
<td>dist = 1</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[Next Layer]</td>
<td>Continue</td>
<td>dist = 2</td>
</tr>
<tr class="even">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The first time a node is visited, we know it’s from the nearest source.</p>
</section>
<section id="tiny-code-easy-versions-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-7">Tiny Code (Easy Versions)</h4>
<p>C (Multi-Source BFS on Grid)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> grid<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> distv<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> vis<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> qx<span class="op">[</span>MAX<span class="op">*</span>MAX<span class="op">],</span> qy<span class="op">[</span>MAX<span class="op">*</span>MAX<span class="op">];</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> front <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> rear <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dx<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dy<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> enqueue<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span> qx<span class="op">[</span>rear<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span> qy<span class="op">[</span>rear<span class="op">]</span> <span class="op">=</span> y<span class="op">;</span> rear<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dequeue<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>x<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>y<span class="op">)</span> <span class="op">{</span> <span class="op">*</span>x <span class="op">=</span> qx<span class="op">[</span>front<span class="op">];</span> <span class="op">*</span>y <span class="op">=</span> qy<span class="op">[</span>front<span class="op">];</span> front<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> empty<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> front <span class="op">==</span> rear<span class="op">;</span> <span class="op">}</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multi_source_bfs<span class="op">()</span> <span class="op">{</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        dequeue<span class="op">(&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> nx <span class="op">=</span> x <span class="op">+</span> dx<span class="op">[</span>k<span class="op">],</span> ny <span class="op">=</span> y <span class="op">+</span> dy<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nx <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> nx <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> ny <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> ny <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>                grid<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>vis<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">])</span> <span class="op">{</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>                vis<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>                distv<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span> <span class="op">=</span> distv<span class="op">[</span>x<span class="op">][</span>y<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>                enqueue<span class="op">(</span>nx<span class="op">,</span> ny<span class="op">);</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter grid size n m: "</span><span class="op">);</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter grid (0 free, 1 blocked, 2 source):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>                vis<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>                distv<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>                enqueue<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>    multi_source_bfs<span class="op">();</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Distance map:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%2d</span><span class="st"> "</span><span class="op">,</span> distv<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple Multi-Source BFS)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> [</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>],</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>n, m <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>m <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> deque()</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> grid[i][j] <span class="op">==</span> <span class="dv">2</span>:  <span class="co"># source</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>            dist[i][j] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>            q.append((i, j))</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>dirs <span class="op">=</span> [(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> q:</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> q.popleft()</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dx, dy <span class="kw">in</span> dirs:</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        nx, ny <span class="op">=</span> x<span class="op">+</span>dx, y<span class="op">+</span>dy</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> n <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> m <span class="kw">and</span> grid[nx][ny] <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> dist[nx][ny] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>            dist[nx][ny] <span class="op">=</span> dist[x][y] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>            q.append((nx, ny))</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Distance Map:"</span>)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> dist:</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(row)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-7" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-7">Why It Matters</h4>
<ul>
<li>Finds nearest source distance for all nodes in one pass</li>
<li>Ideal for multi-origin diffusion problems</li>
<li>Foundation for tasks like multi-fire spread, influence zones, Voronoi partitioning on graphs</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-7" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-7">A Gentle Proof (Why It Works)</h4>
<p>Since all sources start at distance 0 and BFS expands in order of increasing distance, the first time a node is visited, it’s reached by the shortest possible path from any source.</p>
<p>Each cell is enqueued exactly once → O(V + E) time. No need to run BFS separately for each source.</p>
</section>
<section id="try-it-yourself-7" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-7">Try It Yourself</h4>
<ol type="1">
<li>Mark multiple sources (2s) on a grid, verify distances radiate outward.</li>
<li>Change obstacles (1s) and see how waves avoid them.</li>
<li>Count how many steps each free cell is from nearest source.</li>
<li>Modify to return which source id reached each cell first.</li>
<li>Compare total cost vs running single-source BFS repeatedly.</li>
</ol>
</section>
<section id="test-cases-7" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-7">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 41%">
<col style="width: 33%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Grid</th>
<th>Expected Output (Distances)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[2,0,2]]</td>
<td>[0,1,0]</td>
<td>Two sources on edges</td>
</tr>
<tr class="even">
<td>[[2,0,0],[0,1,0],[0,0,2]]</td>
<td>wave radiates from corners</td>
<td>Mixed obstacles</td>
</tr>
<tr class="odd">
<td>[[2,2,2]]</td>
<td>[0,0,0]</td>
<td>All sources</td>
</tr>
<tr class="even">
<td>[[0,0,0],[0,0,0]] + center source</td>
<td>center = 0, corners = 2</td>
<td>Wave expanding</td>
</tr>
<tr class="odd">
<td>All blocked</td>
<td>unchanged</td>
<td>No propagation</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-7" class="level4">
<h4 class="anchored" data-anchor-id="complexity-7">Complexity</h4>
<ul>
<li>Time: O(V + E)</li>
<li>Space: O(V) for queue and distance map</li>
</ul>
<p>Multi-Source BFS is the chorus of wavefronts, expanding together, each note reaching its closest audience in perfect harmony.</p>
</section>
</section>
<section id="topological-sort-dfs-based" class="level3">
<h3 class="anchored" data-anchor-id="topological-sort-dfs-based">309 Topological Sort (DFS-based)</h3>
<p>Topological sort is the linear ordering of vertices in a Directed Acyclic Graph (DAG) such that for every directed edge ( u v ), vertex ( u ) appears before ( v ) in the order. The DFS-based approach discovers this order by exploring deeply and recording finishing times.</p>
<section id="what-problem-are-we-solving-8" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-8">What Problem Are We Solving?</h4>
<p>We want a way to order tasks that have dependencies. Topological sort answers: <em>In what order can we perform tasks so that prerequisites come first?</em></p>
<p>Typical use cases:</p>
<ul>
<li>Build systems (compile order)</li>
<li>Course prerequisite scheduling</li>
<li>Pipeline stage ordering</li>
<li>Dependency resolution (e.g.&nbsp;package installs)</li>
</ul>
<p>Example: If task A must finish before B and C, and C before D, then one valid order is A → C → D → B.</p>
</section>
<section id="how-does-it-work-plain-language-8" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-8">How Does It Work (Plain Language)?</h4>
<p>DFS explores from each unvisited node. When a node finishes (no more outgoing edges to explore), push it onto a stack. After all DFS calls, reverse the stack, that’s your topological order.</p>
<ol type="1">
<li><p>Initialize all nodes as unvisited</p></li>
<li><p>For each node <code>v</code>:</p>
<ul>
<li>Run DFS if not visited</li>
<li>After exploring all neighbors, push <code>v</code> to stack</li>
</ul></li>
<li><p>Reverse stack to get topological order</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Current Node</th>
<th>Action</th>
<th>Stack</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A</td>
<td>Visit neighbors</td>
<td>[]</td>
</tr>
<tr class="even">
<td>2</td>
<td>B</td>
<td>Visit</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>D</td>
<td>Visit</td>
<td>[]</td>
</tr>
<tr class="even">
<td>4</td>
<td>D done</td>
<td>Push D</td>
<td>[D]</td>
</tr>
<tr class="odd">
<td>5</td>
<td>B done</td>
<td>Push B</td>
<td>[D, B]</td>
</tr>
<tr class="even">
<td>6</td>
<td>A done</td>
<td>Push A</td>
<td>[D, B, A]</td>
</tr>
</tbody>
</table>
<p>Reverse: [A, B, D]</p>
</section>
<section id="tiny-code-easy-versions-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-8">Tiny Code (Easy Versions)</h4>
<p>C (DFS-based Topological Sort)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> visited<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stack<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> top <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>            dfs<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">[++</span>top<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span> <span class="co">// push after exploring neighbors</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> topological_sort<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>i<span class="op">])</span> dfs<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Topological order: "</span><span class="op">);</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>top <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> stack<span class="op">[</span>top<span class="op">--]);</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (DAG):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    topological_sort<span class="op">();</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (DFS-based)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">3</span>],</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">3</span>],</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: []</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>stack <span class="op">=</span> []</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(v):</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    visited.add(v)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>            dfs(u)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    stack.append(v)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> graph:</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        dfs(v)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>stack.reverse()</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Topological order:"</span>, stack)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-8" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-8">Why It Matters</h4>
<ul>
<li><p>Ensures dependency order in DAGs</p></li>
<li><p>Fundamental in compilers, schedulers, and build systems</p></li>
<li><p>Basis for advanced algorithms:</p>
<ul>
<li>Kahn’s Algorithm (queue-based)</li>
<li>DAG shortest paths / DP</li>
<li>Critical path analysis</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-8" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-8">A Gentle Proof (Why It Works)</h4>
<p>Each vertex is pushed onto the stack after all its descendants are explored. So if there’s an edge ( u v ), DFS ensures ( v ) finishes first and is pushed earlier, meaning ( u ) will appear later in the stack. Reversing the stack thus guarantees ( u ) precedes ( v ).</p>
<p>No cycles allowed, if a back edge is found, topological sort is impossible.</p>
</section>
<section id="try-it-yourself-8" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-8">Try It Yourself</h4>
<ol type="1">
<li>Draw a DAG and label edges as prerequisites.</li>
<li>Run DFS and record finish times.</li>
<li>Push nodes on completion, reverse the order.</li>
<li>Add a cycle and see why it breaks.</li>
<li>Compare with Kahn’s Algorithm results.</li>
</ol>
</section>
<section id="test-cases-8" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-8">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Topological Order (Possible)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A→B→C</td>
<td>A→B, B→C</td>
<td>A B C</td>
</tr>
<tr class="even">
<td>A→C, B→C</td>
<td>A→C, B→C</td>
<td>A B C or B A C</td>
</tr>
<tr class="odd">
<td>0→1, 0→2, 1→3, 2→3</td>
<td>DAG</td>
<td>0 2 1 3 or 0 1 2 3</td>
</tr>
<tr class="even">
<td>Chain 0→1→2→3</td>
<td>Linear DAG</td>
<td>0 1 2 3</td>
</tr>
<tr class="odd">
<td>Cycle 0→1→2→0</td>
<td>Not DAG</td>
<td>No valid order</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-8" class="level4">
<h4 class="anchored" data-anchor-id="complexity-8">Complexity</h4>
<ul>
<li>Time: O(V + E) (each node and edge visited once)</li>
<li>Space: O(V) (stack + visited array)</li>
</ul>
<p>Topological sort (DFS-based) is your dependency detective, exploring deeply, marking completion, and leaving behind a perfect trail of prerequisites.</p>
</section>
</section>
<section id="topological-sort-kahns-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="topological-sort-kahns-algorithm">310 Topological Sort (Kahn’s Algorithm)</h3>
<p>Kahn’s Algorithm is the queue-based way to perform topological sorting. Instead of relying on recursion, it tracks in-degrees (how many edges point into each node) and repeatedly removes nodes with zero in-degree. It’s clean, iterative, and naturally detects cycles.</p>
<section id="what-problem-are-we-solving-9" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-9">What Problem Are We Solving?</h4>
<p>We want a linear ordering of tasks in a Directed Acyclic Graph (DAG) such that each task appears after all its prerequisites.</p>
<p>Kahn’s method is especially handy when:</p>
<ul>
<li>You want an iterative (non-recursive) algorithm</li>
<li>You need to detect cycles automatically</li>
<li>You’re building a scheduler or compiler dependency resolver</li>
</ul>
<p>Example: If A must happen before B and C, and C before D, then valid orders: A C D B or A B C D. Kahn’s algorithm builds this order by peeling off “ready” nodes (those with no remaining prerequisites).</p>
</section>
<section id="how-does-it-work-plain-language-9" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-9">How Does It Work (Plain Language)?</h4>
<p>Each node starts with an in-degree (count of incoming edges). Nodes with in-degree = 0 are ready to process.</p>
<ol type="1">
<li><p>Compute in-degree for each node</p></li>
<li><p>Enqueue all nodes with in-degree = 0</p></li>
<li><p>While queue not empty:</p>
<ul>
<li>Pop node <code>v</code> and add it to the topological order</li>
<li>For each neighbor <code>u</code> of <code>v</code>, decrement <code>in-degree[u]</code></li>
<li>If <code>in-degree[u]</code> becomes 0, enqueue <code>u</code></li>
</ul></li>
<li><p>If all nodes processed → valid topological order Otherwise → cycle detected</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Queue</th>
<th>Popped</th>
<th>Updated In-Degree</th>
<th>Order</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[A]</td>
<td>A</td>
<td>B:0, C:1, D:2</td>
<td>[A]</td>
</tr>
<tr class="even">
<td>2</td>
<td>[B]</td>
<td>B</td>
<td>C:0, D:2</td>
<td>[A, B]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[C]</td>
<td>C</td>
<td>D:1</td>
<td>[A, B, C]</td>
</tr>
<tr class="even">
<td>4</td>
<td>[D]</td>
<td>D</td>
<td>–</td>
<td>[A, B, C, D]</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-9">Tiny Code (Easy Versions)</h4>
<p>C (Kahn’s Algorithm)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> indeg<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> queue<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> front <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> rear <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> enqueue<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span> queue<span class="op">[</span>rear<span class="op">++]</span> <span class="op">=</span> v<span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dequeue<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> queue<span class="op">[</span>front<span class="op">++];</span> <span class="op">}</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> empty<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> front <span class="op">==</span> rear<span class="op">;</span> <span class="op">}</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> kahn_topo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>indeg<span class="op">[</span>v<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> enqueue<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> order<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> dequeue<span class="op">();</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        order<span class="op">[</span>count<span class="op">++]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>                indeg<span class="op">[</span>u<span class="op">]--;</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>indeg<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> enqueue<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>count <span class="op">!=</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Graph has a cycle, topological sort not possible</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Topological order: "</span><span class="op">);</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> order<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> indeg<span class="op">[</span>j<span class="op">]++;</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>    kahn_topo<span class="op">();</span></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Using Queue)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">3</span>],</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">3</span>],</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: []</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>indeg <span class="op">=</span> {v: <span class="dv">0</span> <span class="cf">for</span> v <span class="kw">in</span> graph}</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> graph:</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        indeg[u] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> deque([v <span class="cf">for</span> v <span class="kw">in</span> graph <span class="cf">if</span> indeg[v] <span class="op">==</span> <span class="dv">0</span>])</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> []</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> q:</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> q.popleft()</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    order.append(v)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        indeg[u] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> indeg[u] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>            q.append(u)</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(order) <span class="op">==</span> <span class="bu">len</span>(graph):</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Topological order:"</span>, order)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Cycle detected, no valid order"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-9" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-9">Why It Matters</h4>
<ul>
<li>Fully iterative (no recursion stack)</li>
<li>Naturally detects cycles</li>
<li>Efficient for build systems, task planners, and dependency graphs</li>
<li>Forms the base for Kahn’s scheduling algorithm in DAG processing</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-9" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-9">A Gentle Proof (Why It Works)</h4>
<p>Nodes with in-degree 0 have no prerequisites, they can appear first. Once processed, they are removed (decrementing in-degree of successors). This ensures:</p>
<ul>
<li>Each node is processed only after all its dependencies</li>
<li>If a cycle exists, some nodes never reach in-degree 0 → detection built-in</li>
</ul>
<p>Since each edge is considered once, runtime = O(V + E).</p>
</section>
<section id="try-it-yourself-9" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-9">Try It Yourself</h4>
<ol type="1">
<li>Build a small DAG manually and run the algorithm step by step.</li>
<li>Introduce a cycle (A→B→A) and observe detection.</li>
<li>Compare with DFS-based order, both valid.</li>
<li>Add priority to queue (min vertex first) to get lexicographically smallest order.</li>
<li>Apply to course prerequisite planner.</li>
</ol>
</section>
<section id="test-cases-9" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-9">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 13%">
<col style="width: 30%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A→B→C</td>
<td>A→B, B→C</td>
<td>A B C</td>
<td>Linear chain</td>
</tr>
<tr class="even">
<td>A→C, B→C</td>
<td>A→C, B→C</td>
<td>A B C or B A C</td>
<td>Multiple sources</td>
</tr>
<tr class="odd">
<td>0→1, 0→2, 1→3, 2→3</td>
<td>DAG</td>
<td>0 1 2 3 or 0 2 1 3</td>
<td>Multiple valid</td>
</tr>
<tr class="even">
<td>0→1, 1→2, 2→0</td>
<td>Cycle</td>
<td>No order</td>
<td>Cycle detected</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-9" class="level4">
<h4 class="anchored" data-anchor-id="complexity-9">Complexity</h4>
<ul>
<li>Time: O(V + E)</li>
<li>Space: O(V) (queue, indegrees)</li>
</ul>
<p>Kahn’s Algorithm is the dependency peeler, stripping away nodes layer by layer until a clean, linear order emerges.</p>
</section>
</section>
</section>
<section id="section-32.-strongly-connected-components" class="level2">
<h2 class="anchored" data-anchor-id="section-32.-strongly-connected-components">Section 32. Strongly Connected Components</h2>
<section id="kosarajus-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="kosarajus-algorithm">311 Kosaraju’s Algorithm</h3>
<p>Kosaraju’s algorithm is one of the clearest ways to find strongly connected components (SCCs) in a directed graph. It uses two depth-first searches, one on the original graph, and one on its reversed version, to peel off SCCs layer by layer.</p>
<section id="what-problem-are-we-solving-10" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-10">What Problem Are We Solving?</h4>
<p>In a directed graph, a <em>strongly connected component</em> is a maximal set of vertices such that each vertex is reachable from every other vertex in the same set.</p>
<p>Kosaraju’s algorithm groups the graph into these SCCs.</p>
<p>This is useful for:</p>
<ul>
<li>Condensing a graph into a DAG (meta-graph)</li>
<li>Dependency analysis in compilers</li>
<li>Finding cycles or redundant modules</li>
<li>Graph simplification before DP or optimization</li>
</ul>
<p>Example: Imagine a one-way road network, SCCs are groups of cities where you can travel between any pair.</p>
</section>
<section id="how-does-it-work-plain-language-10" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-10">How Does It Work (Plain Language)?</h4>
<p>Kosaraju’s algorithm runs in two DFS passes:</p>
<ol type="1">
<li><p>First DFS (Original Graph): Explore all vertices. Each time a node finishes (recursion ends), record it on a stack (by finish time).</p></li>
<li><p>Reverse the Graph: Reverse all edges (flip direction).</p></li>
<li><p>Second DFS (Reversed Graph): Pop nodes from the stack (highest finish time first). Each DFS from an unvisited node forms one strongly connected component.</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Phase</th>
<th>Graph</th>
<th>Action</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Original</td>
<td>DFS all, push finish order</td>
<td>Stack of vertices</td>
</tr>
<tr class="even">
<td>2</td>
<td>Reversed</td>
<td>DFS by pop order</td>
<td>Identify SCCs</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Output</td>
<td>Each DFS tree</td>
<td>SCC list</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-10">Tiny Code (Easy Versions)</h4>
<p>C (Adjacency List)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> rev<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> visited<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stack<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> top <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span> dfs1<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">[++</span>top<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span> <span class="co">// push after finishing</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>rev<span class="op">[</span>v<span class="op">][</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>u<span class="op">])</span> dfs2<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (directed):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>            rev<span class="op">[</span>j<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span> <span class="co">// build reverse</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Step 1: first DFS</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>        visited<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>i<span class="op">])</span> dfs1<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Step 2: second DFS on reversed</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>        visited<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Strongly Connected Components:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>top <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> stack<span class="op">[</span>top<span class="op">--];</span></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>            dfs2<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Using Lists)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>rev <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">3</span>)]</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    graph[u].append(v)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    rev[v].append(u)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>stack <span class="op">=</span> []</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs1(v):</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    visited.add(v)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>            dfs1(u)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    stack.append(v)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> graph:</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        dfs1(v)</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>visited.clear()</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs2(v, comp):</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    visited.add(v)</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    comp.append(v)</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> rev[v]:</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>            dfs2(u, comp)</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Strongly Connected Components:"</span>)</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> stack:</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> stack.pop()</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        comp <span class="op">=</span> []</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>        dfs2(v, comp)</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(comp)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-10" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-10">Why It Matters</h4>
<ul>
<li>Splits a directed graph into mutually reachable groups</li>
<li>Used in condensation (convert cyclic graph → DAG)</li>
<li>Helps detect cyclic dependencies</li>
<li>Foundation for component-level optimization</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-10" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-10">A Gentle Proof (Why It Works)</h4>
<ol type="1">
<li>Finishing times from the first DFS ensure we process “sinks” first (post-order).</li>
<li>Reversing edges turns sinks into sources.</li>
<li>The second DFS finds all nodes reachable from that source, i.e.&nbsp;an SCC.</li>
<li>Every node is assigned to exactly one SCC.</li>
</ol>
<p>Correctness follows from properties of finishing times and reachability symmetry.</p>
</section>
<section id="try-it-yourself-10" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-10">Try It Yourself</h4>
<ol type="1">
<li>Draw a directed graph with cycles and run the steps manually.</li>
<li>Track finish order stack.</li>
<li>Reverse all edges and start popping nodes.</li>
<li>Each DFS tree = one SCC.</li>
<li>Compare results with Tarjan’s algorithm.</li>
</ol>
</section>
<section id="test-cases-10" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-10">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1, 1→2, 2→0</td>
<td>Cycle</td>
<td>{0,1,2}</td>
</tr>
<tr class="even">
<td>0→1, 1→2</td>
<td>Chain</td>
<td>{0}, {1}, {2}</td>
</tr>
<tr class="odd">
<td>0→1, 1→2, 2→0, 2→3</td>
<td>Cycle + tail</td>
<td>{0,1,2}, {3}</td>
</tr>
<tr class="even">
<td>0→1, 1→0, 1→2, 2→3, 3→2</td>
<td>Two SCCs</td>
<td>{0,1}, {2,3}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-10" class="level4">
<h4 class="anchored" data-anchor-id="complexity-10">Complexity</h4>
<ul>
<li>Time: O(V + E) (2 DFS passes)</li>
<li>Space: O(V + E) (graph + stack)</li>
</ul>
<p>Kosaraju’s Algorithm is your mirror explorer, traverse once to record the story, flip the graph, then replay it backward to reveal every strongly bound group.</p>
</section>
</section>
<section id="tarjans-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="tarjans-algorithm">312 Tarjan’s Algorithm</h3>
<p>Tarjan’s algorithm finds all strongly connected components (SCCs) in a directed graph in one DFS pass, without reversing the graph. It’s an elegant and efficient method that tracks each node’s discovery time and lowest reachable ancestor to identify SCC roots.</p>
<section id="what-problem-are-we-solving-11" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-11">What Problem Are We Solving?</h4>
<p>We need to group vertices of a directed graph into SCCs, where each node is reachable from every other node in the same group. Unlike Kosaraju’s two-pass method, Tarjan’s algorithm finds all SCCs in a single DFS, making it faster in practice and easy to integrate into larger graph algorithms.</p>
<p>Common applications:</p>
<ul>
<li>Cycle detection in directed graphs</li>
<li>Component condensation for DAG processing</li>
<li>Deadlock analysis</li>
<li>Strong connectivity queries in compilers, networks, and systems</li>
</ul>
<p>Example: Imagine a group of cities connected by one-way roads. SCCs are clusters of cities that can all reach each other, forming a tightly connected region.</p>
</section>
<section id="how-does-it-work-plain-language-11" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-11">How Does It Work (Plain Language)?</h4>
<p>Each vertex gets:</p>
<ul>
<li>A discovery time (disc), when it’s first visited</li>
<li>A low-link value (low), the smallest discovery time reachable (including back edges)</li>
</ul>
<p>A stack keeps track of the active recursion path (current DFS stack). When a vertex’s <code>disc</code> equals its <code>low</code>, it’s the root of an SCC, pop nodes from the stack until this vertex reappears.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 40%">
<col style="width: 12%">
<col style="width: 11%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>Stack</th>
<th>SCC Found</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Visit node, assign disc &amp; low</td>
<td>[A]</td>
<td>–</td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>Go deeper (DFS neighbors)</td>
<td>[A, B, C]</td>
<td>–</td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>Reach node with no new neighbors</td>
<td>Update low</td>
<td>[A, B, C]</td>
<td>–</td>
</tr>
<tr class="even">
<td>4</td>
<td>Backtrack, compare lows</td>
<td>[A, B]</td>
<td>SCC {C}</td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>When disc == low</td>
<td>Pop SCC</td>
<td>[A]</td>
<td>SCC {B, C} (if connected)</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-11">Tiny Code (Easy Versions)</h4>
<p>C (Tarjan’s Algorithm)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> disc<span class="op">[</span>MAX<span class="op">],</span> low<span class="op">[</span>MAX<span class="op">],</span> stack<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> inStack<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> time_counter <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> top <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs_tarjan<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    disc<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> low<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>time_counter<span class="op">;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">[++</span>top<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    inStack<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>disc<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>            dfs_tarjan<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>low<span class="op">[</span>u<span class="op">]</span> <span class="op">&lt;</span> low<span class="op">[</span>v<span class="op">])</span> low<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> low<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>inStack<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>disc<span class="op">[</span>u<span class="op">]</span> <span class="op">&lt;</span> low<span class="op">[</span>v<span class="op">])</span> low<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> disc<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>disc<span class="op">[</span>v<span class="op">]</span> <span class="op">==</span> low<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"SCC: "</span><span class="op">);</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> w<span class="op">;</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> stack<span class="op">[</span>top<span class="op">--];</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>            inStack<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> w<span class="op">);</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>w <span class="op">!=</span> v<span class="op">);</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (directed):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>        disc<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>        inStack<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Strongly Connected Components:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>disc<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>            dfs_tarjan<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Using Adjacency List)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">3</span>)]</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    graph[u].append(v)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>disc <span class="op">=</span> {}</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>low <span class="op">=</span> {}</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>stack <span class="op">=</span> []</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>in_stack <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>sccs <span class="op">=</span> []</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(v):</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> time</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    time <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    disc[v] <span class="op">=</span> low[v] <span class="op">=</span> time</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    stack.append(v)</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    in_stack.add(v)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> disc:</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>            dfs(u)</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>            low[v] <span class="op">=</span> <span class="bu">min</span>(low[v], low[u])</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> u <span class="kw">in</span> in_stack:</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>            low[v] <span class="op">=</span> <span class="bu">min</span>(low[v], disc[u])</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> disc[v] <span class="op">==</span> low[v]:</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>        scc <span class="op">=</span> []</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> stack.pop()</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>            in_stack.remove(w)</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>            scc.append(w)</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="op">==</span> v:</span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>        sccs.append(scc)</span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> <span class="bu">list</span>(graph.keys()):</span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> disc:</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>        dfs(v)</span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Strongly Connected Components:"</span>, sccs)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-11" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-11">Why It Matters</h4>
<ul>
<li>Runs in one DFS, efficient and elegant</li>
<li>Detects SCCs on the fly (no reversing edges)</li>
<li>Useful for online algorithms (process SCCs as discovered)</li>
<li>Powers cycle detection, condensation graphs, component-based optimization</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-11" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-11">A Gentle Proof (Why It Works)</h4>
<ul>
<li><code>disc[v]</code>: time when <code>v</code> is first visited</li>
<li><code>low[v]</code>: smallest discovery time reachable via descendants or back edges</li>
<li>When <code>disc[v] == low[v]</code>, <code>v</code> is the root of its SCC (no back edges go above it)</li>
<li>Popping from the stack gives all nodes reachable within the component</li>
</ul>
<p>Each edge examined once → linear time.</p>
</section>
<section id="try-it-yourself-11" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-11">Try It Yourself</h4>
<ol type="1">
<li>Run Tarjan on a graph with multiple cycles.</li>
<li>Observe <code>disc</code> and <code>low</code> values.</li>
<li>Print stack content at each step to see grouping.</li>
<li>Compare SCC output with Kosaraju’s result.</li>
<li>Try adding a cycle and check grouping changes.</li>
</ol>
</section>
<section id="test-cases-11" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-11">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1, 1→2, 2→0</td>
<td>Cycle</td>
<td>{0,1,2}</td>
</tr>
<tr class="even">
<td>0→1, 1→2</td>
<td>Chain</td>
<td>{2}, {1}, {0}</td>
</tr>
<tr class="odd">
<td>0→1, 1→2, 2→0, 2→3</td>
<td>Cycle + tail</td>
<td>{0,1,2}, {3}</td>
</tr>
<tr class="even">
<td>1→2, 2→3, 3→1, 3→4</td>
<td>Two groups</td>
<td>{1,2,3}, {4}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-11" class="level4">
<h4 class="anchored" data-anchor-id="complexity-11">Complexity</h4>
<ul>
<li>Time: O(V + E) (one DFS pass)</li>
<li>Space: O(V) (stack, arrays)</li>
</ul>
<p>Tarjan’s Algorithm is your clockwork explorer, tagging each vertex by time, tracing the deepest paths, and snapping off every strongly connected cluster in one graceful pass.</p>
</section>
</section>
<section id="gabows-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="gabows-algorithm">313 Gabow’s Algorithm</h3>
<p>Gabow’s algorithm is another elegant one-pass method for finding strongly connected components (SCCs). It’s less well-known than Tarjan’s, but equally efficient, using two stacks to track active vertices and roots. It’s a perfect example of “stack discipline” in graph exploration.</p>
<section id="what-problem-are-we-solving-12" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-12">What Problem Are We Solving?</h4>
<p>We want to find all strongly connected components in a directed graph, subsets where every node can reach every other.</p>
<p>Gabow’s algorithm, like Tarjan’s, works in a single DFS traversal, but instead of computing <code>low-link</code> values, it uses two stacks to manage component discovery and boundaries.</p>
<p>This approach is especially helpful in streaming, online, or iterative DFS environments, where explicit low-link computations can get messy.</p>
<p>Applications:</p>
<ul>
<li>Cycle decomposition</li>
<li>Program dependency analysis</li>
<li>Component condensation (DAG creation)</li>
<li>Strong connectivity testing</li>
</ul>
<p>Example: Think of traversing a web of roads. One stack tracks where you’ve been, another stack marks “checkpoints” where loops close, each loop is a component.</p>
</section>
<section id="how-does-it-work-plain-language-12" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-12">How Does It Work (Plain Language)?</h4>
<p>Gabow’s algorithm keeps track of discovery order and component boundaries using two stacks:</p>
<ul>
<li>S (main stack): stores all currently active nodes</li>
<li>P (boundary stack): stores potential roots of SCCs</li>
</ul>
<p>Steps:</p>
<ol type="1">
<li><p>Perform DFS. Assign each node an increasing index (<code>preorder</code>)</p></li>
<li><p>Push node onto both stacks (S and P)</p></li>
<li><p>For each edge ( v u ):</p>
<ul>
<li>If <code>u</code> unvisited → recurse</li>
<li>If <code>u</code> on stack S → adjust boundary stack P</li>
</ul></li>
<li><p>After exploring neighbors:</p>
<ul>
<li><p>If the top of P is current node <code>v</code>:</p>
<ul>
<li>Pop P</li>
<li>Pop from S until <code>v</code></li>
<li>Those popped form an SCC</li>
</ul></li>
</ul></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Stack S</th>
<th>Stack P</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[A]</td>
<td>[A]</td>
<td>Visit A</td>
</tr>
<tr class="even">
<td>2</td>
<td>[A, B]</td>
<td>[A, B]</td>
<td>Visit B</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[A, B, C]</td>
<td>[A, B, C]</td>
<td>Visit C</td>
</tr>
<tr class="even">
<td>4</td>
<td>[A, B, C]</td>
<td>[A, B]</td>
<td>Back edge C→B</td>
</tr>
<tr class="odd">
<td>5</td>
<td>[A, B]</td>
<td>[A]</td>
<td>Pop SCC {C}</td>
</tr>
<tr class="even">
<td>6</td>
<td>[A]</td>
<td>[]</td>
<td>Pop SCC {B}</td>
</tr>
<tr class="odd">
<td>7</td>
<td>[]</td>
<td>[]</td>
<td>Pop SCC {A}</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-12">Tiny Code (Easy Versions)</h4>
<p>C (Gabow’s Algorithm)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> index_counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> preorder<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> onStack<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stackS<span class="op">[</span>MAX<span class="op">],</span> topS <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stackP<span class="op">[</span>MAX<span class="op">],</span> topP <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs_gabow<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    preorder<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>index_counter<span class="op">;</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    stackS<span class="op">[++</span>topS<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    stackP<span class="op">[++</span>topP<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    onStack<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>preorder<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>            dfs_gabow<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>onStack<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>preorder<span class="op">[</span>stackP<span class="op">[</span>topP<span class="op">]]</span> <span class="op">&gt;</span> preorder<span class="op">[</span>u<span class="op">])</span> topP<span class="op">--;</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stackP<span class="op">[</span>topP<span class="op">]</span> <span class="op">==</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>        topP<span class="op">--;</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"SCC: "</span><span class="op">);</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> w<span class="op">;</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> stackS<span class="op">[</span>topS<span class="op">--];</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>            onStack<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> w<span class="op">);</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>w <span class="op">!=</span> v<span class="op">);</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (directed):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>        preorder<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>        onStack<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Strongly Connected Components:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>preorder<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>            dfs_gabow<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Readable Implementation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">3</span>)]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    graph[u].append(v)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>index_counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>preorder <span class="op">=</span> {}</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>on_stack <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>stackS, stackP <span class="op">=</span> [], []</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>sccs <span class="op">=</span> []</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(v):</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> index_counter</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    index_counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    preorder[v] <span class="op">=</span> index_counter</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    stackS.append(v)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    stackP.append(v)</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    on_stack.add(v)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> preorder:</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>            dfs(u)</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> u <span class="kw">in</span> on_stack:</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> preorder[stackP[<span class="op">-</span><span class="dv">1</span>]] <span class="op">&gt;</span> preorder[u]:</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>                stackP.pop()</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> stackP <span class="kw">and</span> stackP[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> v:</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>        stackP.pop()</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>        comp <span class="op">=</span> []</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> stackS.pop()</span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>            on_stack.remove(w)</span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>            comp.append(w)</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="op">==</span> v:</span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a>        sccs.append(comp)</span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> graph:</span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> preorder:</span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a>        dfs(v)</span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Strongly Connected Components:"</span>, sccs)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-12" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-12">Why It Matters</h4>
<ul>
<li>Single DFS pass, no reverse graph</li>
<li>Purely stack-based, avoids recursion depth issues in some variants</li>
<li>Efficient and practical for large graphs</li>
<li>Simpler low-link logic than Tarjan’s in some applications</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-12" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-12">A Gentle Proof (Why It Works)</h4>
<p>Each node gets a preorder index. The second stack P tracks the earliest root reachable. Whenever the top of P equals the current node, all nodes above it in S form one SCC.</p>
<p>Invariant:</p>
<ul>
<li>S contains active nodes</li>
<li>P contains possible roots (ordered by discovery)</li>
<li>When back edges discovered, P trimmed to smallest reachable ancestor</li>
</ul>
<p>This ensures each SCC is identified exactly once when its root finishes.</p>
</section>
<section id="try-it-yourself-12" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-12">Try It Yourself</h4>
<ol type="1">
<li>Draw a graph and trace preorder indices.</li>
<li>Observe how stack P shrinks on back edges.</li>
<li>Record SCCs as they’re popped.</li>
<li>Compare output to Tarjan’s algorithm.</li>
<li>Try it on DAGs, cycles, and mixed graphs.</li>
</ol>
</section>
<section id="test-cases-12" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-12">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1, 1→2, 2→0</td>
<td>{0,1,2}</td>
<td>One big SCC</td>
</tr>
<tr class="even">
<td>0→1, 1→2</td>
<td>{2}, {1}, {0}</td>
<td>Chain</td>
</tr>
<tr class="odd">
<td>0→1, 1→0, 2→3</td>
<td>{0,1}, {2}, {3}</td>
<td>Mixed</td>
</tr>
<tr class="even">
<td>0→1, 1→2, 2→3, 3→1</td>
<td>{1,2,3}, {0}</td>
<td>Nested cycle</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-12" class="level4">
<h4 class="anchored" data-anchor-id="complexity-12">Complexity</h4>
<ul>
<li>Time: O(V + E)</li>
<li>Space: O(V) (two stacks + metadata)</li>
</ul>
<p>Gabow’s Algorithm is your two-stack sculptor, carving SCCs from the graph in one graceful sweep, balancing exploration and boundaries like a craftsman marking edges before the final cut.</p>
</section>
</section>
<section id="scc-dag-construction" class="level3">
<h3 class="anchored" data-anchor-id="scc-dag-construction">314 SCC DAG Construction</h3>
<p>Once we’ve found strongly connected components (SCCs), we can build the condensation graph, a Directed Acyclic Graph (DAG) where each node represents an SCC, and edges connect them if any vertex in one SCC points to a vertex in another.</p>
<p>This structure is crucial because it transforms a messy cyclic graph into a clean acyclic skeleton, perfect for topological sorting, dynamic programming, and dependency analysis.</p>
<section id="what-problem-are-we-solving-13" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-13">What Problem Are We Solving?</h4>
<p>We want to take a directed graph and reduce it into a simpler form by collapsing each SCC into a single node. The resulting graph (called the <em>condensation graph</em>) is always a DAG.</p>
<p>Why do this?</p>
<ul>
<li>To simplify reasoning about complex systems</li>
<li>To run DAG algorithms on cyclic graphs (by condensing cycles)</li>
<li>To perform component-level optimization</li>
<li>To study dependencies between strongly connected subsystems</li>
</ul>
<p>Example: Think of a city map where SCCs are tightly connected neighborhoods. The DAG shows how traffic flows between neighborhoods, not within them.</p>
</section>
<section id="how-does-it-work-plain-language-13" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-13">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Find SCCs (using Kosaraju, Tarjan, or Gabow).</p></li>
<li><p>Assign each node an SCC ID (e.g., <code>comp[v] = c_id</code>).</p></li>
<li><p>Create a new graph with one node per SCC.</p></li>
<li><p>For each edge ( (u, v) ) in the original graph:</p>
<ul>
<li>If <code>comp[u] != comp[v]</code>, add an edge from <code>comp[u]</code> to <code>comp[v]</code></li>
</ul></li>
<li><p>Remove duplicates (or store edges in sets).</p></li>
</ol>
<p>Now the new graph has no cycles, since cycles are already condensed inside SCCs.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Original Graph</th>
<th>SCCs</th>
<th>DAG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1, 1→2, 2→0, 2→3</td>
<td>{0,1,2}, {3}</td>
<td>C0 → C1</td>
</tr>
<tr class="even">
<td>0→1, 1→2, 2→3, 3→1</td>
<td>{1,2,3}, {0}</td>
<td>C0 → C1</td>
</tr>
<tr class="odd">
<td>0→1, 1→2</td>
<td>{0}, {1}, {2}</td>
<td>0 → 1 → 2</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-13">Tiny Code (Easy Versions)</h4>
<p>C (Using Tarjan’s Output)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> comp<span class="op">[</span>MAX<span class="op">];</span>   <span class="co">// component ID</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> comp_count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Suppose comp[] already filled by Tarjan or Kosaraju</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> build_condensed_graph<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> new_graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">&amp;&amp;</span> comp<span class="op">[</span>u<span class="op">]</span> <span class="op">!=</span> comp<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>                new_graph<span class="op">[</span>comp<span class="op">[</span>u<span class="op">]][</span>comp<span class="op">[</span>v<span class="op">]]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Condensation Graph (Adjacency Matrix):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> comp_count<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> comp_count<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> new_graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>(Assumes <code>comp[v]</code> and <code>comp_count</code> were computed before.)</em></p>
<p>Python (with Tarjan’s or Kosaraju’s Components)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Suppose we already have SCCs</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>sccs <span class="op">=</span> [[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>], [<span class="dv">3</span>], [<span class="dv">4</span>,<span class="dv">5</span>]]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>],</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">2</span>,<span class="dv">3</span>],</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">0</span>],</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [<span class="dv">4</span>],</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: [<span class="dv">5</span>],</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: []</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: assign component ID</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>comp_id <span class="op">=</span> {}</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, comp <span class="kw">in</span> <span class="bu">enumerate</span>(sccs):</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> comp:</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>        comp_id[v] <span class="op">=</span> i</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: build DAG</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>dag <span class="op">=</span> defaultdict(<span class="bu">set</span>)</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u <span class="kw">in</span> graph:</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> comp_id[u] <span class="op">!=</span> comp_id[v]:</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>            dag[comp_id[u]].add(comp_id[v])</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Condensation Graph (as DAG):"</span>)</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> dag:</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(c, <span class="st">"-&gt;"</span>, <span class="bu">sorted</span>(dag[c]))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-13" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-13">Why It Matters</h4>
<ul>
<li>Turns cyclic graph → acyclic graph</li>
<li>Enables topological sorting, dynamic programming, path counting</li>
<li>Clarifies inter-component dependencies</li>
<li>Used in compiler analysis, SCC-based optimizations, graph condensation</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-13" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-13">A Gentle Proof (Why It Works)</h4>
<p>Inside each SCC, every vertex can reach every other. When edges cross SCC boundaries, they go in one direction only (since returning would merge the components). Thus, the condensation graph cannot contain cycles, proving it’s a DAG.</p>
<p>Each edge in the DAG represents at least one edge between components in the original graph.</p>
</section>
<section id="try-it-yourself-13" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-13">Try It Yourself</h4>
<ol type="1">
<li>Run Tarjan’s algorithm to get <code>comp[v]</code> for each vertex.</li>
<li>Build DAG edges using component IDs.</li>
<li>Visualize original vs condensed graphs.</li>
<li>Topologically sort the DAG.</li>
<li>Use DP on DAG to compute longest path or reachability.</li>
</ol>
</section>
<section id="test-cases-13" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-13">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 28%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Original Graph</th>
<th>SCCs</th>
<th>Condensed Edges</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1, 1→2, 2→0, 2→3</td>
<td>{0,1,2}, {3}</td>
<td>0→1</td>
</tr>
<tr class="even">
<td>0→1, 1→0, 1→2, 2→3, 3→2</td>
<td>{0,1}, {2,3}</td>
<td>0→1</td>
</tr>
<tr class="odd">
<td>0→1, 1→2, 2→3</td>
<td>{0}, {1}, {2}, {3}</td>
<td>0→1→2→3</td>
</tr>
<tr class="even">
<td>0→1, 1→2, 2→0</td>
<td>{0,1,2}</td>
<td>None (single node DAG)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-13" class="level4">
<h4 class="anchored" data-anchor-id="complexity-13">Complexity</h4>
<ul>
<li>Time: O(V + E) (using precomputed SCCs)</li>
<li>Space: O(V + E) (new DAG structure)</li>
</ul>
<p>SCC DAG Construction is your mapmaker’s step, compressing tangled roads into clean highways, where each city (SCC) is a hub, and the new map is finally acyclic, ready for analysis.</p>
</section>
</section>
<section id="scc-online-merge" class="level3">
<h3 class="anchored" data-anchor-id="scc-online-merge">315 SCC Online Merge</h3>
<p>SCC Online Merge is a dynamic approach to maintain strongly connected components when a graph is growing over time (new edges are added). Instead of recomputing SCCs from scratch after each update, we <em>incrementally merge</em> components as they become connected.</p>
<p>It’s the foundation of dynamic graph algorithms where edges arrive one by one, useful in online systems, incremental compilers, and evolving dependency graphs.</p>
<section id="what-problem-are-we-solving-14" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-14">What Problem Are We Solving?</h4>
<p>We want to maintain SCC structure as we add edges to a directed graph.</p>
<p>In static algorithms like Tarjan or Kosaraju, SCCs are computed once. But if new edges appear over time, recomputing everything is too slow.</p>
<p>SCC Online Merge gives us:</p>
<ul>
<li>Efficient incremental updates (no full recompute)</li>
<li>Fast component merging</li>
<li>Up-to-date condensation DAG</li>
</ul>
<p>Typical use cases:</p>
<ul>
<li>Incremental program analysis (new dependencies)</li>
<li>Dynamic network reachability</li>
<li>Streaming graph processing</li>
<li>Online algorithm design</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-14" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-14">How Does It Work (Plain Language)?</h4>
<p>We start with each node as its own SCC. When a new edge ( u v ) is added:</p>
<ol type="1">
<li>Check if ( u ) and ( v ) are already in the same SCC, if yes, nothing changes.</li>
<li>If not, check whether v’s SCC can reach u’s SCC (cycle detection).</li>
<li>If reachable, merge both SCCs into one.</li>
<li>Otherwise, add a DAG edge from <code>SCC(u)</code> → <code>SCC(v)</code>.</li>
</ol>
<p>We maintain:</p>
<ul>
<li>Union-Find / DSU structure for SCC groups</li>
<li>Reachability or DAG edges between SCCs</li>
<li>Optional topological order for fast cycle checks</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge Added</th>
<th>Action</th>
<th>New SCCs</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1</td>
<td>Create edge</td>
<td>{0}, {1}</td>
<td>Separate</td>
</tr>
<tr class="even">
<td>1→2</td>
<td>Create edge</td>
<td>{0}, {1}, {2}</td>
<td>Separate</td>
</tr>
<tr class="odd">
<td>2→0</td>
<td>Cycle formed</td>
<td>Merge {0,1,2}</td>
<td>New SCC</td>
</tr>
<tr class="even">
<td>3→1</td>
<td>Add edge</td>
<td>{3}, {0,1,2}</td>
<td>No merge</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-conceptual-demo" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-conceptual-demo">Tiny Code (Conceptual Demo)</h4>
<p>Python (Simplified DSU + DAG Check)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DSU:</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, x):</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.parent[x] <span class="op">!=</span> x:</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent[x] <span class="op">=</span> <span class="va">self</span>.find(<span class="va">self</span>.parent[x])</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.parent[x]</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(<span class="va">self</span>, a, b):</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        ra, rb <span class="op">=</span> <span class="va">self</span>.find(a), <span class="va">self</span>.find(b)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ra <span class="op">!=</span> rb:</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent[rb] <span class="op">=</span> ra</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> OnlineSCC:</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dsu <span class="op">=</span> DSU(n)</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.graph <span class="op">=</span> [<span class="bu">set</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_edge(<span class="va">self</span>, u, v):</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>        su, sv <span class="op">=</span> <span class="va">self</span>.dsu.find(u), <span class="va">self</span>.dsu.find(v)</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> su <span class="op">==</span> sv:</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span>  <span class="co"># already connected</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># check if v's component reaches u's component</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>._reachable(sv, su):</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># merge components</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.dsu.union(su, sv)</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>            merged <span class="op">=</span> <span class="va">self</span>.dsu.find(su)</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.graph[merged] <span class="op">=</span> <span class="va">self</span>.graph[su] <span class="op">|</span> <span class="va">self</span>.graph[sv]</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.graph[su].add(sv)</span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _reachable(<span class="va">self</span>, start, target, seen<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> seen <span class="kw">is</span> <span class="va">None</span>: seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> start <span class="op">==</span> target: <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>        seen.add(start)</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> <span class="va">self</span>.graph[start]:</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> seen <span class="kw">and</span> <span class="va">self</span>._reachable(nxt, target, seen):</span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> components(<span class="va">self</span>):</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a>        groups <span class="op">=</span> {}</span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.n):</span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> <span class="va">self</span>.dsu.find(v)</span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a>            groups.setdefault(root, []).append(v)</span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">list</span>(groups.values())</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true" tabindex="-1"></a>scc <span class="op">=</span> OnlineSCC(<span class="dv">4</span>)</span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true" tabindex="-1"></a>scc.add_edge(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true" tabindex="-1"></a>scc.add_edge(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SCCs:"</span>, scc.components())  <span class="co"># [[0], [1], [2], [3]]</span></span>
<span id="cb29-53"><a href="#cb29-53" aria-hidden="true" tabindex="-1"></a>scc.add_edge(<span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb29-54"><a href="#cb29-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SCCs:"</span>, scc.components())  <span class="co"># [[0,1,2], [3]]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-14" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-14">Why It Matters</h4>
<ul>
<li>Dynamic SCC maintenance without recomputation</li>
<li>Handles edge insertions in O(V + E) amortized</li>
<li>Enables real-time graph updates</li>
<li>Basis for more advanced algorithms (fully dynamic SCC with deletions)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-14" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-14">A Gentle Proof (Why It Works)</h4>
<p>Every time we add an edge, one of two things happens:</p>
<ul>
<li>It connects existing SCCs without creating a cycle → add DAG edge</li>
<li>It creates a cycle → merge involved SCCs</li>
</ul>
<p>Since merging SCCs preserves the DAG structure (merging collapses cycles), the algorithm keeps the condensation graph valid at all times.</p>
<p>By maintaining reachability between SCCs, we can detect cycle formation efficiently.</p>
</section>
<section id="try-it-yourself-14" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-14">Try It Yourself</h4>
<ol type="1">
<li>Start with 5 nodes, no edges.</li>
<li>Add edges step-by-step, printing SCCs.</li>
<li>Add a back-edge forming a cycle → watch SCCs merge.</li>
<li>Visualize condensation DAG after each update.</li>
<li>Compare with recomputing using Tarjan’s, they match!</li>
</ol>
</section>
<section id="test-cases-14" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-14">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Edge</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0→1</td>
<td>{0}, {1}, {2}, {3}</td>
</tr>
<tr class="even">
<td>2</td>
<td>1→2</td>
<td>{0}, {1}, {2}, {3}</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2→0</td>
<td>{0,1,2}, {3}</td>
</tr>
<tr class="even">
<td>4</td>
<td>3→1</td>
<td>{0,1,2}, {3}</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2→3</td>
<td>{0,1,2,3}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-14" class="level4">
<h4 class="anchored" data-anchor-id="complexity-14">Complexity</h4>
<ul>
<li>Time: O(V + E) amortized (per edge addition)</li>
<li>Space: O(V + E) (graph + DSU)</li>
</ul>
<p>SCC Online Merge is your dynamic sculptor, merging components as new edges appear, maintaining structure without ever starting over.</p>
</section>
</section>
<section id="component-label-propagation" class="level3">
<h3 class="anchored" data-anchor-id="component-label-propagation">316 Component Label Propagation</h3>
<p>Component Label Propagation is a simple, iterative algorithm to find connected components (or strongly connected components in symmetric graphs) by repeatedly propagating minimum labels across edges until all nodes in a component share the same label.</p>
<p>It’s conceptually clean, highly parallelizable, and forms the backbone of graph processing frameworks like Google’s Pregel, Apache Giraph, and GraphX, perfect for large-scale or distributed systems.</p>
<section id="what-problem-are-we-solving-15" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-15">What Problem Are We Solving?</h4>
<p>We want to identify components, groups of vertices that are mutually reachable. Instead of deep recursion or complex stacks, we iteratively propagate labels across the graph until convergence.</p>
<p>This approach is ideal when:</p>
<ul>
<li>The graph is massive (too large for recursion)</li>
<li>You’re using parallel / distributed computation</li>
<li>You want a message-passing style algorithm</li>
</ul>
<p>For undirected graphs, it finds connected components. For directed graphs, it can approximate SCCs (often used as a preprocessing step).</p>
<p>Example: Think of spreading an ID through a crowd, each node tells its neighbors its smallest known label, and everyone updates to match their smallest neighbor’s label. Eventually, all in a group share the same number.</p>
</section>
<section id="how-does-it-work-plain-language-15" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-15">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Initialize: Each vertex’s label = its own ID.</p></li>
<li><p>Iterate: For each vertex:</p>
<ul>
<li>Look at all neighbors’ labels.</li>
<li>Update to the smallest label seen.</li>
</ul></li>
<li><p>Repeat until no label changes (convergence).</p></li>
</ol>
<p>All nodes that end up sharing a label belong to the same component.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Node</th>
<th>Current Label</th>
<th>Neighbor Labels</th>
<th>New Label</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A</td>
<td>A</td>
<td>{B, C}</td>
<td>min(A, B, C) = A</td>
</tr>
<tr class="even">
<td>2</td>
<td>B</td>
<td>B</td>
<td>{A}</td>
<td>min(B, A) = A</td>
</tr>
<tr class="odd">
<td>3</td>
<td>C</td>
<td>C</td>
<td>{A}</td>
<td>min(C, A) = A</td>
</tr>
</tbody>
</table>
<p>Eventually, A, B, C → all labeled A.</p>
</section>
<section id="tiny-code-easy-versions-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-14">Tiny Code (Easy Versions)</h4>
<p>C (Iterative Label Propagation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> label<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> label_propagation<span class="op">()</span> <span class="op">{</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> changed <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>changed<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        changed <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> min_label <span class="op">=</span> label<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>label<span class="op">[</span>u<span class="op">]</span> <span class="op">&lt;</span> min_label<span class="op">)</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>                        min_label <span class="op">=</span> label<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>min_label <span class="op">&lt;</span> label<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>                label<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> min_label<span class="op">;</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>                changed <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (undirected):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>        label<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>    label_propagation<span class="op">();</span></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Component Labels:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Vertex </span><span class="sc">%d</span><span class="st"> → Label </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> label<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simple Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>],</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">0</span>, <span class="dv">2</span>],</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">1</span>],</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [<span class="dv">4</span>],</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: [<span class="dv">3</span>]</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> {v: v <span class="cf">for</span> v <span class="kw">in</span> graph}</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>changed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> changed:</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    changed <span class="op">=</span> <span class="va">False</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> graph:</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>        min_label <span class="op">=</span> <span class="bu">min</span>([labels[v]] <span class="op">+</span> [labels[u] <span class="cf">for</span> u <span class="kw">in</span> graph[v]])</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> min_label <span class="op">&lt;</span> labels[v]:</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>            labels[v] <span class="op">=</span> min_label</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>            changed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Component labels:"</span>, labels)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-15" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-15">Why It Matters</h4>
<ul>
<li>Simple and parallelizable, ideal for big data systems</li>
<li>No recursion or stack, suitable for GPUs, clusters</li>
<li>Local computation, fits the “think like a vertex” model</li>
<li>Works on massive graphs where DFS is impractical</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-15" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-15">A Gentle Proof (Why It Works)</h4>
<p>Each iteration allows label information to flow along edges. Since the smallest label always propagates, and each propagation only decreases label values, the process must converge (no infinite updates). At convergence, all vertices in a connected component share the same minimal label.</p>
<p>The number of iterations ≤ graph diameter.</p>
</section>
<section id="try-it-yourself-15" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-15">Try It Yourself</h4>
<ol type="1">
<li>Run it on small undirected graphs, label flow is easy to track.</li>
<li>Try a graph with two disconnected parts, they’ll stabilize separately.</li>
<li>Add edges between components and rerun, watch labels merge.</li>
<li>Use directed edges and see how approximation differs from SCCs.</li>
<li>Implement in parallel (multi-threaded loop).</li>
</ol>
</section>
<section id="test-cases-15" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-15">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Final Labels</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–1–2</td>
<td>(0,1), (1,2)</td>
<td>{0,0,0}</td>
</tr>
<tr class="even">
<td>0–1, 2–3</td>
<td>(0,1), (2,3)</td>
<td>{0,0,2,2}</td>
</tr>
<tr class="odd">
<td>0–1–2–3</td>
<td>Chain</td>
<td>{0,0,0,0}</td>
</tr>
<tr class="even">
<td>0–1, 1–2, 2–0</td>
<td>Cycle</td>
<td>{0,0,0}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-15" class="level4">
<h4 class="anchored" data-anchor-id="complexity-15">Complexity</h4>
<ul>
<li>Time: O(V × E) (in worst case, or O(D × E) for D = diameter)</li>
<li>Space: O(V + E)</li>
</ul>
<p>Component Label Propagation is your whispering algorithm, every node shares its name with neighbors, again and again, until all who can reach each other call themselves by the same name.</p>
</section>
</section>
<section id="path-based-scc" class="level3">
<h3 class="anchored" data-anchor-id="path-based-scc">317 Path-Based SCC</h3>
<p>The Path-Based SCC algorithm is another elegant one-pass method for finding strongly connected components in a directed graph. It’s similar in spirit to Tarjan’s algorithm, but instead of computing explicit <code>low-link</code> values, it maintains path stacks to detect when a full component has been traversed.</p>
<p>Developed by Donald B. Johnson, it uses two stacks to keep track of DFS path order and potential roots. When a vertex cannot reach any earlier vertex, it becomes the root of an SCC, and the algorithm pops all nodes in that SCC from the path.</p>
<section id="what-problem-are-we-solving-16" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-16">What Problem Are We Solving?</h4>
<p>We want to find SCCs in a directed graph, subsets of vertices where each node can reach every other node. Path-Based SCC offers a conceptually simple and efficient way to do this without <code>low-link</code> math.</p>
<p>Why it’s useful:</p>
<ul>
<li>Single DFS traversal</li>
<li>Clean stack-based logic</li>
<li>Great for teaching, reasoning, and implementation clarity</li>
<li>Easy to extend for incremental or streaming SCC detection</li>
</ul>
<p>Applications:</p>
<ul>
<li>Compiler analysis (strongly connected variables)</li>
<li>Circuit analysis</li>
<li>Deadlock detection</li>
<li>Dataflow optimization</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-16" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-16">How Does It Work (Plain Language)?</h4>
<p>We maintain:</p>
<ul>
<li><code>index[v]</code>: discovery order</li>
<li>S stack: DFS path (nodes in current exploration)</li>
<li>P stack: candidates for SCC roots</li>
</ul>
<p>Algorithm steps:</p>
<ol type="1">
<li><p>Assign <code>index[v]</code> when visiting a node.</p></li>
<li><p>Push <code>v</code> onto both stacks (<code>S</code> and <code>P</code>).</p></li>
<li><p>For each neighbor <code>u</code>:</p>
<ul>
<li>If <code>u</code> is unvisited → recurse</li>
<li>If <code>u</code> is on <code>S</code> → adjust <code>P</code> by popping until its top has an index ≤ <code>index[u]</code></li>
</ul></li>
<li><p>If <code>v</code> is at the top of <code>P</code> after processing all neighbors:</p>
<ul>
<li>Pop <code>P</code></li>
<li>Pop from <code>S</code> until <code>v</code> is removed</li>
<li>The popped vertices form one SCC</li>
</ul></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Current Node</th>
<th>Stack S</th>
<th>Stack P</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A</td>
<td>[A]</td>
<td>[A]</td>
<td>Visit A</td>
</tr>
<tr class="even">
<td>2</td>
<td>B</td>
<td>[A,B]</td>
<td>[A,B]</td>
<td>Visit B</td>
</tr>
<tr class="odd">
<td>3</td>
<td>C</td>
<td>[A,B,C]</td>
<td>[A,B,C]</td>
<td>Visit C</td>
</tr>
<tr class="even">
<td>4</td>
<td>Back edge C→B</td>
<td>[A,B,C]</td>
<td>[A,B]</td>
<td>Adjust</td>
</tr>
<tr class="odd">
<td>5</td>
<td>C done</td>
<td>[A,B,C]</td>
<td>[A,B]</td>
<td>Continue</td>
</tr>
<tr class="even">
<td>6</td>
<td>P top == B</td>
<td>[A]</td>
<td>[A]</td>
<td>Found SCC {B,C}</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-15" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-15">Tiny Code (Easy Versions)</h4>
<p>C (Path-Based SCC)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> index_counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> indexv<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> onStack<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stackS<span class="op">[</span>MAX<span class="op">],</span> topS <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stackP<span class="op">[</span>MAX<span class="op">],</span> topP <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs_scc<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    indexv<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>index_counter<span class="op">;</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    stackS<span class="op">[++</span>topS<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    stackP<span class="op">[++</span>topP<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    onStack<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>graph<span class="op">[</span>v<span class="op">][</span>u<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>indexv<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>            dfs_scc<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>onStack<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>indexv<span class="op">[</span>stackP<span class="op">[</span>topP<span class="op">]]</span> <span class="op">&gt;</span> indexv<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>                topP<span class="op">--;</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stackP<span class="op">[</span>topP<span class="op">]</span> <span class="op">==</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>        topP<span class="op">--;</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"SCC: "</span><span class="op">);</span></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> w<span class="op">;</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> stackS<span class="op">[</span>topS<span class="op">--];</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>            onStack<span class="op">[</span>w<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> w<span class="op">);</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>w <span class="op">!=</span> v<span class="op">);</span></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (directed):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> indexv<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Strongly Connected Components:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>indexv<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a>            dfs_scc<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Readable Implementation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">3</span>)]</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    graph[u].append(v)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>index_counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> {}</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>stackS, stackP <span class="op">=</span> [], []</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>on_stack <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>sccs <span class="op">=</span> []</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(v):</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> index_counter</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    index_counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    index[v] <span class="op">=</span> index_counter</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    stackS.append(v)</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    stackP.append(v)</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    on_stack.add(v)</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> index:</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>            dfs(u)</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> u <span class="kw">in</span> on_stack:</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> index[stackP[<span class="op">-</span><span class="dv">1</span>]] <span class="op">&gt;</span> index[u]:</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>                stackP.pop()</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> stackP <span class="kw">and</span> stackP[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> v:</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>        stackP.pop()</span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>        comp <span class="op">=</span> []</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> stackS.pop()</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>            on_stack.remove(w)</span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>            comp.append(w)</span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="op">==</span> v:</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a>        sccs.append(comp)</span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> v <span class="kw">in</span> <span class="bu">list</span>(graph.keys()):</span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> index:</span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>        dfs(v)</span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Strongly Connected Components:"</span>, sccs)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-16" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-16">Why It Matters</h4>
<ul>
<li>Single DFS</li>
<li>No low-link math, purely path-based reasoning</li>
<li>Compact and intuitive for stack lovers</li>
<li>Well-suited for theoretical clarity and educational use</li>
<li>Matches Tarjan’s O(V + E) performance</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-16" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-16">A Gentle Proof (Why It Works)</h4>
<ul>
<li>Each vertex gets a discovery index;</li>
<li>Stack <code>S</code> stores active path nodes;</li>
<li>Stack <code>P</code> tracks potential SCC roots (lowest index still reachable). When a vertex finishes and equals top of <code>P</code>, all nodes above it in <code>S</code> form an SCC, they’re mutually reachable, and none can reach earlier nodes.</li>
</ul>
<p>The invariant ensures:</p>
<ul>
<li>Nodes stay on stack until their SCC is found</li>
<li>SCCs are discovered in reverse topological order</li>
</ul>
</section>
<section id="try-it-yourself-16" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-16">Try It Yourself</h4>
<ol type="1">
<li>Run it on a small graph, print <code>index[v]</code>, stack states after each call.</li>
<li>Add a cycle, trace how P adjusts.</li>
<li>Compare output with Tarjan’s algorithm, they match!</li>
<li>Visualize path-based pops as SCC boundaries.</li>
<li>Try graphs with multiple disjoint SCCs.</li>
</ol>
</section>
<section id="test-cases-16" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-16">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1, 1→2, 2→0</td>
<td>Cycle</td>
<td>{0,1,2}</td>
</tr>
<tr class="even">
<td>0→1, 1→2</td>
<td>Chain</td>
<td>{0}, {1}, {2}</td>
</tr>
<tr class="odd">
<td>0→1, 1→0, 2→3</td>
<td>Mixed</td>
<td>{0,1}, {2}, {3}</td>
</tr>
<tr class="even">
<td>0→1, 1→2, 2→3, 3→1</td>
<td>Nested</td>
<td>{1,2,3}, {0}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-16" class="level4">
<h4 class="anchored" data-anchor-id="complexity-16">Complexity</h4>
<ul>
<li>Time: O(V + E)</li>
<li>Space: O(V)</li>
</ul>
<p>Path-Based SCC is your stack ballet, each vertex steps forward, marks its place, and retreats gracefully, leaving behind a tightly choreographed component.</p>
</section>
</section>
<section id="kosaraju-parallel-version" class="level3">
<h3 class="anchored" data-anchor-id="kosaraju-parallel-version">318 Kosaraju Parallel Version</h3>
<p>The Parallel Kosaraju Algorithm adapts Kosaraju’s classic two-pass SCC method to run on multiple processors or threads, making it suitable for large-scale graphs that can’t be processed efficiently by a single thread. It divides the heavy lifting, DFS traversals and graph reversals, across many workers.</p>
<p>It’s the natural evolution of Kosaraju’s idea in the age of parallel computing: split the graph, explore concurrently, merge SCCs.</p>
<section id="what-problem-are-we-solving-17" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-17">What Problem Are We Solving?</h4>
<p>We want to compute SCCs in a massive directed graph efficiently, by taking advantage of parallel hardware, multicore CPUs, GPUs, or distributed systems.</p>
<p>The classic Kosaraju algorithm:</p>
<ol type="1">
<li>DFS on the original graph to record finishing times</li>
<li>Reverse all edges to create the transpose graph</li>
<li>DFS on the reversed graph in decreasing order of finishing time</li>
</ol>
<p>The parallel version accelerates each phase by partitioning vertices or edges among processors.</p>
<p>Applications include:</p>
<ul>
<li>Large dependency graphs (package managers, compilers)</li>
<li>Web graphs (page connectivity)</li>
<li>Social networks (mutual reachability)</li>
<li>GPU-accelerated analytics and graph mining</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-17" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-17">How Does It Work (Plain Language)?</h4>
<p>We parallelize Kosaraju’s two key passes:</p>
<ol type="1">
<li><p>Parallel Forward DFS (Finishing Order):</p>
<ul>
<li>Partition vertices across threads.</li>
<li>Each thread runs DFS independently on its subgraph.</li>
<li>Maintain a shared stack of finish times (atomic appends).</li>
</ul></li>
<li><p>Graph Reversal:</p>
<ul>
<li>Reverse each edge <span class="math inline">\((u, v)\)</span> into <span class="math inline">\((v, u)\)</span> in parallel.</li>
<li>Each thread processes a slice of the edge list.</li>
</ul></li>
<li><p>Parallel Reverse DFS (SCC Labeling):</p>
<ul>
<li>Threads pop vertices from the global stack.</li>
<li>Each unvisited node starts a new component.</li>
<li>DFS labeling runs concurrently with atomic visited flags.</li>
</ul></li>
<li><p>Merge Components:</p>
<ul>
<li>Combine local SCC results using union–find if overlapping sets appear.</li>
</ul></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Phase</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Parallelized</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">DFS on original graph</td>
<td style="text-align: left;">✅ Yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;">Reverse edges</td>
<td style="text-align: left;">✅ Yes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;">DFS on reversed graph</td>
<td style="text-align: left;">✅ Yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;">Merge labels</td>
<td style="text-align: left;">✅ Yes</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-pseudocode-python-threaded-sketch" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-pseudocode-python-threaded-sketch">Tiny Code (Pseudocode / Python Threaded Sketch)</h4>
<blockquote class="blockquote">
<p>This example is conceptual, real parallel implementations use task queues, GPU kernels, or work-stealing schedulers.</p>
</blockquote>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> threading</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">2</span>), (<span class="dv">2</span>,<span class="dv">0</span>), (<span class="dv">2</span>,<span class="dv">3</span>), (<span class="dv">3</span>,<span class="dv">4</span>)]</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    graph[u].append(v)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>finish_order <span class="op">=</span> []</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>lock <span class="op">=</span> threading.Lock()</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs_forward(v):</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    visited[v] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph[v]:</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> visited[u]:</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>            dfs_forward(u)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> lock:</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>        finish_order.append(v)</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parallel_forward():</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    threads <span class="op">=</span> []</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> visited[v]:</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> threading.Thread(target<span class="op">=</span>dfs_forward, args<span class="op">=</span>(v,))</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>            t.start()</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>            threads.append(t)</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> threads:</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>        t.join()</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Reverse graph in parallel</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>rev <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u <span class="kw">in</span> graph:</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>        rev[v].append(u)</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>components <span class="op">=</span> []</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs_reverse(v, comp):</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>    visited[v] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a>    comp.append(v)</span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> rev[v]:</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> visited[u]:</span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a>            dfs_reverse(u, comp)</span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parallel_reverse():</span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> finish_order:</span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> finish_order.pop()</span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> visited[v]:</span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true" tabindex="-1"></a>            comp <span class="op">=</span> []</span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true" tabindex="-1"></a>            dfs_reverse(v, comp)</span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true" tabindex="-1"></a>            components.append(comp)</span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true" tabindex="-1"></a>parallel_forward()</span>
<span id="cb34-57"><a href="#cb34-57" aria-hidden="true" tabindex="-1"></a>parallel_reverse()</span>
<span id="cb34-58"><a href="#cb34-58" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SCCs:"</span>, components)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-17" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-17">Why It Matters</h4>
<ul>
<li>Enables SCC computation at scale</li>
<li>Exploits multicore / GPU parallelism</li>
<li>Critical for dataflow analysis, reachability, and graph condensation</li>
<li>Powers large-scale graph analytics in scientific computing</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-17" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-17">A Gentle Proof (Why It Works)</h4>
<p>Kosaraju’s correctness depends on finishing times and reversed reachability:</p>
<ul>
<li>In the forward pass, each vertex <span class="math inline">\(v\)</span> gets a finishing time <span class="math inline">\(t(v)\)</span>.</li>
<li>In the reversed graph, DFS in descending <span class="math inline">\(t(v)\)</span> ensures that every SCC is discovered as a contiguous DFS tree.</li>
</ul>
<p>Parallel execution maintains these invariants because:</p>
<ol type="1">
<li>All threads respect atomic finishing-time insertion</li>
<li>The global finishing order preserves a valid topological order</li>
<li>The reversed DFS still discovers mutually reachable vertices together</li>
</ol>
<p>Thus, correctness holds under synchronized access, even with concurrent DFS traversals.</p>
</section>
<section id="try-it-yourself-17" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-17">Try It Yourself</h4>
<ol type="1">
<li>Split vertices into <span class="math inline">\(p\)</span> partitions.</li>
<li>Run forward DFS in parallel; record global finish stack.</li>
<li>Reverse edges concurrently.</li>
<li>Run backward DFS by popping from the stack.</li>
<li>Compare results with single-threaded Kosaraju, they match.</li>
</ol>
</section>
<section id="test-cases-17" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-17">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Graph</th>
<th style="text-align: left;">Edges</th>
<th style="text-align: left;">SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Cycle</td>
<td style="text-align: left;">0→1, 1→2, 2→0</td>
<td style="text-align: left;">{0, 1, 2}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Chain</td>
<td style="text-align: left;">0→1, 1→2</td>
<td style="text-align: left;">{0}, {1}, {2}</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Two cycles</td>
<td style="text-align: left;">0→1, 1→0, 2→3, 3→2</td>
<td style="text-align: left;">{0, 1}, {2, 3}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Mixed</td>
<td style="text-align: left;">0→1, 1→2, 2→3, 3→0, 4→5</td>
<td style="text-align: left;">{0, 1, 2, 3}, {4, 5}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-17" class="level4">
<h4 class="anchored" data-anchor-id="complexity-17">Complexity</h4>
<p>Let <span class="math inline">\(V\)</span> be vertices, <span class="math inline">\(E\)</span> edges, <span class="math inline">\(p\)</span> processors.</p>
<ul>
<li>Work: <span class="math inline">\(O(V + E)\)</span> (same as sequential)</li>
<li>Parallel Time: <span class="math inline">\(T_p = O!\left(\frac{V + E}{p} + \text{sync\_cost}\right)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Kosaraju Parallel is your multi-voice chorus, each DFS sings in harmony, covering its section of the graph, and when the echoes settle, the full harmony of strongly connected components is revealed.</p>
</section>
</section>
<section id="dynamic-scc-maintenance" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-scc-maintenance">319 Dynamic SCC Maintenance</h3>
<p>Dynamic SCC Maintenance deals with maintaining strongly connected components as a directed graph changes over time, edges or vertices may be added or removed. The goal is to update SCCs incrementally rather than recomputing them from scratch after each change.</p>
<p>This approach is crucial in streaming, interactive, or evolving systems, where graphs represent real-world structures that shift continuously.</p>
<section id="what-problem-are-we-solving-18" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-18">What Problem Are We Solving?</h4>
<p>We want to keep track of SCCs under dynamic updates:</p>
<ul>
<li>Insertions: New edges can connect SCCs and form larger ones.</li>
<li>Deletions: Removing edges can split SCCs into smaller ones.</li>
</ul>
<p>Static algorithms like Tarjan or Kosaraju must restart completely. Dynamic maintenance updates only the affected components, improving efficiency for large, frequently changing graphs.</p>
<p>Use cases include:</p>
<ul>
<li>Incremental compilation</li>
<li>Dynamic program analysis</li>
<li>Real-time dependency resolution</li>
<li>Continuous graph query systems</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-18" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-18">How Does It Work (Plain Language)?</h4>
<p>The dynamic SCC algorithm maintains:</p>
<ul>
<li>A condensation DAG representing SCCs.</li>
<li>A reachability structure to detect cycles upon insertion.</li>
<li>Local re-evaluation for affected nodes.</li>
</ul>
<p>When an edge <span class="math inline">\((u, v)\)</span> is added:</p>
<ol type="1">
<li>Identify components <span class="math inline">\(C_u\)</span> and <span class="math inline">\(C_v\)</span>.</li>
<li>If <span class="math inline">\(C_u = C_v\)</span>, no change.</li>
<li>If <span class="math inline">\(C_v\)</span> can reach <span class="math inline">\(C_u\)</span>, a new cycle forms → merge SCCs.</li>
<li>Otherwise, add edge <span class="math inline">\(C_u \to C_v\)</span> in the condensation DAG.</li>
</ol>
<p>When an edge <span class="math inline">\((u, v)\)</span> is removed:</p>
<ol type="1">
<li>Remove it from the graph.</li>
<li>Check if <span class="math inline">\(C_u\)</span> and <span class="math inline">\(C_v\)</span> remain mutually reachable.</li>
<li>If not, recompute SCCs locally on the affected subgraph.</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Update</th>
<th>Action</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Add edge forming cycle</td>
<td>Merge SCCs</td>
<td>Larger component</td>
</tr>
<tr class="even">
<td>Add edge without cycle</td>
<td>DAG edge only</td>
<td>No merge</td>
</tr>
<tr class="odd">
<td>Remove edge breaking cycle</td>
<td>Split SCC</td>
<td>New components</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-simplified-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-example">Tiny Code (Simplified Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DSU:</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, x):</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.parent[x] <span class="op">!=</span> x:</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent[x] <span class="op">=</span> <span class="va">self</span>.find(<span class="va">self</span>.parent[x])</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.parent[x]</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(<span class="va">self</span>, a, b):</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>        ra, rb <span class="op">=</span> <span class="va">self</span>.find(a), <span class="va">self</span>.find(b)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ra <span class="op">!=</span> rb:</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent[rb] <span class="op">=</span> ra</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DynamicSCC:</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dsu <span class="op">=</span> DSU(n)</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.graph <span class="op">=</span> [<span class="bu">set</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_edge(<span class="va">self</span>, u, v):</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>        su, sv <span class="op">=</span> <span class="va">self</span>.dsu.find(u), <span class="va">self</span>.dsu.find(v)</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> su <span class="op">==</span> sv:</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>._reachable(sv, su):</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.dsu.union(su, sv)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.graph[su].add(sv)</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _reachable(<span class="va">self</span>, start, target, seen<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> seen <span class="kw">is</span> <span class="va">None</span>: seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> start <span class="op">==</span> target: <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>        seen.add(start)</span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nxt <span class="kw">in</span> <span class="va">self</span>.graph[start]:</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="kw">not</span> <span class="kw">in</span> seen <span class="kw">and</span> <span class="va">self</span>._reachable(nxt, target, seen):</span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> components(<span class="va">self</span>):</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>        comps <span class="op">=</span> {}</span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.n):</span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> <span class="va">self</span>.dsu.find(v)</span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>            comps.setdefault(root, []).append(v)</span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">list</span>(comps.values())</span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>scc <span class="op">=</span> DynamicSCC(<span class="dv">4</span>)</span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>scc.add_edge(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>scc.add_edge(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(scc.components())  <span class="co"># [[0], [1], [2], [3]]</span></span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>scc.add_edge(<span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(scc.components())  <span class="co"># [[0,1,2], [3]]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-18" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-18">Why It Matters</h4>
<ul>
<li>Efficient for long-running systems where graphs evolve</li>
<li>Updates SCCs incrementally rather than rebuilding</li>
<li>Supports real-time queries of connectivity</li>
<li>Useful for streaming graph databases, incremental compilers, interactive modeling tools</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-18" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-18">A Gentle Proof (Why It Works)</h4>
<p>For insertion:</p>
<ul>
<li>If <span class="math inline">\((u, v)\)</span> connects components <span class="math inline">\(C_u\)</span> and <span class="math inline">\(C_v\)</span></li>
<li>And if <span class="math inline">\(C_v\)</span> can reach <span class="math inline">\(C_u\)</span>, then a cycle forms</li>
<li>Merging <span class="math inline">\(C_u\)</span> and <span class="math inline">\(C_v\)</span> yields a valid SCC</li>
<li>The condensation DAG remains acyclic</li>
</ul>
<p>For deletion:</p>
<ul>
<li>If removal breaks reachability, SCC splits</li>
<li>Recomputing locally ensures correctness</li>
<li>Other unaffected SCCs remain valid</li>
</ul>
<p>Each update modifies only the local neighborhood of the affected components.</p>
</section>
<section id="try-it-yourself-18" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-18">Try It Yourself</h4>
<ol type="1">
<li>Build a small directed graph.</li>
<li>Insert edges step by step and print components.</li>
<li>Add a back-edge to create a cycle and observe merging.</li>
<li>Remove an edge and check local recomputation.</li>
<li>Compare results with full Tarjan recomputation.</li>
</ol>
</section>
<section id="test-cases-18" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-18">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Edge</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0→1</td>
<td>{0}, {1}, {2}</td>
</tr>
<tr class="even">
<td>2</td>
<td>1→2</td>
<td>{0}, {1}, {2}</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2→0</td>
<td>{0,1,2}</td>
</tr>
<tr class="even">
<td>4</td>
<td>2→3</td>
<td>{0,1,2}, {3}</td>
</tr>
<tr class="odd">
<td>5</td>
<td>remove 1→2</td>
<td>{0,1}, {2}, {3}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-18" class="level4">
<h4 class="anchored" data-anchor-id="complexity-18">Complexity</h4>
<ul>
<li>Insertion: <span class="math inline">\(O(V + E)\)</span> amortized (with reachability check)</li>
<li>Deletion: Local recomputation, typically sublinear</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Dynamic SCC Maintenance provides a framework to keep SCCs consistent as the graph evolves, adapting efficiently to both incremental growth and structural decay.</p>
</section>
</section>
<section id="scc-for-weighted-graph" class="level3">
<h3 class="anchored" data-anchor-id="scc-for-weighted-graph">320 SCC for Weighted Graph</h3>
<p>SCC detection is usually discussed for unweighted graphs, where edge weights are irrelevant to reachability. However, in many real-world systems, weights encode constraints (cost, capacity, priority, probability), and we need to identify strong connectivity under these weighted conditions. This variant integrates SCC algorithms with weighted edge logic, allowing selective inclusion or exclusion of edges based on weight criteria.</p>
<section id="what-problem-are-we-solving-19" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-19">What Problem Are We Solving?</h4>
<p>We want to find strongly connected components in a weighted directed graph. A standard SCC algorithm ignores weights, it only checks reachability. Here, we define SCCs based on edges satisfying a given weight predicate:</p>
<p><span class="math display">\[
(u, v) \in E_w \quad \text{iff} \quad w(u, v) \leq \theta
\]</span></p>
<p>We can then run SCC algorithms (Tarjan, Kosaraju, Gabow, Path-based) on the subgraph induced by edges satisfying the constraint.</p>
<p>Common use cases:</p>
<ul>
<li>Thresholded connectivity: Keep edges below cost <span class="math inline">\(\theta\)</span>.</li>
<li>Capacity-limited systems: Only include edges with capacity ≥ threshold.</li>
<li>Dynamic constraint graphs: Recompute SCCs as thresholds shift.</li>
<li>Probabilistic networks: Consider edges with probability ≥ <span class="math inline">\(p\)</span>.</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-19" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-19">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li>Start with a weighted directed graph <span class="math inline">\(G = (V, E, w)\)</span></li>
<li>Apply a predicate on weights (e.g.&nbsp;<span class="math inline">\(w(u, v) \le \theta\)</span>)</li>
<li>Build a filtered subgraph <span class="math inline">\(G_\theta = (V, E_\theta)\)</span></li>
<li>Run a standard SCC algorithm on <span class="math inline">\(G_\theta\)</span></li>
</ol>
<p>The result groups vertices that are strongly connected under the weight constraint.</p>
<p>If <span class="math inline">\(\theta\)</span> changes, components can merge or split:</p>
<ul>
<li>Increasing <span class="math inline">\(\theta\)</span> (loosening) → SCCs merge</li>
<li>Decreasing <span class="math inline">\(\theta\)</span> (tightening) → SCCs split</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Threshold <span class="math inline">\(\theta\)</span></th>
<th>Included Edges</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td><span class="math inline">\(w \le 3\)</span></td>
<td>{A,B}, {C}</td>
</tr>
<tr class="even">
<td>5</td>
<td><span class="math inline">\(w \le 5\)</span></td>
<td>{A,B,C}</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-threshold-based-filtering" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-threshold-based-filtering">Tiny Code (Threshold-Based Filtering)</h4>
<p>Python Example</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>),</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>),</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">6</span>),</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">6</span>)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_subgraph(edges, theta):</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> w <span class="op">&lt;=</span> theta:</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>            g[u].append(v)</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(v, g, visited, stack):</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    visited.add(v)</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> g[v]:</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>            dfs(u, g, visited, stack)</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    stack.append(v)</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_graph(g):</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    rg <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> g:</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>            rg[v].append(u)</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rg</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kosaraju(g):</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>    visited, stack <span class="op">=</span> <span class="bu">set</span>(), []</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g:</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>            dfs(v, g, visited, stack)</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>    rg <span class="op">=</span> reverse_graph(g)</span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>    visited.clear()</span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>    comps <span class="op">=</span> []</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stack:</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> stack.pop()</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>            comp <span class="op">=</span> []</span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>            dfs(v, rg, visited, comp)</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>            comps.append(comp)</span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> comps</span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a>g_theta <span class="op">=</span> build_subgraph(edges, theta)</span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SCCs with threshold"</span>, theta, <span class="st">":"</span>, kosaraju(g_theta))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SCCs with threshold 4 : [[2, 0, 1], [3]]</code></pre>
</section>
<section id="why-it-matters-19" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-19">Why It Matters</h4>
<ul>
<li>Incorporates weight constraints into connectivity</li>
<li>Useful in optimization, routing, and clustering</li>
<li>Supports incremental recomputation under shifting thresholds</li>
<li>Enables multi-layer graph analysis (vary <span class="math inline">\(\theta\)</span> to see component evolution)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-19" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-19">A Gentle Proof (Why It Works)</h4>
<p>Reachability in a weighted graph depends on which edges are active. Filtering edges by predicate preserves a subset of original reachability:</p>
<p>If there is a path <span class="math inline">\(u \to v\)</span> in <span class="math inline">\(G_\theta\)</span>, all edges on that path satisfy <span class="math inline">\(w(e) \le \theta\)</span>. Since SCCs depend solely on reachability, standard algorithms applied to <span class="math inline">\(G_\theta\)</span> correctly identify weight-constrained SCCs.</p>
<p>As <span class="math inline">\(\theta\)</span> increases, the edge set <span class="math inline">\(E_\theta\)</span> grows monotonically:</p>
<p><span class="math display">\[
E_{\theta_1} \subseteq E_{\theta_2} \quad \text{for} \quad \theta_1 &lt; \theta_2
\]</span></p>
<p>Therefore, the SCC partition becomes coarser (components merge).</p>
</section>
<section id="try-it-yourself-19" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-19">Try It Yourself</h4>
<ol type="1">
<li>Build a weighted graph.</li>
<li>Pick thresholds <span class="math inline">\(\theta = 2, 4, 6\)</span> and record SCCs.</li>
<li>Plot how components merge as <span class="math inline">\(\theta\)</span> increases.</li>
<li>Try predicates like <span class="math inline">\(w(u, v) \ge \theta\)</span>.</li>
<li>Combine with Dynamic SCC Maintenance for evolving thresholds.</li>
</ol>
</section>
<section id="test-cases-19" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-19">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(\theta\)</span></th>
<th>Edges Included</th>
<th>SCCs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>(0→1,2), (2→0)</td>
<td>{0,2}, {1}, {3}</td>
</tr>
<tr class="even">
<td>4</td>
<td>(0→1), (1→2), (2→0)</td>
<td>{0,1,2}, {3}</td>
</tr>
<tr class="odd">
<td>6</td>
<td>All edges</td>
<td>{0,1,2,3}</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-19" class="level4">
<h4 class="anchored" data-anchor-id="complexity-19">Complexity</h4>
<ul>
<li>Filtering: <span class="math inline">\(O(E)\)</span></li>
<li>SCC computation: <span class="math inline">\(O(V + E_\theta)\)</span></li>
<li>Total: <span class="math inline">\(O(V + E)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>SCC for Weighted Graphs extends classic connectivity to contexts where not all edges are equal, revealing the layered structure of a graph as thresholds vary.</p>
</section>
</section>
</section>
<section id="section-33.-shortest-paths" class="level2">
<h2 class="anchored" data-anchor-id="section-33.-shortest-paths">Section 33. Shortest Paths</h2>
<section id="dijkstra-binary-heap" class="level3">
<h3 class="anchored" data-anchor-id="dijkstra-binary-heap">321 Dijkstra (Binary Heap)</h3>
<p>Dijkstra’s Algorithm is the cornerstone of shortest path computation in weighted graphs with nonnegative edge weights. It grows a frontier of known shortest paths, always expanding from the vertex with the smallest current distance, much like a wavefront advancing through the graph.</p>
<p>Using a binary heap (priority queue) keeps the next closest vertex selection efficient, making this version the standard for practical use.</p>
<section id="what-problem-are-we-solving-20" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-20">What Problem Are We Solving?</h4>
<p>We need to find the shortest path from a single source vertex <span class="math inline">\(s\)</span> to all other vertices in a directed or undirected graph with nonnegative weights.</p>
<p>Given a weighted graph <span class="math inline">\(G = (V, E, w)\)</span> where <span class="math inline">\(w(u, v) \ge 0\)</span> for all <span class="math inline">\((u, v)\)</span>, the task is to compute:</p>
<p><span class="math display">\[
\text{dist}[v] = \min_{\text{path } s \to v} \sum_{(u, v) \in \text{path}} w(u, v)
\]</span></p>
<p>Typical use cases:</p>
<ul>
<li>GPS navigation (road networks)</li>
<li>Network routing</li>
<li>Pathfinding in games</li>
<li>Dependency resolution in weighted systems</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-20" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-20">How Does It Work (Plain Language)?</h4>
<p>The algorithm maintains a distance array <code>dist[]</code>, initialized with infinity for all vertices except the source.</p>
<ol type="1">
<li>Set <code>dist[s] = 0</code>.</li>
<li>Use a min-priority queue to repeatedly extract the vertex with the smallest distance.</li>
<li>For each neighbor, try to relax the edge:</li>
</ol>
<p><span class="math display">\[
\text{if } \text{dist}[u] + w(u, v) &lt; \text{dist}[v], \text{ then update } \text{dist}[v]
\]</span></p>
<ol start="4" type="1">
<li>Push the neighbor into the queue with updated distance.</li>
<li>Continue until the queue is empty.</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Vertex Extracted</th>
<th>Updated Distances</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><span class="math inline">\(s\)</span></td>
<td><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td>2</td>
<td>Next smallest</td>
<td>Update neighbors</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Repeat</td>
<td>Until all vertices finalized</td>
</tr>
</tbody>
</table>
<p>This is a greedy algorithm, once a vertex is visited, its shortest distance is final.</p>
</section>
<section id="tiny-code-binary-heap" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-binary-heap">Tiny Code (Binary Heap)</h4>
<p>C (Using a Simple Priority Queue with <code>qsort</code>)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF INT_MAX</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dijkstra<span class="op">(</span><span class="dt">int</span> src<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dist<span class="op">[</span>MAX<span class="op">],</span> visited<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>        dist<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>        visited<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>src<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> count <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> count<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> min <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>v<span class="op">]</span> <span class="op">&amp;&amp;</span> dist<span class="op">[</span>v<span class="op">]</span> <span class="op">&lt;</span> min<span class="op">)</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>                min <span class="op">=</span> dist<span class="op">[</span>v<span class="op">],</span> u <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>u <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>        visited<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>v<span class="op">]</span> <span class="op">&amp;&amp;</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>                dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">&lt;</span> dist<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>                dist<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">];</span></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Vertex</span><span class="sc">\t</span><span class="st">Distance</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\t%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> dist<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (0 for no edge):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>    dijkstra<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Heap-Based Implementation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra(graph, src):</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> n</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, src)]</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&gt;</span> dist[u]:</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (dist[v], v))</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">4</span>)],</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [(<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">3</span>, <span class="dv">7</span>)],</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [(<span class="dv">4</span>, <span class="dv">3</span>)],</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [(<span class="dv">4</span>, <span class="dv">1</span>)],</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: []</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dijkstra(graph, <span class="dv">0</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-20" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-20">Why It Matters</h4>
<ul>
<li>Efficient shortest path when weights are nonnegative</li>
<li>Deterministic and greedy, produces optimal paths</li>
<li>Widely applicable to routing, logistics, and AI search</li>
<li>Forms the foundation for A* and Johnson’s algorithm</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-20" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-20">A Gentle Proof (Why It Works)</h4>
<p>Dijkstra’s invariant: When a vertex <span class="math inline">\(u\)</span> is extracted from the priority queue, <span class="math inline">\(\text{dist}[u]\)</span> is final.</p>
<p>Proof idea: All alternative paths to <span class="math inline">\(u\)</span> must go through vertices with greater or equal tentative distances, since edges are nonnegative. Thus, no shorter path exists.</p>
<p>By induction, the algorithm assigns the correct shortest distance to every vertex.</p>
</section>
<section id="try-it-yourself-20" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-20">Try It Yourself</h4>
<ol type="1">
<li>Run on a graph with 5 vertices and random weights.</li>
<li>Add an edge with a smaller weight and see how paths update.</li>
<li>Remove negative edges and note incorrect results.</li>
<li>Visualize the frontier expansion step by step.</li>
<li>Compare with Bellman–Ford on the same graph.</li>
</ol>
</section>
<section id="test-cases-20" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-20">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 63%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Shortest Paths from 0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple</td>
<td>0→1(2), 0→2(4), 1→2(1), 2→4(3), 1→3(7), 3→4(1)</td>
<td>[0, 2, 3, 7, 6]</td>
</tr>
<tr class="even">
<td>Chain</td>
<td>0→1(1), 1→2(1), 2→3(1)</td>
<td>[0, 1, 2, 3]</td>
</tr>
<tr class="odd">
<td>Star</td>
<td>0→1(5), 0→2(2), 0→3(8)</td>
<td>[0, 5, 2, 8]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-20" class="level4">
<h4 class="anchored" data-anchor-id="complexity-20">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O((V + E)\log V)\)</span> with binary heap</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Works only if: <span class="math inline">\(w(u, v) \ge 0\)</span></li>
</ul>
<p>Dijkstra (Binary Heap) is the workhorse of graph search, greedy but precise, always chasing the next closest frontier until all paths fall into place.</p>
</section>
</section>
<section id="dijkstra-fibonacci-heap" class="level3">
<h3 class="anchored" data-anchor-id="dijkstra-fibonacci-heap">322 Dijkstra (Fibonacci Heap)</h3>
<p>Dijkstra’s algorithm can be further optimized by replacing the binary heap with a Fibonacci heap, which offers faster decrease-key operations. This improvement reduces the overall time complexity, making it more suitable for dense graphs or theoretical analysis where asymptotic efficiency matters.</p>
<p>While the constant factors are higher, the asymptotic time is improved to:</p>
<p><span class="math display">\[
O(E + V \log V)
\]</span></p>
<p>compared to the binary heap’s <span class="math inline">\(O((V + E)\log V)\)</span>.</p>
<section id="what-problem-are-we-solving-21" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-21">What Problem Are We Solving?</h4>
<p>We are computing single-source shortest paths in a directed or undirected weighted graph with nonnegative weights, but we want to optimize the priority queue operations to improve theoretical performance.</p>
<p>Given <span class="math inline">\(G = (V, E, w)\)</span> with <span class="math inline">\(w(u, v) \ge 0\)</span>, the task remains:</p>
<p><span class="math display">\[
\text{dist}[v] = \min_{\text{path } s \to v} \sum_{(u,v) \in \text{path}} w(u, v)
\]</span></p>
<p>The difference lies in how we manage the priority queue that selects the next vertex to process.</p>
</section>
<section id="how-does-it-work-plain-language-21" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-21">How Does It Work (Plain Language)?</h4>
<p>The logic of Dijkstra’s algorithm is unchanged, only the data structure used for vertex selection and updates differs.</p>
<ol type="1">
<li><p>Initialize all distances to <span class="math inline">\(\infty\)</span>, except <span class="math inline">\(\text{dist}[s] = 0\)</span>.</p></li>
<li><p>Insert all vertices into a Fibonacci heap keyed by their current distance.</p></li>
<li><p>Repeatedly extract the vertex <span class="math inline">\(u\)</span> with smallest distance.</p></li>
<li><p>For each neighbor <span class="math inline">\((u, v)\)</span>:</p>
<ul>
<li>If <span class="math inline">\(\text{dist}[u] + w(u, v) &lt; \text{dist}[v]\)</span>, update: <span class="math display">\[
\text{dist}[v] \gets \text{dist}[u] + w(u, v)
\]</span> and call decrease-key on <span class="math inline">\(v\)</span> in the heap.</li>
</ul></li>
<li><p>Continue until all vertices are finalized.</p></li>
</ol>
<p>The Fibonacci heap provides:</p>
<ul>
<li><code>extract-min</code>: <span class="math inline">\(O(\log V)\)</span> amortized</li>
<li><code>decrease-key</code>: <span class="math inline">\(O(1)\)</span> amortized</li>
</ul>
<p>This improves the performance for dense graphs where edge relaxations dominate.</p>
</section>
<section id="tiny-code-python-simplified-fibonacci-heap" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-simplified-fibonacci-heap">Tiny Code (Python, Simplified Fibonacci Heap)</h4>
<p>This code illustrates the structure but omits full heap details, production implementations use libraries like <code>networkx</code> or specialized data structures.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heapq <span class="im">import</span> heappush, heappop  <span class="co"># stand-in for demonstration</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra_fib(graph, src):</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> n</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    heap <span class="op">=</span> [(<span class="dv">0</span>, src)]</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> heap:</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heappop(heap)</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> visited[u]:</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>        visited[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> visited[v] <span class="kw">and</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>                heappush(heap, (dist[v], v))</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [(<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">4</span>)],</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [(<span class="dv">2</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">6</span>)],</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [(<span class="dv">3</span>, <span class="dv">3</span>)],</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: []</span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dijkstra_fib(graph, <span class="dv">0</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>(The above uses <code>heapq</code> for illustration; true Fibonacci heap gives better theoretical bounds.)</em></p>
</section>
<section id="why-it-matters-21" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-21">Why It Matters</h4>
<ul>
<li>Improves theoretical time to <span class="math inline">\(O(E + V \log V)\)</span></li>
<li>Demonstrates asymptotic optimization using advanced heaps</li>
<li>Used in dense networks, theoretical research, and competition problems</li>
<li>Foundation for algorithms like Johnson’s APSP and minimum mean cycle</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-21" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-21">A Gentle Proof (Why It Works)</h4>
<p>The correctness remains identical to Dijkstra’s original proof: When a vertex <span class="math inline">\(u\)</span> is extracted (minimum key), its shortest distance is final because all edge weights are nonnegative.</p>
<p>The heap choice only affects efficiency:</p>
<ul>
<li>Binary heap: every <code>decrease-key</code> = <span class="math inline">\(O(\log V)\)</span></li>
<li>Fibonacci heap: every <code>decrease-key</code> = <span class="math inline">\(O(1)\)</span> amortized</li>
</ul>
<p>Total operations:</p>
<ul>
<li><span class="math inline">\(V\)</span> extractions × <span class="math inline">\(O(\log V)\)</span></li>
<li><span class="math inline">\(E\)</span> decreases × <span class="math inline">\(O(1)\)</span></li>
</ul>
<p>Hence total time:</p>
<p><span class="math display">\[
O(V \log V + E) = O(E + V \log V)
\]</span></p>
</section>
<section id="try-it-yourself-21" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-21">Try It Yourself</h4>
<ol type="1">
<li>Build a dense graph (e.g.&nbsp;<span class="math inline">\(V=1000, E \approx V^2\)</span>).</li>
<li>Compare runtimes with binary heap version.</li>
<li>Visualize priority queue operations.</li>
<li>Implement <code>decrease-key</code> manually for insight.</li>
<li>Explore Johnson’s algorithm using this version.</li>
</ol>
</section>
<section id="test-cases-21" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-21">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Shortest Paths from 0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain</td>
<td>0→1(1), 1→2(2), 2→3(3)</td>
<td>[0, 1, 3, 6]</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td>0→1(2), 1→2(2), 0→2(5)</td>
<td>[0, 2, 4]</td>
</tr>
<tr class="odd">
<td>Dense</td>
<td>All pairs with small weights</td>
<td>Works efficiently</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-21" class="level4">
<h4 class="anchored" data-anchor-id="complexity-21">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E + V \log V)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Works only if: <span class="math inline">\(w(u, v) \ge 0\)</span></li>
</ul>
<p>Dijkstra (Fibonacci Heap) shows how data structure choice transforms an algorithm, the same idea, made sharper through careful engineering of priority operations.</p>
</section>
</section>
<section id="bellmanford" class="level3">
<h3 class="anchored" data-anchor-id="bellmanford">323 Bellman–Ford</h3>
<p>The Bellman–Ford algorithm solves the single-source shortest path problem for graphs that may contain negative edge weights. Unlike Dijkstra’s algorithm, it does not rely on greedy selection and can handle edges with <span class="math inline">\(w(u, v) &lt; 0\)</span>, as long as there are no negative-weight cycles reachable from the source.</p>
<p>It systematically relaxes every edge multiple times, ensuring all paths up to length <span class="math inline">\(V-1\)</span> are considered.</p>
<section id="what-problem-are-we-solving-22" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-22">What Problem Are We Solving?</h4>
<p>We want to compute shortest paths from a source <span class="math inline">\(s\)</span> in a weighted directed graph that may include negative weights.</p>
<p>Given <span class="math inline">\(G = (V, E, w)\)</span>, find for all <span class="math inline">\(v \in V\)</span>:</p>
<p><span class="math display">\[
\text{dist}[v] = \min_{\text{path } s \to v} \sum_{(u,v) \in \text{path}} w(u,v)
\]</span></p>
<p>If a negative-weight cycle is reachable from <span class="math inline">\(s\)</span>, the shortest path is undefined (it can be reduced indefinitely). Bellman–Ford detects this situation explicitly.</p>
</section>
<section id="how-does-it-work-plain-language-22" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-22">How Does It Work (Plain Language)?</h4>
<p>Bellman–Ford uses edge relaxation repeatedly.</p>
<ol type="1">
<li>Initialize <span class="math inline">\(\text{dist}[s] = 0\)</span>, others <span class="math inline">\(\infty\)</span>.</li>
<li>Repeat <span class="math inline">\(V - 1\)</span> times: For every edge <span class="math inline">\((u, v)\)</span>: <span class="math display">\[
\text{if } \text{dist}[u] + w(u, v) &lt; \text{dist}[v], \text{ then update } \text{dist}[v]
\]</span></li>
<li>After <span class="math inline">\(V - 1\)</span> passes, all shortest paths are settled.</li>
<li>Perform one more pass: if any edge can still relax, a negative-weight cycle exists.</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Iteration</th>
<th>Updated Vertices</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Neighbors of source</td>
<td>First layer</td>
</tr>
<tr class="even">
<td>2</td>
<td>Next layer</td>
<td>Propagate</td>
</tr>
<tr class="odd">
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="even">
<td><span class="math inline">\(V-1\)</span></td>
<td>All shortest paths stabilized</td>
<td>Done</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-c-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> u<span class="op">,</span> v<span class="op">,</span> w<span class="op">;</span> <span class="op">}</span> Edge<span class="op">;</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>Edge edges<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dist<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V<span class="op">,</span> E<span class="op">,</span> s<span class="op">;</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter vertices, edges, source: "</span><span class="op">);</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>V<span class="op">,</span> <span class="op">&amp;</span>E<span class="op">,</span> <span class="op">&amp;</span>s<span class="op">);</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter edges (u v w):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> E<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>edges<span class="op">[</span>i<span class="op">].</span>u<span class="op">,</span> <span class="op">&amp;</span>edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">,</span> <span class="op">&amp;</span>edges<span class="op">[</span>i<span class="op">].</span>w<span class="op">);</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> E<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> edges<span class="op">[</span>j<span class="op">].</span>u<span class="op">,</span> v <span class="op">=</span> edges<span class="op">[</span>j<span class="op">].</span>v<span class="op">,</span> w <span class="op">=</span> edges<span class="op">[</span>j<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">!=</span> INF <span class="op">&amp;&amp;</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w <span class="op">&lt;</span> dist<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>                dist<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w<span class="op">;</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> E<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> edges<span class="op">[</span>j<span class="op">].</span>u<span class="op">,</span> v <span class="op">=</span> edges<span class="op">[</span>j<span class="op">].</span>v<span class="op">,</span> w <span class="op">=</span> edges<span class="op">[</span>j<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">!=</span> INF <span class="op">&amp;&amp;</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w <span class="op">&lt;</span> dist<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Negative cycle detected</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Vertex</span><span class="sc">\t</span><span class="st">Distance</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\t%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> dist<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Readable Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bellman_ford(V, edges, src):</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Detect negative cycle</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Negative cycle detected"</span>)</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">6</span>), (<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">7</span>), (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">8</span>), (<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>),</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>         (<span class="dv">1</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">4</span>), (<span class="dv">2</span>, <span class="dv">3</span>, <span class="op">-</span><span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">9</span>), (<span class="dv">3</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>),</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>         (<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">7</span>)]</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(bellman_ford(<span class="dv">5</span>, edges, <span class="dv">0</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-22" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-22">Why It Matters</h4>
<ul>
<li>Works with negative weights</li>
<li>Detects negative-weight cycles</li>
<li>Simpler logic, easier to prove correctness</li>
<li>Used in currency arbitrage, dynamic programming, policy evaluation</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-22" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-22">A Gentle Proof (Why It Works)</h4>
<p>A shortest path has at most <span class="math inline">\(V-1\)</span> edges (a path longer than that must contain a cycle). Each iteration ensures all paths up to that length are relaxed. Thus after <span class="math inline">\(V-1\)</span> rounds, all shortest paths are found.</p>
<p>The <span class="math inline">\((V)\)</span>-th round detects further improvement, indicating a negative cycle.</p>
<p>Formally, after iteration <span class="math inline">\(k\)</span>, <span class="math inline">\(\text{dist}[v]\)</span> is the length of the shortest path from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span> using at most <span class="math inline">\(k\)</span> edges.</p>
</section>
<section id="try-it-yourself-22" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-22">Try It Yourself</h4>
<ol type="1">
<li>Run on graphs with negative weights.</li>
<li>Add a negative cycle and observe detection.</li>
<li>Compare results with Dijkstra (fails with negative edges).</li>
<li>Visualize relaxation per iteration.</li>
<li>Use it to detect arbitrage in currency exchange graphs.</li>
</ol>
</section>
<section id="test-cases-22" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-22">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Shortest Distances</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain</td>
<td>0→1(5), 1→2(-2)</td>
<td>[0, 5, 3]</td>
</tr>
<tr class="even">
<td>Negative edge</td>
<td>0→1(4), 0→2(5), 1→2(-10)</td>
<td>[0, 4, -6]</td>
</tr>
<tr class="odd">
<td>Negative cycle</td>
<td>0→1(1), 1→2(-2), 2→0(-1)</td>
<td>Detected</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-22" class="level4">
<h4 class="anchored" data-anchor-id="complexity-22">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(VE)\)</span></li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
<li>Handles: <span class="math inline">\(w(u, v) \ge -\infty\)</span>, no negative cycles</li>
</ul>
<p>Bellman–Ford is the steady walker of shortest path algorithms, slower than Dijkstra, but unshaken by negative edges and always alert to cycles that break the rules.</p>
</section>
</section>
<section id="spfa-queue-optimization" class="level3">
<h3 class="anchored" data-anchor-id="spfa-queue-optimization">324 SPFA (Queue Optimization)</h3>
<p>The Shortest Path Faster Algorithm (SPFA) is an optimized implementation of Bellman–Ford that uses a queue to avoid unnecessary relaxations. Instead of relaxing all edges in every iteration, SPFA only processes vertices whose distances were recently updated, often resulting in much faster average performance, especially in sparse graphs or those without negative cycles.</p>
<p>In the worst case, it still runs in <span class="math inline">\(O(VE)\)</span>, but typical performance is closer to <span class="math inline">\(O(E)\)</span>.</p>
<section id="what-problem-are-we-solving-23" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-23">What Problem Are We Solving?</h4>
<p>We want to find single-source shortest paths in a graph that may contain negative weights, but no negative-weight cycles.</p>
<p>Given a directed graph <span class="math inline">\(G = (V, E, w)\)</span> with edge weights <span class="math inline">\(w(u, v)\)</span> possibly negative, we compute:</p>
<p><span class="math display">\[
\text{dist}[v] = \min_{\text{path } s \to v} \sum_{(u, v) \in \text{path}} w(u, v)
\]</span></p>
<p>Bellman–Ford’s <span class="math inline">\(V-1\)</span> rounds of edge relaxation can be wasteful; SPFA avoids rechecking edges from vertices that haven’t improved.</p>
</section>
<section id="how-does-it-work-plain-language-23" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-23">How Does It Work (Plain Language)?</h4>
<p>SPFA keeps a queue of vertices whose outgoing edges might lead to relaxation. Each time a vertex’s distance improves, it’s enqueued for processing.</p>
<ol type="1">
<li><p>Initialize <span class="math inline">\(\text{dist}[s] = 0\)</span>, others <span class="math inline">\(\infty\)</span>.</p></li>
<li><p>Push <span class="math inline">\(s\)</span> into a queue.</p></li>
<li><p>While the queue is not empty:</p>
<ul>
<li>Pop vertex <span class="math inline">\(u\)</span>.</li>
<li>For each <span class="math inline">\((u, v)\)</span>: <span class="math display">\[
\text{if } \text{dist}[u] + w(u, v) &lt; \text{dist}[v], \text{ then update } \text{dist}[v]
\]</span></li>
<li>If <span class="math inline">\(\text{dist}[v]\)</span> changed and <span class="math inline">\(v\)</span> is not in queue, enqueue <span class="math inline">\(v\)</span>.</li>
</ul></li>
<li><p>Continue until queue is empty.</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Queue</th>
<th>Operation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[s]</td>
<td>Start</td>
</tr>
<tr class="even">
<td>2</td>
<td>Pop u, relax neighbors</td>
<td>Push improved vertices</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Repeat</td>
<td>Until no more improvements</td>
</tr>
</tbody>
</table>
<p>SPFA uses a lazy relaxation strategy, guided by actual updates.</p>
</section>
<section id="tiny-code-c-example-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example-1">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> v<span class="op">,</span> w<span class="op">;</span> <span class="op">}</span> Edge<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>Edge graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> deg<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> queue<span class="op">[</span>MAX<span class="op">],</span> front <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> rear <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> in_queue<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dist<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> enqueue<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    queue<span class="op">[</span>rear<span class="op">++]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    in_queue<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dequeue<span class="op">()</span> <span class="op">{</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> queue<span class="op">[</span>front<span class="op">++];</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>    in_queue<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V<span class="op">,</span> E<span class="op">,</span> s<span class="op">;</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter vertices, edges, source: "</span><span class="op">);</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>V<span class="op">,</span> <span class="op">&amp;</span>E<span class="op">,</span> <span class="op">&amp;</span>s<span class="op">);</span></span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> deg<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter edges (u v w):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> E<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span> v<span class="op">,</span> w<span class="op">;</span></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">,</span> <span class="op">&amp;</span>v<span class="op">,</span> <span class="op">&amp;</span>w<span class="op">);</span></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">][</span>deg<span class="op">[</span>u<span class="op">]].</span>v <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">][</span>deg<span class="op">[</span>u<span class="op">]].</span>w <span class="op">=</span> w<span class="op">;</span></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>        deg<span class="op">[</span>u<span class="op">]++;</span></span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>    enqueue<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>front <span class="op">&lt;</span> rear<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> dequeue<span class="op">();</span></span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> graph<span class="op">[</span>u<span class="op">][</span>i<span class="op">].</span>v<span class="op">,</span> w <span class="op">=</span> graph<span class="op">[</span>u<span class="op">][</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w <span class="op">&lt;</span> dist<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb43-50"><a href="#cb43-50" aria-hidden="true" tabindex="-1"></a>                dist<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w<span class="op">;</span></span>
<span id="cb43-51"><a href="#cb43-51" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>in_queue<span class="op">[</span>v<span class="op">])</span> enqueue<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb43-52"><a href="#cb43-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb43-53"><a href="#cb43-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-54"><a href="#cb43-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-55"><a href="#cb43-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-56"><a href="#cb43-56" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Vertex</span><span class="sc">\t</span><span class="st">Distance</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb43-57"><a href="#cb43-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb43-58"><a href="#cb43-58" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\t%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> dist<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb43-59"><a href="#cb43-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Queue-Based Implementation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spfa(V, edges, src):</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    in_queue <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> V</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque([src])</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    in_queue[src] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> q.popleft()</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>        in_queue[u] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> in_queue[v]:</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>                    q.append(v)</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>                    in_queue[v] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>)]</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(spfa(<span class="dv">4</span>, edges, <span class="dv">0</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-23" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-23">Why It Matters</h4>
<ul>
<li>Practical improvement over Bellman–Ford</li>
<li>Efficient for sparse and nearly acyclic graphs</li>
<li>Can handle negative weights</li>
<li>Used in network optimization, real-time routing, flow systems</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-23" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-23">A Gentle Proof (Why It Works)</h4>
<p>Each vertex enters the queue when its distance improves. At most <span class="math inline">\(V-1\)</span> improvements per vertex (no shorter path with more edges). Thus, every relaxation converges to the same fixed point as Bellman–Ford.</p>
<p>SPFA is an asynchronous relaxation method:</p>
<ul>
<li>Still guarantees correctness under nonnegative cycles</li>
<li>Detects negative cycles if a vertex is enqueued <span class="math inline">\(\ge V\)</span> times</li>
</ul>
<p>To check for negative cycles:</p>
<ul>
<li>Maintain a <code>count[v]</code> of relaxations</li>
<li>If <code>count[v] &gt; V</code>, report a cycle</li>
</ul>
</section>
<section id="try-it-yourself-23" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-23">Try It Yourself</h4>
<ol type="1">
<li>Test on graphs with negative edges.</li>
<li>Compare runtime with Bellman–Ford.</li>
<li>Add negative cycle detection.</li>
<li>Try both sparse and dense graphs.</li>
<li>Measure how queue length varies during execution.</li>
</ol>
</section>
<section id="test-cases-23" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-23">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple</td>
<td>0→1(2), 0→2(4), 1→2(-1), 2→3(2)</td>
<td>[0, 2, 1, 3]</td>
</tr>
<tr class="even">
<td>Negative edge</td>
<td>0→1(5), 1→2(-3)</td>
<td>[0, 5, 2]</td>
</tr>
<tr class="odd">
<td>Cycle</td>
<td>0→1(1), 1→2(-2), 2→0(1)</td>
<td>Detect</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-23" class="level4">
<h4 class="anchored" data-anchor-id="complexity-23">Complexity</h4>
<ul>
<li>Average: <span class="math inline">\(O(E)\)</span></li>
<li>Worst case: <span class="math inline">\(O(VE)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>SPFA (Queue Optimization) is the agile Bellman–Ford, reacting only when change is needed, converging faster in practice while preserving the same correctness guarantees.</p>
</section>
</section>
<section id="a-search" class="level3">
<h3 class="anchored" data-anchor-id="a-search">325 A* Search</h3>
<p>The A* (A-star) algorithm combines Dijkstra’s shortest path with best-first search, guided by a heuristic function. It efficiently finds the shortest path from a start node to a goal node by always expanding the vertex that seems closest to the goal, according to the estimate:</p>
<p><span class="math display">\[
f(v) = g(v) + h(v)
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(g(v)\)</span> = cost from start to <span class="math inline">\(v\)</span> (known),</li>
<li><span class="math inline">\(h(v)\)</span> = heuristic estimate from <span class="math inline">\(v\)</span> to goal (guessed),</li>
<li><span class="math inline">\(f(v)\)</span> = total estimated cost through <span class="math inline">\(v\)</span>.</li>
</ul>
<p>When the heuristic is admissible (never overestimates), A* guarantees optimality.</p>
<section id="what-problem-are-we-solving-24" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-24">What Problem Are We Solving?</h4>
<p>We want to find the shortest path from a source <span class="math inline">\(s\)</span> to a target <span class="math inline">\(t\)</span> in a weighted graph (often spatial), using additional knowledge about the goal to guide the search.</p>
<p>Given <span class="math inline">\(G = (V, E, w)\)</span> and a heuristic <span class="math inline">\(h(v)\)</span>, the task is to minimize:</p>
<p><span class="math display">\[
\text{cost}(s, t) = \min_{\text{path } s \to t} \sum_{(u, v) \in \text{path}} w(u, v)
\]</span></p>
<p>Applications:</p>
<ul>
<li>Pathfinding (games, robotics, navigation)</li>
<li>Planning systems (AI, logistics)</li>
<li>Grid and map searches</li>
<li>State-space exploration</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-24" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-24">How Does It Work (Plain Language)?</h4>
<p>A* behaves like Dijkstra’s algorithm, but instead of expanding the closest node to the start (<span class="math inline">\(g\)</span>), it expands the one with smallest estimated total cost (<span class="math inline">\(f = g + h\)</span>).</p>
<ol type="1">
<li><p>Initialize all distances: <code>g[start] = 0</code>, others <span class="math inline">\(\infty\)</span>.</p></li>
<li><p>Compute <code>f[start] = h[start]</code>.</p></li>
<li><p>Push <code>(f, node)</code> into a priority queue.</p></li>
<li><p>While queue not empty:</p>
<ul>
<li>Pop node <span class="math inline">\(u\)</span> with smallest <span class="math inline">\(f(u)\)</span>.</li>
<li>If <span class="math inline">\(u = \text{goal}\)</span>, stop, path found.</li>
<li>For each neighbor <span class="math inline">\(v\)</span>: <span class="math display">\[
g'(v) = g(u) + w(u, v)
\]</span> If <span class="math inline">\(g'(v) &lt; g(v)\)</span>, update: <span class="math display">\[
g(v) = g'(v), \quad f(v) = g(v) + h(v)
\]</span> Push <span class="math inline">\(v\)</span> into the queue.</li>
</ul></li>
<li><p>Reconstruct path using parent pointers.</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Node</th>
<th><span class="math inline">\(g(v)\)</span></th>
<th><span class="math inline">\(h(v)\)</span></th>
<th><span class="math inline">\(f(v) = g + h\)</span></th>
<th>Expanded?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>start</td>
<td>0</td>
<td>heuristic</td>
<td>heuristic</td>
<td>✅</td>
</tr>
<tr class="even">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The heuristic guides exploration, focusing on promising routes.</p>
</section>
<section id="tiny-code-python-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example">Tiny Code (Python Example)</h4>
<p>Grid-based A* (Manhattan heuristic):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heuristic(a, b):</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">abs</span>(a[<span class="dv">0</span>] <span class="op">-</span> b[<span class="dv">0</span>]) <span class="op">+</span> <span class="bu">abs</span>(a[<span class="dv">1</span>] <span class="op">-</span> b[<span class="dv">1</span>])</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> astar(grid, start, goal):</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> {start: <span class="dv">0</span>}</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> {start: heuristic(start, goal)}</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(f[start], start)]</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> {start: <span class="va">None</span>}</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>        _, current <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current <span class="op">==</span> goal:</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>            path <span class="op">=</span> []</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> current:</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>                path.append(current)</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>                current <span class="op">=</span> parent[current]</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>        visited.add(current)</span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> current</span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx, dy <span class="kw">in</span> [(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>)]:</span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>            nx, ny <span class="op">=</span> x <span class="op">+</span> dx, y <span class="op">+</span> dy</span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>            neighbor <span class="op">=</span> (nx, ny)</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> cols <span class="kw">and</span> grid[nx][ny] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>                tentative <span class="op">=</span> g[current] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> tentative <span class="op">&lt;</span> g.get(neighbor, <span class="bu">float</span>(<span class="st">'inf'</span>)):</span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>                    g[neighbor] <span class="op">=</span> tentative</span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a>                    f[neighbor] <span class="op">=</span> tentative <span class="op">+</span> heuristic(neighbor, goal)</span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>                    parent[neighbor] <span class="op">=</span> current</span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a>                    heapq.heappush(pq, (f[neighbor], neighbor))</span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> [</span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>],</span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>],</span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> (<span class="dv">0</span>,<span class="dv">0</span>)</span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true" tabindex="-1"></a>goal <span class="op">=</span> (<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> astar(grid, start, goal)</span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(path)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-24" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-24">Why It Matters</h4>
<ul>
<li>Faster than Dijkstra for goal-directed search</li>
<li>Optimal if heuristic is admissible (<span class="math inline">\(h(v) \le \text{true cost}\)</span>)</li>
<li>Efficient if heuristic is also consistent (triangle inequality)</li>
<li>Widely used in AI, robotics, navigation, route planning</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-24" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-24">A Gentle Proof (Why It Works)</h4>
<p>If the heuristic <span class="math inline">\(h(v)\)</span> never overestimates the true remaining cost:</p>
<p><span class="math display">\[
h(v) \le \text{cost}(v, t)
\]</span></p>
<p>then <span class="math inline">\(f(v) = g(v) + h(v)\)</span> is always a lower bound on the true cost. Therefore, when the goal is extracted (smallest <span class="math inline">\(f\)</span>), the path is guaranteed optimal.</p>
<p>If <span class="math inline">\(h\)</span> also satisfies consistency: <span class="math display">\[
h(u) \le w(u, v) + h(v)
\]</span> then <span class="math inline">\(f\)</span>-values are nondecreasing, and each node is expanded only once.</p>
</section>
<section id="try-it-yourself-24" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-24">Try It Yourself</h4>
<ol type="1">
<li>Implement A* on a grid with obstacles.</li>
<li>Experiment with different heuristics (Manhattan, Euclidean).</li>
<li>Set <span class="math inline">\(h(v) = 0\)</span> → becomes Dijkstra.</li>
<li>Set <span class="math inline">\(h(v) = \text{true distance}\)</span> → ideal search.</li>
<li>Try inadmissible <span class="math inline">\(h\)</span> → faster but possibly suboptimal.</li>
</ol>
</section>
<section id="test-cases-24" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-24">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph Type</th>
<th>Heuristic</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Grid (4×4)</td>
<td>Manhattan</td>
<td>Shortest path found</td>
</tr>
<tr class="even">
<td>Weighted</td>
<td>Euclidean</td>
<td>Optimal route</td>
</tr>
<tr class="odd">
<td>All <span class="math inline">\(h=0\)</span></td>
<td>None</td>
<td>Becomes Dijkstra</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-24" class="level4">
<h4 class="anchored" data-anchor-id="complexity-24">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log V)\)</span> (depends on heuristic)</li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
<li>Optimal if: <span class="math inline">\(h\)</span> admissible</li>
<li>Complete if: finite branching factor</li>
</ul>
<p>A* Search is Dijkstra with foresight, driven not just by cost so far, but by an informed guess of the journey ahead.</p>
</section>
</section>
<section id="floydwarshall" class="level3">
<h3 class="anchored" data-anchor-id="floydwarshall">326 Floyd–Warshall</h3>
<p>The Floyd–Warshall algorithm is a dynamic programming approach for computing all-pairs shortest paths (APSP) in a weighted directed graph. It iteratively refines the shortest path estimates between every pair of vertices by allowing intermediate vertices step by step.</p>
<p>It works even with negative weights, as long as there are no negative cycles.</p>
<section id="what-problem-are-we-solving-25" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-25">What Problem Are We Solving?</h4>
<p>We want to compute:</p>
<p><span class="math display">\[
\text{dist}(u, v) = \min_{\text{paths } u \to v} \sum_{(x, y) \in \text{path}} w(x, y)
\]</span></p>
<p>for all pairs <span class="math inline">\((u, v)\)</span> in a graph <span class="math inline">\(G = (V, E, w)\)</span>.</p>
<p>We allow negative weights but no negative cycles. It’s particularly useful when:</p>
<ul>
<li>We need all-pairs shortest paths.</li>
<li>The graph is dense (<span class="math inline">\(E \approx V^2\)</span>).</li>
<li>We want transitive closure or reachability (set <span class="math inline">\(w(u, v) = 1\)</span>).</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-25" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-25">How Does It Work (Plain Language)?</h4>
<p>We progressively allow each vertex as a possible intermediate waypoint. Initially, the shortest path from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> is just the direct edge. Then, for each vertex <span class="math inline">\(k\)</span>, we check if a path through <span class="math inline">\(k\)</span> improves the distance.</p>
<p>The recurrence relation:</p>
<p><span class="math display">\[
d_k(i, j) = \min \big( d_{k-1}(i, j),; d_{k-1}(i, k) + d_{k-1}(k, j) \big)
\]</span></p>
<p>Implementation uses in-place updates:</p>
<p><span class="math display">\[
\text{dist}[i][j] = \min(\text{dist}[i][j],; \text{dist}[i][k] + \text{dist}[k][j])
\]</span></p>
<p>Three nested loops:</p>
<ol type="1">
<li><code>k</code> (intermediate)</li>
<li><code>i</code> (source)</li>
<li><code>j</code> (destination)</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>k</th>
<th>i</th>
<th>j</th>
<th>Update</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>all</td>
<td>all</td>
<td>consider vertex 0 as waypoint</td>
</tr>
<tr class="even">
<td>1</td>
<td>all</td>
<td>all</td>
<td>consider vertex 1 as waypoint</td>
</tr>
<tr class="odd">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>After <span class="math inline">\(V\)</span> iterations, all shortest paths are finalized.</p>
</section>
<section id="tiny-code-c-example-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example-2">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb46"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">100</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter number of vertices: "</span><span class="op">);</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dist<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Enter adjacency matrix (INF=9999, 0 for self):</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>dist<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> k<span class="op">++)</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dist<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;</span> dist<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>                    dist<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dist<span class="op">[</span>k<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"All-Pairs Shortest Distances:</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"</span><span class="sc">%8d</span><span class="st"> "</span><span class="op">,</span> dist<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python Version</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> floyd_warshall(graph):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [row[:] <span class="cf">for</span> row <span class="kw">in</span> graph]</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dist[i][k] <span class="op">+</span> dist[k][j] <span class="op">&lt;</span> dist[i][j]:</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>                    dist[i][j] <span class="op">=</span> dist[i][k] <span class="op">+</span> dist[k][j]</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> [</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">3</span>, INF, <span class="dv">7</span>],</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">8</span>, <span class="dv">0</span>, <span class="dv">2</span>, INF],</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">5</span>, INF, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">2</span>, INF, INF, <span class="dv">0</span>]</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> floyd_warshall(graph)</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> res:</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(row)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-25" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-25">Why It Matters</h4>
<ul>
<li>Computes all-pairs shortest paths in one pass</li>
<li>Works with negative weights</li>
<li>Detects negative cycles if <span class="math inline">\(\text{dist}[i][i] &lt; 0\)</span></li>
<li>Useful for transitive closure, routing tables, graph condensation</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-25" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-25">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(d_k(i, j)\)</span> be the shortest path from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> using only intermediate vertices from <span class="math inline">\({1, 2, \dots, k}\)</span>.</p>
<p>Base case (<span class="math inline">\(k=0\)</span>): <span class="math inline">\(d_0(i, j) = w(i, j)\)</span>, the direct edge.</p>
<p>Inductive step: For each <span class="math inline">\(k\)</span>, either the shortest path avoids <span class="math inline">\(k\)</span> or goes through <span class="math inline">\(k\)</span>. Thus:</p>
<p><span class="math display">\[
d_k(i, j) = \min \big(d_{k-1}(i, j),; d_{k-1}(i, k) + d_{k-1}(k, j)\big)
\]</span></p>
<p>By induction, after <span class="math inline">\(V\)</span> iterations, all shortest paths are covered.</p>
</section>
<section id="try-it-yourself-25" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-25">Try It Yourself</h4>
<ol type="1">
<li>Build a 4×4 weighted matrix.</li>
<li>Introduce a negative edge (but no cycle).</li>
<li>Check results after each iteration.</li>
<li>Detect cycle: observe if <span class="math inline">\(\text{dist}[i][i] &lt; 0\)</span>.</li>
<li>Use it to compute reachability (replace INF with 0/1).</li>
</ol>
</section>
<section id="test-cases-25" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-25">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 50%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Distances</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple</td>
<td>0→1(3), 0→3(7), 1→2(2), 2→0(5), 3→0(2)</td>
<td>All-pairs paths computed</td>
</tr>
<tr class="even">
<td>Negative edge</td>
<td>0→1(1), 1→2(-2), 2→0(4)</td>
<td>Valid shortest paths</td>
</tr>
<tr class="odd">
<td>Negative cycle</td>
<td>0→1(1), 1→2(-2), 2→0(-1)</td>
<td><span class="math inline">\(\text{dist}[0][0] &lt; 0\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-25" class="level4">
<h4 class="anchored" data-anchor-id="complexity-25">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V^3)\)</span></li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
<li>Detects: negative cycles if <span class="math inline">\(\text{dist}[i][i] &lt; 0\)</span></li>
</ul>
<p>Floyd–Warshall is the complete memory of a graph, every distance, every route, all computed through careful iteration over all possible intermediates.</p>
</section>
</section>
<section id="johnsons-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="johnsons-algorithm">327 Johnson’s Algorithm</h3>
<p>Johnson’s Algorithm efficiently computes all-pairs shortest paths (APSP) in a sparse weighted directed graph, even when negative weights are present (but no negative cycles). It cleverly combines Bellman–Ford and Dijkstra, using reweighting to eliminate negative edges while preserving shortest path relationships.</p>
<p>The result: <span class="math display">\[
O(VE + V^2 \log V)
\]</span> which is far more efficient than Floyd–Warshall (<span class="math inline">\(O(V^3)\)</span>) for sparse graphs.</p>
<section id="what-problem-are-we-solving-26" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-26">What Problem Are We Solving?</h4>
<p>We need shortest paths between every pair of vertices, even if some edges have negative weights. Directly running Dijkstra fails with negative edges, and running Bellman–Ford for each vertex would cost <span class="math inline">\(O(V^2E)\)</span>.</p>
<p>Johnson’s approach fixes this by reweighting edges to make them nonnegative, then applying Dijkstra from every vertex.</p>
<p>Given a weighted directed graph <span class="math inline">\(G = (V, E, w)\)</span>:</p>
<p><span class="math display">\[
w(u, v) \in \mathbb{R}, \quad \text{no negative cycles.}
\]</span></p>
<p>We seek:</p>
<p><span class="math display">\[
\text{dist}(u, v) = \min_{\text{path } u \to v} \sum w(x, y)
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-26" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-26">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Add a new vertex <span class="math inline">\(s\)</span>, connect it to every other vertex with edge weight <span class="math inline">\(0\)</span>.</p></li>
<li><p>Run Bellman–Ford from <span class="math inline">\(s\)</span> to compute potential values <span class="math inline">\(h(v)\)</span>: <span class="math display">\[
h(v) = \text{dist}_s(v)
\]</span></p></li>
<li><p>Reweight edges: <span class="math display">\[
w'(u, v) = w(u, v) + h(u) - h(v)
\]</span> This ensures all <span class="math inline">\(w'(u, v) \ge 0\)</span>.</p></li>
<li><p>Remove <span class="math inline">\(s\)</span>.</p></li>
<li><p>For each vertex <span class="math inline">\(u\)</span>, run Dijkstra on the reweighted graph <span class="math inline">\(w'\)</span>.</p></li>
<li><p>Recover original distances: <span class="math display">\[
\text{dist}(u, v) = \text{dist}'(u, v) + h(v) - h(u)
\]</span></p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Add source <span class="math inline">\(s\)</span></td>
<td>Connect to all</td>
</tr>
<tr class="even">
<td>2</td>
<td>Bellman–Ford</td>
<td>Compute potentials</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Reweight edges</td>
<td>All nonnegative</td>
</tr>
<tr class="even">
<td>4</td>
<td>Run Dijkstra</td>
<td><span class="math inline">\(O(VE + V^2 \log V)\)</span></td>
</tr>
<tr class="odd">
<td>5</td>
<td>Restore distances</td>
<td>Adjust using <span class="math inline">\(h\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-1">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bellman_ford(V, edges, s):</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Negative cycle detected"</span>)</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra(V, adj, src):</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, src)]</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&gt;</span> dist[u]:</span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> adj[u]:</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (dist[v], v))</span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> johnson(V, edges):</span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: add new source s</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> V</span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>    new_edges <span class="op">=</span> edges <span class="op">+</span> [(s, v, <span class="dv">0</span>) <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> bellman_ford(V <span class="op">+</span> <span class="dv">1</span>, new_edges, s)</span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: reweight edges</span></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>    adj <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>        adj[u].append((v, w <span class="op">+</span> h[u] <span class="op">-</span> h[v]))</span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: run Dijkstra from each vertex</span></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>    dist_matrix <span class="op">=</span> [[<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(V):</span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> dijkstra(V, adj, u)</span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(V):</span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>            dist_matrix[u][v] <span class="op">=</span> d[v] <span class="op">+</span> h[v] <span class="op">-</span> h[u]</span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist_matrix</span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb48-49"><a href="#cb48-49" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb48-50"><a href="#cb48-50" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">2</span>),</span>
<span id="cb48-51"><a href="#cb48-51" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">4</span>),</span>
<span id="cb48-52"><a href="#cb48-52" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>),</span>
<span id="cb48-53"><a href="#cb48-53" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">7</span>)</span>
<span id="cb48-54"><a href="#cb48-54" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb48-55"><a href="#cb48-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-56"><a href="#cb48-56" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> johnson(<span class="dv">4</span>, edges)</span>
<span id="cb48-57"><a href="#cb48-57" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> res:</span>
<span id="cb48-58"><a href="#cb48-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(row)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-26" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-26">Why It Matters</h4>
<ul>
<li>Works with negative weights</li>
<li>Combines Bellman–Ford’s flexibility with Dijkstra’s speed</li>
<li>Much faster than Floyd–Warshall for sparse graphs</li>
<li>Used in routing, dependency graphs, and AI navigation</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-26" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-26">A Gentle Proof (Why It Works)</h4>
<p>Reweighting preserves shortest path order:</p>
<p>For any path <span class="math inline">\(P = (v_0, v_1, \dots, v_k)\)</span>:</p>
<p><span class="math display">\[
w'(P) = w(P) + h(v_0) - h(v_k)
\]</span></p>
<p>Therefore:</p>
<p><span class="math display">\[
w'(u, v) &lt; w'(u, x) \iff w(u, v) &lt; w(u, x)
\]</span></p>
<p>All shortest paths in <span class="math inline">\(w\)</span> are shortest in <span class="math inline">\(w'\)</span>, but now all weights are nonnegative, allowing Dijkstra.</p>
<p>Finally, distances are restored:</p>
<p><span class="math display">\[
\text{dist}(u, v) = \text{dist}'(u, v) + h(v) - h(u)
\]</span></p>
</section>
<section id="try-it-yourself-26" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-26">Try It Yourself</h4>
<ol type="1">
<li>Add negative-weight edges (no cycles) and compare results with Floyd–Warshall.</li>
<li>Visualize reweighting: show <span class="math inline">\(w'(u, v)\)</span>.</li>
<li>Test on sparse vs dense graphs.</li>
<li>Introduce negative cycle to trigger detection.</li>
<li>Replace Dijkstra with Fibonacci heap for <span class="math inline">\(O(VE + V^2 \log V)\)</span>.</li>
</ol>
</section>
<section id="test-cases-26" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-26">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>0→1(1), 1→2(-2), 2→0(4)</td>
<td>All-pairs distances</td>
</tr>
<tr class="even">
<td>Negative Edge</td>
<td>0→1(-1), 1→2(2)</td>
<td>Correct</td>
</tr>
<tr class="odd">
<td>Negative Cycle</td>
<td>0→1(-2), 1→0(-3)</td>
<td>Detected</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-26" class="level4">
<h4 class="anchored" data-anchor-id="complexity-26">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(VE + V^2 \log V)\)</span></li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
<li>Works if: no negative cycles</li>
</ul>
<p>Johnson’s Algorithm is the harmonizer of shortest paths, reweighting the melody so every note becomes nonnegative, letting Dijkstra play across the entire graph with speed and precision.</p>
</section>
</section>
<section id="bfs" class="level3">
<h3 class="anchored" data-anchor-id="bfs">328 0–1 BFS</h3>
<p>The 0–1 BFS algorithm is a specialized shortest path technique for graphs where edge weights are only 0 or 1. It uses a deque (double-ended queue) instead of a priority queue, allowing efficient relaxation in linear time.</p>
<p>By pushing 0-weight edges to the front and 1-weight edges to the back, the algorithm maintains an always-correct frontier, effectively simulating Dijkstra’s behavior in <span class="math inline">\(O(V + E)\)</span> time.</p>
<section id="what-problem-are-we-solving-27" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-27">What Problem Are We Solving?</h4>
<p>We want to compute single-source shortest paths in a directed or undirected graph with edge weights in <span class="math inline">\({0, 1}\)</span>:</p>
<p><span class="math display">\[
w(u, v) \in {0, 1}
\]</span></p>
<p>We need:</p>
<p><span class="math display">\[
\text{dist}[v] = \min_{\text{path } s \to v} \sum_{(u, v) \in \text{path}} w(u, v)
\]</span></p>
<p>Typical applications:</p>
<ul>
<li>Unweighted graphs with special transitions (e.g.&nbsp;toggles, switches)</li>
<li>State-space searches with free vs costly actions</li>
<li>Binary grids, bitmask problems, or minimum operations graphs</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-27" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-27">How Does It Work (Plain Language)?</h4>
<p>0–1 BFS replaces the priority queue in Dijkstra’s algorithm with a deque, exploiting the fact that edge weights are only 0 or 1.</p>
<ol type="1">
<li><p>Initialize <code>dist[v] = ∞</code> for all <span class="math inline">\(v\)</span>, set <code>dist[s] = 0</code>.</p></li>
<li><p>Push <span class="math inline">\(s\)</span> into deque.</p></li>
<li><p>While deque not empty:</p>
<ul>
<li><p>Pop from front.</p></li>
<li><p>For each neighbor <span class="math inline">\((u, v)\)</span>:</p>
<ul>
<li>If <span class="math inline">\(w(u, v) = 0\)</span> and improves distance, push front.</li>
<li>If <span class="math inline">\(w(u, v) = 1\)</span> and improves distance, push back.</li>
</ul></li>
</ul></li>
</ol>
<p>This ensures vertices are always processed in non-decreasing order of distance, just like Dijkstra.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Edge Type</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(w=0\)</span></td>
<td>push front</td>
<td>process immediately</td>
</tr>
<tr class="even">
<td><span class="math inline">\(w=1\)</span></td>
<td>push back</td>
<td>process later</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-c-example-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example-3">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX </span><span class="dv">1000</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> v<span class="op">,</span> w<span class="op">;</span> <span class="op">}</span> Edge<span class="op">;</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>Edge graph<span class="op">[</span>MAX<span class="op">][</span>MAX<span class="op">];</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> deg<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dist<span class="op">[</span>MAX<span class="op">];</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> deque<span class="op">[</span>MAX <span class="op">*</span> <span class="dv">2</span><span class="op">],</span> front <span class="op">=</span> MAX<span class="op">,</span> back <span class="op">=</span> MAX<span class="op">;</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> push_front<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> deque<span class="op">[--</span>front<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> push_back<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> deque<span class="op">[</span>back<span class="op">++]</span> <span class="op">=</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> pop_front<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> deque<span class="op">[</span>front<span class="op">++];</span> <span class="op">}</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> empty<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> front <span class="op">==</span> back<span class="op">;</span> <span class="op">}</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V<span class="op">,</span> E<span class="op">,</span> s<span class="op">;</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>V<span class="op">,</span> <span class="op">&amp;</span>E<span class="op">,</span> <span class="op">&amp;</span>s<span class="op">);</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> E<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span> v<span class="op">,</span> w<span class="op">;</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">,</span> <span class="op">&amp;</span>v<span class="op">,</span> <span class="op">&amp;</span>w<span class="op">);</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">][</span>deg<span class="op">[</span>u<span class="op">]].</span>v <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">][</span>deg<span class="op">[</span>u<span class="op">]].</span>w <span class="op">=</span> w<span class="op">;</span></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>        deg<span class="op">[</span>u<span class="op">]++;</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>    push_front<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> pop_front<span class="op">();</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> graph<span class="op">[</span>u<span class="op">][</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> w <span class="op">=</span> graph<span class="op">[</span>u<span class="op">][</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w <span class="op">&lt;</span> dist<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>                dist<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w<span class="op">;</span></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>w <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> push_front<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> push_back<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">,</span> dist<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Deque-Based)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zero_one_bfs(V, edges, src):</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    dq <span class="op">=</span> deque([src])</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> dq:</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> dq.popleft()</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> w <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>                    dq.appendleft(v)</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>                    dq.append(v)</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">0</span>)]</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(zero_one_bfs(<span class="dv">4</span>, edges, <span class="dv">0</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-27" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-27">Why It Matters</h4>
<ul>
<li>Linear time for graphs with 0/1 weights</li>
<li>Simpler than Dijkstra, faster in special cases</li>
<li>Works on state-transition graphs (bit flips, BFS + cost)</li>
<li>Common in competitive programming, AI, robotics</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-27" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-27">A Gentle Proof (Why It Works)</h4>
<p>Because all edge weights are either 0 or 1, distances increase by at most 1 each step. The deque ensures that nodes are processed in order of nondecreasing distance:</p>
<ul>
<li>When relaxing a <span class="math inline">\(0\)</span>-edge, we push the vertex to the front (same distance).</li>
<li>When relaxing a <span class="math inline">\(1\)</span>-edge, we push to the back (distance +1).</li>
</ul>
<p>Thus, the deque acts like a monotonic priority queue, guaranteeing correctness equivalent to Dijkstra.</p>
</section>
<section id="try-it-yourself-27" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-27">Try It Yourself</h4>
<ol type="1">
<li>Build a small graph with edges of 0 and 1.</li>
<li>Compare output with Dijkstra’s algorithm.</li>
<li>Visualize deque operations.</li>
<li>Try a grid where moving straight costs 0, turning costs 1.</li>
<li>Measure runtime vs Dijkstra on sparse graphs.</li>
</ol>
</section>
<section id="test-cases-27" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-27">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple</td>
<td>0→1(0), 1→2(1), 0→2(1), 2→3(0)</td>
<td>[0, 0, 1, 1]</td>
</tr>
<tr class="even">
<td>Zero edges</td>
<td>0→1(0), 1→2(0), 2→3(0)</td>
<td>[0, 0, 0, 0]</td>
</tr>
<tr class="odd">
<td>Mixed</td>
<td>0→1(1), 0→2(0), 2→3(1)</td>
<td>[0, 1, 0, 1]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-27" class="level4">
<h4 class="anchored" data-anchor-id="complexity-27">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V + E)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Conditions: <span class="math inline">\(w(u, v) \in {0, 1}\)</span></li>
</ul>
<p>0–1 BFS is the binary Dijkstra, a two-speed traveler that knows when to sprint ahead for free and when to patiently queue for a cost.</p>
</section>
</section>
<section id="dials-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="dials-algorithm">329 Dial’s Algorithm</h3>
<p>Dial’s Algorithm is a variant of Dijkstra’s algorithm optimized for graphs with nonnegative integer weights that are small and bounded. Instead of a heap, it uses an array of buckets, one for each possible distance modulo the maximum edge weight. This yields <span class="math inline">\(O(V + E + C)\)</span> performance, where <span class="math inline">\(C\)</span> is the maximum edge cost.</p>
<p>It’s ideal when edge weights are integers in a small range, such as <span class="math inline">\({0, 1, \dots, C}\)</span>.</p>
<section id="what-problem-are-we-solving-28" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-28">What Problem Are We Solving?</h4>
<p>We want single-source shortest paths in a graph where:</p>
<p><span class="math display">\[
w(u, v) \in {0, 1, 2, \dots, C}, \quad C \text{ small}
\]</span></p>
<p>Given a weighted directed graph <span class="math inline">\(G = (V, E, w)\)</span>, the goal is to compute:</p>
<p><span class="math display">\[
\text{dist}[v] = \min_{\text{path } s \to v} \sum_{(u, v) \in \text{path}} w(u, v)
\]</span></p>
<p>If we know the maximum edge weight <span class="math inline">\(C\)</span>, we can replace a heap with an array of queues, cycling through distances efficiently.</p>
<p>Applications:</p>
<ul>
<li>Network routing with small costs</li>
<li>Grid-based movement with few weight levels</li>
<li>Telecommunication scheduling</li>
<li>Traffic flow problems</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-28" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-28">How Does It Work (Plain Language)?</h4>
<p>Dial’s algorithm groups vertices by their current tentative distance. Instead of a priority queue, it maintains buckets <code>B[0..C]</code>, where each bucket stores vertices with distance congruent modulo <span class="math inline">\((C+1)\)</span>.</p>
<ol type="1">
<li><p>Initialize <span class="math inline">\(\text{dist}[v] = \infty\)</span>; set <span class="math inline">\(\text{dist}[s] = 0\)</span>.</p></li>
<li><p>Place <span class="math inline">\(s\)</span> in <code>B[0]</code>.</p></li>
<li><p>For current bucket index <code>i</code>, process all vertices in <code>B[i]</code>:</p>
<ul>
<li>For each edge <span class="math inline">\((u, v, w)\)</span>: <span class="math display">\[
\text{if } \text{dist}[u] + w &lt; \text{dist}[v], \text{ then update } \text{dist}[v]
\]</span> Place <span class="math inline">\(v\)</span> in bucket <code>B[(i + w) \bmod (C+1)]</code>.</li>
</ul></li>
<li><p>Move <code>i</code> to next nonempty bucket (cyclic).</p></li>
<li><p>Stop when all buckets empty.</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Bucket</th>
<th>Vertices</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>[0]</td>
<td>start vertex</td>
<td>relax edges</td>
</tr>
<tr class="even">
<td>1</td>
<td>[1]</td>
<td>next layer</td>
<td>propagate</td>
</tr>
<tr class="odd">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>This bucket-based relaxation ensures we always process vertices in increasing distance order, just like Dijkstra.</p>
</section>
<section id="tiny-code-python-example-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-2">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dial_algorithm(V, edges, src, C):</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [INF] <span class="op">*</span> V</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    buckets <span class="op">=</span> [deque() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(C <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    buckets[<span class="dv">0</span>].append(src)</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    processed <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> processed <span class="op">&lt;</span> V:</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">not</span> buckets[idx <span class="op">%</span> (C <span class="op">+</span> <span class="dv">1</span>)]:</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>        dq <span class="op">=</span> buckets[idx <span class="op">%</span> (C <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> dq.popleft()</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>        processed <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>                old <span class="op">=</span> dist[v]</span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>                new_idx <span class="op">=</span> dist[v] <span class="op">%</span> (C <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>                buckets[new_idx].append(v)</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>),</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>),</span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>),</span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dial_algorithm(<span class="dv">4</span>, edges, <span class="dv">0</span>, <span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>[0, 2, 1, 2]</code></pre>
</section>
<section id="why-it-matters-28" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-28">Why It Matters</h4>
<ul>
<li>Replaces heap with fixed-size array of queues</li>
<li>Faster for small integer weights</li>
<li>Linear-time behavior when <span class="math inline">\(C\)</span> is constant</li>
<li>Simpler than Fibonacci heaps, but often as effective in practice</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-28" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-28">A Gentle Proof (Why It Works)</h4>
<p>All edge weights are nonnegative integers bounded by <span class="math inline">\(C\)</span>. Each relaxation increases distance by at most <span class="math inline">\(C\)</span>, so we only need <span class="math inline">\(C+1\)</span> buckets to track possible remainders modulo <span class="math inline">\(C+1\)</span>.</p>
<p>Because each bucket is processed in cyclic order and vertices are only revisited when their distance decreases, the algorithm maintains nondecreasing distance order, ensuring correctness equivalent to Dijkstra.</p>
</section>
<section id="try-it-yourself-28" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-28">Try It Yourself</h4>
<ol type="1">
<li>Run on graphs with small integer weights (0–5).</li>
<li>Compare runtime vs binary heap Dijkstra.</li>
<li>Try <span class="math inline">\(C=1\)</span> → becomes 0–1 BFS.</li>
<li>Test <span class="math inline">\(C=10\)</span> → more buckets, but still fast.</li>
<li>Plot number of relaxations per bucket.</li>
</ol>
</section>
<section id="test-cases-28" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-28">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 45%">
<col style="width: 21%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Max Weight <span class="math inline">\(C\)</span></th>
<th>Distances</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple</td>
<td>0→1(2), 0→2(1), 2→3(1), 1→3(3)</td>
<td>3</td>
<td>[0, 2, 1, 2]</td>
</tr>
<tr class="even">
<td>Uniform</td>
<td>0→1(1), 1→2(1), 2→3(1)</td>
<td>1</td>
<td>[0, 1, 2, 3]</td>
</tr>
<tr class="odd">
<td>Zero edges</td>
<td>0→1(0), 1→2(0)</td>
<td>1</td>
<td>[0, 0, 0]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-28" class="level4">
<h4 class="anchored" data-anchor-id="complexity-28">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V + E + C)\)</span></li>
<li>Space: <span class="math inline">\(O(V + C)\)</span></li>
<li>Condition: all edge weights <span class="math inline">\(\in [0, C]\)</span></li>
</ul>
<p>Dial’s Algorithm is the bucketed Dijkstra, it walks through distances layer by layer, storing each vertex in the slot that fits its cost, never needing a heap to know who’s next.</p>
</section>
</section>
<section id="multi-source-dijkstra" class="level3">
<h3 class="anchored" data-anchor-id="multi-source-dijkstra">330 Multi-Source Dijkstra</h3>
<p>Multi-Source Dijkstra is a variant of Dijkstra’s algorithm designed to find the shortest distance from multiple starting vertices to all others in a weighted graph. Instead of running Dijkstra repeatedly, we initialize the priority queue with all sources at distance 0, and let the algorithm propagate the minimum distances simultaneously.</p>
<p>It’s a powerful technique when you have several origins (cities, servers, entry points) and want the nearest path from any of them.</p>
<section id="what-problem-are-we-solving-29" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-29">What Problem Are We Solving?</h4>
<p>Given a weighted graph <span class="math inline">\(G = (V, E, w)\)</span> and a set of source vertices <span class="math inline">\(S = {s_1, s_2, \dots, s_k}\)</span>, we want to compute:</p>
<p><span class="math display">\[
\text{dist}[v] = \min_{s_i \in S} \text{dist}(s_i, v)
\]</span></p>
<p>In other words, the distance to the closest source.</p>
<p>Typical use cases:</p>
<ul>
<li>Multi-depot routing (shortest route from any facility)</li>
<li>Nearest service center (hospital, server, store)</li>
<li>Multi-seed propagation (fire spread, BFS-like effects)</li>
<li>Voronoi partitions in graphs</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-29" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-29">How Does It Work (Plain Language)?</h4>
<p>The logic is simple:</p>
<ol type="1">
<li>Start with all sources in the priority queue, each at distance 0.</li>
<li>Perform Dijkstra’s algorithm as usual.</li>
<li>Whenever a vertex is relaxed, the source that reached it first determines its distance.</li>
</ol>
<p>Because we process vertices in increasing distance order, every vertex’s distance reflects the nearest source.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Initialize dist[v] = ∞</td>
<td></td>
</tr>
<tr class="even">
<td>For each source s ∈ S: dist[s] = 0</td>
<td></td>
</tr>
<tr class="odd">
<td>Push all s into priority queue</td>
<td></td>
</tr>
<tr class="even">
<td>Run standard Dijkstra</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-3">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_source_dijkstra(V, edges, sources):</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>        graph[v].append((u, w))  <span class="co"># for undirected graph</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [INF] <span class="op">*</span> V</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> []</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> sources:</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>        dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>        heapq.heappush(pq, (<span class="dv">0</span>, s))</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&gt;</span> dist[u]:</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (dist[v], v))</span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>),</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>),</span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>),</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>)</span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>sources <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">4</span>]</span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(multi_source_dijkstra(<span class="dv">5</span>, edges, sources))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>[0, 2, 3, 1, 0]</code></pre>
<p>Each vertex now knows its shortest distance from either source 0 or 4.</p>
</section>
<section id="why-it-matters-29" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-29">Why It Matters</h4>
<ul>
<li>Efficient for multiple origins (no need for <span class="math inline">\(k\)</span> separate Dijkstra runs)</li>
<li>Great for nearest-neighbor labeling or multi-region BFS</li>
<li>Works on weighted graphs, unlike basic multi-source BFS</li>
<li>A building block for graph Voronoi diagrams</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-29" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-29">A Gentle Proof (Why It Works)</h4>
<p>Dijkstra’s algorithm ensures vertices are processed in nondecreasing distance order. By initializing all sources with distance 0, we treat them as a super-source connected by 0-weight edges:</p>
<p><span class="math display">\[
S^* \to s_i, \quad w(S^*, s_i) = 0
\]</span></p>
<p>Thus, multi-source Dijkstra is equivalent to a single-source Dijkstra from a virtual node connected to all sources, which guarantees correctness.</p>
</section>
<section id="try-it-yourself-29" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-29">Try It Yourself</h4>
<ol type="1">
<li>Add multiple sources to a city map graph.</li>
<li>Observe which source each node connects to first.</li>
<li>Compare results with <span class="math inline">\(k\)</span> separate Dijkstra runs.</li>
<li>Modify to also store source label (for Voronoi assignment).</li>
<li>Try on a grid where certain cells are starting fires or signals.</li>
</ol>
</section>
<section id="test-cases-29" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-29">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Sources</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line graph 0–4</td>
<td>[0, 4]</td>
<td>[0, 1, 2, 1, 0]</td>
</tr>
<tr class="even">
<td>Triangle 0–1–2</td>
<td>[0, 2]</td>
<td>[0, 1, 0]</td>
</tr>
<tr class="odd">
<td>Grid</td>
<td>Corners</td>
<td>Minimum steps from corners</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-29" class="level4">
<h4 class="anchored" data-anchor-id="complexity-29">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O((V + E) \log V)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Condition: Nonnegative weights</li>
</ul>
<p>Multi-Source Dijkstra is the chorus of shortest paths, all sources sing together, and every vertex listens to the closest voice.</p>
</section>
</section>
</section>
<section id="section-34.-shortest-path-variants" class="level2">
<h2 class="anchored" data-anchor-id="section-34.-shortest-path-variants">Section 34. Shortest Path Variants</h2>
<section id="bfs-1" class="level3">
<h3 class="anchored" data-anchor-id="bfs-1">331 0–1 BFS</h3>
<p>The 0–1 BFS algorithm is a specialized shortest path technique for graphs whose edge weights are only 0 or 1. It’s a streamlined version of Dijkstra’s algorithm that replaces the priority queue with a deque (double-ended queue), taking advantage of the fact that only two possible edge weights exist. This allows computing all shortest paths in linear time:</p>
<p><span class="math display">\[
O(V + E)
\]</span></p>
<section id="what-problem-are-we-solving-30" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-30">What Problem Are We Solving?</h4>
<p>We want to find the shortest path from a source vertex <span class="math inline">\(s\)</span> to all other vertices in a graph where</p>
<p><span class="math display">\[
w(u, v) \in {0, 1}
\]</span></p>
<p>Standard Dijkstra’s algorithm works, but maintaining a heap is unnecessary overhead when edge weights are so simple. The insight: edges with weight 0 do not increase distance, so they should be explored immediately, while edges with weight 1 should be explored next.</p>
</section>
<section id="how-does-it-work-plain-language-30" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-30">How Does It Work (Plain Language)?</h4>
<p>Instead of a heap, we use a deque to manage vertices by their current shortest distance.</p>
<ol type="1">
<li><p>Initialize all distances to <span class="math inline">\(\infty\)</span>, except <span class="math inline">\(\text{dist}[s] = 0\)</span>.</p></li>
<li><p>Push <span class="math inline">\(s\)</span> into the deque.</p></li>
<li><p>While the deque is not empty:</p>
<ul>
<li><p>Pop vertex <span class="math inline">\(u\)</span> from the front.</p></li>
<li><p>For each edge <span class="math inline">\((u, v)\)</span> with weight <span class="math inline">\(w\)</span>:</p>
<ul>
<li>If <span class="math inline">\(\text{dist}[u] + w &lt; \text{dist}[v]\)</span>, update <span class="math inline">\(\text{dist}[v]\)</span>.</li>
<li>If <span class="math inline">\(w = 0\)</span>, push <span class="math inline">\(v\)</span> to the front (no distance increase).</li>
<li>If <span class="math inline">\(w = 1\)</span>, push <span class="math inline">\(v\)</span> to the back (distance +1).</li>
</ul></li>
</ul></li>
</ol>
<p>Because all edge weights are 0 or 1, this preserves correct ordering without a heap.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Weight</th>
<th>Action</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>push front</td>
<td>explore immediately</td>
</tr>
<tr class="even">
<td>1</td>
<td>push back</td>
<td>explore later</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-4">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zero_one_bfs(V, edges, src):</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for undirected graph, also add graph[v].append((u, w))</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>    dq <span class="op">=</span> deque([src])</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> dq:</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> dq.popleft()</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> w <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>                    dq.appendleft(v)</span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>                    dq.append(v)</span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">0</span>)]</span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(zero_one_bfs(<span class="dv">4</span>, edges, <span class="dv">0</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>[0, 0, 1, 1]</code></pre>
</section>
<section id="why-it-matters-30" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-30">Why It Matters</h4>
<ul>
<li><p>Runs in <span class="math inline">\(O(V + E)\)</span>, faster than Dijkstra’s <span class="math inline">\(O(E \log V)\)</span></p></li>
<li><p>Simplifies implementation when weights are 0 or 1</p></li>
<li><p>Works on directed or undirected graphs</p></li>
<li><p>Perfect for problems like:</p>
<ul>
<li>Minimum number of flips/operations</li>
<li>Shortest path in binary grids</li>
<li>BFS with special cost transitions</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-30" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-30">A Gentle Proof (Why It Works)</h4>
<p>At every step, the deque contains vertices ordered by nondecreasing distance. When an edge of weight 0 is relaxed, the neighbor’s distance equals <span class="math inline">\(\text{dist}[u]\)</span>, so we process it immediately (push front). When an edge of weight 1 is relaxed, the neighbor’s distance increases by 1, so it goes to the back.</p>
<p>This maintains the same invariant as Dijkstra’s:</p>
<blockquote class="blockquote">
<p>Every vertex is processed when its shortest distance is finalized.</p>
</blockquote>
<p>Thus, correctness follows.</p>
</section>
<section id="try-it-yourself-30" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-30">Try It Yourself</h4>
<ol type="1">
<li>Compare with Dijkstra’s algorithm on graphs with 0–1 weights.</li>
<li>Create a grid where moving straight costs 0 and turning costs 1.</li>
<li>Modify to handle undirected edges.</li>
<li>Use it for “minimum walls to break” problems.</li>
<li>Draw the deque contents step-by-step to visualize progression.</li>
</ol>
</section>
<section id="test-cases-30" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-30">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Distances</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple</td>
<td>0→1(0), 1→2(1), 0→2(1), 2→3(0)</td>
<td>[0, 0, 1, 1]</td>
</tr>
<tr class="even">
<td>All 0</td>
<td>0→1(0), 1→2(0), 2→3(0)</td>
<td>[0, 0, 0, 0]</td>
</tr>
<tr class="odd">
<td>Mixed</td>
<td>0→1(1), 1→2(0), 0→2(1)</td>
<td>[0, 1, 1]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-30" class="level4">
<h4 class="anchored" data-anchor-id="complexity-30">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V + E)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Condition: <span class="math inline">\(w(u, v) \in {0, 1}\)</span></li>
</ul>
<p>0–1 BFS is a binary Dijkstra, moving through zero-cost edges first and one-cost edges next, fast, simple, and perfectly ordered.</p>
</section>
</section>
<section id="bidirectional-dijkstra" class="level3">
<h3 class="anchored" data-anchor-id="bidirectional-dijkstra">332 Bidirectional Dijkstra</h3>
<p>Bidirectional Dijkstra is an optimization of the classic Dijkstra’s algorithm for single-pair shortest paths. Instead of searching from just the source, we run two simultaneous Dijkstra searches, one forward from the source and one backward from the target, and stop when they meet.</p>
<p>This dramatically reduces the explored search space, especially in sparse or road-network-like graphs.</p>
<section id="what-problem-are-we-solving-31" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-31">What Problem Are We Solving?</h4>
<p>We want the shortest path between two specific vertices, <span class="math inline">\(s\)</span> (source) and <span class="math inline">\(t\)</span> (target), in a graph with nonnegative weights. Standard Dijkstra explores the entire reachable graph, which is wasteful if we only need <span class="math inline">\(s \to t\)</span>.</p>
<p>Bidirectional Dijkstra searches from both ends and meets in the middle:</p>
<p><span class="math display">\[
\text{dist}(s, t) = \min_{v \in V} \left( \text{dist}*\text{fwd}[v] + \text{dist}*\text{bwd}[v] \right)
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-31" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-31">How Does It Work (Plain Language)?</h4>
<p>The algorithm maintains two priority queues, one for the forward search (from <span class="math inline">\(s\)</span>) and one for the backward search (from <span class="math inline">\(t\)</span>). Each search relaxes edges as in standard Dijkstra, but they alternate steps until their frontiers intersect.</p>
<ol type="1">
<li>Initialize all <span class="math inline">\(\text{dist}*\text{fwd}\)</span> and <span class="math inline">\(\text{dist}*\text{bwd}\)</span> to <span class="math inline">\(\infty\)</span>.</li>
<li>Set <span class="math inline">\(\text{dist}*\text{fwd}[s] = 0\)</span>, <span class="math inline">\(\text{dist}*\text{bwd}[t] = 0\)</span>.</li>
<li>Insert <span class="math inline">\(s\)</span> into the forward heap, <span class="math inline">\(t\)</span> into the backward heap.</li>
<li>Alternate expanding one step forward and one step backward.</li>
<li>When a vertex <span class="math inline">\(v\)</span> is visited by both searches, compute candidate path: <span class="math display">\[
\text{dist}(s, v) + \text{dist}(t, v)
\]</span></li>
<li>Stop when both queues are empty or the current minimum key exceeds the best candidate path.</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Direction</th>
<th>Heap</th>
<th>Distance Array</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Forward</td>
<td>From source</td>
<td><span class="math inline">\(\text{dist}_\text{fwd}\)</span></td>
</tr>
<tr class="even">
<td>Backward</td>
<td>From target</td>
<td><span class="math inline">\(\text{dist}_\text{bwd}\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-5">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bidirectional_dijkstra(V, edges, s, t):</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    rev_graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        rev_graph[v].append((u, w))  <span class="co"># reverse for backward search</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    dist_f <span class="op">=</span> [INF] <span class="op">*</span> V</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    dist_b <span class="op">=</span> [INF] <span class="op">*</span> V</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>    visited_f <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> V</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>    visited_b <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> V</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    dist_f[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>    dist_b[t] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>    pq_f <span class="op">=</span> [(<span class="dv">0</span>, s)]</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>    pq_b <span class="op">=</span> [(<span class="dv">0</span>, t)]</span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> INF</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq_f <span class="kw">or</span> pq_b:</span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pq_f:</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a>            d, u <span class="op">=</span> heapq.heappop(pq_f)</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&gt;</span> dist_f[u]:</span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>            visited_f[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> visited_b[u]:</span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> <span class="bu">min</span>(best, dist_f[u] <span class="op">+</span> dist_b[u])</span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dist_f[u] <span class="op">+</span> w <span class="op">&lt;</span> dist_f[v]:</span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a>                    dist_f[v] <span class="op">=</span> dist_f[u] <span class="op">+</span> w</span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a>                    heapq.heappush(pq_f, (dist_f[v], v))</span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pq_b:</span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a>            d, u <span class="op">=</span> heapq.heappop(pq_b)</span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&gt;</span> dist_b[u]:</span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true" tabindex="-1"></a>            visited_b[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> visited_f[u]:</span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> <span class="bu">min</span>(best, dist_f[u] <span class="op">+</span> dist_b[u])</span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v, w <span class="kw">in</span> rev_graph[u]:</span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dist_b[u] <span class="op">+</span> w <span class="op">&lt;</span> dist_b[v]:</span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true" tabindex="-1"></a>                    dist_b[v] <span class="op">=</span> dist_b[u] <span class="op">+</span> w</span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true" tabindex="-1"></a>                    heapq.heappush(pq_b, (dist_b[v], v))</span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-47"><a href="#cb57-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best <span class="op">&lt;</span> <span class="bu">min</span>(pq_f[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> pq_f <span class="cf">else</span> INF, pq_b[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> pq_b <span class="cf">else</span> INF):</span>
<span id="cb57-48"><a href="#cb57-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb57-49"><a href="#cb57-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-50"><a href="#cb57-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best <span class="cf">if</span> best <span class="op">!=</span> INF <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb57-51"><a href="#cb57-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-52"><a href="#cb57-52" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb57-53"><a href="#cb57-53" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>),</span>
<span id="cb57-54"><a href="#cb57-54" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</span>
<span id="cb57-55"><a href="#cb57-55" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>),</span>
<span id="cb57-56"><a href="#cb57-56" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>),</span>
<span id="cb57-57"><a href="#cb57-57" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb57-58"><a href="#cb57-58" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb57-59"><a href="#cb57-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-60"><a href="#cb57-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(bidirectional_dijkstra(<span class="dv">5</span>, edges, <span class="dv">0</span>, <span class="dv">2</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>5</code></pre>
</section>
<section id="why-it-matters-31" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-31">Why It Matters</h4>
<ul>
<li>Half the work of standard Dijkstra on average</li>
<li>Best suited for sparse, road-like networks</li>
<li>Great for navigation, routing, pathfinding</li>
<li>Foundation for advanced methods like ALT and Contraction Hierarchies</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-31" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-31">A Gentle Proof (Why It Works)</h4>
<p>Dijkstra’s invariant: vertices are processed in nondecreasing distance order. By running two searches, we maintain this invariant in both directions. When a vertex is reached by both searches, any further expansion can only find paths longer than the current best:</p>
<p><span class="math display">\[
\text{dist}*\text{fwd}[u] + \text{dist}*\text{bwd}[u] = \text{candidate shortest path}
\]</span></p>
<p>Thus, the first intersection yields the optimal distance.</p>
</section>
<section id="try-it-yourself-31" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-31">Try It Yourself</h4>
<ol type="1">
<li>Compare explored nodes vs single Dijkstra.</li>
<li>Visualize frontiers meeting in the middle.</li>
<li>Add a grid graph with uniform weights.</li>
<li>Combine with heuristics → bidirectional A*.</li>
<li>Use backward search on reverse edges.</li>
</ol>
</section>
<section id="test-cases-31" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-31">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Source</th>
<th>Target</th>
<th>Result</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line</td>
<td>0→1→2→3</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td>0→1(2), 1→2(2), 0→2(5)</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Road</td>
<td>0→1(1), 1→2(2), 0→3(3), 3→2(1)</td>
<td>0</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-31" class="level4">
<h4 class="anchored" data-anchor-id="complexity-31">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O((V + E) \log V)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Condition: Nonnegative weights</li>
</ul>
<p>Bidirectional Dijkstra is a meeting-in-the-middle pathfinder, two explorers start from opposite ends, racing toward each other until they share the shortest route.</p>
</section>
</section>
<section id="a-with-euclidean-heuristic" class="level3">
<h3 class="anchored" data-anchor-id="a-with-euclidean-heuristic">333 A* with Euclidean Heuristic</h3>
<p>The A* algorithm is a heuristic-guided shortest path search, blending Dijkstra’s rigor with informed direction. By introducing a heuristic function <span class="math inline">\(h(v)\)</span> that estimates the remaining distance, it expands fewer nodes and focuses the search toward the goal. When using Euclidean distance as the heuristic, A* is perfect for spatial graphs, grids, maps, road networks.</p>
<section id="what-problem-are-we-solving-32" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-32">What Problem Are We Solving?</h4>
<p>We want the shortest path from a source <span class="math inline">\(s\)</span> to a target <span class="math inline">\(t\)</span> in a weighted graph with nonnegative weights, but we also want to avoid exploring unnecessary regions.</p>
<p>Dijkstra expands all nodes in order of true cost <span class="math inline">\(g(v)\)</span> (distance so far). A* expands nodes in order of estimated total cost:</p>
<p><span class="math display">\[
f(v) = g(v) + h(v)
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(g(v)\)</span> = cost so far from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span>,</li>
<li><span class="math inline">\(h(v)\)</span> = heuristic estimate from <span class="math inline">\(v\)</span> to <span class="math inline">\(t\)</span>.</li>
</ul>
<p>If <span class="math inline">\(h(v)\)</span> never overestimates the true cost, A* guarantees the optimal path.</p>
</section>
<section id="how-does-it-work-plain-language-32" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-32">How Does It Work (Plain Language)?</h4>
<p>Think of A* as Dijkstra with a compass. While Dijkstra explores all directions equally, A* uses <span class="math inline">\(h(v)\)</span> to bias exploration toward the target.</p>
<ol type="1">
<li><p>Initialize <span class="math inline">\(\text{dist}[s] = 0\)</span>, <span class="math inline">\(\text{f}[s] = h(s)\)</span></p></li>
<li><p>Push <span class="math inline">\((f(s), s)\)</span> into a priority queue</p></li>
<li><p>While queue not empty:</p>
<ul>
<li><p>Pop vertex <span class="math inline">\(u\)</span> with smallest <span class="math inline">\(f(u)\)</span></p></li>
<li><p>If <span class="math inline">\(u = t\)</span>, stop, path found</p></li>
<li><p>For each neighbor <span class="math inline">\((u, v)\)</span> with weight <span class="math inline">\(w\)</span>:</p>
<ul>
<li>Compute tentative cost <span class="math inline">\(g' = \text{dist}[u] + w\)</span></li>
<li>If <span class="math inline">\(g' &lt; \text{dist}[v]\)</span>: <span class="math display">\[
\text{dist}[v] = g', \quad f(v) = g' + h(v)
\]</span> Push <span class="math inline">\((f(v), v)\)</span> into queue</li>
</ul></li>
</ul></li>
</ol>
<p>Heuristic types:</p>
<ul>
<li>Euclidean: <span class="math inline">\(h(v) = \sqrt{(x_v - x_t)^2 + (y_v - y_t)^2}\)</span></li>
<li>Manhattan: <span class="math inline">\(h(v) = |x_v - x_t| + |y_v - y_t|\)</span></li>
<li>Zero: <span class="math inline">\(h(v) = 0\)</span> → reduces to Dijkstra</li>
</ul>
</section>
<section id="tiny-code-python-example-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-6">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> a_star_euclidean(V, edges, coords, s, t):</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>        graph[v].append((u, w))  <span class="co"># undirected</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> h(v):</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> coords[v]</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> coords[t]</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> math.sqrt((x1 <span class="op">-</span> x2)<span class="dv">2</span> <span class="op">+</span> (y1 <span class="op">-</span> y2)<span class="dv">2</span>)</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(h(s), s)]</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>        f, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dist[u]</span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>            g_new <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> g_new <span class="op">&lt;</span> dist[v]:</span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> g_new</span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (g_new <span class="op">+</span> h(v), v))</span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">2</span>,<span class="dv">1</span>)]</span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>)]</span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a_star_euclidean(<span class="dv">4</span>, edges, coords, <span class="dv">0</span>, <span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>3</code></pre>
</section>
<section id="why-it-matters-32" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-32">Why It Matters</h4>
<ul>
<li>Optimal if <span class="math inline">\(h(v)\)</span> is admissible (<span class="math inline">\(h(v) \le\)</span> true distance)</li>
<li>Fast if <span class="math inline">\(h(v)\)</span> is consistent (<span class="math inline">\(h(u) \le w(u,v) + h(v)\)</span>)</li>
<li>Perfect for spatial navigation and grid-based pathfinding</li>
<li>Underpins many AI systems: games, robots, GPS routing</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-32" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-32">A Gentle Proof (Why It Works)</h4>
<p>A* ensures correctness through admissibility: <span class="math display">\[
h(v) \le \text{dist}(v, t)
\]</span></p>
<p>This means <span class="math inline">\(f(v) = g(v) + h(v)\)</span> never underestimates the total path cost, so the first time <span class="math inline">\(t\)</span> is dequeued, the shortest path is found.</p>
<p>Consistency ensures that <span class="math inline">\(f(v)\)</span> values are nondecreasing, mimicking Dijkstra’s invariant.</p>
<p>Thus, A* retains Dijkstra’s guarantees while guiding exploration efficiently.</p>
</section>
<section id="try-it-yourself-32" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-32">Try It Yourself</h4>
<ol type="1">
<li>Compare explored nodes with Dijkstra’s algorithm.</li>
<li>Use Euclidean and Manhattan heuristics on a grid.</li>
<li>Try a bad heuristic (e.g.&nbsp;double true distance) → see failure.</li>
<li>Visualize search frontier for each step.</li>
<li>Apply to a maze or road map.</li>
</ol>
</section>
<section id="test-cases-32" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-32">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Heuristic</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Grid</td>
<td>Euclidean</td>
<td>Straight path</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td><span class="math inline">\(h=0\)</span></td>
<td>Dijkstra</td>
</tr>
<tr class="odd">
<td>Overestimate</td>
<td><span class="math inline">\(h(v) &gt; \text{dist}(v,t)\)</span></td>
<td>May fail</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-32" class="level4">
<h4 class="anchored" data-anchor-id="complexity-32">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log V)\)</span></li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
<li>Condition: Nonnegative weights, admissible heuristic</li>
</ul>
<p>A* with Euclidean heuristic is the navigator’s Dijkstra, guided by distance, it finds the shortest route while knowing where it’s headed.</p>
</section>
</section>
<section id="alt-algorithm-a-landmarks-triangle-inequality" class="level3">
<h3 class="anchored" data-anchor-id="alt-algorithm-a-landmarks-triangle-inequality">334 ALT Algorithm (A* Landmarks + Triangle Inequality)</h3>
<p>The ALT Algorithm enhances A* search with precomputed landmarks and the triangle inequality, giving it a strong, admissible heuristic that dramatically speeds up shortest path queries on large road networks.</p>
<p>The name “ALT” comes from A* (search), Landmarks, and Triangle inequality, a trio that balances preprocessing with query-time efficiency.</p>
<section id="what-problem-are-we-solving-33" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-33">What Problem Are We Solving?</h4>
<p>We want to find shortest paths efficiently in large weighted graphs (like road maps), where a single-source search (like Dijkstra or A*) may explore millions of nodes.</p>
<p>To guide the search more effectively, we precompute distances from special nodes (landmarks) and use them to build tight heuristic bounds during A*.</p>
<p>Given nonnegative edge weights, we define a heuristic based on the triangle inequality:</p>
<p><span class="math display">\[
d(a, b) \le d(a, L) + d(L, b)
\]</span></p>
<p>From this we derive a lower bound for <span class="math inline">\(d(a, b)\)</span>:</p>
<p><span class="math display">\[
h(a) = \max_{L \in \text{landmarks}} |d(L, t) - d(L, a)|
\]</span></p>
<p>This <span class="math inline">\(h(a)\)</span> is admissible (never overestimates) and consistent (monotone).</p>
</section>
<section id="how-does-it-work-plain-language-33" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-33">How Does It Work (Plain Language)?</h4>
<p>ALT augments A* with preprocessing and landmark distances:</p>
<p>Preprocessing:</p>
<ol type="1">
<li>Choose a small set of landmarks <span class="math inline">\(L_1, L_2, \dots, L_k\)</span> (spread across the graph).</li>
<li>Run Dijkstra (or BFS) from each landmark to compute distances to all nodes: <span class="math display">\[
d(L_i, v) \text{ and } d(v, L_i)
\]</span></li>
</ol>
<p>Query phase:</p>
<ol type="1">
<li>For a query <span class="math inline">\((s, t)\)</span>, compute: <span class="math display">\[
h(v) = \max_{i=1}^k |d(L_i, t) - d(L_i, v)|
\]</span></li>
<li>Run A* with this heuristic: <span class="math display">\[
f(v) = g(v) + h(v)
\]</span></li>
<li>Guaranteed optimal path (admissible and consistent).</li>
</ol>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 52%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Phase</th>
<th>Task</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Preprocessing</td>
<td>Multi-source Dijkstra from landmarks</td>
<td><span class="math inline">\(O(k(V+E)\log V)\)</span></td>
</tr>
<tr class="even">
<td>Query</td>
<td>A* with landmark heuristic</td>
<td>Fast (<span class="math inline">\(O(E'\log V)\)</span>)</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-7">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra(V, graph, src):</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, src)]</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&gt;</span> dist[u]:</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> d <span class="op">+</span> w</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (dist[v], v))</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> alt_search(V, graph, landmarks, d_landmark_to, s, t):</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> h(v):</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># max of triangle inequality heuristic</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(<span class="bu">abs</span>(d_landmark_to[L][t] <span class="op">-</span> d_landmark_to[L][v]) <span class="cf">for</span> L <span class="kw">in</span> landmarks)</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>    dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(h(s), s)]</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>        f, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dist[u]</span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>            g_new <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> g_new <span class="op">&lt;</span> dist[v]:</span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> g_new</span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (g_new <span class="op">+</span> h(v), v))</span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> [</span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">4</span>)],</span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">3</span>, <span class="dv">7</span>)],</span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">3</span>, <span class="dv">3</span>)],</span>
<span id="cb61-43"><a href="#cb61-43" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">4</span>, <span class="dv">1</span>)],</span>
<span id="cb61-44"><a href="#cb61-44" aria-hidden="true" tabindex="-1"></a>    []</span>
<span id="cb61-45"><a href="#cb61-45" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb61-46"><a href="#cb61-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-47"><a href="#cb61-47" aria-hidden="true" tabindex="-1"></a>landmarks <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">4</span>]</span>
<span id="cb61-48"><a href="#cb61-48" aria-hidden="true" tabindex="-1"></a>d_landmark_to <span class="op">=</span> [dijkstra(V, graph, L) <span class="cf">for</span> L <span class="kw">in</span> landmarks]</span>
<span id="cb61-49"><a href="#cb61-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-50"><a href="#cb61-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(alt_search(V, graph, landmarks, d_landmark_to, <span class="dv">0</span>, <span class="dv">4</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>11</code></pre>
</section>
<section id="why-it-matters-33" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-33">Why It Matters</h4>
<ul>
<li>Far fewer node expansions than Dijkstra or vanilla A*</li>
<li>Admissible (never overestimates) and consistent</li>
<li>Especially effective on road networks, navigation systems, GIS, and logistics routing</li>
<li>Preprocessing is offline, query is real-time fast</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-33" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-33">A Gentle Proof (Why It Works)</h4>
<p>For any nodes <span class="math inline">\(a, b\)</span>, and landmark <span class="math inline">\(L\)</span>:</p>
<p><span class="math display">\[
|d(L, b) - d(L, a)| \le d(a, b)
\]</span></p>
<p>By taking the maximum over all chosen landmarks:</p>
<p><span class="math display">\[
h(a) = \max_L |d(L, t) - d(L, a)| \le d(a, t)
\]</span></p>
<p>Therefore <span class="math inline">\(h(a)\)</span> is admissible, and since triangle inequality is symmetric, it is consistent:</p>
<p><span class="math display">\[
h(a) \le w(a, b) + h(b)
\]</span></p>
<p>Thus, A* with <span class="math inline">\(h(a)\)</span> preserves optimality.</p>
</section>
<section id="try-it-yourself-33" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-33">Try It Yourself</h4>
<ol type="1">
<li>Choose 2–3 landmarks spread across your graph.</li>
<li>Compare A* expansions with and without ALT heuristic.</li>
<li>Visualize heuristic contours around landmarks.</li>
<li>Use in city maps to speed up routing queries.</li>
<li>Experiment with random vs central landmarks.</li>
</ol>
</section>
<section id="test-cases-33" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-33">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Landmarks</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain</td>
<td>[first, last]</td>
<td>Exact heuristic</td>
</tr>
<tr class="even">
<td>Grid</td>
<td>4 corners</td>
<td>Smooth guidance</td>
</tr>
<tr class="odd">
<td>Random</td>
<td>random nodes</td>
<td>Varying performance</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-33" class="level4">
<h4 class="anchored" data-anchor-id="complexity-33">Complexity</h4>
<ul>
<li>Preprocessing: <span class="math inline">\(O(k(V + E) \log V)\)</span></li>
<li>Query: <span class="math inline">\(O(E' \log V)\)</span> (small subset)</li>
<li>Space: <span class="math inline">\(O(kV)\)</span></li>
<li>Condition: Nonnegative weights</li>
</ul>
<p>The ALT Algorithm is A* on steroids, guided by precomputed wisdom (landmarks), it leaps across the graph using geometry, not guesswork.</p>
</section>
</section>
<section id="contraction-hierarchies" class="level3">
<h3 class="anchored" data-anchor-id="contraction-hierarchies">335 Contraction Hierarchies</h3>
<p>Contraction Hierarchies (CH) is a powerful speedup technique for shortest path queries on large, static road networks. It preprocesses the graph by adding shortcuts and ordering vertices by importance, enabling queries that run orders of magnitude faster than plain Dijkstra.</p>
<p>It’s the backbone of many modern routing engines (like OSRM, GraphHopper, Valhalla) used in GPS systems.</p>
<section id="what-problem-are-we-solving-34" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-34">What Problem Are We Solving?</h4>
<p>We want to answer many shortest path queries quickly on a large, unchanging graph (like a road map). Running Dijkstra or even A* for each query is too slow.</p>
<p>Contraction Hierarchies solves this by:</p>
<ol type="1">
<li>Preprocessing once to create a hierarchy of nodes.</li>
<li>Answering each query with a much smaller search (bidirectional).</li>
</ol>
<p>Tradeoff: expensive preprocessing, blazing-fast queries.</p>
</section>
<section id="how-does-it-work-plain-language-34" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-34">How Does It Work (Plain Language)?</h4>
<p>Contraction Hierarchies is a two-phase algorithm:</p>
<section id="preprocessing-phase-build-hierarchy" class="level5">
<h5 class="anchored" data-anchor-id="preprocessing-phase-build-hierarchy">1. Preprocessing Phase (Build Hierarchy)</h5>
<p>We order nodes by importance (e.g., degree, centrality, traffic volume). Then we contract them one by one, adding shortcut edges so that shortest path distances remain correct.</p>
<p>For each node <span class="math inline">\(v\)</span> being removed:</p>
<ul>
<li><p>For each pair of neighbors <span class="math inline">\((u, w)\)</span>:</p>
<ul>
<li>If the shortest path <span class="math inline">\(u \to v \to w\)</span> is the only shortest path between <span class="math inline">\(u\)</span> and <span class="math inline">\(w\)</span>, add a shortcut <span class="math inline">\((u, w)\)</span> with weight <span class="math inline">\(w(u, v) + w(v, w)\)</span>.</li>
</ul></li>
</ul>
<p>We record the order in which nodes are contracted.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pick node <span class="math inline">\(v\)</span></td>
<td>Contract</td>
<td>Add shortcuts</td>
</tr>
<tr class="even">
<td>Continue</td>
<td>Until all nodes</td>
<td>Build hierarchy</td>
</tr>
</tbody>
</table>
<p>The graph becomes layered: low-importance nodes contracted first, high-importance last.</p>
</section>
<section id="query-phase-up-down-search" class="level5">
<h5 class="anchored" data-anchor-id="query-phase-up-down-search">2. Query Phase (Up-Down Search)</h5>
<p>Given a query <span class="math inline">\((s, t)\)</span>:</p>
<ul>
<li>Run bidirectional Dijkstra, but only “upward” along higher-ranked nodes.</li>
<li>Stop when both searches meet.</li>
</ul>
<p>This Up-Down constraint keeps the search small, only a tiny fraction of the graph is explored.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Direction</th>
<th>Constraint</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Forward</td>
<td>Visit only higher-ranked nodes</td>
</tr>
<tr class="even">
<td>Backward</td>
<td>Visit only higher-ranked nodes</td>
</tr>
</tbody>
</table>
<p>The shortest path is the lowest point where the two searches meet.</p>
</section>
</section>
<section id="tiny-code-python-example-conceptual" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-conceptual">Tiny Code (Python Example, Conceptual)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_shortcuts(graph, order):</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    shortcuts <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> order:</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>        neighbors <span class="op">=</span> graph[v]</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, wu <span class="kw">in</span> neighbors:</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> w, ww <span class="kw">in</span> neighbors:</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> u <span class="op">==</span> w:</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>                new_dist <span class="op">=</span> wu <span class="op">+</span> ww</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>                <span class="co"># If no shorter path exists between u and w, add shortcut</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>                exists <span class="op">=</span> <span class="bu">any</span>(n <span class="op">==</span> w <span class="kw">and</span> cost <span class="op">&lt;=</span> new_dist <span class="cf">for</span> n, cost <span class="kw">in</span> graph[u])</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> exists:</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>                    shortcuts[u].append((w, new_dist))</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove v (contract)</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>        graph[v] <span class="op">=</span> []</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [graph[i] <span class="op">+</span> shortcuts[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> upward_edges(graph, order):</span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> {v: i <span class="cf">for</span> i, v <span class="kw">in</span> <span class="bu">enumerate</span>(order)}</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>    up <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graph))]</span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graph)):</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> rank[v] <span class="op">&gt;</span> rank[u]:</span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>                up[u].append((v, w))</span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> up</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ch_query(up_graph, s, t):</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dijkstra_dir(start):</span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">=</span> {}</span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a>        pq <span class="op">=</span> [(<span class="dv">0</span>, start)]</span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pq:</span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a>            d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> u <span class="kw">in</span> dist:</span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a>            dist[u] <span class="op">=</span> d</span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v, w <span class="kw">in</span> up_graph[u]:</span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (d <span class="op">+</span> w, v))</span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dist</span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a>    dist_s <span class="op">=</span> dijkstra_dir(s)</span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a>    dist_t <span class="op">=</span> dijkstra_dir(t)</span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> dist_s:</span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="kw">in</span> dist_t:</span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> <span class="bu">min</span>(best, dist_s[v] <span class="op">+</span> dist_t[v])</span>
<span id="cb63-49"><a href="#cb63-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span>
<span id="cb63-50"><a href="#cb63-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-51"><a href="#cb63-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Example graph</span></span>
<span id="cb63-52"><a href="#cb63-52" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> [</span>
<span id="cb63-53"><a href="#cb63-53" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">4</span>)],</span>
<span id="cb63-54"><a href="#cb63-54" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">3</span>, <span class="dv">7</span>)],</span>
<span id="cb63-55"><a href="#cb63-55" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">3</span>, <span class="dv">3</span>)],</span>
<span id="cb63-56"><a href="#cb63-56" aria-hidden="true" tabindex="-1"></a>    []</span>
<span id="cb63-57"><a href="#cb63-57" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb63-58"><a href="#cb63-58" aria-hidden="true" tabindex="-1"></a>order <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]  <span class="co"># Simplified</span></span>
<span id="cb63-59"><a href="#cb63-59" aria-hidden="true" tabindex="-1"></a>up_graph <span class="op">=</span> upward_edges(add_shortcuts(graph, order), order)</span>
<span id="cb63-60"><a href="#cb63-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ch_query(up_graph, <span class="dv">0</span>, <span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>8</code></pre>
</section>
<section id="why-it-matters-34" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-34">Why It Matters</h4>
<ul>
<li>Query speed: microseconds, even on million-node graphs</li>
<li>Used in GPS navigation, road routing, logistics planning</li>
<li>Preprocessing preserves correctness via shortcuts</li>
<li>Easily combined with ALT, A*, and Multi-level Dijkstra</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-34" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-34">A Gentle Proof (Why It Works)</h4>
<p>When contracting node <span class="math inline">\(v\)</span>, we add shortcuts to preserve all shortest paths that pass through <span class="math inline">\(v\)</span>. Thus, removing <span class="math inline">\(v\)</span> never breaks shortest-path correctness.</p>
<p>During query:</p>
<ul>
<li>We only travel upward in rank.</li>
<li>Since all paths can be expressed as up-down-up, the meeting point of the forward and backward searches must lie on the true shortest path.</li>
</ul>
<p>By limiting exploration to “upward” edges, CH keeps searches small without losing completeness.</p>
</section>
<section id="try-it-yourself-34" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-34">Try It Yourself</h4>
<ol type="1">
<li>Build a small graph, choose an order, and add shortcuts.</li>
<li>Compare Dijkstra vs CH query times.</li>
<li>Visualize hierarchy (contracted vs remaining).</li>
<li>Experiment with random vs heuristic node orderings.</li>
<li>Add landmarks (ALT+CH) for further optimization.</li>
</ol>
</section>
<section id="test-cases-34" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-34">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Nodes</th>
<th>Query</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain</td>
<td>0–1–2–3</td>
<td>0→3</td>
<td>3 edges</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td>0–1–2</td>
<td>0→2</td>
<td>Shortcut 0–2 added</td>
</tr>
<tr class="odd">
<td>Grid</td>
<td>3×3</td>
<td>Corner→Corner</td>
<td>Shortcuts reduce hops</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-34" class="level4">
<h4 class="anchored" data-anchor-id="complexity-34">Complexity</h4>
<ul>
<li>Preprocessing: <span class="math inline">\(O(V \log V + E)\)</span> (with heuristic ordering)</li>
<li>Query: <span class="math inline">\(O(\log V)\)</span> (tiny search space)</li>
<li>Space: <span class="math inline">\(O(V + E + \text{shortcuts})\)</span></li>
<li>Condition: Static graph, nonnegative weights</li>
</ul>
<p>Contraction Hierarchies is the architect’s Dijkstra, it reshapes the city first, then navigates with near-instant precision.</p>
</section>
</section>
<section id="ch-query-algorithm-shortcut-based-routing" class="level3">
<h3 class="anchored" data-anchor-id="ch-query-algorithm-shortcut-based-routing">336 CH Query Algorithm (Shortcut-Based Routing)</h3>
<p>The CH Query Algorithm is the online phase of Contraction Hierarchies (CH). Once preprocessing builds the shortcut-augmented hierarchy, queries can be answered in microseconds by performing an upward bidirectional Dijkstra, searching only along edges that lead to more important (higher-ranked) nodes.</p>
<p>It’s the practical magic behind instantaneous route planning in navigation systems.</p>
<section id="what-problem-are-we-solving-35" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-35">What Problem Are We Solving?</h4>
<p>Given a contracted graph (with shortcuts) and a node ranking, we want to compute the shortest distance between two vertices <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> — without exploring the full graph.</p>
<p>Rather than scanning every node, CH Query:</p>
<ol type="1">
<li>Searches upward from both <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> (following rank order).</li>
<li>Stops when both searches meet.</li>
<li>The meeting point with the smallest sum of forward + backward distances gives the shortest path.</li>
</ol>
</section>
<section id="how-does-it-work-plain-language-35" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-35">How Does It Work (Plain Language)?</h4>
<p>After preprocessing (which contracts nodes and inserts shortcuts), the query algorithm runs two simultaneous upward Dijkstra searches:</p>
<ol type="1">
<li><p>Initialize two heaps:</p>
<ul>
<li>Forward from <span class="math inline">\(s\)</span></li>
<li>Backward from <span class="math inline">\(t\)</span></li>
</ul></li>
<li><p>Relax only upward edges, from lower-rank nodes to higher-rank ones. (Edge <span class="math inline">\((u, v)\)</span> is upward if <span class="math inline">\(\text{rank}(v) &gt; \text{rank}(u)\)</span>.)</p></li>
<li><p>Whenever a node <span class="math inline">\(v\)</span> is settled by both searches, compute potential path: <span class="math display">\[
d = \text{dist}_f[v] + \text{dist}_b[v]
\]</span></p></li>
<li><p>Track the minimum such <span class="math inline">\(d\)</span>.</p></li>
<li><p>Stop when current best <span class="math inline">\(d\)</span> is smaller than remaining unvisited frontier keys.</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Phase</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Forward Search</td>
<td>Upward edges from <span class="math inline">\(s\)</span></td>
</tr>
<tr class="even">
<td>Backward Search</td>
<td>Upward edges from <span class="math inline">\(t\)</span> (in reversed graph)</td>
</tr>
<tr class="odd">
<td>Meet in Middle</td>
<td>Combine distances at intersection</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-conceptual-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-conceptual-1">Tiny Code (Python Example, Conceptual)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ch_query(up_graph, rank, s, t):</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(up_graph)</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    dist_f <span class="op">=</span> [INF] <span class="op">*</span> n</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    dist_b <span class="op">=</span> [INF] <span class="op">*</span> n</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    visited_f <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    visited_b <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    dist_f[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    dist_b[t] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    pq_f <span class="op">=</span> [(<span class="dv">0</span>, s)]</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    pq_b <span class="op">=</span> [(<span class="dv">0</span>, t)]</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> INF</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq_f <span class="kw">or</span> pq_b:</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forward direction</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pq_f:</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>            d, u <span class="op">=</span> heapq.heappop(pq_f)</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&gt;</span> dist_f[u]:</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>            visited_f[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> visited_b[u]:</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> <span class="bu">min</span>(best, dist_f[u] <span class="op">+</span> dist_b[u])</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v, w <span class="kw">in</span> up_graph[u]:</span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> rank[v] <span class="op">&gt;</span> rank[u] <span class="kw">and</span> dist_f[u] <span class="op">+</span> w <span class="op">&lt;</span> dist_f[v]:</span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>                    dist_f[v] <span class="op">=</span> dist_f[u] <span class="op">+</span> w</span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>                    heapq.heappush(pq_f, (dist_f[v], v))</span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Backward direction</span></span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pq_b:</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>            d, u <span class="op">=</span> heapq.heappop(pq_b)</span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&gt;</span> dist_b[u]:</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a>            visited_b[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> visited_f[u]:</span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> <span class="bu">min</span>(best, dist_f[u] <span class="op">+</span> dist_b[u])</span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v, w <span class="kw">in</span> up_graph[u]:</span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> rank[v] <span class="op">&gt;</span> rank[u] <span class="kw">and</span> dist_b[u] <span class="op">+</span> w <span class="op">&lt;</span> dist_b[v]:</span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a>                    dist_b[v] <span class="op">=</span> dist_b[u] <span class="op">+</span> w</span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a>                    heapq.heappush(pq_b, (dist_b[v], v))</span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Early stop condition</span></span>
<span id="cb65-45"><a href="#cb65-45" aria-hidden="true" tabindex="-1"></a>        min_frontier <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb65-46"><a href="#cb65-46" aria-hidden="true" tabindex="-1"></a>            pq_f[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> pq_f <span class="cf">else</span> INF,</span>
<span id="cb65-47"><a href="#cb65-47" aria-hidden="true" tabindex="-1"></a>            pq_b[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> pq_b <span class="cf">else</span> INF</span>
<span id="cb65-48"><a href="#cb65-48" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb65-49"><a href="#cb65-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> min_frontier <span class="op">&gt;=</span> best:</span>
<span id="cb65-50"><a href="#cb65-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb65-51"><a href="#cb65-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-52"><a href="#cb65-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best <span class="cf">if</span> best <span class="op">!=</span> INF <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb65-53"><a href="#cb65-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-54"><a href="#cb65-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: upward graph with rank</span></span>
<span id="cb65-55"><a href="#cb65-55" aria-hidden="true" tabindex="-1"></a>up_graph <span class="op">=</span> [</span>
<span id="cb65-56"><a href="#cb65-56" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">4</span>)],  <span class="co"># 0</span></span>
<span id="cb65-57"><a href="#cb65-57" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">3</span>, <span class="dv">7</span>)],          <span class="co"># 1</span></span>
<span id="cb65-58"><a href="#cb65-58" aria-hidden="true" tabindex="-1"></a>    [(<span class="dv">3</span>, <span class="dv">3</span>)],          <span class="co"># 2</span></span>
<span id="cb65-59"><a href="#cb65-59" aria-hidden="true" tabindex="-1"></a>    []                 <span class="co"># 3</span></span>
<span id="cb65-60"><a href="#cb65-60" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb65-61"><a href="#cb65-61" aria-hidden="true" tabindex="-1"></a>rank <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb65-62"><a href="#cb65-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ch_query(up_graph, rank, <span class="dv">0</span>, <span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>8</code></pre>
</section>
<section id="why-it-matters-35" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-35">Why It Matters</h4>
<ul>
<li>Ultra-fast queries, typically microseconds on large graphs</li>
<li>No heuristics, 100% exact shortest paths</li>
<li>Used in real-time GPS navigation, logistics optimization, map routing APIs</li>
<li>Can be combined with ALT, turn penalties, or time-dependent weights</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-35" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-35">A Gentle Proof (Why It Works)</h4>
<p>During preprocessing, every node <span class="math inline">\(v\)</span> is contracted with shortcuts preserving all shortest paths. Each valid shortest path can be represented as an up–down path:</p>
<ul>
<li>ascending ranks (up), then descending ranks (down).</li>
</ul>
<p>By running upward-only searches from both <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>, we explore the up segments of all such paths. The first meeting point <span class="math inline">\(v\)</span> with <span class="math display">\[
\text{dist}_f[v] + \text{dist}_b[v]
\]</span> minimal corresponds to the optimal path.</p>
</section>
<section id="try-it-yourself-35" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-35">Try It Yourself</h4>
<ol type="1">
<li>Visualize ranks and edges before and after contraction.</li>
<li>Compare number of visited nodes with full Dijkstra.</li>
<li>Combine with landmarks (ALT) for even faster queries.</li>
<li>Measure query times on grid vs road-like graphs.</li>
<li>Add path reconstruction by storing parent pointers.</li>
</ol>
</section>
<section id="test-cases-35" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-35">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Query (s,t)</th>
<th>Result</th>
<th>Nodes Visited</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–1–2–3</td>
<td>(0,3)</td>
<td>3 edges</td>
<td>4 (Dijkstra: 4)</td>
</tr>
<tr class="even">
<td>0–1–2–3–4 (line)</td>
<td>(0,4)</td>
<td>path=4</td>
<td>5 (Dijkstra: 5)</td>
</tr>
<tr class="odd">
<td>Grid (5×5)</td>
<td>(corner, corner)</td>
<td>correct</td>
<td>~20x fewer</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-35" class="level4">
<h4 class="anchored" data-anchor-id="complexity-35">Complexity</h4>
<ul>
<li>Preprocessing: handled by CH build (<span class="math inline">\(O(V \log V + E)\)</span>)</li>
<li>Query: <span class="math inline">\(O(\log V)\)</span> (tiny frontier)</li>
<li>Space: <span class="math inline">\(O(V + E + \text{shortcuts})\)</span></li>
<li>Condition: Nonnegative weights, static graph</li>
</ul>
<p>The CH Query Algorithm is the express lane of graph search — prebuilt shortcuts and a smart hierarchy let it fly from source to target in a fraction of the time.</p>
</section>
</section>
<section id="bellmanford-queue-variant-early-termination-spfa" class="level3">
<h3 class="anchored" data-anchor-id="bellmanford-queue-variant-early-termination-spfa">337 Bellman–Ford Queue Variant (Early Termination SPFA)</h3>
<p>The Bellman–Ford Queue Variant, commonly known as SPFA (<em>Shortest Path Faster Algorithm</em>), improves upon the standard Bellman–Ford by using a queue to relax only active vertices, those whose distances were updated. In practice, it’s often much faster, though in the worst case it still runs in <span class="math inline">\(O(VE)\)</span>.</p>
<p>It’s a clever hybrid: Bellman–Ford’s correctness, Dijkstra’s selectivity.</p>
<section id="what-problem-are-we-solving-36" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-36">What Problem Are We Solving?</h4>
<p>We want to compute shortest paths from a single source <span class="math inline">\(s\)</span> in a weighted graph that may include negative edges (but no negative cycles):</p>
<p><span class="math display">\[
w(u, v) \in \mathbb{R}, \quad \text{and no negative cycles}
\]</span></p>
<p>The classic Bellman–Ford relaxes all edges <span class="math inline">\(V-1\)</span> times — too slow when most nodes don’t change often.</p>
<p>SPFA optimizes by:</p>
<ul>
<li>Tracking which nodes were updated last round,</li>
<li>Pushing them into a queue,</li>
<li>Relaxing only their outgoing edges.</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-36" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-36">How Does It Work (Plain Language)?</h4>
<p>The algorithm uses a queue of “active” nodes. When a node’s distance improves, we enqueue it (if not already in the queue). Each iteration pulls one node, relaxes its neighbors, and enqueues those whose distances improve.</p>
<p>It’s like a wavefront of updates spreading only where needed.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 94%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Initialize <span class="math inline">\(\text{dist}[s] = 0\)</span>, others <span class="math inline">\(\infty\)</span></td>
</tr>
<tr class="even">
<td>2</td>
<td>Push <span class="math inline">\(s\)</span> into queue</td>
</tr>
<tr class="odd">
<td>3</td>
<td>While queue not empty:</td>
</tr>
<tr class="even">
<td></td>
<td>Pop <span class="math inline">\(u\)</span>, relax <span class="math inline">\((u, v)\)</span></td>
</tr>
<tr class="odd">
<td></td>
<td>If <span class="math inline">\(\text{dist}[u] + w(u,v) &lt; \text{dist}[v]\)</span>, update and push <span class="math inline">\(v\)</span></td>
</tr>
<tr class="even">
<td>4</td>
<td>Optional: detect negative cycles</td>
</tr>
</tbody>
</table>
<p>When every node leaves the queue with no new updates, we’re done, early termination!</p>
</section>
<section id="tiny-code-c-example-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-example-4">Tiny Code (C Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb67"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXV </span><span class="dv">1000</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> v<span class="op">,</span> w<span class="op">;</span> <span class="op">}</span> Edge<span class="op">;</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>Edge graph<span class="op">[</span>MAXV<span class="op">][</span>MAXV<span class="op">];</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> deg<span class="op">[</span>MAXV<span class="op">],</span> dist<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> in_queue<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> queue<span class="op">[</span>MAXV<span class="op">*</span><span class="dv">10</span><span class="op">],</span> front<span class="op">,</span> back<span class="op">;</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> spfa<span class="op">(</span><span class="dt">int</span> V<span class="op">,</span> <span class="dt">int</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">,</span> in_queue<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>    front <span class="op">=</span> back <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>    queue<span class="op">[</span>back<span class="op">++]</span> <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>    in_queue<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>front <span class="op">!=</span> back<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> queue<span class="op">[</span>front<span class="op">++];</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>front <span class="op">==</span> MAXV<span class="op">*</span><span class="dv">10</span><span class="op">)</span> front <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>        in_queue<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> deg<span class="op">[</span>u<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> graph<span class="op">[</span>u<span class="op">][</span>i<span class="op">].</span>v<span class="op">,</span> w <span class="op">=</span> graph<span class="op">[</span>u<span class="op">][</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w <span class="op">&lt;</span> dist<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>                dist<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w<span class="op">;</span></span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>in_queue<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a>                    queue<span class="op">[</span>back<span class="op">++]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>back <span class="op">==</span> MAXV<span class="op">*</span><span class="dv">10</span><span class="op">)</span> back <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a>                    in_queue<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb67-35"><a href="#cb67-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb67-36"><a href="#cb67-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-37"><a href="#cb67-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-38"><a href="#cb67-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (Simplified)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spfa(V, edges, src):</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>    inq <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> V</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    dist[src] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    dq <span class="op">=</span> deque([src])</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    inq[src] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> dq:</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> dq.popleft()</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>        inq[u] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> inq[v]:</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>                    dq.append(v)</span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>                    inq[v] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-36" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-36">Why It Matters</h4>
<ul>
<li>Often faster than Bellman–Ford on sparse graphs</li>
<li>Early termination when no further updates</li>
<li>Handles negative edges safely</li>
<li>Basis for Min-Cost Max-Flow (SPFA version)</li>
<li>Popular in competitive programming and network routing</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-36" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-36">A Gentle Proof (Why It Works)</h4>
<p>Bellman–Ford relies on edge relaxation propagating shortest paths through <span class="math inline">\(V-1\)</span> iterations.</p>
<p>SPFA dynamically schedules relaxations:</p>
<ul>
<li>Each vertex enters the queue only when <span class="math inline">\(\text{dist}\)</span> improves.</li>
<li>Since each relaxation respects edge constraints, shortest paths converge after at most <span class="math inline">\(V-1\)</span> relaxations per vertex.</li>
</ul>
<p>Thus, SPFA preserves correctness and can terminate earlier when convergence is reached.</p>
<p>Worst case (e.g.&nbsp;negative-weight grid), each vertex relaxes <span class="math inline">\(O(V)\)</span> times, so time is <span class="math inline">\(O(VE)\)</span>. But in practice, it’s near <span class="math inline">\(O(E)\)</span>.</p>
</section>
<section id="try-it-yourself-36" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-36">Try It Yourself</h4>
<ol type="1">
<li>Run on graphs with negative weights but no cycles.</li>
<li>Compare steps with Bellman–Ford, fewer relaxations.</li>
<li>Add a counter per node to detect negative cycles.</li>
<li>Use as core for Min-Cost Max-Flow.</li>
<li>Test dense vs sparse graphs, watch runtime difference.</li>
</ol>
</section>
<section id="test-cases-36" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-36">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0→1(2), 1→2(-1), 0→2(4)</td>
<td>no neg cycle</td>
<td>[0, 2, 1]</td>
</tr>
<tr class="even">
<td>0→1(1), 1→2(2), 2→0(-4)</td>
<td>neg cycle</td>
<td>detect</td>
</tr>
<tr class="odd">
<td>0→1(5), 0→2(2), 2→1(-3)</td>
<td>no cycle</td>
<td>[0, -1, 2]</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-36" class="level4">
<h4 class="anchored" data-anchor-id="complexity-36">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(VE)\)</span> worst, often <span class="math inline">\(O(E)\)</span> average</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Condition: Negative edges allowed, no negative cycles</li>
</ul>
<p>The Bellman–Ford Queue Variant is the smart scheduler — instead of looping blindly, it listens for updates and moves only where change happens.</p>
</section>
</section>
<section id="dijkstra-with-early-stop" class="level3">
<h3 class="anchored" data-anchor-id="dijkstra-with-early-stop">338 Dijkstra with Early Stop</h3>
<p>Dijkstra with Early Stop is a target-aware optimization of the classic Dijkstra’s algorithm. It leverages the fact that Dijkstra processes vertices in nondecreasing order of distance, so as soon as the target node is extracted from the priority queue, its shortest distance is final and the search can safely terminate.</p>
<p>This simple tweak can cut runtime dramatically for single-pair shortest path queries.</p>
<section id="what-problem-are-we-solving-37" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-37">What Problem Are We Solving?</h4>
<p>In standard Dijkstra’s algorithm, the search continues until all reachable vertices have been settled, even if we only care about one destination <span class="math inline">\(t\)</span>. That’s wasteful for point-to-point routing, where we only need <span class="math inline">\(\text{dist}(s, t)\)</span>.</p>
<p>The Early Stop version stops immediately when <span class="math inline">\(t\)</span> is extracted from the priority queue:</p>
<p><span class="math display">\[
\text{dist}(t) = \text{final shortest distance}
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-37" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-37">How Does It Work (Plain Language)?</h4>
<p>Same setup as Dijkstra, but with an exit condition:</p>
<ol type="1">
<li><p>Initialize <span class="math inline">\(\text{dist}[s] = 0\)</span>, all others <span class="math inline">\(\infty\)</span>.</p></li>
<li><p>Push <span class="math inline">\((0, s)\)</span> into priority queue.</p></li>
<li><p>While queue not empty:</p>
<ul>
<li><p>Pop <span class="math inline">\((d, u)\)</span> with smallest tentative distance.</p></li>
<li><p>If <span class="math inline">\(u = t\)</span>: stop, we found the shortest path.</p></li>
<li><p>For each neighbor <span class="math inline">\((v, w)\)</span>:</p>
<ul>
<li>If <span class="math inline">\(\text{dist}[u] + w &lt; \text{dist}[v]\)</span>, relax and push.</li>
</ul></li>
</ul></li>
</ol>
<p>Because Dijkstra’s invariant guarantees we always pop nodes in order of increasing distance, the first time we pop <span class="math inline">\(t\)</span>, we have found its true shortest distance.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Extract min node <span class="math inline">\(u\)</span></td>
<td>Expand neighbors</td>
</tr>
<tr class="even">
<td>If <span class="math inline">\(u = t\)</span></td>
<td>Stop immediately</td>
</tr>
<tr class="odd">
<td>Else</td>
<td>Continue</td>
</tr>
</tbody>
</table>
<p>No need to explore the entire graph.</p>
</section>
<section id="tiny-code-python-example-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-8">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra_early_stop(V, edges, s, t):</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>        graph[v].append((u, w))  <span class="co"># undirected</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [INF] <span class="op">*</span> V</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>    dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, s)]</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>        d, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> d <span class="op">&gt;</span> dist[u]:</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dist[t]</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[u] <span class="op">+</span> w <span class="op">&lt;</span> dist[v]:</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (dist[v], v))</span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>  <span class="co"># unreachable</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>),</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>),</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>),</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dijkstra_early_stop(<span class="dv">5</span>, edges, <span class="dv">0</span>, <span class="dv">2</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>5</code></pre>
</section>
<section id="why-it-matters-37" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-37">Why It Matters</h4>
<ul>
<li>Early termination = fewer expansions = faster queries</li>
<li>Ideal for point-to-point routing</li>
<li>Combines well with A* (guided early stop) and ALT</li>
<li>Simple to implement (just one <code>if</code> condition)</li>
</ul>
<p>Used in:</p>
<ul>
<li>GPS navigation (city-to-city routes)</li>
<li>Network routing (specific endpoints)</li>
<li>Game AI pathfinding</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-37" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-37">A Gentle Proof (Why It Works)</h4>
<p>Dijkstra’s correctness relies on the fact that when a node is extracted from the heap, its shortest distance is final (no smaller distance can appear later).</p>
<p>Thus, when <span class="math inline">\(t\)</span> is extracted: <span class="math display">\[
\text{dist}(t) = \min_{u \in V} \text{dist}(u)
\]</span> and any other unvisited vertex has <span class="math inline">\(\text{dist}[v] \ge \text{dist}[t]\)</span>.</p>
<p>Therefore, stopping immediately when <span class="math inline">\(u = t\)</span> preserves correctness.</p>
</section>
<section id="try-it-yourself-37" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-37">Try It Yourself</h4>
<ol type="1">
<li>Compare runtime vs full Dijkstra on large graphs.</li>
<li>Visualize heap operations with and without early stop.</li>
<li>Apply to grid graphs (start vs goal corner).</li>
<li>Combine with A* to reduce visited nodes even more.</li>
<li>Test on disconnected graphs (target unreachable).</li>
</ol>
</section>
<section id="test-cases-37" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-37">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 15%">
<col style="width: 22%">
<col style="width: 25%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Source</th>
<th>Target</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain 0–1–2–3</td>
<td>0</td>
<td>3</td>
<td>3 edges</td>
<td>Stops at 3</td>
</tr>
<tr class="even">
<td>Star (0–others)</td>
<td>0</td>
<td>4</td>
<td>direct edge</td>
<td>1 step</td>
</tr>
<tr class="odd">
<td>Grid</td>
<td>(0,0)→(n,n)</td>
<td>Early stop saves</td>
<td>Many nodes skipped</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-37" class="level4">
<h4 class="anchored" data-anchor-id="complexity-37">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log V)\)</span> (best-case ≪ full graph)</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Condition: Nonnegative weights</li>
</ul>
<p>Dijkstra with Early Stop is the sniper version — it locks onto the target and halts the moment the job’s done, saving every wasted move.</p>
</section>
</section>
<section id="goal-directed-search" class="level3">
<h3 class="anchored" data-anchor-id="goal-directed-search">339 Goal-Directed Search</h3>
<p>Goal-Directed Search is a general strategy for focusing graph exploration toward a specific target, rather than scanning the entire space. It modifies shortest-path algorithms (like BFS or Dijkstra) by biasing expansions in the direction of the goal using geometry, landmarks, or precomputed heuristics.</p>
<p>When the bias is admissible (never overestimates cost), it still guarantees optimal paths while greatly reducing explored nodes.</p>
<section id="what-problem-are-we-solving-38" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-38">What Problem Are We Solving?</h4>
<p>In standard BFS or Dijkstra, exploration radiates uniformly outward, even in directions that clearly don’t lead to the target. For large graphs (grids, road maps), that’s wasteful.</p>
<p>We need a way to steer the search toward the destination without losing correctness.</p>
<p>Formally, for source <span class="math inline">\(s\)</span> and target <span class="math inline">\(t\)</span>, we want to find</p>
<p><span class="math display">\[
\text{dist}(s, t) = \min_{\text{path } P: s \to t} \sum_{(u,v)\in P} w(u,v)
\]</span></p>
<p>while visiting as few nodes as possible.</p>
</section>
<section id="how-does-it-work-plain-language-38" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-38">How Does It Work (Plain Language)?</h4>
<p>Goal-directed search attaches a heuristic bias to each node’s priority in the queue, so nodes closer (or more promising) to the target are expanded earlier.</p>
<p>Typical scoring rule:</p>
<p><span class="math display">\[
f(v) = g(v) + \lambda \cdot h(v)
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(g(v)\)</span> = distance from <span class="math inline">\(s\)</span> so far,</li>
<li><span class="math inline">\(h(v)\)</span> = heuristic estimate from <span class="math inline">\(v\)</span> to <span class="math inline">\(t\)</span>,</li>
<li><span class="math inline">\(\lambda\)</span> = bias factor (often <span class="math inline">\(1\)</span> for A*, or <span class="math inline">\(&lt;1\)</span> for partial guidance).</li>
</ul>
<p>Admissible heuristics (<span class="math inline">\(h(v) \le \text{true distance}(v,t)\)</span>) preserve optimality. Even simple directional heuristics, like Euclidean or Manhattan distance, can dramatically reduce search space.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 36%">
<col style="width: 18%">
<col style="width: 1%">
<col style="width: 14%">
<col style="width: 1%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>Heuristic Type</th>
<th>Definition</th>
<th>Use Case</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Euclidean</td>
<td><span class="math inline">\(\sqrt{(x_v-x_t)^2+(y_v-y_t)^2}\)</span></td>
<td>geometric graphs</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Manhattan</td>
<td>$</td>
<td>x_v-x_t</td>
<td>+</td>
<td>y_v-y_t</td>
<td>$</td>
<td>grid worlds</td>
</tr>
<tr class="odd">
<td>Landmark (ALT)</td>
<td>$</td>
<td>d(L,t)-d(L,v)</td>
<td>$</td>
<td>road networks</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-9">Tiny Code (Python Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> goal_directed_search(V, edges, coords, s, t):</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>        graph[v].append((u, w))  <span class="co"># undirected</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> heuristic(v):</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>        x1, y1 <span class="op">=</span> coords[v]</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>        x2, y2 <span class="op">=</span> coords[t]</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> math.sqrt((x1 <span class="op">-</span> x2)<span class="dv">2</span> <span class="op">+</span> (y1 <span class="op">-</span> y2)<span class="dv">2</span>)</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>    dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(heuristic(s), s)]</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>        f, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dist[u]</span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>            g_new <span class="op">=</span> dist[u] <span class="op">+</span> w</span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> g_new <span class="op">&lt;</span> dist[v]:</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>                dist[v] <span class="op">=</span> g_new</span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>                f_v <span class="op">=</span> g_new <span class="op">+</span> heuristic(v)</span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (f_v, v))</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">2</span>,<span class="dv">1</span>)]</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>)]</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(goal_directed_search(<span class="dv">4</span>, edges, coords, <span class="dv">0</span>, <span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>3</code></pre>
</section>
<section id="why-it-matters-38" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-38">Why It Matters</h4>
<ul>
<li>Fewer node expansions than unguided Dijkstra</li>
<li>Naturally integrates with A*, ALT, CH, landmark heuristics</li>
<li>Applicable to navigation, pathfinding, planning</li>
<li>Easily adapted to grids, 3D spaces, or weighted networks</li>
</ul>
<p>Used in:</p>
<ul>
<li>GPS navigation</li>
<li>AI game agents</li>
<li>Robotics (motion planning)</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-38" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-38">A Gentle Proof (Why It Works)</h4>
<p>When <span class="math inline">\(h(v)\)</span> is admissible, <span class="math display">\[
h(v) \le \text{true distance}(v,t),
\]</span> then <span class="math inline">\(f(v) = g(v) + h(v)\)</span> never underestimates the cost of the optimal path through <span class="math inline">\(v\)</span>.</p>
<p>Therefore, the first time the target <span class="math inline">\(t\)</span> is popped from the queue, <span class="math inline">\(\text{dist}(t)\)</span> is guaranteed to be the true shortest distance.</p>
<p>If <span class="math inline">\(h\)</span> is also consistent, then <span class="math display">\[
h(u) \le w(u,v) + h(v),
\]</span> which ensures the priority order behaves like Dijkstra’s, preserving monotonicity.</p>
</section>
<section id="try-it-yourself-38" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-38">Try It Yourself</h4>
<ol type="1">
<li><p>Run with <span class="math inline">\(h=0\)</span> → becomes normal Dijkstra.</p></li>
<li><p>Try different <span class="math inline">\(\lambda\)</span>:</p>
<ul>
<li><span class="math inline">\(\lambda=1\)</span> → A*</li>
<li><span class="math inline">\(\lambda&lt;1\)</span> → softer guidance (more exploration).</li>
</ul></li>
<li><p>Compare expansions with plain Dijkstra on a grid.</p></li>
<li><p>Visualize frontier growth, goal-directed forms a cone instead of a circle.</p></li>
<li><p>Test non-admissible <span class="math inline">\(h\)</span> (may speed up but lose optimality).</p></li>
</ol>
</section>
<section id="test-cases-38" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-38">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Heuristic</th>
<th>Result</th>
<th>Nodes Visited</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4-node line</td>
<td>Euclidean</td>
<td>3</td>
<td>fewer</td>
</tr>
<tr class="even">
<td>Grid 5×5</td>
<td>Manhattan</td>
<td>Optimal</td>
<td>~½ nodes</td>
</tr>
<tr class="odd">
<td>Zero heuristic</td>
<td><span class="math inline">\(h=0\)</span></td>
<td>Dijkstra</td>
<td>all nodes</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-38" class="level4">
<h4 class="anchored" data-anchor-id="complexity-38">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log V)\)</span> (fewer relaxations in practice)</li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
<li>Condition: Nonnegative weights, admissible <span class="math inline">\(h(v)\)</span></li>
</ul>
<p>Goal-Directed Search is the compass-guided Dijkstra — it still guarantees the shortest route, but marches confidently toward the goal instead of wandering in every direction.</p>
</section>
</section>
<section id="yens-k-shortest-paths" class="level3">
<h3 class="anchored" data-anchor-id="yens-k-shortest-paths">340 Yen’s K Shortest Paths</h3>
<p>Yen’s Algorithm finds not just the single shortest path, but the K shortest loopless paths between two nodes in a weighted directed graph. It’s a natural extension of Dijkstra’s, instead of stopping at the first solution, it systematically explores path deviations to discover the next-best routes in ascending order of total length.</p>
<p>Used widely in network routing, multi-route planning, and alternatives in navigation systems.</p>
<section id="what-problem-are-we-solving-39" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-39">What Problem Are We Solving?</h4>
<p>Given a graph <span class="math inline">\(G = (V, E)\)</span> with nonnegative edge weights, a source <span class="math inline">\(s\)</span>, and a target <span class="math inline">\(t\)</span>, we want to compute the first <span class="math inline">\(K\)</span> distinct shortest paths:</p>
<p><span class="math display">\[
P_1, P_2, \dots, P_K
\]</span></p>
<p>ordered by total weight:</p>
<p><span class="math display">\[
\text{len}(P_1) \le \text{len}(P_2) \le \cdots \le \text{len}(P_K)
\]</span></p>
<p>Each path must be simple (no repeated nodes).</p>
</section>
<section id="how-does-it-work-plain-language-39" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-39">How Does It Work (Plain Language)?</h4>
<p>Yen’s Algorithm builds upon Dijkstra’s algorithm and the deviation path concept.</p>
<ol type="1">
<li><p>Compute the shortest path <span class="math inline">\(P_1\)</span> using Dijkstra.</p></li>
<li><p>For each <span class="math inline">\(i = 2, \dots, K\)</span>:</p>
<ul>
<li><p>Let <span class="math inline">\(P_{i-1}\)</span> be the previous path.</p></li>
<li><p>For each node (spur node) in <span class="math inline">\(P_{i-1}\)</span>:</p>
<ul>
<li><p>Split the path into root path (prefix up to spur node).</p></li>
<li><p>Temporarily remove:</p>
<ul>
<li>Any edge that would recreate a previously found path.</li>
<li>Any node in the root path (except spur node) to prevent cycles.</li>
</ul></li>
<li><p>Run Dijkstra from spur node to <span class="math inline">\(t\)</span>.</p></li>
<li><p>Combine root path + spur path → candidate path.</p></li>
</ul></li>
<li><p>Among all candidates, choose the shortest one not yet selected.</p></li>
<li><p>Add it as <span class="math inline">\(P_i\)</span>.</p></li>
</ul></li>
</ol>
<p>Repeat until <span class="math inline">\(K\)</span> paths are found or no candidates remain.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Operation</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><span class="math inline">\(P_1\)</span> = Dijkstra(s, t)</td>
<td>base path</td>
</tr>
<tr class="even">
<td>2</td>
<td>Deviation from prefixes</td>
<td>explore alternatives</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Collect candidates</td>
<td>min-heap</td>
</tr>
<tr class="even">
<td>4</td>
<td>Select shortest</td>
<td>next path</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-example-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-10">Tiny Code (Python Example)</h4>
<p>A simplified version for small graphs:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dijkstra(graph, s, t):</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, s, [s])]</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>        d, u, path <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (d, path)</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">in</span> seen: </span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>        seen.add(u)</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> seen:</span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (d <span class="op">+</span> w, v, path <span class="op">+</span> [v]))</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> yen_k_shortest_paths(graph, s, t, K):</span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> []</span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> []</span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>    first <span class="op">=</span> dijkstra(graph, s, t)</span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> first:</span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> A</span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>    A.append(first)</span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, K):</span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a>        prev_path <span class="op">=</span> A[k <span class="op">-</span> <span class="dv">1</span>][<span class="dv">1</span>]</span>
<span id="cb75-27"><a href="#cb75-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(prev_path) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb75-28"><a href="#cb75-28" aria-hidden="true" tabindex="-1"></a>            spur_node <span class="op">=</span> prev_path[i]</span>
<span id="cb75-29"><a href="#cb75-29" aria-hidden="true" tabindex="-1"></a>            root_path <span class="op">=</span> prev_path[:i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb75-30"><a href="#cb75-30" aria-hidden="true" tabindex="-1"></a>            removed_edges <span class="op">=</span> []</span>
<span id="cb75-31"><a href="#cb75-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Temporarily remove edges</span></span>
<span id="cb75-32"><a href="#cb75-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> d, p <span class="kw">in</span> A:</span>
<span id="cb75-33"><a href="#cb75-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> p[:i <span class="op">+</span> <span class="dv">1</span>] <span class="op">==</span> root_path <span class="kw">and</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(p):</span>
<span id="cb75-34"><a href="#cb75-34" aria-hidden="true" tabindex="-1"></a>                    u <span class="op">=</span> p[i]</span>
<span id="cb75-35"><a href="#cb75-35" aria-hidden="true" tabindex="-1"></a>                    v <span class="op">=</span> p[i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb75-36"><a href="#cb75-36" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> e <span class="kw">in</span> graph[u]:</span>
<span id="cb75-37"><a href="#cb75-37" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> e[<span class="dv">0</span>] <span class="op">==</span> v:</span>
<span id="cb75-38"><a href="#cb75-38" aria-hidden="true" tabindex="-1"></a>                            graph[u].remove(e)</span>
<span id="cb75-39"><a href="#cb75-39" aria-hidden="true" tabindex="-1"></a>                            removed_edges.append((u, e))</span>
<span id="cb75-40"><a href="#cb75-40" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">break</span></span>
<span id="cb75-41"><a href="#cb75-41" aria-hidden="true" tabindex="-1"></a>            spur <span class="op">=</span> dijkstra(graph, spur_node, t)</span>
<span id="cb75-42"><a href="#cb75-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> spur:</span>
<span id="cb75-43"><a href="#cb75-43" aria-hidden="true" tabindex="-1"></a>                total_path <span class="op">=</span> root_path[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> spur[<span class="dv">1</span>]</span>
<span id="cb75-44"><a href="#cb75-44" aria-hidden="true" tabindex="-1"></a>                total_cost <span class="op">=</span> <span class="bu">sum</span>(graph[u][v][<span class="dv">1</span>] <span class="cf">for</span> u, v <span class="kw">in</span> <span class="bu">zip</span>(total_path, total_path[<span class="dv">1</span>:])) <span class="cf">if</span> <span class="va">False</span> <span class="cf">else</span> spur[<span class="dv">0</span>] <span class="op">+</span> <span class="bu">sum</span>(<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> root_path)</span>
<span id="cb75-45"><a href="#cb75-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (total_cost, total_path) <span class="kw">not</span> <span class="kw">in</span> B:</span>
<span id="cb75-46"><a href="#cb75-46" aria-hidden="true" tabindex="-1"></a>                    B.append((total_cost, total_path))</span>
<span id="cb75-47"><a href="#cb75-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> u, e <span class="kw">in</span> removed_edges:</span>
<span id="cb75-48"><a href="#cb75-48" aria-hidden="true" tabindex="-1"></a>                graph[u].append(e)</span>
<span id="cb75-49"><a href="#cb75-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> B:</span>
<span id="cb75-50"><a href="#cb75-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb75-51"><a href="#cb75-51" aria-hidden="true" tabindex="-1"></a>        B.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>])</span>
<span id="cb75-52"><a href="#cb75-52" aria-hidden="true" tabindex="-1"></a>        A.append(B.pop(<span class="dv">0</span>))</span>
<span id="cb75-53"><a href="#cb75-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> {</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [(<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">2</span>)],</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [(<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">3</span>, <span class="dv">3</span>)],</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [(<span class="dv">3</span>, <span class="dv">1</span>)],</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: []</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(yen_k_shortest_paths(graph, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">3</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>[(3, [0, 1, 2, 3]), (4, [0, 2, 3]), (5, [0, 1, 3])]</code></pre>
</section>
<section id="why-it-matters-39" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-39">Why It Matters</h4>
<ul>
<li>Provides multiple distinct routes, not just one</li>
<li>Used in multi-path routing, backup planning, logistics optimization</li>
<li>Guarantees simple paths (no loops)</li>
<li>Reuses Dijkstra, easy to integrate with existing solvers</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-39" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-39">A Gentle Proof (Why It Works)</h4>
<p>Every <span class="math inline">\(P_i\)</span> is generated by deviating from earlier paths at some spur node, ensuring uniqueness. Dijkstra ensures each spur path is locally shortest. Since all candidates are stored and selected by global order, the sequence <span class="math inline">\(P_1, P_2, \dots, P_K\)</span> is globally sorted by total cost.</p>
<p>Thus: <span class="math display">\[
\text{len}(P_1) \le \text{len}(P_2) \le \cdots \le \text{len}(P_K)
\]</span></p>
<p>and each path is simple.</p>
</section>
<section id="try-it-yourself-39" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-39">Try It Yourself</h4>
<ol type="1">
<li>Generate the 3 shortest paths in a small network.</li>
<li>Compare with Eppstein’s algorithm (faster for large K).</li>
<li>Remove edges dynamically and re-run, observe reordering.</li>
<li>Visualize path tree (root = <span class="math inline">\(s\)</span>, branches = deviations).</li>
<li>Adapt for undirected or bi-directional graphs.</li>
</ol>
</section>
<section id="test-cases-39" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-39">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 13%">
<col style="width: 4%">
<col style="width: 21%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th><span class="math inline">\(s\)</span></th>
<th><span class="math inline">\(t\)</span></th>
<th><span class="math inline">\(K\)</span></th>
<th>Paths</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line 0–1–2–3</td>
<td>0</td>
<td>3</td>
<td>2</td>
<td>one main, one deviation</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>0–1–2, 0–2, 0–1–0–2 (if allowed)</td>
</tr>
<tr class="odd">
<td>Weighted grid</td>
<td>start–goal</td>
<td>3</td>
<td>alternate routes</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-39" class="level4">
<h4 class="anchored" data-anchor-id="complexity-39">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(K \cdot V \cdot (E + V \log V))\)</span></li>
<li>Space: <span class="math inline">\(O(KV)\)</span></li>
<li>Condition: Nonnegative weights, finite paths</li>
</ul>
<p>Yen’s Algorithm is the explorer’s Dijkstra, it doesn’t stop at the first road found but keeps discovering better detours, one deviation at a time.</p>
</section>
</section>
</section>
<section id="section-35.-minimum-spanning-trees" class="level2">
<h2 class="anchored" data-anchor-id="section-35.-minimum-spanning-trees">Section 35. Minimum Spanning Trees</h2>
<section id="kruskals-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="kruskals-algorithm">341 Kruskal’s Algorithm</h3>
<p>Kruskal’s algorithm builds a minimum spanning tree (MST) by repeatedly adding the lightest edge that does not create a cycle. It uses a disjoint set union (DSU) data structure to track components efficiently.</p>
<section id="what-problem-are-we-solving-40" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-40">What Problem Are We Solving?</h4>
<p>Given a connected, undirected, weighted graph <span class="math inline">\(G=(V,E,w)\)</span>, find a subset <span class="math inline">\(T\subseteq E\)</span> such that:</p>
<ul>
<li><span class="math inline">\(T\)</span> connects all vertices,</li>
<li><span class="math inline">\(|T|=|V|-1\)</span>,</li>
<li><span class="math inline">\(\sum_{e\in T}w(e)\)</span> is minimized.</li>
</ul>
<p>If the graph is not connected, Kruskal builds a minimum spanning forest.</p>
</section>
<section id="how-does-it-work-plain-language-40" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-40">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Sort all edges by nondecreasing weight.</p></li>
<li><p>Initialize DSU with each vertex in its own set.</p></li>
<li><p>Scan edges in order. For edge <span class="math inline">\((u,v)\)</span>:</p>
<ul>
<li>If <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are in different sets, add the edge to the MST and union their sets.</li>
<li>Otherwise, skip it to avoid a cycle.</li>
</ul></li>
<li><p>Stop when you have <span class="math inline">\(|V|-1\)</span> edges.</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>DSU effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sort edges</td>
<td>Light to heavy</td>
<td>None</td>
</tr>
<tr class="even">
<td>Check <span class="math inline">\((u,v)\)</span></td>
<td>If find(u) ≠ find(v)</td>
<td>union(u,v) and keep edge</td>
</tr>
<tr class="odd">
<td>Cycle case</td>
<td>If find(u) = find(v)</td>
<td>skip edge</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code">Tiny Code</h4>
<p>C (DSU + Kruskal)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb78"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> <span class="dt">int</span> u<span class="op">,</span> v<span class="op">;</span> <span class="dt">int</span> w<span class="op">;</span> <span class="op">}</span> Edge<span class="op">;</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>p<span class="op">,</span> <span class="op">*</span>r<span class="op">;</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> DSU<span class="op">;</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>DSU make_dsu<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>    DSU d<span class="op">;</span> d<span class="op">.</span>n <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>    d<span class="op">.</span>p <span class="op">=</span> malloc<span class="op">(</span>n <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    d<span class="op">.</span>r <span class="op">=</span> malloc<span class="op">(</span>n <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span> d<span class="op">.</span>p<span class="op">[</span>i<span class="op">]=</span>i<span class="op">;</span> d<span class="op">.</span>r<span class="op">[</span>i<span class="op">]=</span><span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find<span class="op">(</span>DSU <span class="op">*</span>d<span class="op">,</span> <span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>d<span class="op">-&gt;</span>p<span class="op">[</span>x<span class="op">]!=</span>x<span class="op">)</span> d<span class="op">-&gt;</span>p<span class="op">[</span>x<span class="op">]=</span>find<span class="op">(</span>d<span class="op">,</span> d<span class="op">-&gt;</span>p<span class="op">[</span>x<span class="op">]);</span></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">-&gt;</span>p<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> unite<span class="op">(</span>DSU <span class="op">*</span>d<span class="op">,</span> <span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">){</span></span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a>    a<span class="op">=</span>find<span class="op">(</span>d<span class="op">,</span>a<span class="op">);</span> b<span class="op">=</span>find<span class="op">(</span>d<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>a<span class="op">==</span>b<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>d<span class="op">-&gt;</span>r<span class="op">[</span>a<span class="op">]&lt;</span>d<span class="op">-&gt;</span>r<span class="op">[</span>b<span class="op">])</span> d<span class="op">-&gt;</span>p<span class="op">[</span>a<span class="op">]=</span>b<span class="op">;</span></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>d<span class="op">-&gt;</span>r<span class="op">[</span>b<span class="op">]&lt;</span>d<span class="op">-&gt;</span>r<span class="op">[</span>a<span class="op">])</span> d<span class="op">-&gt;</span>p<span class="op">[</span>b<span class="op">]=</span>a<span class="op">;</span></span>
<span id="cb78-27"><a href="#cb78-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span> d<span class="op">-&gt;</span>p<span class="op">[</span>b<span class="op">]=</span>a<span class="op">;</span> d<span class="op">-&gt;</span>r<span class="op">[</span>a<span class="op">]++;</span> <span class="op">}</span></span>
<span id="cb78-28"><a href="#cb78-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-29"><a href="#cb78-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmp_edge<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> A<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span><span class="op">*</span> B<span class="op">){</span></span>
<span id="cb78-30"><a href="#cb78-30" aria-hidden="true" tabindex="-1"></a>    Edge <span class="op">*</span>a<span class="op">=(</span>Edge<span class="op">*)</span>A<span class="op">,</span> <span class="op">*</span>b<span class="op">=(</span>Edge<span class="op">*)</span>B<span class="op">;</span></span>
<span id="cb78-31"><a href="#cb78-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">-&gt;</span>w <span class="op">-</span> b<span class="op">-&gt;</span>w<span class="op">;</span></span>
<span id="cb78-32"><a href="#cb78-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-33"><a href="#cb78-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-34"><a href="#cb78-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">){</span></span>
<span id="cb78-35"><a href="#cb78-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb78-36"><a href="#cb78-36" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">,</span> <span class="op">&amp;</span>m<span class="op">);</span></span>
<span id="cb78-37"><a href="#cb78-37" aria-hidden="true" tabindex="-1"></a>    Edge <span class="op">*</span>E <span class="op">=</span> malloc<span class="op">(</span>m <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>Edge<span class="op">));</span></span>
<span id="cb78-38"><a href="#cb78-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>m<span class="op">;</span>i<span class="op">++)</span> scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>E<span class="op">[</span>i<span class="op">].</span>u<span class="op">,</span> <span class="op">&amp;</span>E<span class="op">[</span>i<span class="op">].</span>v<span class="op">,</span> <span class="op">&amp;</span>E<span class="op">[</span>i<span class="op">].</span>w<span class="op">);</span></span>
<span id="cb78-39"><a href="#cb78-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-40"><a href="#cb78-40" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>E<span class="op">,</span> m<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Edge<span class="op">),</span> cmp_edge<span class="op">);</span></span>
<span id="cb78-41"><a href="#cb78-41" aria-hidden="true" tabindex="-1"></a>    DSU d <span class="op">=</span> make_dsu<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb78-42"><a href="#cb78-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-43"><a href="#cb78-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> taken <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-44"><a href="#cb78-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> cost <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-45"><a href="#cb78-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>m <span class="op">&amp;&amp;</span> taken <span class="op">&lt;</span> n<span class="op">-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb78-46"><a href="#cb78-46" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a <span class="op">=</span> find<span class="op">(&amp;</span>d<span class="op">,</span> E<span class="op">[</span>i<span class="op">].</span>u<span class="op">),</span> b <span class="op">=</span> find<span class="op">(&amp;</span>d<span class="op">,</span> E<span class="op">[</span>i<span class="op">].</span>v<span class="op">);</span></span>
<span id="cb78-47"><a href="#cb78-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>a <span class="op">!=</span> b<span class="op">){</span></span>
<span id="cb78-48"><a href="#cb78-48" aria-hidden="true" tabindex="-1"></a>            unite<span class="op">(&amp;</span>d<span class="op">,</span> a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb78-49"><a href="#cb78-49" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">+=</span> E<span class="op">[</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb78-50"><a href="#cb78-50" aria-hidden="true" tabindex="-1"></a>            taken<span class="op">++;</span></span>
<span id="cb78-51"><a href="#cb78-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb78-52"><a href="#cb78-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-53"><a href="#cb78-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>taken <span class="op">!=</span> n<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span> printf<span class="op">(</span><span class="st">"Graph not connected</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb78-54"><a href="#cb78-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span> printf<span class="op">(</span><span class="st">"MST cost: </span><span class="sc">%lld\n</span><span class="st">"</span><span class="op">,</span> cost<span class="op">);</span> <span class="op">}</span></span>
<span id="cb78-55"><a href="#cb78-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-56"><a href="#cb78-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python (DSU + Kruskal)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DSU:</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.p <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.r <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, x):</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.p[x] <span class="op">!=</span> x:</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.p[x] <span class="op">=</span> <span class="va">self</span>.find(<span class="va">self</span>.p[x])</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.p[x]</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(<span class="va">self</span>, a, b):</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> <span class="va">self</span>.find(a), <span class="va">self</span>.find(b)</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">==</span> b: <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.r[a] <span class="op">&lt;</span> <span class="va">self</span>.r[b]: <span class="va">self</span>.p[a] <span class="op">=</span> b</span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.r[b] <span class="op">&lt;</span> <span class="va">self</span>.r[a]: <span class="va">self</span>.p[b] <span class="op">=</span> a</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="va">self</span>.p[b] <span class="op">=</span> a<span class="op">;</span> <span class="va">self</span>.r[a] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kruskal(n, edges):</span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> <span class="bu">sorted</span>(edges)</span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>    dsu <span class="op">=</span> DSU(n)</span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a>    mst <span class="op">=</span> []</span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w, u, v <span class="kw">in</span> edges:</span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dsu.union(u, v):</span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">+=</span> w</span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>            mst.append((u, v, w))</span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(mst) <span class="op">==</span> n<span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost, mst</span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">3</span>)]</span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(kruskal(n, edges))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-40" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-40">Why It Matters</h4>
<ul>
<li>Simple and fast with sorting plus DSU.</li>
<li>Works well on sparse graphs.</li>
<li>Produces an MST that minimizes total edge weight.</li>
<li>Easy to adapt for minimum spanning forest on disconnected graphs.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-40" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-40">A Gentle Proof (Why It Works)</h4>
<p>Kruskal relies on the cut property: Let <span class="math inline">\(S \subset V\)</span> be any proper subset and consider the cut <span class="math inline">\((S, V \setminus S)\)</span>. The lightest edge crossing the cut is safe to include in some MST.</p>
<p>Sorting edges by weight and always taking the next lightest that connects two different components is equivalent to repeatedly applying the cut property to the partition defined by current DSU components. This never creates a cycle and never excludes the possibility of an optimal MST. By induction on the number of chosen edges, the final set is an MST.</p>
</section>
<section id="try-it-yourself-40" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-40">Try It Yourself</h4>
<ol type="1">
<li>Generate random sparse graphs and compare Kruskal vs Prim.</li>
<li>Remove an edge from the MST and recompute to observe changes.</li>
<li>Force ties in edge weights and confirm multiple valid MSTs.</li>
<li>Run on a disconnected graph to obtain a minimum spanning forest.</li>
<li>Log chosen edges to visualize the growth of components.</li>
</ol>
</section>
<section id="test-cases-40" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-40">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 52%">
<col style="width: 20%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges <span class="math inline">\((u,v,w)\)</span></th>
<th>MST Edges</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>(0,1,1), (1,2,2), (0,2,3)</td>
<td>(0,1,1), (1,2,2)</td>
<td>3</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2)</td>
<td>any 3 of weight 1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>Disconnected</td>
<td>two separate triangles</td>
<td>MST per component</td>
<td>sum of two</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-40" class="level4">
<h4 class="anchored" data-anchor-id="complexity-40">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log E)\)</span> for sorting plus almost linear DSU, which is <span class="math inline">\(O(E \alpha(V))\)</span>. Usually written as <span class="math inline">\(O(E \log E)\)</span> or <span class="math inline">\(O(E \log V)\)</span>.</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span>.</li>
<li>Output size: <span class="math inline">\(|V|-1\)</span> edges for a connected graph.</li>
</ul>
<p>Kruskal is the sort then stitch approach to MSTs. Sort edges globally, then stitch components locally with DSU until the tree locks into place.</p>
</section>
</section>
<section id="prims-algorithm-heap" class="level3">
<h3 class="anchored" data-anchor-id="prims-algorithm-heap">342 Prim’s Algorithm (Heap)</h3>
<p>Prim’s algorithm builds a minimum spanning tree (MST) by growing a connected subtree one vertex at a time, always choosing the lightest edge that connects a vertex inside the tree to one outside. It’s a greedy algorithm, often implemented with a min-heap for efficiency.</p>
<section id="what-problem-are-we-solving-41" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-41">What Problem Are We Solving?</h4>
<p>Given a connected, undirected, weighted graph <span class="math inline">\(G=(V,E,w)\)</span>, find a subset of edges <span class="math inline">\(T\subseteq E\)</span> such that:</p>
<ul>
<li><span class="math inline">\(T\)</span> connects all vertices,</li>
<li><span class="math inline">\(|T|=|V|-1\)</span>,</li>
<li><span class="math inline">\(\sum_{e\in T}w(e)\)</span> is minimized.</li>
</ul>
<p>Prim’s algorithm grows the MST from a single seed vertex.</p>
</section>
<section id="how-does-it-work-plain-language-41" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-41">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Choose any starting vertex <span class="math inline">\(s\)</span>.</p></li>
<li><p>Initialize all vertices with <span class="math inline">\(\text{key}[v]=\infty\)</span>, except <span class="math inline">\(\text{key}[s]=0\)</span>.</p></li>
<li><p>Use a min-heap (priority queue) keyed by edge weight.</p></li>
<li><p>Repeatedly extract the vertex <span class="math inline">\(u\)</span> with the smallest key (edge weight):</p>
<ul>
<li><p>Mark <span class="math inline">\(u\)</span> as part of the MST.</p></li>
<li><p>For each neighbor <span class="math inline">\(v\)</span> of <span class="math inline">\(u\)</span>:</p>
<ul>
<li>If <span class="math inline">\(v\)</span> is not yet in the MST and <span class="math inline">\(w(u,v)&lt;\text{key}[v]\)</span>, update <span class="math inline">\(\text{key}[v]=w(u,v)\)</span> and set <span class="math inline">\(\text{parent}[v]=u\)</span>.</li>
</ul></li>
</ul></li>
<li><p>Continue until all vertices are included.</p></li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Initialize</td>
<td>Choose start vertex</td>
<td><span class="math inline">\(\text{key}[s]=0\)</span></td>
</tr>
<tr class="even">
<td>Extract min</td>
<td>Add lightest edge</td>
<td>Expands MST</td>
</tr>
<tr class="odd">
<td>Relax neighbors</td>
<td>Update cheaper edges</td>
<td>Maintain frontier</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-1">Tiny Code</h4>
<p>Python (Min-Heap Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prim_mst(V, edges, start<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((w, v))</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>        graph[v].append((w, u))  <span class="co"># undirected</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> V</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, start, <span class="op">-</span><span class="dv">1</span>)]  <span class="co"># (weight, vertex, parent)</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    mst_edges <span class="op">=</span> []</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>        w, u, parent <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> visited[u]:</span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>        visited[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>        total_cost <span class="op">+=</span> w</span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parent <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a>            mst_edges.append((parent, u, w))</span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> weight, v <span class="kw">in</span> graph[u]:</span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> visited[v]:</span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (weight, v, u))</span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_cost, mst_edges</span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-27"><a href="#cb80-27" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>)]</span>
<span id="cb80-28"><a href="#cb80-28" aria-hidden="true" tabindex="-1"></a>cost, mst <span class="op">=</span> prim_mst(<span class="dv">4</span>, edges)</span>
<span id="cb80-29"><a href="#cb80-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cost, mst)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>7 [(0,1,2), (1,2,1), (1,3,4)]</code></pre>
</section>
<section id="why-it-matters-41" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-41">Why It Matters</h4>
<ul>
<li>Suitable for dense graphs (especially with adjacency lists and heaps).</li>
<li>Builds MST incrementally (like Dijkstra).</li>
<li>Great for online construction where the tree must stay connected.</li>
<li>Easier to integrate with adjacency matrix for small graphs.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-41" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-41">A Gentle Proof (Why It Works)</h4>
<p>Prim’s algorithm obeys the cut property: At each step, consider the cut between the current MST set <span class="math inline">\(S\)</span> and the remaining vertices <span class="math inline">\(V \setminus S\)</span>. The lightest edge crossing that cut is always safe to include. By repeatedly choosing the minimum such edge, Prim’s maintains a valid MST prefix. When all vertices are added, the resulting tree is minimal.</p>
</section>
<section id="try-it-yourself-41" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-41">Try It Yourself</h4>
<ol type="1">
<li>Run Prim’s on a dense graph vs Kruskal, compare edge choices.</li>
<li>Visualize the growing frontier.</li>
<li>Try with adjacency matrix (without heap).</li>
<li>Test on disconnected graph, each component forms its own tree.</li>
<li>Replace heap with a simple array to see <span class="math inline">\(O(V^2)\)</span> version.</li>
</ol>
</section>
<section id="test-cases-41" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-41">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 47%">
<col style="width: 35%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges <span class="math inline">\((u,v,w)\)</span></th>
<th>MST Edges</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>(0,1,1), (1,2,2), (0,2,3)</td>
<td>(0,1,1), (1,2,2)</td>
<td>3</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(0,1,2), (1,2,3), (2,3,1), (3,0,4)</td>
<td>(2,3,1), (0,1,2), (1,2,3)</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Line</td>
<td>(0,1,5), (1,2,1), (2,3,2)</td>
<td>(1,2,1), (2,3,2), (0,1,5)</td>
<td>8</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-41" class="level4">
<h4 class="anchored" data-anchor-id="complexity-41">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E\log V)\)</span> with heap, <span class="math inline">\(O(V^2)\)</span> with array.</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Output size: <span class="math inline">\(|V|-1\)</span> edges</li>
</ul>
<p>Prim’s is the grow from seed approach to MSTs. It builds the tree step by step, always pulling the next lightest edge from the frontier.</p>
</section>
</section>
<section id="prims-algorithm-adjacency-matrix" class="level3">
<h3 class="anchored" data-anchor-id="prims-algorithm-adjacency-matrix">343 Prim’s Algorithm (Adjacency Matrix)</h3>
<p>This is the array-based version of Prim’s algorithm, optimized for dense graphs. Instead of using a heap, it directly scans all vertices to find the next minimum key vertex at each step. The logic is identical to Prim’s heap version but trades priority queues for simple loops.</p>
<section id="what-problem-are-we-solving-42" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-42">What Problem Are We Solving?</h4>
<p>Given a connected, undirected, weighted graph <span class="math inline">\(G=(V,E,w)\)</span>, represented by an adjacency matrix <span class="math inline">\(W\)</span>, we want to construct an MST, a subset of edges that:</p>
<ul>
<li>connects all vertices,</li>
<li>contains <span class="math inline">\(|V|-1\)</span> edges,</li>
<li>and minimizes total weight <span class="math inline">\(\sum w(e)\)</span>.</li>
</ul>
<p>The adjacency matrix form simplifies edge lookups and is ideal for dense graphs, where <span class="math inline">\(E\approx V^2\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-42" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-42">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Start from an arbitrary vertex (say <span class="math inline">\(0\)</span>).</p></li>
<li><p>Initialize <span class="math inline">\(\text{key}[v]=\infty\)</span> for all vertices, except <span class="math inline">\(\text{key}[0]=0\)</span>.</p></li>
<li><p>Maintain a set <span class="math inline">\(\text{inMST}[v]\)</span> marking vertices already included.</p></li>
<li><p>Repeat <span class="math inline">\(V-1\)</span> times:</p>
<ul>
<li>Choose the vertex <span class="math inline">\(u\)</span> not yet in MST with the smallest <span class="math inline">\(\text{key}[u]\)</span>.</li>
<li>Add <span class="math inline">\(u\)</span> to MST.</li>
<li>For each vertex <span class="math inline">\(v\)</span>, if <span class="math inline">\(W[u][v]\)</span> is smaller than <span class="math inline">\(\text{key}[v]\)</span>, update it and record parent <span class="math inline">\(v\gets u\)</span>.</li>
</ul></li>
</ol>
<p>At each iteration, one vertex joins the MST, the one connected by the lightest edge to the existing set.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Initialize</td>
<td><span class="math inline">\(\text{key}[0]=0\)</span></td>
<td>start from vertex 0</td>
</tr>
<tr class="even">
<td>Extract min</td>
<td>find smallest key</td>
<td>next vertex to add</td>
</tr>
<tr class="odd">
<td>Update</td>
<td>relax edges</td>
<td>update keys of neighbors</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-2">Tiny Code</h4>
<p>C (Adjacency Matrix Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb82"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INF </span><span class="dv">1000000000</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">100</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minKey<span class="op">(</span><span class="dt">int</span> key<span class="op">[],</span> <span class="dt">bool</span> inMST<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> min <span class="op">=</span> INF<span class="op">,</span> idx <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>inMST<span class="op">[</span>v<span class="op">]</span> <span class="op">&amp;&amp;</span> key<span class="op">[</span>v<span class="op">]</span> <span class="op">&lt;</span> min<span class="op">)</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>            min <span class="op">=</span> key<span class="op">[</span>v<span class="op">],</span> idx <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> idx<span class="op">;</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> primMatrix<span class="op">(</span><span class="dt">int</span> graph<span class="op">[</span>N<span class="op">][</span>N<span class="op">],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> key<span class="op">[</span>N<span class="op">],</span> parent<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> inMST<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>        key<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">,</span> inMST<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>    key<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> parent<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> count <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> count<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> minKey<span class="op">(</span>key<span class="op">,</span> inMST<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>        inMST<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>inMST<span class="op">[</span>v<span class="op">]</span> <span class="op">&amp;&amp;</span> graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">&lt;</span> key<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>                parent<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>                key<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">];</span></span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> - </span><span class="sc">%d</span><span class="st">: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> parent<span class="op">[</span>i<span class="op">],</span> i<span class="op">,</span> graph<span class="op">[</span>i<span class="op">][</span>parent<span class="op">[</span>i<span class="op">]]);</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> graph<span class="op">[</span>i<span class="op">][</span>parent<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"MST cost: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> total<span class="op">);</span></span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> graph<span class="op">[</span>N<span class="op">][</span>N<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">0</span><span class="op">},</span></span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">2</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">5</span><span class="op">},</span></span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">7</span><span class="op">},</span></span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">6</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">9</span><span class="op">},</span></span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">0</span><span class="op">}</span></span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a>    primMatrix<span class="op">(</span>graph<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>0 - 1: 2
1 - 2: 3
0 - 3: 6
1 - 4: 5
MST cost: 16</code></pre>
<p>Python Version</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prim_matrix(graph):</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    key <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> V</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    in_mst <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> V</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>    key[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> <span class="bu">min</span>((key[v], v) <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(V) <span class="cf">if</span> <span class="kw">not</span> in_mst[v])[<span class="dv">1</span>]</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>        in_mst[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(V):</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> graph[u][v] <span class="op">!=</span> <span class="dv">0</span> <span class="kw">and</span> <span class="kw">not</span> in_mst[v] <span class="kw">and</span> graph[u][v] <span class="op">&lt;</span> key[v]:</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>                key[v] <span class="op">=</span> graph[u][v]</span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>                parent[v] <span class="op">=</span> u</span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> [(parent[i], i, graph[i][parent[i]]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, V)]</span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> <span class="bu">sum</span>(w <span class="cf">for</span> _, _, w <span class="kw">in</span> edges)</span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost, edges</span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> [</span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">0</span>],</span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">8</span>,<span class="dv">5</span>],</span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>],</span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>],</span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">0</span>]</span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(prim_matrix(graph))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(16, [(0,1,2), (1,2,3), (0,3,6), (1,4,5)])</code></pre>
</section>
<section id="why-it-matters-42" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-42">Why It Matters</h4>
<ul>
<li>Simple to implement with adjacency matrices.</li>
<li>Best for dense graphs where <span class="math inline">\(E \approx V^2\)</span>.</li>
<li>Avoids the complexity of heaps.</li>
<li>Easy to visualize and debug for classroom or teaching use.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-42" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-42">A Gentle Proof (Why It Works)</h4>
<p>Like the heap-based version, this variant relies on the cut property: At each step, the chosen edge connects a vertex inside the tree to one outside with minimum weight, so it is always safe. Each iteration expands the MST without cycles, and after <span class="math inline">\(V-1\)</span> iterations, all vertices are connected.</p>
</section>
<section id="try-it-yourself-42" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-42">Try It Yourself</h4>
<ol type="1">
<li>Run on a complete graph, expect <span class="math inline">\(V-1\)</span> smallest edges.</li>
<li>Modify weights, see how edge choices change.</li>
<li>Compare with heap-based Prim on runtime as <span class="math inline">\(V\)</span> grows.</li>
<li>Implement in <span class="math inline">\(O(V^2)\)</span> and confirm complexity experimentally.</li>
<li>Test on disconnected graph, see where algorithm stops.</li>
</ol>
</section>
<section id="test-cases-42" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-42">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 38%">
<col style="width: 26%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>MST Edges</th>
<th>Cost</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5-node matrix</td>
<td>(0,1,2), (1,2,3), (0,3,6), (1,4,5)</td>
<td>16</td>
<td></td>
</tr>
<tr class="even">
<td>3-node triangle</td>
<td>(0,1,1), (1,2,2)</td>
<td>3</td>
<td></td>
</tr>
<tr class="odd">
<td>Dense complete 4-node</td>
<td>6 edges</td>
<td>chooses lightest 3 edges</td>
<td>sum of min</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-42" class="level4">
<h4 class="anchored" data-anchor-id="complexity-42">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V^2)\)</span></li>
<li>Space: <span class="math inline">\(O(V^2)\)</span> (matrix)</li>
<li>Output size: <span class="math inline">\(|V|-1\)</span> edges</li>
</ul>
<p>Prim (Adjacency Matrix) is the classic dense-graph version, it trades speed for simplicity and predictable access time.</p>
</section>
</section>
<section id="borůvkas-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="borůvkas-algorithm">344 Borůvka’s Algorithm</h3>
<p>Borůvka’s algorithm is one of the earliest MST algorithms (1926), designed to build the minimum spanning tree by repeatedly connecting each component with its cheapest outgoing edge. It operates in phases, merging components until a single tree remains.</p>
<section id="what-problem-are-we-solving-43" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-43">What Problem Are We Solving?</h4>
<p>Given a connected, undirected, weighted graph <span class="math inline">\(G = (V, E, w)\)</span>, we want to find a minimum spanning tree (MST), a subset <span class="math inline">\(T \subseteq E\)</span> such that:</p>
<ul>
<li><span class="math inline">\(T\)</span> connects all vertices,</li>
<li><span class="math inline">\(|T| = |V| - 1\)</span>,</li>
<li><span class="math inline">\(\sum_{e \in T} w(e)\)</span> is minimized.</li>
</ul>
<p>Borůvka’s approach grows multiple subtrees in parallel, making it highly suitable for parallel or distributed computation.</p>
</section>
<section id="how-does-it-work-plain-language-43" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-43">How Does It Work (Plain Language)?</h4>
<p>The algorithm works in rounds. Each round connects every component to another via its lightest outgoing edge.</p>
<ol type="1">
<li>Start with each vertex as its own component.</li>
<li>For each component, find the minimum-weight edge that connects it to another component.</li>
<li>Add all these edges to the MST, they are guaranteed safe (by the cut property).</li>
<li>Merge components connected by these edges.</li>
<li>Repeat until only one component remains.</li>
</ol>
<p>Each round at least halves the number of components, so the algorithm finishes in <span class="math inline">\(O(\log V)\)</span> phases.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Initialize components</td>
<td>each vertex alone</td>
</tr>
<tr class="even">
<td>2</td>
<td>Find cheapest edge per component</td>
<td>lightest outgoing</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Add edges</td>
<td>merge components</td>
</tr>
<tr class="even">
<td>4</td>
<td>Repeat</td>
<td>until single component</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-3">Tiny Code</h4>
<p>Python (DSU Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DSU:</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.p <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.r <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, x):</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.p[x] <span class="op">!=</span> x:</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.p[x] <span class="op">=</span> <span class="va">self</span>.find(<span class="va">self</span>.p[x])</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.p[x]</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(<span class="va">self</span>, a, b):</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> <span class="va">self</span>.find(a), <span class="va">self</span>.find(b)</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a <span class="op">==</span> b: <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.r[a] <span class="op">&lt;</span> <span class="va">self</span>.r[b]: <span class="va">self</span>.p[a] <span class="op">=</span> b</span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.r[a] <span class="op">&gt;</span> <span class="va">self</span>.r[b]: <span class="va">self</span>.p[b] <span class="op">=</span> a</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="va">self</span>.p[b] <span class="op">=</span> a<span class="op">;</span> <span class="va">self</span>.r[a] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> boruvka_mst(V, edges):</span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>    dsu <span class="op">=</span> DSU(V)</span>
<span id="cb86-19"><a href="#cb86-19" aria-hidden="true" tabindex="-1"></a>    mst <span class="op">=</span> []</span>
<span id="cb86-20"><a href="#cb86-20" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb86-21"><a href="#cb86-21" aria-hidden="true" tabindex="-1"></a>    components <span class="op">=</span> V</span>
<span id="cb86-22"><a href="#cb86-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-23"><a href="#cb86-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> components <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb86-24"><a href="#cb86-24" aria-hidden="true" tabindex="-1"></a>        cheapest <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> V</span>
<span id="cb86-25"><a href="#cb86-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, (u, v, w) <span class="kw">in</span> <span class="bu">enumerate</span>(edges):</span>
<span id="cb86-26"><a href="#cb86-26" aria-hidden="true" tabindex="-1"></a>            set_u <span class="op">=</span> dsu.find(u)</span>
<span id="cb86-27"><a href="#cb86-27" aria-hidden="true" tabindex="-1"></a>            set_v <span class="op">=</span> dsu.find(v)</span>
<span id="cb86-28"><a href="#cb86-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> set_u <span class="op">!=</span> set_v:</span>
<span id="cb86-29"><a href="#cb86-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cheapest[set_u] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">or</span> edges[cheapest[set_u]][<span class="dv">2</span>] <span class="op">&gt;</span> w:</span>
<span id="cb86-30"><a href="#cb86-30" aria-hidden="true" tabindex="-1"></a>                    cheapest[set_u] <span class="op">=</span> i</span>
<span id="cb86-31"><a href="#cb86-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cheapest[set_v] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">or</span> edges[cheapest[set_v]][<span class="dv">2</span>] <span class="op">&gt;</span> w:</span>
<span id="cb86-32"><a href="#cb86-32" aria-hidden="true" tabindex="-1"></a>                    cheapest[set_v] <span class="op">=</span> i</span>
<span id="cb86-33"><a href="#cb86-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(V):</span>
<span id="cb86-34"><a href="#cb86-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cheapest[i] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb86-35"><a href="#cb86-35" aria-hidden="true" tabindex="-1"></a>                u, v, w <span class="op">=</span> edges[cheapest[i]]</span>
<span id="cb86-36"><a href="#cb86-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dsu.union(u, v):</span>
<span id="cb86-37"><a href="#cb86-37" aria-hidden="true" tabindex="-1"></a>                    mst.append((u, v, w))</span>
<span id="cb86-38"><a href="#cb86-38" aria-hidden="true" tabindex="-1"></a>                    total_cost <span class="op">+=</span> w</span>
<span id="cb86-39"><a href="#cb86-39" aria-hidden="true" tabindex="-1"></a>                    components <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb86-40"><a href="#cb86-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_cost, mst</span>
<span id="cb86-41"><a href="#cb86-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-42"><a href="#cb86-42" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>), (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>), (<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>)]</span>
<span id="cb86-43"><a href="#cb86-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(boruvka_mst(<span class="dv">4</span>, edges))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(6, [(0,1,1), (1,2,1), (1,3,4)])</code></pre>
</section>
<section id="why-it-matters-43" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-43">Why It Matters</h4>
<ul>
<li>Naturally parallelizable (each component acts independently).</li>
<li>Simple and elegant, based on repeated application of the cut property.</li>
<li>Ideal for sparse graphs and distributed systems.</li>
<li>Often used in hybrid MST algorithms (combining with Kruskal/Prim).</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-43" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-43">A Gentle Proof (Why It Works)</h4>
<p>By the cut property, for each component <span class="math inline">\(C\)</span>, the cheapest edge leaving <span class="math inline">\(C\)</span> is always safe to include in the MST. Since edges are chosen simultaneously across all components, and no cycles are created within a single phase (components merge only across cuts), each round preserves correctness. After each phase, components merge, and the process repeats until all are unified.</p>
<p>Each iteration reduces the number of components by at least half, ensuring <span class="math inline">\(O(\log V)\)</span> phases.</p>
</section>
<section id="try-it-yourself-43" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-43">Try It Yourself</h4>
<ol type="1">
<li>Run on a small graph and trace phases manually.</li>
<li>Compare with Kruskal’s sorted-edge approach.</li>
<li>Add parallel logging to visualize simultaneous merges.</li>
<li>Observe how components shrink exponentially.</li>
<li>Mix with Kruskal: use Borůvka until few components remain, then switch.</li>
</ol>
</section>
<section id="test-cases-43" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-43">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 39%">
<col style="width: 29%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges <span class="math inline">\((u,v,w)\)</span></th>
<th>MST</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>(0,1,1),(1,2,2),(0,2,3)</td>
<td>(0,1,1),(1,2,2)</td>
<td>3</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(0,1,1),(1,2,2),(2,3,1),(3,0,2)</td>
<td>(0,1,1),(2,3,1),(1,2,2)</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Dense 4-node</td>
<td>6 edges</td>
<td>builds MST in 2 phases</td>
<td>verified cost</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-43" class="level4">
<h4 class="anchored" data-anchor-id="complexity-43">Complexity</h4>
<ul>
<li>Phases: <span class="math inline">\(O(\log V)\)</span></li>
<li>Time per phase: <span class="math inline">\(O(E)\)</span></li>
<li>Total Time: <span class="math inline">\(O(E \log V)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Borůvka’s algorithm is the parallel grow-and-merge strategy for MSTs, every component reaches out through its lightest edge until the whole graph becomes one connected tree.</p>
</section>
</section>
<section id="reverse-delete-mst" class="level3">
<h3 class="anchored" data-anchor-id="reverse-delete-mst">345 Reverse-Delete MST</h3>
<p>The Reverse-Delete Algorithm builds a minimum spanning tree (MST) by starting with the full graph and repeatedly removing edges, but only when their removal does not disconnect the graph. It’s the conceptual mirror image of Kruskal’s algorithm.</p>
<section id="what-problem-are-we-solving-44" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-44">What Problem Are We Solving?</h4>
<p>Given a connected, undirected, weighted graph <span class="math inline">\(G = (V, E, w)\)</span>, we want to find an MST — a spanning tree that connects all vertices with minimum total weight.</p>
<p>Instead of adding edges like Kruskal, we start with all edges and delete them one by one, making sure the graph remains connected after each deletion.</p>
</section>
<section id="how-does-it-work-plain-language-44" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-44">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Sort all edges by decreasing weight.</p></li>
<li><p>Initialize the working graph <span class="math inline">\(T = G\)</span>.</p></li>
<li><p>For each edge <span class="math inline">\((u,v)\)</span> in that order:</p>
<ul>
<li>Temporarily remove <span class="math inline">\((u,v)\)</span> from <span class="math inline">\(T\)</span>.</li>
<li>If <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are still connected in <span class="math inline">\(T\)</span>, permanently delete the edge (it’s not needed).</li>
<li>Otherwise, restore it (it’s essential).</li>
</ul></li>
<li><p>When all edges are processed, <span class="math inline">\(T\)</span> is the MST.</p></li>
</ol>
<p>This approach ensures only indispensable edges remain, forming a spanning tree of minimal total weight.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 39%">
<col style="width: 41%">
<col style="width: 1%">
<col style="width: 1%">
<col style="width: 1%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Action</th>
<th>Description</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Sort edges descending</td>
<td>heavy edges first</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>Remove edge</td>
<td>test connectivity</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>Keep if needed</td>
<td>if removal disconnects</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>Stop</td>
<td>when $</td>
<td>T</td>
<td>=</td>
<td>V</td>
<td>-1$</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-4">Tiny Code</h4>
<p>Python (Using DFS for Connectivity Check)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(graph, start, visited):</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    visited.add(start)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v, _ <span class="kw">in</span> graph[start]:</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>            dfs(graph, v, visited)</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_connected(graph, u, v):</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>    dfs(graph, u, visited)</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> v <span class="kw">in</span> visited</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_delete_mst(V, edges):</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> <span class="bu">sorted</span>(edges, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">2</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> {i: [] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(V)}</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>        graph[v].append((u, w))</span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>    mst_cost <span class="op">=</span> <span class="bu">sum</span>(w <span class="cf">for</span> _, _, w <span class="kw">in</span> edges)</span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># remove edge</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>        graph[u] <span class="op">=</span> [(x, wx) <span class="cf">for</span> x, wx <span class="kw">in</span> graph[u] <span class="cf">if</span> x <span class="op">!=</span> v]</span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>        graph[v] <span class="op">=</span> [(x, wx) <span class="cf">for</span> x, wx <span class="kw">in</span> graph[v] <span class="cf">if</span> x <span class="op">!=</span> u]</span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_connected(graph, u, v):</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>            mst_cost <span class="op">-=</span> w  <span class="co"># edge not needed</span></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>            <span class="co"># restore edge</span></span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>            graph[u].append((v, w))</span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>            graph[v].append((u, w))</span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>    mst_edges <span class="op">=</span> []</span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> collect(u):</span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>        visited.add(u)</span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (v, w) <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>                mst_edges.append((u, v, w))</span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a>                    collect(v)</span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a>    collect(<span class="dv">0</span>)</span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mst_cost, mst_edges</span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-45"><a href="#cb88-45" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), (<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>), (<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>)]</span>
<span id="cb88-46"><a href="#cb88-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(reverse_delete_mst(<span class="dv">4</span>, edges))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(7, [(0,1,1), (0,2,2), (1,3,4)])</code></pre>
</section>
<section id="why-it-matters-44" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-44">Why It Matters</h4>
<ul>
<li><p>Simple dual perspective to Kruskal’s algorithm.</p></li>
<li><p>Demonstrates the cycle property:</p>
<blockquote class="blockquote">
<p>In any cycle, the edge with the largest weight cannot be in an MST.</p>
</blockquote></li>
<li><p>Good for teaching proofs and conceptual understanding.</p></li>
<li><p>Can be used for verifying MSTs or constructing them in reverse.</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-44" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-44">A Gentle Proof (Why It Works)</h4>
<p>The cycle property states:</p>
<blockquote class="blockquote">
<p>For any cycle in a graph, the edge with the largest weight cannot belong to the MST.</p>
</blockquote>
<p>By sorting edges in descending order and removing each maximum-weight edge that lies in a cycle (i.e., when <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> remain connected without it), we eliminate all non-MST edges. When no such edge remains, the result is an MST.</p>
<p>Since each deletion preserves connectivity, the final graph is a spanning tree with minimal total weight.</p>
</section>
<section id="try-it-yourself-44" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-44">Try It Yourself</h4>
<ol type="1">
<li>Run on a triangle graph, see heaviest edge removed.</li>
<li>Compare deletion order with Kruskal’s addition order.</li>
<li>Visualize graph at each step.</li>
<li>Replace DFS with BFS or Union-Find for speed.</li>
<li>Use to verify MST output from another algorithm.</li>
</ol>
</section>
<section id="test-cases-44" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-44">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 46%">
<col style="width: 34%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges <span class="math inline">\((u,v,w)\)</span></th>
<th>MST</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>(0,1,1),(1,2,2),(0,2,3)</td>
<td>(0,1,1),(1,2,2)</td>
<td>3</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(0,1,1),(1,2,2),(2,3,3),(3,0,4)</td>
<td>(0,1,1),(1,2,2),(2,3,3)</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Line</td>
<td>(0,1,2),(1,2,1),(2,3,3)</td>
<td>all edges</td>
<td>6</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-44" class="level4">
<h4 class="anchored" data-anchor-id="complexity-44">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E(E+V))\)</span> with naive DFS (each edge removal checks connectivity). With Union-Find optimizations or precomputed structures, it can be reduced.</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span>.</li>
</ul>
<p>Reverse-Delete is the subtract instead of add view of MSTs, peel away heavy edges until only the essential light structure remains.</p>
</section>
</section>
<section id="mst-via-dijkstra-trick" class="level3">
<h3 class="anchored" data-anchor-id="mst-via-dijkstra-trick">346 MST via Dijkstra Trick</h3>
<p>This variant constructs a Minimum Spanning Tree (MST) using a Dijkstra-like process, repeatedly expanding the tree by selecting the lightest edge connecting any vertex inside the tree to one outside. It’s essentially Prim’s algorithm recast through Dijkstra’s lens, showing the deep parallel between shortest-path and spanning-tree growth.</p>
<section id="what-problem-are-we-solving-45" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-45">What Problem Are We Solving?</h4>
<p>Given a connected, undirected, weighted graph <span class="math inline">\(G=(V,E,w)\)</span> with nonnegative edge weights, we want an MST — a subset <span class="math inline">\(T \subseteq E\)</span> that connects all vertices with <span class="math display">\[
|T| = |V| - 1, \quad \text{and} \quad \sum_{e \in T} w(e) \text{ minimized.}
\]</span></p>
<p>While Dijkstra’s algorithm builds shortest-path trees based on <em>path cost</em>, this version builds an MST by using edge weights directly as “distances” from the current tree.</p>
</section>
<section id="how-does-it-work-plain-language-45" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-45">How Does It Work (Plain Language)?</h4>
<p>This is Prim’s algorithm in disguise: Instead of tracking the shortest path from a root, we track the lightest edge connecting each vertex to the growing tree.</p>
<ol type="1">
<li><p>Initialize all vertices with <span class="math inline">\(\text{key}[v]=\infty\)</span>, except start vertex <span class="math inline">\(s\)</span> with <span class="math inline">\(\text{key}[s]=0\)</span>.</p></li>
<li><p>Use a priority queue (min-heap) keyed by <span class="math inline">\(\text{key}[v]\)</span>.</p></li>
<li><p>Repeatedly extract vertex <span class="math inline">\(u\)</span> with smallest key.</p></li>
<li><p>For each neighbor <span class="math inline">\(v\)</span>:</p>
<ul>
<li>If <span class="math inline">\(v\)</span> not yet in tree and <span class="math inline">\(w(u,v)&lt;\text{key}[v]\)</span>, update <span class="math inline">\(\text{key}[v]=w(u,v)\)</span> and record parent.</li>
</ul></li>
<li><p>Repeat until all vertices are included.</p></li>
</ol>
<p>Unlike Dijkstra, we do not sum edge weights, we only care about the minimum edge to reach each vertex.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 41%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Dijkstra</th>
<th>MST via Dijkstra Trick</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Distance update</td>
<td><span class="math inline">\(\text{dist}[v] = \text{dist}[u] + w(u,v)\)</span></td>
<td><span class="math inline">\(\text{key}[v] = \min(\text{key}[v], w(u,v))\)</span></td>
</tr>
<tr class="even">
<td>Priority</td>
<td>Path cost</td>
<td>Edge cost</td>
</tr>
<tr class="odd">
<td>Goal</td>
<td>Shortest path</td>
<td>MST</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-5">Tiny Code</h4>
<p>Python (Heap Implementation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mst_dijkstra_trick(V, edges, start<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>        graph[u].append((v, w))</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>        graph[v].append((u, w))</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>    in_tree <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> V</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>    key <span class="op">=</span> [<span class="bu">float</span>(<span class="st">'inf'</span>)] <span class="op">*</span> V</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> V</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>    key[start] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>    pq <span class="op">=</span> [(<span class="dv">0</span>, start)]</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pq:</span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>        w, u <span class="op">=</span> heapq.heappop(pq)</span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> in_tree[u]:</span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a>        in_tree[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a>        total_cost <span class="op">+=</span> w</span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, wt <span class="kw">in</span> graph[u]:</span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> in_tree[v] <span class="kw">and</span> wt <span class="op">&lt;</span> key[v]:</span>
<span id="cb90-25"><a href="#cb90-25" aria-hidden="true" tabindex="-1"></a>                key[v] <span class="op">=</span> wt</span>
<span id="cb90-26"><a href="#cb90-26" aria-hidden="true" tabindex="-1"></a>                parent[v] <span class="op">=</span> u</span>
<span id="cb90-27"><a href="#cb90-27" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(pq, (wt, v))</span>
<span id="cb90-28"><a href="#cb90-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-29"><a href="#cb90-29" aria-hidden="true" tabindex="-1"></a>    mst_edges <span class="op">=</span> [(parent[v], v, key[v]) <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(V) <span class="cf">if</span> parent[v] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb90-30"><a href="#cb90-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_cost, mst_edges</span>
<span id="cb90-31"><a href="#cb90-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-32"><a href="#cb90-32" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>)]</span>
<span id="cb90-33"><a href="#cb90-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mst_dijkstra_trick(<span class="dv">4</span>, edges))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(7, [(0,1,2), (1,2,1), (1,3,4)])</code></pre>
</section>
<section id="why-it-matters-45" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-45">Why It Matters</h4>
<ul>
<li>Demonstrates the duality between MST and shortest-path search.</li>
<li>Provides a conceptual bridge between Prim and Dijkstra.</li>
<li>Useful for teaching and algorithmic unification.</li>
<li>Intuitive when already familiar with Dijkstra’s structure.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-45" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-45">A Gentle Proof (Why It Works)</h4>
<p>At each iteration, we maintain a set <span class="math inline">\(S\)</span> of vertices already in the MST. The cut property guarantees that the lightest edge connecting <span class="math inline">\(S\)</span> to <span class="math inline">\(V\setminus S\)</span> is always safe to include.</p>
<p>By storing these edge weights in a priority queue and always selecting the smallest, we exactly follow this property, thus constructing an MST incrementally.</p>
<p>The algorithm stops when all vertices are included, yielding an MST.</p>
</section>
<section id="try-it-yourself-45" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-45">Try It Yourself</h4>
<ol type="1">
<li>Compare line by line with Dijkstra, only one change in relaxation.</li>
<li>Run on complete graphs, observe star-like MSTs.</li>
<li>Try graphs with multiple equal edges, see tie-handling.</li>
<li>Replace heap with array, check <span class="math inline">\(O(V^2)\)</span> version.</li>
<li>Visualize with frontier highlighting, edges instead of distances.</li>
</ol>
</section>
<section id="test-cases-45" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-45">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 46%">
<col style="width: 34%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges <span class="math inline">\((u,v,w)\)</span></th>
<th>MST</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>(0,1,1),(1,2,2),(0,2,3)</td>
<td>(0,1,1),(1,2,2)</td>
<td>3</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(0,1,2),(1,2,3),(2,3,1),(3,0,4)</td>
<td>(2,3,1),(0,1,2),(1,2,3)</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Line</td>
<td>(0,1,5),(1,2,2),(2,3,1)</td>
<td>all edges</td>
<td>8</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-45" class="level4">
<h4 class="anchored" data-anchor-id="complexity-45">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log V)\)</span> (heap) or <span class="math inline">\(O(V^2)\)</span> (array)</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Output size: <span class="math inline">\(|V|-1\)</span> edges</li>
</ul>
<p>MST via Dijkstra Trick is Prim’s algorithm reimagined, it replaces distance summation with edge minimization, proving how two classic graph ideas share one greedy heart.</p>
</section>
</section>
<section id="dynamic-mst-maintenance" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-mst-maintenance">347 Dynamic MST Maintenance</h3>
<p>Dynamic MST maintenance addresses the question: how can we update an MST efficiently when the underlying graph changes, edges are added, removed, or their weights change, without rebuilding from scratch?</p>
<p>This problem arises in systems where the graph evolves over time, such as networks, road maps, or real-time optimization systems.</p>
<section id="what-problem-are-we-solving-46" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-46">What Problem Are We Solving?</h4>
<p>Given a graph <span class="math inline">\(G=(V,E,w)\)</span> and its MST <span class="math inline">\(T\)</span>, we want to maintain <span class="math inline">\(T\)</span> under updates:</p>
<ul>
<li>Edge Insertion: add new edge <span class="math inline">\((u,v,w)\)</span></li>
<li>Edge Deletion: remove existing edge <span class="math inline">\((u,v)\)</span></li>
<li>Edge Weight Update: change weight <span class="math inline">\(w(u,v)\)</span></li>
</ul>
<p>Naively recomputing the MST after each change costs <span class="math inline">\(O(E \log V)\)</span>. Dynamic maintenance reduces this significantly using incremental repair of <span class="math inline">\(T\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-46" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-46">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Edge Insertion:</p>
<ul>
<li>Add the new edge <span class="math inline">\((u,v,w)\)</span>.</li>
<li>Check if it creates a cycle in <span class="math inline">\(T\)</span>.</li>
<li>If the new edge is lighter than the heaviest edge on that cycle, replace the heavy one.</li>
<li>Otherwise, discard it.</li>
</ul></li>
<li><p>Edge Deletion:</p>
<ul>
<li>Remove <span class="math inline">\((u,v)\)</span> from <span class="math inline">\(T\)</span>, splitting it into two components.</li>
<li>Find the lightest edge connecting the two components in <span class="math inline">\(G\)</span>.</li>
<li>Add that edge to restore connectivity.</li>
</ul></li>
<li><p>Edge Weight Update:</p>
<ul>
<li>If an edge’s weight increases, treat as potential deletion.</li>
<li>If it decreases, treat as potential insertion.</li>
</ul></li>
</ol>
<p>To do this efficiently, we need data structures that can:</p>
<ul>
<li>find max edge on path quickly (for cycles)</li>
<li>find min cross edge between components</li>
</ul>
<p>These can be implemented via dynamic trees, Link-Cut Trees, or Euler Tour Trees.</p>
</section>
<section id="tiny-code-simplified-static-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-static-version">Tiny Code (Simplified Static Version)</h4>
<p>This version demonstrates edge insertion maintenance with cycle detection.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find(parent, x):</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> parent[x] <span class="op">!=</span> x:</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>        parent[x] <span class="op">=</span> find(parent, parent[x])</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parent[x]</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> union(parent, rank, x, y):</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>    rx, ry <span class="op">=</span> find(parent, x), find(parent, y)</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rx <span class="op">==</span> ry:</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank[rx] <span class="op">&lt;</span> rank[ry]:</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>        parent[rx] <span class="op">=</span> ry</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> rank[rx] <span class="op">&gt;</span> rank[ry]:</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>        parent[ry] <span class="op">=</span> rx</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>        parent[ry] <span class="op">=</span> rx</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>        rank[rx] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dynamic_mst_insert(V, mst_edges, new_edge):</span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true" tabindex="-1"></a>    u, v, w <span class="op">=</span> new_edge</span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb92-22"><a href="#cb92-22" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>V</span>
<span id="cb92-23"><a href="#cb92-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y, _ <span class="kw">in</span> mst_edges:</span>
<span id="cb92-24"><a href="#cb92-24" aria-hidden="true" tabindex="-1"></a>        union(parent, rank, x, y)</span>
<span id="cb92-25"><a href="#cb92-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> find(parent, u) <span class="op">!=</span> find(parent, v):</span>
<span id="cb92-26"><a href="#cb92-26" aria-hidden="true" tabindex="-1"></a>        mst_edges.append(new_edge)</span>
<span id="cb92-27"><a href="#cb92-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb92-28"><a href="#cb92-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># would form cycle, pick lighter edge</span></span>
<span id="cb92-29"><a href="#cb92-29" aria-hidden="true" tabindex="-1"></a>        cycle_edges <span class="op">=</span> mst_edges <span class="op">+</span> [new_edge]</span>
<span id="cb92-30"><a href="#cb92-30" aria-hidden="true" tabindex="-1"></a>        heaviest <span class="op">=</span> <span class="bu">max</span>(cycle_edges, key<span class="op">=</span><span class="kw">lambda</span> e: e[<span class="dv">2</span>])</span>
<span id="cb92-31"><a href="#cb92-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> heaviest <span class="op">!=</span> new_edge:</span>
<span id="cb92-32"><a href="#cb92-32" aria-hidden="true" tabindex="-1"></a>            mst_edges.remove(heaviest)</span>
<span id="cb92-33"><a href="#cb92-33" aria-hidden="true" tabindex="-1"></a>            mst_edges.append(new_edge)</span>
<span id="cb92-34"><a href="#cb92-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mst_edges</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This is conceptual; in practice, Link-Cut Trees make this dynamic in logarithmic time.</p>
</section>
<section id="why-it-matters-46" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-46">Why It Matters</h4>
<ul>
<li>Crucial for streaming graphs, online networks, real-time routing.</li>
<li>Avoids recomputation after each update.</li>
<li>Demonstrates greedy invariants under change, the MST remains minimal if maintained properly.</li>
<li>Forms basis for fully dynamic graph algorithms.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-46" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-46">A Gentle Proof (Why It Works)</h4>
<p>MST invariants are preserved through cut and cycle properties:</p>
<ul>
<li>Cycle Property: In a cycle, the heaviest edge cannot be in an MST.</li>
<li>Cut Property: In any cut, the lightest edge crossing it must be in the MST.</li>
</ul>
<p>When inserting an edge:</p>
<ul>
<li>It forms a cycle, we drop the heaviest to maintain minimality.</li>
</ul>
<p>When deleting an edge:</p>
<ul>
<li>It forms a cut, we insert the lightest crossing edge to maintain connectivity.</li>
</ul>
<p>Thus each update restores a valid MST in local time.</p>
</section>
<section id="try-it-yourself-46" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-46">Try It Yourself</h4>
<ol type="1">
<li>Start from an MST of a small graph.</li>
<li>Insert an edge and track the created cycle.</li>
<li>Delete an MST edge and find replacement.</li>
<li>Try batch updates, see structure evolve.</li>
<li>Compare runtime with full recomputation.</li>
</ol>
</section>
<section id="test-cases-46" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-46">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 29%">
<col style="width: 31%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Description</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert <span class="math inline">\((1,3,1)\)</span></td>
<td>creates cycle <span class="math inline">\((1,2,3,1)\)</span></td>
<td>remove heaviest edge</td>
</tr>
<tr class="even">
<td>Delete <span class="math inline">\((0,1)\)</span></td>
<td>breaks tree</td>
<td>find lightest reconnecting edge</td>
</tr>
<tr class="odd">
<td>Decrease weight <span class="math inline">\((2,3)\)</span></td>
<td>recheck inclusion</td>
<td>edge may enter MST</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-46" class="level4">
<h4 class="anchored" data-anchor-id="complexity-46">Complexity</h4>
<ul>
<li>Insertion/Deletion (Naive): <span class="math inline">\(O(E)\)</span></li>
<li>Dynamic Tree (Link-Cut): <span class="math inline">\(O(\log^2 V)\)</span> per update</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Dynamic MST maintenance shows how local adjustments preserve global optimality, a powerful principle for evolving systems.</p>
</section>
</section>
<section id="minimum-bottleneck-spanning-tree" class="level3">
<h3 class="anchored" data-anchor-id="minimum-bottleneck-spanning-tree">348 Minimum Bottleneck Spanning Tree</h3>
<p>A Minimum Bottleneck Spanning Tree (MBST) is a spanning tree that minimizes the maximum edge weight among all edges in the tree. Unlike the standard MST, which minimizes the total sum of edge weights, an MBST focuses on the worst (heaviest) edge in the tree.</p>
<p>In many real-world systems, such as network design or transportation planning, you may care less about total cost and more about bottleneck constraints, the weakest or slowest connection.</p>
<section id="what-problem-are-we-solving-47" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-47">What Problem Are We Solving?</h4>
<p>Given a connected, undirected, weighted graph <span class="math inline">\(G = (V, E, w)\)</span>, we want a spanning tree <span class="math inline">\(T \subseteq E\)</span> such that</p>
<p><span class="math display">\[
\max_{e \in T} w(e)
\]</span></p>
<p>is as small as possible.</p>
<p>In other words, among all spanning trees, pick one where the largest edge weight is minimal.</p>
</section>
<section id="how-does-it-work-plain-language-47" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-47">How Does It Work (Plain Language)?</h4>
<p>You can build an MBST using the same algorithms as MST (Kruskal or Prim), because:</p>
<blockquote class="blockquote">
<p>Every Minimum Spanning Tree is also a Minimum Bottleneck Spanning Tree.</p>
</blockquote>
<p>The reasoning:</p>
<ul>
<li>An MST minimizes the total sum.</li>
<li>In doing so, it also ensures no unnecessarily heavy edges remain.</li>
</ul>
<p>So any MST automatically satisfies the bottleneck property.</p>
<p>Alternatively, you can use a binary search + connectivity test:</p>
<ol type="1">
<li>Sort edges by weight.</li>
<li>Binary search for a threshold <span class="math inline">\(W\)</span>.</li>
<li>Check if edges with <span class="math inline">\(w(e) \le W\)</span> can connect all vertices.</li>
<li>The smallest <span class="math inline">\(W\)</span> for which graph is connected is the bottleneck weight.</li>
<li>Extract any spanning tree using only edges <span class="math inline">\(\le W\)</span>.</li>
</ol>
</section>
<section id="tiny-code-kruskal-based" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-kruskal-based">Tiny Code (Kruskal-based)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find(parent, x):</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> parent[x] <span class="op">!=</span> x:</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>        parent[x] <span class="op">=</span> find(parent, parent[x])</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parent[x]</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> union(parent, rank, x, y):</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    rx, ry <span class="op">=</span> find(parent, x), find(parent, y)</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rx <span class="op">==</span> ry:</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank[rx] <span class="op">&lt;</span> rank[ry]:</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>        parent[rx] <span class="op">=</span> ry</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> rank[rx] <span class="op">&gt;</span> rank[ry]:</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>        parent[ry] <span class="op">=</span> rx</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>        parent[ry] <span class="op">=</span> rx</span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>        rank[rx] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimum_bottleneck_spanning_tree(V, edges):</span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> <span class="bu">sorted</span>(edges, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">2</span>])</span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>V</span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a>    bottleneck <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb93-25"><a href="#cb93-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb93-26"><a href="#cb93-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> union(parent, rank, u, v):</span>
<span id="cb93-27"><a href="#cb93-27" aria-hidden="true" tabindex="-1"></a>            bottleneck <span class="op">=</span> <span class="bu">max</span>(bottleneck, w)</span>
<span id="cb93-28"><a href="#cb93-28" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb93-29"><a href="#cb93-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> count <span class="op">==</span> V <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb93-30"><a href="#cb93-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb93-31"><a href="#cb93-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> bottleneck</span>
<span id="cb93-32"><a href="#cb93-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-33"><a href="#cb93-33" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">6</span>)]</span>
<span id="cb93-34"><a href="#cb93-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(minimum_bottleneck_spanning_tree(<span class="dv">4</span>, edges))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>5</code></pre>
<p>Here, the MST has total weight 4+3+2=9, and bottleneck edge weight 5.</p>
</section>
<section id="why-it-matters-47" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-47">Why It Matters</h4>
<ul>
<li>Useful for quality-of-service or bandwidth-constrained systems.</li>
<li>Ensures no edge in the tree exceeds a critical capacity threshold.</li>
<li>Illustrates that minimizing maximum and minimizing sum can align, a key insight in greedy algorithms.</li>
<li>Provides a way to test MST correctness: if an MST doesn’t minimize the bottleneck, it’s invalid.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-47" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-47">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(T^*\)</span> be an MST and <span class="math inline">\(B(T^*)\)</span> be its maximum edge weight.</p>
<p>Suppose another tree <span class="math inline">\(T'\)</span> had a smaller bottleneck: <span class="math display">\[
B(T') &lt; B(T^*)
\]</span> Then there exists an edge <span class="math inline">\(e\)</span> in <span class="math inline">\(T^*\)</span> with <span class="math inline">\(w(e) = B(T^*)\)</span>, but <span class="math inline">\(T'\)</span> avoids it while staying connected using lighter edges.</p>
<p>This contradicts the cycle property, since <span class="math inline">\(e\)</span> would be replaced by a lighter edge crossing the same cut, meaning <span class="math inline">\(T^*\)</span> wasn’t minimal.</p>
<p>Thus, every MST is an MBST.</p>
</section>
<section id="try-it-yourself-47" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-47">Try It Yourself</h4>
<ol type="1">
<li>Build a graph with multiple MSTs, check if they share the same bottleneck.</li>
<li>Compare MST total weight vs MBST bottleneck.</li>
<li>Apply binary search approach, confirm consistency.</li>
<li>Visualize all spanning trees and mark max edge in each.</li>
<li>Construct a case where multiple MBSTs exist.</li>
</ol>
</section>
<section id="test-cases-47" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-47">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 43%">
<col style="width: 31%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges <span class="math inline">\((u,v,w)\)</span></th>
<th>MST</th>
<th>Bottleneck</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>(0,1,1),(1,2,2),(0,2,3)</td>
<td>(0,1,1),(1,2,2)</td>
<td>2</td>
</tr>
<tr class="even">
<td>Square</td>
<td>(0,1,1),(1,2,5),(2,3,2),(3,0,4)</td>
<td>(0,1,1),(2,3,2),(3,0,4)</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Chain</td>
<td>(0,1,2),(1,2,3),(2,3,4)</td>
<td>same</td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-47" class="level4">
<h4 class="anchored" data-anchor-id="complexity-47">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log E)\)</span> (same as Kruskal)</li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
<li>Output: bottleneck weight or edges</li>
</ul>
<p>A Minimum Bottleneck Spanning Tree highlights the heaviest load-bearing link, a critical measure when resilience, latency, or bandwidth limits matter more than total cost.</p>
</section>
</section>
<section id="manhattan-mst" class="level3">
<h3 class="anchored" data-anchor-id="manhattan-mst">349 Manhattan MST</h3>
<p>A Manhattan Minimum Spanning Tree (Manhattan MST) finds a spanning tree that minimizes the sum of Manhattan distances between connected points on a grid. This variant is common in VLSI design, city planning, and grid-based path optimization, where movement is constrained to axis-aligned directions.</p>
<section id="what-problem-are-we-solving-48" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-48">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> points in 2D space with coordinates <span class="math inline">\((x_i, y_i)\)</span>, the Manhattan distance between points <span class="math inline">\(p_i\)</span> and <span class="math inline">\(p_j\)</span> is</p>
<p><span class="math display">\[
d(p_i, p_j) = |x_i - x_j| + |y_i - y_j|
\]</span></p>
<p>We want to build a spanning tree connecting all points such that the total Manhattan distance is minimal.</p>
<p>A naive solution considers all <span class="math inline">\(\binom{n}{2}\)</span> edges and runs Kruskal’s algorithm, but that’s too slow for large <span class="math inline">\(n\)</span>. The key is exploiting geometry to limit candidate edges.</p>
</section>
<section id="how-does-it-work-plain-language-48" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-48">How Does It Work (Plain Language)?</h4>
<p>The Manhattan MST problem leverages a geometric property:</p>
<blockquote class="blockquote">
<p>For each point, only a small number of nearest neighbors (under certain transformations) can belong to the MST.</p>
</blockquote>
<p>Thus, instead of checking all pairs, we:</p>
<ol type="1">
<li>Sort points in specific directions (rotations/reflections).</li>
<li>Use a sweep line or Fenwick tree to find candidate neighbors.</li>
<li>Collect <span class="math inline">\(O(n)\)</span> potential edges.</li>
<li>Run Kruskal’s algorithm on this reduced set.</li>
</ol>
<p>By considering 8 directional transforms, we ensure all possible nearest edges are included.</p>
<p>Example transforms:</p>
<ul>
<li><span class="math inline">\((x, y)\)</span></li>
<li><span class="math inline">\((y, x)\)</span></li>
<li><span class="math inline">\((-x, y)\)</span></li>
<li><span class="math inline">\((x, -y)\)</span></li>
<li>etc.</li>
</ul>
<p>For each transform:</p>
<ul>
<li>Sort points by <span class="math inline">\((x+y)\)</span> or <span class="math inline">\((x-y)\)</span>.</li>
<li>For each, track candidate neighbor minimizing <span class="math inline">\(|x|+|y|\)</span>.</li>
<li>Add edge between each point and its nearest neighbor.</li>
</ul>
<p>Finally, compute MST using Kruskal on the collected edges.</p>
</section>
<section id="tiny-code-simplified-illustration" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-illustration">Tiny Code (Simplified Illustration)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> manhattan_distance(p1, p2):</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">abs</span>(p1[<span class="dv">0</span>]<span class="op">-</span>p2[<span class="dv">0</span>]) <span class="op">+</span> <span class="bu">abs</span>(p1[<span class="dv">1</span>]<span class="op">-</span>p2[<span class="dv">1</span>])</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> manhattan_mst(points):</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> []</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n):</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> manhattan_distance(points[i], points[j])</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>            edges.append((i, j, w))</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>    edges.sort(key<span class="op">=</span><span class="kw">lambda</span> e: e[<span class="dv">2</span>])</span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(x):</span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parent[x]<span class="op">!=</span>x:</span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>            parent[x]<span class="op">=</span>find(parent[x])</span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parent[x]</span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(x, y):</span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>        rx, ry <span class="op">=</span> find(x), find(y)</span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> rx<span class="op">!=</span>ry:</span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>            parent[ry]<span class="op">=</span>rx</span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a>    mst_edges <span class="op">=</span> []</span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb95-28"><a href="#cb95-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> union(u, v):</span>
<span id="cb95-29"><a href="#cb95-29" aria-hidden="true" tabindex="-1"></a>            mst_edges.append((u, v, w))</span>
<span id="cb95-30"><a href="#cb95-30" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">+=</span> w</span>
<span id="cb95-31"><a href="#cb95-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost, mst_edges</span>
<span id="cb95-32"><a href="#cb95-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-33"><a href="#cb95-33" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">2</span>,<span class="dv">2</span>), (<span class="dv">2</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="dv">2</span>)]</span>
<span id="cb95-34"><a href="#cb95-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(manhattan_mst(points))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(8, [(0,2,2),(0,3,2),(2,1,4)])</code></pre>
<p>This brute-force example builds a Manhattan MST by checking all pairs. Efficient geometric variants reduce this from <span class="math inline">\(O(n^2)\)</span> to <span class="math inline">\(O(n \log n)\)</span>.</p>
</section>
<section id="why-it-matters-48" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-48">Why It Matters</h4>
<ul>
<li>Captures grid-based movement (no diagonals).</li>
<li>Critical in VLSI circuit layout (wire length minimization).</li>
<li>Foundational for city-block planning and delivery networks.</li>
<li>Shows how geometry and graph theory merge in spatial problems.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-48" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-48">A Gentle Proof (Why It Works)</h4>
<p>The MST under Manhattan distance obeys the cut property, the lightest edge crossing any partition must be in the MST. By ensuring all directional neighbors are included, we never miss the minimal edge across any cut.</p>
<p>Thus, even though we prune candidate edges, correctness is preserved.</p>
</section>
<section id="try-it-yourself-48" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-48">Try It Yourself</h4>
<ol type="1">
<li>Generate random points, visualize MST edges.</li>
<li>Compare Manhattan MST vs Euclidean MST.</li>
<li>Add a diagonal, see how cost differs.</li>
<li>Try optimized directional neighbor search.</li>
<li>Observe symmetry, each transform covers a quadrant.</li>
</ol>
</section>
<section id="test-cases-48" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-48">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>MST Edges</th>
<th>Total Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(0,0),(1,0),(1,1)</td>
<td>(0,1),(1,2)</td>
<td>2</td>
</tr>
<tr class="even">
<td>(0,0),(2,2),(2,0),(0,2)</td>
<td>3 edges</td>
<td>8</td>
</tr>
<tr class="odd">
<td>(0,0),(3,0),(0,4)</td>
<td>(0,1),(0,2)</td>
<td>7</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-48" class="level4">
<h4 class="anchored" data-anchor-id="complexity-48">Complexity</h4>
<ul>
<li>Naive: <span class="math inline">\(O(n^2 \log n)\)</span></li>
<li>Optimized (geometry-based): <span class="math inline">\(O(n \log n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Manhattan MSTs bridge grid geometry and graph optimization, the perfect example of structure guiding efficiency.</p>
</section>
</section>
<section id="euclidean-mst-kruskal-geometry" class="level3">
<h3 class="anchored" data-anchor-id="euclidean-mst-kruskal-geometry">350 Euclidean MST (Kruskal + Geometry)</h3>
<p>A Euclidean Minimum Spanning Tree (EMST) connects a set of points in the plane with the shortest total Euclidean length, the minimal possible wiring, pipeline, or connection layout under straight-line distances.</p>
<p>It is the geometric counterpart to classical MST problems, central to computational geometry, network design, and spatial clustering.</p>
<section id="what-problem-are-we-solving-49" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-49">What Problem Are We Solving?</h4>
<p>Given <span class="math inline">\(n\)</span> points <span class="math inline">\(P = {p_1, p_2, \dots, p_n}\)</span> in 2D (or higher dimensions), we want a spanning tree <span class="math inline">\(T\)</span> minimizing</p>
<p><span class="math display">\[
\text{cost}(T) = \sum_{(p_i,p_j) \in T} \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}
\]</span></p>
<p>Unlike abstract graph MSTs, here the graph is complete, every pair of points has an edge weighted by Euclidean distance — but we cannot afford <span class="math inline">\(O(n^2)\)</span> edges for large <span class="math inline">\(n\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-49" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-49">How Does It Work (Plain Language)?</h4>
<p>The key geometric insight:</p>
<blockquote class="blockquote">
<p>The EMST is always a subgraph of the Delaunay Triangulation (DT).</p>
</blockquote>
<p>So we don’t need all <span class="math inline">\(\binom{n}{2}\)</span> edges, only those in the Delaunay graph (which has <span class="math inline">\(O(n)\)</span> edges).</p>
<p>Algorithm sketch:</p>
<ol type="1">
<li>Compute the Delaunay Triangulation (DT) of the points.</li>
<li>Extract all DT edges with their Euclidean weights.</li>
<li>Run Kruskal’s or Prim’s algorithm on these edges.</li>
<li>The resulting tree is the EMST.</li>
</ol>
<p>This drastically reduces time from quadratic to near-linear.</p>
</section>
<section id="tiny-code-brute-force-demonstration" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-brute-force-demonstration">Tiny Code (Brute-Force Demonstration)</h4>
<p>Here’s a minimal version using all pairs, good for small <span class="math inline">\(n\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euclidean_distance(p1, p2):</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.sqrt((p1[<span class="dv">0</span>]<span class="op">-</span>p2[<span class="dv">0</span>])<span class="dv">2</span> <span class="op">+</span> (p1[<span class="dv">1</span>]<span class="op">-</span>p2[<span class="dv">1</span>])<span class="dv">2</span>)</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euclidean_mst(points):</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> []</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n):</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> euclidean_distance(points[i], points[j])</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>            edges.append((i, j, w))</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>    edges.sort(key<span class="op">=</span><span class="kw">lambda</span> e: e[<span class="dv">2</span>])</span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(x):</span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parent[x] <span class="op">!=</span> x:</span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>            parent[x] <span class="op">=</span> find(parent[x])</span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parent[x]</span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(x, y):</span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>        rx, ry <span class="op">=</span> find(x), find(y)</span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> rx <span class="op">!=</span> ry:</span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>            parent[ry] <span class="op">=</span> rx</span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-27"><a href="#cb97-27" aria-hidden="true" tabindex="-1"></a>    mst_edges <span class="op">=</span> []</span>
<span id="cb97-28"><a href="#cb97-28" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb97-29"><a href="#cb97-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb97-30"><a href="#cb97-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> union(u, v):</span>
<span id="cb97-31"><a href="#cb97-31" aria-hidden="true" tabindex="-1"></a>            mst_edges.append((u, v, w))</span>
<span id="cb97-32"><a href="#cb97-32" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">+=</span> w</span>
<span id="cb97-33"><a href="#cb97-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost, mst_edges</span>
<span id="cb97-34"><a href="#cb97-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-35"><a href="#cb97-35" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">1</span>)]</span>
<span id="cb97-36"><a href="#cb97-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(euclidean_mst(points))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(3.0, [(0,1,1.0),(0,2,1.0),(1,3,1.0)])</code></pre>
<p>For real use, replace the all-pairs loop with Delaunay edges from a geometry library.</p>
</section>
<section id="why-it-matters-49" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-49">Why It Matters</h4>
<ul>
<li>Optimally connects points with minimum total length.</li>
<li>Used in geographic information systems, road networks, clustering (single-linkage), sensor networks, and pattern analysis.</li>
<li>Demonstrates interplay between geometry and graph theory.</li>
<li>Foundation for Steiner trees and TSP approximations.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-49" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-49">A Gentle Proof (Why It Works)</h4>
<p>The EMST obeys the cut property, for every partition of points, the shortest connecting edge must be in the EMST.</p>
<p>Edges outside the Delaunay Triangulation can be replaced by shorter edges crossing the same cut (from DT), so the EMST must lie within the DT.</p>
<p>Thus, we can safely restrict candidate edges to the Delaunay set, preserving optimality.</p>
</section>
<section id="try-it-yourself-49" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-49">Try It Yourself</h4>
<ol type="1">
<li>Plot points on a plane, draw EMST edges.</li>
<li>Compare EMST vs MST with Manhattan distances.</li>
<li>Generate points in clusters, visualize how EMST bridges clusters.</li>
<li>Use a geometry library (e.g.&nbsp;<code>scipy.spatial.Delaunay</code>) to build fast DT edges.</li>
<li>Measure runtime difference: brute-force vs DT-based.</li>
</ol>
</section>
<section id="test-cases-49" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-49">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Points</th>
<th>EMST</th>
<th>Total Length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Square corners</td>
<td>(0,0),(1,0),(1,1),(0,1)</td>
<td>3.0</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td>(0,0),(2,0),(1,√3)</td>
<td>4.0</td>
</tr>
<tr class="odd">
<td>Random 5 points</td>
<td>,</td>
<td>Depends on coordinates</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-49" class="level4">
<h4 class="anchored" data-anchor-id="complexity-49">Complexity</h4>
<ul>
<li>Brute-force: <span class="math inline">\(O(n^2 \log n)\)</span></li>
<li>Delaunay-based: <span class="math inline">\(O(n \log n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>The Euclidean MST is the geometric minimal backbone, the shortest invisible thread that ties all points together in the plane.</p>
</section>
</section>
</section>
<section id="section-36.-flows" class="level2">
<h2 class="anchored" data-anchor-id="section-36.-flows">Section 36. Flows</h2>
<section id="fordfulkerson" class="level3">
<h3 class="anchored" data-anchor-id="fordfulkerson">351 Ford–Fulkerson</h3>
<p>The Ford–Fulkerson method is the foundational algorithm for computing the maximum flow in a directed network. It views flow as water moving through a system of pipes, pushing flow from a source to a sink, respecting capacity limits and flow conservation.</p>
<section id="what-problem-are-we-solving-50" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-50">What Problem Are We Solving?</h4>
<p>Given a flow network <span class="math inline">\(G = (V, E)\)</span> with</p>
<ul>
<li>a source <span class="math inline">\(s\)</span>,</li>
<li>a sink <span class="math inline">\(t\)</span>,</li>
<li>and capacities <span class="math inline">\(c(u, v)\)</span> on each edge,</li>
</ul>
<p>we want to find a maximum flow <span class="math inline">\(f(u, v)\)</span> such that:</p>
<ol type="1">
<li><p>Capacity constraint: <span class="math display">\[0 \le f(u, v) \le c(u, v)\]</span></p></li>
<li><p>Flow conservation: <span class="math display">\[\sum_{(u,v)\in E} f(u,v) = \sum_{(v,u)\in E} f(v,u) \quad \forall u \in V \setminus {s, t}\]</span></p></li>
<li><p>Maximize total flow: <span class="math display">\[
\text{Maximize } |f| = \sum_{(s,v)\in E} f(s,v)
\]</span></p></li>
</ol>
</section>
<section id="how-does-it-work-plain-language-50" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-50">How Does It Work (Plain Language)?</h4>
<p>The algorithm repeatedly searches for augmenting paths, routes from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> where additional flow can still be sent. Each iteration increases total flow until no augmenting path remains.</p>
<p>Step-by-step:</p>
<ol type="1">
<li><p>Initialize all flows to 0.</p></li>
<li><p>While an augmenting path <span class="math inline">\(P\)</span> exists from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> in the residual graph:</p>
<ul>
<li>Find the bottleneck capacity along <span class="math inline">\(P\)</span>: <span class="math display">\[b = \min_{(u,v)\in P} (c(u,v) - f(u,v))\]</span></li>
<li>Augment flow along <span class="math inline">\(P\)</span> by <span class="math inline">\(b\)</span>: <span class="math display">\[f(u,v) \gets f(u,v) + b\]</span> <span class="math display">\[f(v,u) \gets f(v,u) - b\]</span></li>
</ul></li>
<li><p>Update residual capacities and repeat.</p></li>
<li><p>When no path remains, current flow is maximum.</p></li>
</ol>
<p>The residual graph represents remaining capacity, allowing backward edges to cancel flow if needed.</p>
</section>
<section id="tiny-code-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-6">Tiny Code</h4>
<p>Python (DFS-based Augmentation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ford_fulkerson(capacity, s, t):</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(capacity)</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    flow <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(u, t, f, visited):</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> f</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>        visited[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>            residual <span class="op">=</span> capacity[u][v] <span class="op">-</span> flow[u][v]</span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> residual <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="kw">not</span> visited[v]:</span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>                pushed <span class="op">=</span> dfs(v, t, <span class="bu">min</span>(f, residual), visited)</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pushed <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>                    flow[u][v] <span class="op">+=</span> pushed</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>                    flow[v][u] <span class="op">-=</span> pushed</span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> pushed</span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>    max_flow <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>        visited <span class="op">=</span> [<span class="va">False</span>]<span class="op">*</span>n</span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>        pushed <span class="op">=</span> dfs(s, t, <span class="bu">float</span>(<span class="st">'inf'</span>), visited)</span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pushed <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a>        max_flow <span class="op">+=</span> pushed</span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_flow</span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> [</span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">16</span>, <span class="dv">13</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">14</span>, <span class="dv">0</span>],</span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>],</span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">0</span>, <span class="dv">4</span>],</span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ford_fulkerson(capacity, <span class="dv">0</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>23</code></pre>
</section>
<section id="why-it-matters-50" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-50">Why It Matters</h4>
<ul>
<li><p>Introduces max-flow concept, a cornerstone of network optimization.</p></li>
<li><p>Underpins algorithms for:</p>
<ul>
<li>bipartite matching</li>
<li>minimum cut problems</li>
<li>circulations and network design</li>
</ul></li>
<li><p>Illustrates residual graphs and augmenting paths, used in many flow-based algorithms.</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-50" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-50">A Gentle Proof (Why It Works)</h4>
<p>Each augmentation increases total flow by a positive amount and maintains feasibility. Because total capacity is finite, the process eventually terminates.</p>
<p>By the Max-Flow Min-Cut Theorem:</p>
<p><span class="math display">\[
|f^*| = \text{capacity of minimum } (S, T) \text{ cut}
\]</span></p>
<p>So when no augmenting path exists, the flow is maximum.</p>
<p>If all capacities are integers, the algorithm converges in finite steps, since each augmentation adds at least 1 unit.</p>
</section>
<section id="try-it-yourself-50" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-50">Try It Yourself</h4>
<ol type="1">
<li>Run on small networks, draw residual graph at each step.</li>
<li>Track augmenting paths and bottleneck edges.</li>
<li>Compare to Edmonds–Karp (BFS search).</li>
<li>Change capacities to fractional, observe potential infinite loops.</li>
<li>Use to solve bipartite matching (convert to flow network).</li>
</ol>
</section>
<section id="test-cases-50" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-50">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple 3-node</td>
<td>5</td>
<td>single augment</td>
</tr>
<tr class="even">
<td>Classic 6-node (above)</td>
<td>23</td>
<td>textbook example</td>
</tr>
<tr class="odd">
<td>Parallel edges</td>
<td>Sum of capacities</td>
<td>additive</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-50" class="level4">
<h4 class="anchored" data-anchor-id="complexity-50">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \cdot |f^*|)\)</span> for integer capacities</li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
<li>Optimized (Edmonds–Karp): <span class="math inline">\(O(VE^2)\)</span></li>
</ul>
<p>Ford–Fulkerson builds the intuition of pushing flow through capacity-constrained paths, the heart of network optimization.</p>
</section>
</section>
<section id="edmondskarp" class="level3">
<h3 class="anchored" data-anchor-id="edmondskarp">352 Edmonds–Karp</h3>
<p>The Edmonds–Karp algorithm is a concrete, polynomial-time implementation of the Ford–Fulkerson method, where each augmenting path is chosen using Breadth-First Search (BFS). By always selecting the shortest path (in edge count) from source to sink, it guarantees efficient convergence.</p>
<section id="what-problem-are-we-solving-51" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-51">What Problem Are We Solving?</h4>
<p>Given a directed flow network <span class="math inline">\(G = (V, E)\)</span> with</p>
<ul>
<li>a source <span class="math inline">\(s\)</span>,</li>
<li>a sink <span class="math inline">\(t\)</span>,</li>
<li>and nonnegative capacities <span class="math inline">\(c(u, v)\)</span>,</li>
</ul>
<p>we want to find a maximum flow <span class="math inline">\(f(u, v)\)</span> that satisfies:</p>
<ol type="1">
<li><p>Capacity constraints: <span class="math display">\[0 \le f(u, v) \le c(u, v)\]</span></p></li>
<li><p>Flow conservation: <span class="math display">\[\sum_{(u,v)\in E} f(u,v) = \sum_{(v,u)\in E} f(v,u) \quad \forall u \in V \setminus {s, t}\]</span></p></li>
<li><p>Maximize total flow: <span class="math display">\[|f| = \sum_{(s,v)\in E} f(s,v)\]</span></p></li>
</ol>
<p>The algorithm improves Ford–Fulkerson by enforcing shortest augmenting path order, which bounds the number of iterations.</p>
</section>
<section id="how-does-it-work-plain-language-51" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-51">How Does It Work (Plain Language)?</h4>
<p>Each iteration finds an augmenting path using BFS (so each edge in the path is part of the shortest route in terms of hops). Then we push the maximum possible flow through that path and update residual capacities.</p>
<p>Step-by-step:</p>
<ol type="1">
<li><p>Initialize <span class="math inline">\(f(u,v)=0\)</span> for all edges.</p></li>
<li><p>While there exists a path <span class="math inline">\(P\)</span> from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> in the residual graph (found by BFS):</p>
<ul>
<li>Compute bottleneck capacity: <span class="math display">\[b = \min_{(u,v)\in P} (c(u,v) - f(u,v))\]</span></li>
<li>Augment along path <span class="math inline">\(P\)</span>: <span class="math display">\[f(u,v) \gets f(u,v) + b\]</span> <span class="math display">\[f(v,u) \gets f(v,u) - b\]</span></li>
</ul></li>
<li><p>Repeat until no augmenting path remains.</p></li>
</ol>
<p>Residual graph is updated after each augmentation, including reverse edges to allow flow cancellation.</p>
</section>
<section id="tiny-code-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-7">Tiny Code</h4>
<p>Python Implementation (BFS Augmentation)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(capacity, flow, s, t):</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(capacity)</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    parent[s] <span class="op">=</span> s</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque([s])</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> q.popleft()</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>            residual <span class="op">=</span> capacity[u][v] <span class="op">-</span> flow[u][v]</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> residual <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> parent[v] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>                parent[v] <span class="op">=</span> u</span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>                q.append(v)</span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> v <span class="op">==</span> t:</span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> parent</span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edmonds_karp(capacity, s, t):</span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(capacity)</span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>    flow <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>    max_flow <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>        parent <span class="op">=</span> bfs(capacity, flow, s, t)</span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> parent:</span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># find bottleneck</span></span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> t</span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>        bottleneck <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> v <span class="op">!=</span> s:</span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> parent[v]</span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>            bottleneck <span class="op">=</span> <span class="bu">min</span>(bottleneck, capacity[u][v] <span class="op">-</span> flow[u][v])</span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> u</span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># augment flow</span></span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> t</span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> v <span class="op">!=</span> s:</span>
<span id="cb101-38"><a href="#cb101-38" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> parent[v]</span>
<span id="cb101-39"><a href="#cb101-39" aria-hidden="true" tabindex="-1"></a>            flow[u][v] <span class="op">+=</span> bottleneck</span>
<span id="cb101-40"><a href="#cb101-40" aria-hidden="true" tabindex="-1"></a>            flow[v][u] <span class="op">-=</span> bottleneck</span>
<span id="cb101-41"><a href="#cb101-41" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> u</span>
<span id="cb101-42"><a href="#cb101-42" aria-hidden="true" tabindex="-1"></a>        max_flow <span class="op">+=</span> bottleneck</span>
<span id="cb101-43"><a href="#cb101-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-44"><a href="#cb101-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_flow</span>
<span id="cb101-45"><a href="#cb101-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-46"><a href="#cb101-46" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> [</span>
<span id="cb101-47"><a href="#cb101-47" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">16</span>, <span class="dv">13</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb101-48"><a href="#cb101-48" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb101-49"><a href="#cb101-49" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">14</span>, <span class="dv">0</span>],</span>
<span id="cb101-50"><a href="#cb101-50" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>],</span>
<span id="cb101-51"><a href="#cb101-51" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">0</span>, <span class="dv">4</span>],</span>
<span id="cb101-52"><a href="#cb101-52" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb101-53"><a href="#cb101-53" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb101-54"><a href="#cb101-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(edmonds_karp(capacity, <span class="dv">0</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>23</code></pre>
</section>
<section id="why-it-matters-51" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-51">Why It Matters</h4>
<ul>
<li>Ensures polynomial time termination.</li>
<li>Demonstrates the power of BFS for finding shortest augmenting paths.</li>
<li>Serves as the canonical maximum flow algorithm in theory and practice.</li>
<li>Provides a clean proof of the Max-Flow Min-Cut Theorem.</li>
<li>Foundation for more advanced methods (Dinic, Push–Relabel).</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-51" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-51">A Gentle Proof (Why It Works)</h4>
<p>Each augmentation uses a shortest path in terms of edges. After each augmentation, at least one edge on that path saturates (reaches full capacity).</p>
<p>Because every edge can only move from residual distance <span class="math inline">\(d\)</span> to <span class="math inline">\(d+2\)</span> a limited number of times, the total number of augmentations is <span class="math inline">\(O(VE)\)</span>.</p>
<p>Each BFS runs in <span class="math inline">\(O(E)\)</span>, giving total runtime <span class="math inline">\(O(VE^2)\)</span>.</p>
<p>The algorithm terminates when no path exists, i.e.&nbsp;the residual graph disconnects <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>, and by the Max-Flow Min-Cut theorem, the current flow is maximum.</p>
</section>
<section id="try-it-yourself-51" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-51">Try It Yourself</h4>
<ol type="1">
<li>Run BFS after each iteration, visualize residual network.</li>
<li>Compare with Ford–Fulkerson (DFS), note fewer augmentations.</li>
<li>Modify capacities, see how path selection changes.</li>
<li>Implement path reconstruction and print augmenting paths.</li>
<li>Use to solve bipartite matching via flow transformation.</li>
</ol>
</section>
<section id="test-cases-51" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-51">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple 3-node</td>
<td>5</td>
<td>BFS finds direct path</td>
</tr>
<tr class="even">
<td>Classic 6-node</td>
<td>23</td>
<td>textbook example</td>
</tr>
<tr class="odd">
<td>Star network</td>
<td>Sum of edge capacities</td>
<td>each edge unique path</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-51" class="level4">
<h4 class="anchored" data-anchor-id="complexity-51">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(VE^2)\)</span></li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
<li>Augmentations: <span class="math inline">\(O(VE)\)</span></li>
</ul>
<p>Edmonds–Karp transforms Ford–Fulkerson into a predictable, efficient, and elegant BFS-based flow engine, ensuring progress, bounding iterations, and revealing the structure of optimal flow.</p>
</section>
</section>
<section id="dinics-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="dinics-algorithm">353 Dinic’s Algorithm</h3>
<p>Dinic’s Algorithm (or Dinitz’s algorithm) is a faster approach to computing maximum flow, improving upon Edmonds–Karp by introducing a level graph and sending blocking flows within it. It combines BFS (to layer the graph) with DFS (to find augmenting paths), achieving a strong polynomial bound.</p>
<section id="what-problem-are-we-solving-52" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-52">What Problem Are We Solving?</h4>
<p>Given a directed flow network <span class="math inline">\(G = (V, E)\)</span> with</p>
<ul>
<li>source <span class="math inline">\(s\)</span>,</li>
<li>sink <span class="math inline">\(t\)</span>,</li>
<li>capacities <span class="math inline">\(c(u,v)\)</span> on each edge,</li>
</ul>
<p>find the maximum flow <span class="math inline">\(f(u,v)\)</span> such that:</p>
<ol type="1">
<li><p>Capacity constraint: <span class="math display">\[0 \le f(u, v) \le c(u, v)\]</span></p></li>
<li><p>Flow conservation: <span class="math display">\[\sum_{(u,v)\in E} f(u,v) = \sum_{(v,u)\in E} f(v,u) \quad \forall u \in V \setminus {s, t}\]</span></p></li>
<li><p>Maximize total flow: <span class="math display">\[|f| = \sum_{(s,v)\in E} f(s,v)\]</span></p></li>
</ol>
</section>
<section id="how-does-it-work-plain-language-52" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-52">How Does It Work (Plain Language)?</h4>
<p>Dinic’s Algorithm operates in phases. Each phase constructs a level graph using BFS, then pushes as much flow as possible within that layered structure using DFS. This approach ensures progress, each phase strictly increases the shortest path length from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> in the residual graph.</p>
<p>Step-by-step:</p>
<ol type="1">
<li><p>Build Level Graph (BFS):</p>
<ul>
<li>Run BFS from <span class="math inline">\(s\)</span>.</li>
<li>Assign each vertex a level = distance from <span class="math inline">\(s\)</span> in residual graph.</li>
<li>Only edges <span class="math inline">\((u,v)\)</span> with <span class="math inline">\(level[v] = level[u] + 1\)</span> are used.</li>
</ul></li>
<li><p>Send Blocking Flow (DFS):</p>
<ul>
<li>Use DFS to push flow from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> along level-respecting paths.</li>
<li>Stop when no more flow can be sent (i.e., blocking flow).</li>
</ul></li>
<li><p>Repeat:</p>
<ul>
<li>Rebuild level graph; continue until <span class="math inline">\(t\)</span> is unreachable from <span class="math inline">\(s\)</span>.</li>
</ul></li>
</ol>
<p>A blocking flow saturates at least one edge on every <span class="math inline">\(s\)</span>–<span class="math inline">\(t\)</span> path in the level graph, ensuring termination per phase.</p>
</section>
<section id="tiny-code-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-8">Tiny Code</h4>
<p>Python Implementation (Adjacency List)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dinic:</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.adj <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_edge(<span class="va">self</span>, u, v, cap):</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.adj[u].append([v, cap, <span class="bu">len</span>(<span class="va">self</span>.adj[v])])</span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.adj[v].append([u, <span class="dv">0</span>, <span class="bu">len</span>(<span class="va">self</span>.adj[u]) <span class="op">-</span> <span class="dv">1</span>])  <span class="co"># reverse edge</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> bfs(<span class="va">self</span>, s, t, level):</span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> deque([s])</span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>        level[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> q:</span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> q.popleft()</span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v, cap, _ <span class="kw">in</span> <span class="va">self</span>.adj[u]:</span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cap <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> level[v] <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>                    level[v] <span class="op">=</span> level[u] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>                    q.append(v)</span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> level[t] <span class="op">&gt;=</span> <span class="dv">0</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(<span class="va">self</span>, u, t, flow, level, it):</span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> flow</span>
<span id="cb103-26"><a href="#cb103-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> it[u] <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.adj[u]):</span>
<span id="cb103-27"><a href="#cb103-27" aria-hidden="true" tabindex="-1"></a>            v, cap, rev <span class="op">=</span> <span class="va">self</span>.adj[u][it[u]]</span>
<span id="cb103-28"><a href="#cb103-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cap <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> level[v] <span class="op">==</span> level[u] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb103-29"><a href="#cb103-29" aria-hidden="true" tabindex="-1"></a>                pushed <span class="op">=</span> <span class="va">self</span>.dfs(v, t, <span class="bu">min</span>(flow, cap), level, it)</span>
<span id="cb103-30"><a href="#cb103-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pushed <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb103-31"><a href="#cb103-31" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.adj[u][it[u]][<span class="dv">1</span>] <span class="op">-=</span> pushed</span>
<span id="cb103-32"><a href="#cb103-32" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.adj[v][rev][<span class="dv">1</span>] <span class="op">+=</span> pushed</span>
<span id="cb103-33"><a href="#cb103-33" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> pushed</span>
<span id="cb103-34"><a href="#cb103-34" aria-hidden="true" tabindex="-1"></a>            it[u] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb103-35"><a href="#cb103-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb103-36"><a href="#cb103-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-37"><a href="#cb103-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> max_flow(<span class="va">self</span>, s, t):</span>
<span id="cb103-38"><a href="#cb103-38" aria-hidden="true" tabindex="-1"></a>        flow <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb103-39"><a href="#cb103-39" aria-hidden="true" tabindex="-1"></a>        level <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="va">self</span>.n</span>
<span id="cb103-40"><a href="#cb103-40" aria-hidden="true" tabindex="-1"></a>        INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb103-41"><a href="#cb103-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">self</span>.bfs(s, t, level):</span>
<span id="cb103-42"><a href="#cb103-42" aria-hidden="true" tabindex="-1"></a>            it <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="va">self</span>.n</span>
<span id="cb103-43"><a href="#cb103-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb103-44"><a href="#cb103-44" aria-hidden="true" tabindex="-1"></a>                pushed <span class="op">=</span> <span class="va">self</span>.dfs(s, t, INF, level, it)</span>
<span id="cb103-45"><a href="#cb103-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pushed <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb103-46"><a href="#cb103-46" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb103-47"><a href="#cb103-47" aria-hidden="true" tabindex="-1"></a>                flow <span class="op">+=</span> pushed</span>
<span id="cb103-48"><a href="#cb103-48" aria-hidden="true" tabindex="-1"></a>            level <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="va">self</span>.n</span>
<span id="cb103-49"><a href="#cb103-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> flow</span>
<span id="cb103-50"><a href="#cb103-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-51"><a href="#cb103-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb103-52"><a href="#cb103-52" aria-hidden="true" tabindex="-1"></a>dinic <span class="op">=</span> Dinic(<span class="dv">6</span>)</span>
<span id="cb103-53"><a href="#cb103-53" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb103-54"><a href="#cb103-54" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">16</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">13</span>),(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">10</span>),(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">12</span>),</span>
<span id="cb103-55"><a href="#cb103-55" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">9</span>),(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">14</span>),(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">7</span>),(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">20</span>),(<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">4</span>)</span>
<span id="cb103-56"><a href="#cb103-56" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb103-57"><a href="#cb103-57" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v,c <span class="kw">in</span> edges:</span>
<span id="cb103-58"><a href="#cb103-58" aria-hidden="true" tabindex="-1"></a>    dinic.add_edge(u,v,c)</span>
<span id="cb103-59"><a href="#cb103-59" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dinic.max_flow(<span class="dv">0</span>,<span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>23</code></pre>
</section>
<section id="why-it-matters-52" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-52">Why It Matters</h4>
<ul>
<li>Achieves <span class="math inline">\(O(V^2E)\)</span> complexity (faster in practice).</li>
<li>Exploits layering to avoid redundant augmentations.</li>
<li>Basis for advanced flow algorithms like Dinic + scaling, Push–Relabel, and Blocking Flow variants.</li>
<li>Common in competitive programming, network routing, and bipartite matching.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-52" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-52">A Gentle Proof (Why It Works)</h4>
<p>Each phase increases the shortest distance from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> in the residual graph. Because there are at most <span class="math inline">\(V-1\)</span> distinct distances, the algorithm runs for at most <span class="math inline">\(O(V)\)</span> phases. Within each phase, we find a blocking flow, which can be computed in <span class="math inline">\(O(E)\)</span> DFS calls.</p>
<p>Hence total runtime: <span class="math display">\[
O(VE)
\]</span> for unit networks (each edge capacity = 1), and in general, <span class="math display">\[
O(V^2E)
\]</span></p>
<p>When no augmenting path exists, residual graph disconnects <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>, so the current flow is maximum by the Max-Flow Min-Cut theorem.</p>
</section>
<section id="try-it-yourself-52" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-52">Try It Yourself</h4>
<ol type="1">
<li>Compare BFS layers between phases, note increasing depth.</li>
<li>Visualize level graph and residual edges.</li>
<li>Test on bipartite graph, confirm match size = flow.</li>
<li>Modify to store flow per edge.</li>
<li>Add capacity scaling to speed up dense graphs.</li>
</ol>
</section>
<section id="test-cases-52" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-52">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6-node sample</td>
<td>23</td>
<td>classic example</td>
</tr>
<tr class="even">
<td>Unit network</td>
<td>equals #disjoint paths</td>
<td></td>
</tr>
<tr class="odd">
<td>Bipartite graph</td>
<td>equals max matching</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-52" class="level4">
<h4 class="anchored" data-anchor-id="complexity-52">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V^2E)\)</span> general, <span class="math inline">\(O(\sqrt{V}E)\)</span> for unit capacities</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Augmentations per phase: <span class="math inline">\(O(E)\)</span></li>
</ul>
<p>Dinic’s algorithm elegantly combines BFS-level layering with DFS-based flow pushing, a perfect synthesis of structure and greed, powering modern flow computations.</p>
</section>
</section>
<section id="pushrelabel" class="level3">
<h3 class="anchored" data-anchor-id="pushrelabel">354 Push–Relabel</h3>
<p>The Push–Relabel algorithm (also called Preflow–Push) takes a completely different view of the maximum flow problem. Instead of finding paths from the source to the sink, it locally pushes flow along edges and adjusts vertex heights (labels) to guide flow downhill toward the sink.</p>
<p>This approach is highly efficient in practice and forms the basis for many modern flow solvers.</p>
<section id="what-problem-are-we-solving-53" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-53">What Problem Are We Solving?</h4>
<p>Given a directed network <span class="math inline">\(G = (V, E)\)</span> with</p>
<ul>
<li>source <span class="math inline">\(s\)</span>,</li>
<li>sink <span class="math inline">\(t\)</span>,</li>
<li>capacity <span class="math inline">\(c(u, v)\)</span>,</li>
</ul>
<p>we want a flow <span class="math inline">\(f(u,v)\)</span> satisfying:</p>
<ol type="1">
<li><p>Capacity constraint: <span class="math display">\[0 \le f(u, v) \le c(u, v)\]</span></p></li>
<li><p>Flow conservation: <span class="math display">\[\sum_{(u,v)\in E} f(u,v) = \sum_{(v,u)\in E} f(v,u) \quad \forall u \neq s,t\]</span></p></li>
<li><p>Maximize total flow: <span class="math display">\[|f| = \sum_{(s,v)\in E} f(s,v)\]</span></p></li>
</ol>
</section>
<section id="how-does-it-work-plain-language-53" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-53">How Does It Work (Plain Language)?</h4>
<p>Unlike Ford–Fulkerson, which finds augmenting paths, Push–Relabel maintains a preflow (where intermediate nodes may have excess flow) and fixes imbalances gradually.</p>
<p>Key concepts:</p>
<ul>
<li>Preflow: flow can temporarily violate conservation (nodes can have excess).</li>
<li>Height (label): an integer guiding flow direction, flow only moves “downhill.”</li>
<li>Push: send flow from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> if possible.</li>
<li>Relabel: when <span class="math inline">\(u\)</span> is stuck, increase its height so flow can continue.</li>
</ul>
<p>Step-by-step:</p>
<ol type="1">
<li><p>Initialize all <span class="math inline">\(f(u,v)=0\)</span>.</p></li>
<li><p>Set <span class="math inline">\(h(s)=|V|\)</span> and push as much as possible from <span class="math inline">\(s\)</span> to its neighbors.</p></li>
<li><p>While any vertex (other than <span class="math inline">\(s,t\)</span>) has excess flow, do:</p>
<ul>
<li>Push: if <span class="math inline">\((u,v)\)</span> is admissible (<span class="math inline">\(h(u)=h(v)+1\)</span> and residual <span class="math inline">\(&gt;0\)</span>), send <span class="math display">\[\Delta = \min(e(u), c(u,v)-f(u,v))\]</span></li>
<li>Relabel: if no admissible edge, set <span class="math display">\[h(u) = 1 + \min_{(u,v): c(u,v)-f(u,v)&gt;0} h(v)\]</span></li>
</ul></li>
</ol>
<p>Repeat until all excess is at <span class="math inline">\(t\)</span> or <span class="math inline">\(s\)</span>.</p>
</section>
<section id="tiny-code-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-9">Tiny Code</h4>
<p>Python Implementation (Simplified)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> push_relabel(capacity, s, t):</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(capacity)</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    flow <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    excess <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    height[s] <span class="op">=</span> n</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> push(u, v):</span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">=</span> <span class="bu">min</span>(excess[u], capacity[u][v] <span class="op">-</span> flow[u][v])</span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>        flow[u][v] <span class="op">+=</span> delta</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>        flow[v][u] <span class="op">-=</span> delta</span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>        excess[u] <span class="op">-=</span> delta</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>        excess[v] <span class="op">+=</span> delta</span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> relabel(u):</span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>        min_h <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> capacity[u][v] <span class="op">-</span> flow[u][v] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a>                min_h <span class="op">=</span> <span class="bu">min</span>(min_h, height[v])</span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> min_h <span class="op">&lt;</span> <span class="bu">float</span>(<span class="st">'inf'</span>):</span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a>            height[u] <span class="op">=</span> min_h <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> discharge(u):</span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> excess[u] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb105-26"><a href="#cb105-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> capacity[u][v] <span class="op">-</span> flow[u][v] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> height[u] <span class="op">==</span> height[v] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb105-27"><a href="#cb105-27" aria-hidden="true" tabindex="-1"></a>                    push(u, v)</span>
<span id="cb105-28"><a href="#cb105-28" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> excess[u] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb105-29"><a href="#cb105-29" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">break</span></span>
<span id="cb105-30"><a href="#cb105-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb105-31"><a href="#cb105-31" aria-hidden="true" tabindex="-1"></a>                relabel(u)</span>
<span id="cb105-32"><a href="#cb105-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-33"><a href="#cb105-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize preflow</span></span>
<span id="cb105-34"><a href="#cb105-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb105-35"><a href="#cb105-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> capacity[s][v] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb105-36"><a href="#cb105-36" aria-hidden="true" tabindex="-1"></a>            flow[s][v] <span class="op">=</span> capacity[s][v]</span>
<span id="cb105-37"><a href="#cb105-37" aria-hidden="true" tabindex="-1"></a>            flow[v][s] <span class="op">=</span> <span class="op">-</span>capacity[s][v]</span>
<span id="cb105-38"><a href="#cb105-38" aria-hidden="true" tabindex="-1"></a>            excess[v] <span class="op">=</span> capacity[s][v]</span>
<span id="cb105-39"><a href="#cb105-39" aria-hidden="true" tabindex="-1"></a>    excess[s] <span class="op">=</span> <span class="bu">sum</span>(capacity[s])</span>
<span id="cb105-40"><a href="#cb105-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-41"><a href="#cb105-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Discharge active vertices</span></span>
<span id="cb105-42"><a href="#cb105-42" aria-hidden="true" tabindex="-1"></a>    active <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n) <span class="cf">if</span> i <span class="op">!=</span> s <span class="kw">and</span> i <span class="op">!=</span> t]</span>
<span id="cb105-43"><a href="#cb105-43" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb105-44"><a href="#cb105-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> p <span class="op">&lt;</span> <span class="bu">len</span>(active):</span>
<span id="cb105-45"><a href="#cb105-45" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> active[p]</span>
<span id="cb105-46"><a href="#cb105-46" aria-hidden="true" tabindex="-1"></a>        old_height <span class="op">=</span> height[u]</span>
<span id="cb105-47"><a href="#cb105-47" aria-hidden="true" tabindex="-1"></a>        discharge(u)</span>
<span id="cb105-48"><a href="#cb105-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> height[u] <span class="op">&gt;</span> old_height:</span>
<span id="cb105-49"><a href="#cb105-49" aria-hidden="true" tabindex="-1"></a>            active.insert(<span class="dv">0</span>, active.pop(p))  <span class="co"># move to front</span></span>
<span id="cb105-50"><a href="#cb105-50" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb105-51"><a href="#cb105-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb105-52"><a href="#cb105-52" aria-hidden="true" tabindex="-1"></a>            p <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb105-53"><a href="#cb105-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-54"><a href="#cb105-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(flow[s])</span>
<span id="cb105-55"><a href="#cb105-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-56"><a href="#cb105-56" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> [</span>
<span id="cb105-57"><a href="#cb105-57" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">16</span>,<span class="dv">13</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb105-58"><a href="#cb105-58" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb105-59"><a href="#cb105-59" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">14</span>,<span class="dv">0</span>],</span>
<span id="cb105-60"><a href="#cb105-60" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">20</span>],</span>
<span id="cb105-61"><a href="#cb105-61" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">7</span>,<span class="dv">0</span>,<span class="dv">4</span>],</span>
<span id="cb105-62"><a href="#cb105-62" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb105-63"><a href="#cb105-63" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb105-64"><a href="#cb105-64" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(push_relabel(capacity, <span class="dv">0</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>23</code></pre>
</section>
<section id="why-it-matters-53" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-53">Why It Matters</h4>
<ul>
<li>Local view: No need for global augmenting paths.</li>
<li>Highly parallelizable.</li>
<li>Performs very well in dense graphs.</li>
<li>Serves as the basis for highest-label and FIFO variants.</li>
<li>Conceptually elegant: flow “falls downhill” guided by heights.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-53" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-53">A Gentle Proof (Why It Works)</h4>
<ol type="1">
<li>The height invariant ensures no flow moves from lower to higher vertices.</li>
<li>Every push respects capacity and non-negativity.</li>
<li>Height always increases, ensuring termination.</li>
<li>When no vertex (except <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>) has excess, all preflow constraints are satisfied, the preflow becomes a valid maximum flow.</li>
</ol>
<p>By the Max-Flow Min-Cut Theorem, the final preflow’s value equals the capacity of the minimum cut.</p>
</section>
<section id="try-it-yourself-53" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-53">Try It Yourself</h4>
<ol type="1">
<li>Track each vertex’s height and excess after each step.</li>
<li>Compare FIFO vs highest-label variants.</li>
<li>Use small networks to visualize flow movement.</li>
<li>Contrast with path-based algorithms (Ford–Fulkerson).</li>
<li>Add logging to observe relabel events.</li>
</ol>
</section>
<section id="test-cases-53" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-53">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Classic 6-node</td>
<td>23</td>
<td>textbook</td>
</tr>
<tr class="even">
<td>Dense complete</td>
<td>high flow</td>
<td>efficient</td>
</tr>
<tr class="odd">
<td>Sparse path</td>
<td>same as Edmonds–Karp</td>
<td>similar</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-53" class="level4">
<h4 class="anchored" data-anchor-id="complexity-53">Complexity</h4>
<ul>
<li>Time (Generic): <span class="math inline">\(O(V^2E)\)</span></li>
<li>With FIFO / Highest-Label Heuristics: <span class="math inline">\(O(V^3)\)</span> or better</li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
</ul>
<p>Push–Relabel transforms max-flow into a local balancing act, pushing, relabeling, and equalizing pressure until equilibrium is achieved.</p>
</section>
</section>
<section id="capacity-scaling" class="level3">
<h3 class="anchored" data-anchor-id="capacity-scaling">355 Capacity Scaling</h3>
<p>The Capacity Scaling algorithm is a refined version of Ford–Fulkerson, designed to handle large edge capacities efficiently. Instead of augmenting arbitrarily, it focuses on high-capacity edges first, gradually refining the flow as the scaling parameter decreases.</p>
<p>This approach reduces the number of augmentations by focusing early on “big pipes” before worrying about smaller ones.</p>
<section id="what-problem-are-we-solving-54" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-54">What Problem Are We Solving?</h4>
<p>Given a directed flow network <span class="math inline">\(G = (V, E)\)</span> with</p>
<ul>
<li>source <span class="math inline">\(s\)</span>,</li>
<li>sink <span class="math inline">\(t\)</span>,</li>
<li>nonnegative capacities <span class="math inline">\(c(u, v)\)</span>,</li>
</ul>
<p>we want to compute a maximum flow <span class="math inline">\(f(u, v)\)</span> satisfying:</p>
<ol type="1">
<li>Capacity constraint: <span class="math display">\[0 \le f(u, v) \le c(u, v)\]</span></li>
<li>Flow conservation: <span class="math display">\[\sum_{(u,v)\in E} f(u,v) = \sum_{(v,u)\in E} f(v,u), \quad \forall u \neq s,t\]</span></li>
<li>Maximize: <span class="math display">\[|f| = \sum_{(s,v)\in E} f(s,v)\]</span></li>
</ol>
<p>When capacities are large, standard augmenting-path methods can take many iterations. Capacity scaling reduces this by grouping edges by capacity magnitude.</p>
</section>
<section id="how-does-it-work-plain-language-54" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-54">How Does It Work (Plain Language)?</h4>
<p>We introduce a scaling parameter <span class="math inline">\(\Delta\)</span>, starting from the highest power of 2 below the maximum capacity. We only consider edges with residual capacity ≥ Δ during augmentations. Once no such path exists, halve <span class="math inline">\(\Delta\)</span> and continue.</p>
<p>This ensures we push large flows early and refine later.</p>
<p>Step-by-step:</p>
<ol type="1">
<li><p>Initialize <span class="math inline">\(f(u,v) = 0\)</span>.</p></li>
<li><p>Let <span class="math display">\[\Delta = 2^{\lfloor \log_2 C_{\max} \rfloor}\]</span> where <span class="math inline">\(C_{\max} = \max_{(u,v)\in E} c(u,v)\)</span></p></li>
<li><p>While <span class="math inline">\(\Delta \ge 1\)</span>:</p>
<ul>
<li><p>Build Δ-residual graph: edges with residual capacity <span class="math inline">\(\ge \Delta\)</span></p></li>
<li><p>While an augmenting path exists in this graph:</p>
<ul>
<li>Send flow equal to the bottleneck along that path</li>
</ul></li>
<li><p>Update <span class="math inline">\(\Delta \gets \Delta / 2\)</span></p></li>
</ul></li>
<li><p>Return total flow.</p></li>
</ol>
</section>
<section id="tiny-code-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-10">Tiny Code</h4>
<p>Python (DFS Augmentation with Scaling)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, t, f, visited, capacity, flow, delta):</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u <span class="op">==</span> t:</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> f</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    visited[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(capacity)):</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>        residual <span class="op">=</span> capacity[u][v] <span class="op">-</span> flow[u][v]</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> residual <span class="op">&gt;=</span> delta <span class="kw">and</span> <span class="kw">not</span> visited[v]:</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>            pushed <span class="op">=</span> dfs(v, t, <span class="bu">min</span>(f, residual), visited, capacity, flow, delta)</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pushed <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>                flow[u][v] <span class="op">+=</span> pushed</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>                flow[v][u] <span class="op">-=</span> pushed</span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pushed</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> capacity_scaling(capacity, s, t):</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(capacity)</span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>    flow <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>    Cmax <span class="op">=</span> <span class="bu">max</span>(<span class="bu">max</span>(row) <span class="cf">for</span> row <span class="kw">in</span> capacity)</span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>    delta <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> delta <span class="op">*</span> <span class="dv">2</span> <span class="op">&lt;=</span> Cmax:</span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>    max_flow <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> delta <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a>            visited <span class="op">=</span> [<span class="va">False</span>]<span class="op">*</span>n</span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>            pushed <span class="op">=</span> dfs(s, t, <span class="bu">float</span>(<span class="st">'inf'</span>), visited, capacity, flow, delta)</span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pushed <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a>            max_flow <span class="op">+=</span> pushed</span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_flow</span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> [</span>
<span id="cb107-35"><a href="#cb107-35" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">16</span>, <span class="dv">13</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb107-36"><a href="#cb107-36" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb107-37"><a href="#cb107-37" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">14</span>, <span class="dv">0</span>],</span>
<span id="cb107-38"><a href="#cb107-38" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>],</span>
<span id="cb107-39"><a href="#cb107-39" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">0</span>, <span class="dv">4</span>],</span>
<span id="cb107-40"><a href="#cb107-40" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb107-41"><a href="#cb107-41" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb107-42"><a href="#cb107-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(capacity_scaling(capacity, <span class="dv">0</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>23</code></pre>
</section>
<section id="why-it-matters-54" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-54">Why It Matters</h4>
<ul>
<li>Reduces augmentations compared to plain Ford–Fulkerson.</li>
<li>Focuses on big pushes first, improving convergence.</li>
<li>Demonstrates the power of scaling ideas, a recurring optimization in algorithm design.</li>
<li>Serves as a stepping stone to cost scaling and capacity scaling in min-cost flow.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-54" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-54">A Gentle Proof (Why It Works)</h4>
<p>At each scaling phase <span class="math inline">\(\Delta\)</span>,</p>
<ul>
<li>Each augmenting path increases flow by at least <span class="math inline">\(\Delta\)</span>.</li>
<li>Total flow value is at most <span class="math inline">\(|f^*|\)</span>.</li>
<li>Therefore, each phase performs at most <span class="math inline">\(O(|f^*| / \Delta)\)</span> augmentations.</li>
</ul>
<p>Since <span class="math inline">\(\Delta\)</span> halves each phase, the total number of augmentations is <span class="math display">\[
O(E \log C_{\max})
\]</span></p>
<p>Each path search takes <span class="math inline">\(O(E)\)</span>, so <span class="math display">\[
T = O(E^2 \log C_{\max})
\]</span></p>
<p>Termination occurs when <span class="math inline">\(\Delta = 1\)</span> and no path remains, meaning max flow reached.</p>
</section>
<section id="try-it-yourself-54" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-54">Try It Yourself</h4>
<ol type="1">
<li>Compare augmentation order with Ford–Fulkerson.</li>
<li>Track <span class="math inline">\(\Delta\)</span> values and residual graphs per phase.</li>
<li>Observe faster convergence for large capacities.</li>
<li>Combine with BFS to mimic Edmonds–Karp structure.</li>
<li>Visualize flow accumulation at each scale.</li>
</ol>
</section>
<section id="test-cases-54" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-54">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Classic 6-node</td>
<td>23</td>
<td>textbook example</td>
</tr>
<tr class="even">
<td>Large capacity edges</td>
<td>same flow, fewer steps</td>
<td>scaling helps</td>
</tr>
<tr class="odd">
<td>Unit capacities</td>
<td>behaves like Edmonds–Karp</td>
<td>small gains</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-54" class="level4">
<h4 class="anchored" data-anchor-id="complexity-54">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E^2 \log C_{\max})\)</span></li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
<li>Augmentations: <span class="math inline">\(O(E \log C_{\max})\)</span></li>
</ul>
<p>Capacity scaling embodies a simple but powerful idea: solve coarse first, refine later, push the big flows early, and polish at the end.</p>
</section>
</section>
<section id="cost-scaling" class="level3">
<h3 class="anchored" data-anchor-id="cost-scaling">356 Cost Scaling</h3>
<p>The Cost Scaling algorithm tackles the Minimum-Cost Maximum Flow (MCMF) problem by applying a scaling technique not to capacities but to edge costs. It gradually refines the precision of reduced costs, maintaining ε-optimality throughout, and converges to the true optimal flow.</p>
<p>This approach is both theoretically elegant and practically efficient, forming the foundation for high-performance network optimization solvers.</p>
<section id="what-problem-are-we-solving-55" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-55">What Problem Are We Solving?</h4>
<p>Given a directed network <span class="math inline">\(G = (V, E)\)</span> with</p>
<ul>
<li>capacity <span class="math inline">\(c(u, v) \ge 0\)</span>,</li>
<li>cost (per unit flow) <span class="math inline">\(w(u, v)\)</span>,</li>
<li>source <span class="math inline">\(s\)</span>, and sink <span class="math inline">\(t\)</span>,</li>
</ul>
<p>we want to send the maximum flow from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> at minimum total cost.</p>
<p>We minimize: <span class="math display">\[
\text{Cost}(f) = \sum_{(u,v)\in E} f(u,v), w(u,v)
\]</span></p>
<p>subject to:</p>
<ul>
<li>Capacity constraint: <span class="math inline">\(0 \le f(u,v) \le c(u,v)\)</span></li>
<li>Conservation: <span class="math inline">\(\sum_v f(u,v) = \sum_v f(v,u)\)</span> for all <span class="math inline">\(u \neq s,t\)</span></li>
</ul>
</section>
<section id="how-does-it-work-plain-language-55" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-55">How Does It Work (Plain Language)?</h4>
<p>Cost scaling uses successive refinements of reduced costs, ensuring flows are ε-optimal at each phase.</p>
<p>An ε-optimal flow satisfies: <span class="math display">\[
c_p(u,v) = w(u,v) + \pi(u) - \pi(v) \ge -\varepsilon
\]</span> for all residual edges <span class="math inline">\((u,v)\)</span>, where <span class="math inline">\(\pi\)</span> is a potential function.</p>
<p>The algorithm begins with a large <span class="math inline">\(\varepsilon\)</span> (often <span class="math inline">\(C_{\max}\)</span> or <span class="math inline">\(W_{\max}\)</span>) and reduces it geometrically (e.g.&nbsp;<span class="math inline">\(\varepsilon \gets \varepsilon / 2\)</span>). During each phase, pushes are allowed only along admissible edges (<span class="math inline">\(c_p(u,v) &lt; 0\)</span>), maintaining ε-optimality.</p>
<p>Step-by-step:</p>
<ol type="1">
<li><p>Initialize preflow (push as much as possible from <span class="math inline">\(s\)</span>).</p></li>
<li><p>Set <span class="math inline">\(\varepsilon = C_{\max}\)</span>.</p></li>
<li><p>While <span class="math inline">\(\varepsilon \ge 1\)</span>:</p>
<ul>
<li><p>Maintain ε-optimality: adjust flows and potentials.</p></li>
<li><p>For each vertex with excess,</p>
<ul>
<li>Push flow along admissible edges (<span class="math inline">\(c_p(u,v) &lt; 0\)</span>).</li>
<li>If stuck, relabel by increasing <span class="math inline">\(\pi(u)\)</span> (lowering reduced costs).</li>
</ul></li>
<li><p>Halve <span class="math inline">\(\varepsilon\)</span>.</p></li>
</ul></li>
<li><p>When <span class="math inline">\(\varepsilon &lt; 1\)</span>, solution is optimal.</p></li>
</ol>
</section>
<section id="tiny-code-simplified-skeleton" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-skeleton">Tiny Code (Simplified Skeleton)</h4>
<p>Below is a conceptual outline (not a full implementation) for educational clarity:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cost_scaling_mcmf(V, edges, s, t):</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    INF <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    adj <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, cap, cost <span class="kw">in</span> edges:</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>        adj[u].append([v, cap, cost, <span class="bu">len</span>(adj[v])])</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>        adj[v].append([u, <span class="dv">0</span>, <span class="op">-</span>cost, <span class="bu">len</span>(adj[u]) <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>V  <span class="co"># potentials</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>    excess <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>V</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    excess[s] <span class="op">=</span> INF</span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> reduced_cost(u, v, cost):</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cost <span class="op">+</span> pi[u] <span class="op">-</span> pi[v]</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>    epsilon <span class="op">=</span> <span class="bu">max</span>(<span class="bu">abs</span>(c) <span class="cf">for</span> _,_,_,c <span class="kw">in</span> edges)</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> epsilon <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>        active <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(V) <span class="cf">if</span> excess[i] <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> i <span class="op">!=</span> s <span class="kw">and</span> i <span class="op">!=</span> t]</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> active:</span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> active.pop()</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> e <span class="kw">in</span> adj[u]:</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>                v, cap, cost, rev <span class="op">=</span> e</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>                rc <span class="op">=</span> reduced_cost(u, v, cost)</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cap <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> rc <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>                    delta <span class="op">=</span> <span class="bu">min</span>(cap, excess[u])</span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>                    e[<span class="dv">1</span>] <span class="op">-=</span> delta</span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>                    adj[v][rev][<span class="dv">1</span>] <span class="op">+=</span> delta</span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>                    excess[u] <span class="op">-=</span> delta</span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>                    excess[v] <span class="op">+=</span> delta</span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> (s, t) <span class="kw">and</span> excess[v] <span class="op">==</span> delta:</span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>                        active.append(v)</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> excess[u] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>                pi[u] <span class="op">+=</span> epsilon</span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true" tabindex="-1"></a>        epsilon <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(V):</span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v, cap, cost, rev <span class="kw">in</span> adj[u]:</span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cost <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb109-39"><a href="#cb109-39" aria-hidden="true" tabindex="-1"></a>                total_cost <span class="op">+=</span> cost <span class="op">*</span> (adj[v][rev][<span class="dv">1</span>])</span>
<span id="cb109-40"><a href="#cb109-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_cost</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-55" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-55">Why It Matters</h4>
<ul>
<li>Avoids expensive shortest-path searches at each step.</li>
<li>Ensures strong polynomial bounds using ε-optimality.</li>
<li>Suitable for dense graphs and large integer costs.</li>
<li>Forms the backbone of network simplex and scalable MCMF solvers.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-55" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-55">A Gentle Proof (Why It Works)</h4>
<ol type="1">
<li>ε-optimality: ensures approximate optimality at each scaling phase.</li>
<li>Scaling: reduces ε geometrically, converging to exact optimality.</li>
<li>Termination: when <span class="math inline">\(\varepsilon &lt; 1\)</span>, all reduced costs are nonnegative, the flow is optimal.</li>
</ol>
<p>Each push respects capacity and admissibility; each relabel decreases ε, guaranteeing progress.</p>
</section>
<section id="try-it-yourself-55" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-55">Try It Yourself</h4>
<ol type="1">
<li>Compare to Successive Shortest Path algorithm, note fewer path searches.</li>
<li>Track how potentials <span class="math inline">\(\pi(u)\)</span> evolve over phases.</li>
<li>Visualize ε-layers of admissible edges.</li>
<li>Experiment with cost magnitudes, larger costs benefit more from scaling.</li>
<li>Observe convergence as ε halves each phase.</li>
</ol>
</section>
<section id="test-cases-55" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-55">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Min Cost</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple 3-node</td>
<td>5</td>
<td>10</td>
<td>small example</td>
</tr>
<tr class="even">
<td>Classic network</td>
<td>23</td>
<td>42</td>
<td>cost-scaled</td>
</tr>
<tr class="odd">
<td>Dense graph</td>
<td>varies</td>
<td>efficient</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-55" class="level4">
<h4 class="anchored" data-anchor-id="complexity-55">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E \log C_{\max} (V + E))\)</span> (depends on cost range)</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Phases: <span class="math inline">\(O(\log C_{\max})\)</span></li>
</ul>
<p>Cost scaling showcases the precision-refinement paradigm, start coarse, end exact. It’s a masterclass in combining scaling, potential functions, and local admissibility to achieve globally optimal flows.</p>
</section>
</section>
<section id="min-cost-max-flow-bellman-ford" class="level3">
<h3 class="anchored" data-anchor-id="min-cost-max-flow-bellman-ford">357 Min-Cost Max-Flow (Bellman-Ford)</h3>
<p>The Min-Cost Max-Flow (MCMF) algorithm with Bellman-Ford is a cornerstone method for solving flow problems where both capacity and cost constraints matter. It repeatedly augments flow along the shortest-cost paths, ensuring every unit of flow moves as cheaply as possible.</p>
<p>This version uses Bellman-Ford to handle negative edge costs, ensuring correctness even when cycles reduce total cost.</p>
<section id="what-problem-are-we-solving-56" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-56">What Problem Are We Solving?</h4>
<p>Given a directed graph <span class="math inline">\(G = (V, E)\)</span> with:</p>
<ul>
<li>Capacity <span class="math inline">\(c(u, v)\)</span></li>
<li>Cost per unit flow <span class="math inline">\(w(u, v)\)</span></li>
<li>Source <span class="math inline">\(s\)</span> and sink <span class="math inline">\(t\)</span></li>
</ul>
<p>Find a flow <span class="math inline">\(f(u, v)\)</span> that:</p>
<ol type="1">
<li>Respects capacities: <span class="math inline">\(0 \le f(u, v) \le c(u, v)\)</span></li>
<li>Conserves flow: <span class="math inline">\(\sum_v f(u, v) = \sum_v f(v, u)\)</span> for all <span class="math inline">\(u \neq s,t\)</span></li>
<li>Maximizes total flow, while</li>
<li>Minimizing total cost: <span class="math display">\[
\text{Cost}(f) = \sum_{(u,v)\in E} f(u,v),w(u,v)
\]</span></li>
</ol>
</section>
<section id="how-does-it-work-plain-language-56" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-56">How Does It Work (Plain Language)?</h4>
<p>The algorithm iteratively finds augmenting paths from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> using shortest path search by cost (not distance).</p>
<p>At each iteration:</p>
<ol type="1">
<li>Run Bellman-Ford on the residual graph to find the shortest-cost path.</li>
<li>Determine the bottleneck capacity <span class="math inline">\(\delta\)</span> on that path.</li>
<li>Augment flow along that path by <span class="math inline">\(\delta\)</span>.</li>
<li>Update residual capacities and reverse edges.</li>
<li>Repeat until no more augmenting paths exist.</li>
</ol>
<p>Because Bellman-Ford supports negative costs, this algorithm correctly handles graphs where cost reductions occur via cycles.</p>
</section>
<section id="tiny-code-c-like-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-like-pseudocode">Tiny Code (C-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb110"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge <span class="op">{</span> <span class="dt">int</span> v<span class="op">,</span> cap<span class="op">,</span> cost<span class="op">,</span> rev<span class="op">;</span> <span class="op">};</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> adj<span class="op">[</span>V<span class="op">];</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dist<span class="op">[</span>V<span class="op">],</span> parent<span class="op">[</span>V<span class="op">],</span> parent_edge<span class="op">[</span>V<span class="op">];</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bellman_ford<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> V<span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>    fill<span class="op">(</span>dist<span class="op">,</span> dist<span class="op">+</span>V<span class="op">,</span> INF<span class="op">);</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> updated <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">-</span><span class="dv">1</span> <span class="op">&amp;&amp;</span> updated<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>        updated <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> V<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> INF<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> adj<span class="op">[</span>u<span class="op">].</span>size<span class="op">();</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> <span class="op">&amp;</span>e <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>e<span class="op">.</span>cap <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> dist<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">&gt;</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> e<span class="op">.</span>cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>                    dist<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> e<span class="op">.</span>cost<span class="op">;</span></span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>                    parent<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>                    parent_edge<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>                    updated <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist<span class="op">[</span>t<span class="op">]</span> <span class="op">&lt;</span> INF<span class="op">;</span></span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span> min_cost_max_flow<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> V<span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> flow <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> cost <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>bellman_ford<span class="op">(</span>s<span class="op">,</span> t<span class="op">,</span> V<span class="op">))</span> <span class="op">{</span></span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> f <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb110-31"><a href="#cb110-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> t<span class="op">;</span> v <span class="op">!=</span> s<span class="op">;</span> v <span class="op">=</span> parent<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb110-32"><a href="#cb110-32" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> parent<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb110-33"><a href="#cb110-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> <span class="op">&amp;</span>e <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>parent_edge<span class="op">[</span>v<span class="op">]];</span></span>
<span id="cb110-34"><a href="#cb110-34" aria-hidden="true" tabindex="-1"></a>            f <span class="op">=</span> min<span class="op">(</span>f<span class="op">,</span> e<span class="op">.</span>cap<span class="op">);</span></span>
<span id="cb110-35"><a href="#cb110-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb110-36"><a href="#cb110-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> t<span class="op">;</span> v <span class="op">!=</span> s<span class="op">;</span> v <span class="op">=</span> parent<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb110-37"><a href="#cb110-37" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> parent<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb110-38"><a href="#cb110-38" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> <span class="op">&amp;</span>e <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>parent_edge<span class="op">[</span>v<span class="op">]];</span></span>
<span id="cb110-39"><a href="#cb110-39" aria-hidden="true" tabindex="-1"></a>            e<span class="op">.</span>cap <span class="op">-=</span> f<span class="op">;</span></span>
<span id="cb110-40"><a href="#cb110-40" aria-hidden="true" tabindex="-1"></a>            adj<span class="op">[</span>v<span class="op">][</span>e<span class="op">.</span>rev<span class="op">].</span>cap <span class="op">+=</span> f<span class="op">;</span></span>
<span id="cb110-41"><a href="#cb110-41" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">+=</span> f <span class="op">*</span> e<span class="op">.</span>cost<span class="op">;</span></span>
<span id="cb110-42"><a href="#cb110-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb110-43"><a href="#cb110-43" aria-hidden="true" tabindex="-1"></a>        flow <span class="op">+=</span> f<span class="op">;</span></span>
<span id="cb110-44"><a href="#cb110-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb110-45"><a href="#cb110-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>flow<span class="op">,</span> cost<span class="op">};</span></span>
<span id="cb110-46"><a href="#cb110-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-56" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-56">Why It Matters</h4>
<ul>
<li>Handles negative edge costs safely.</li>
<li>Guaranteed optimality if no negative cycles exist.</li>
<li>Works well for small to medium graphs.</li>
<li>A foundation for more efficient variants (e.g.&nbsp;SPFA, Dijkstra with potentials).</li>
</ul>
<p>It’s the go-to teaching implementation for min-cost flow, balancing clarity and correctness.</p>
</section>
<section id="a-gentle-proof-why-it-works-56" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-56">A Gentle Proof (Why It Works)</h4>
<p>Each iteration finds a shortest-cost augmenting path using Bellman-Ford. Because edge costs are non-decreasing over augmentations, the algorithm converges to a globally optimal flow.</p>
<p>Each augmentation:</p>
<ul>
<li>Increases flow.</li>
<li>Does not introduce cheaper paths later (monotonicity).</li>
<li>Terminates when no more augmenting paths exist.</li>
</ul>
<p>Thus, the resulting flow is both maximal and minimum cost.</p>
</section>
<section id="try-it-yourself-56" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-56">Try It Yourself</h4>
<ol type="1">
<li>Draw a simple graph with 4 nodes and a negative edge.</li>
<li>Trace residual updates after each augmentation.</li>
<li>Compare results with a naive greedy path selection.</li>
<li>Replace Bellman-Ford with Dijkstra + potentials to improve speed.</li>
<li>Visualize residual capacity evolution.</li>
</ol>
</section>
<section id="test-cases-56" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-56">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 41%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Min Cost</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain <span class="math inline">\(s \to a \to b \to t\)</span></td>
<td>5</td>
<td>10</td>
<td>Simple path</td>
</tr>
<tr class="even">
<td>Graph with negative cycle</td>
<td>Invalid</td>
<td>-</td>
<td>Must detect</td>
</tr>
<tr class="odd">
<td>Grid-like network</td>
<td>12</td>
<td>24</td>
<td>Multiple augmentations</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-56" class="level4">
<h4 class="anchored" data-anchor-id="complexity-56">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(F \cdot V \cdot E)\)</span>, where <span class="math inline">\(F\)</span> is total flow sent.</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>For small graphs or graphs with negative weights, Bellman-Ford MCMF is the most robust and straightforward method, clear, reliable, and foundational.</p>
</section>
</section>
<section id="min-cost-max-flow-spfa" class="level3">
<h3 class="anchored" data-anchor-id="min-cost-max-flow-spfa">358 Min-Cost Max-Flow (SPFA)</h3>
<p>The Min-Cost Max-Flow algorithm using SPFA (Shortest Path Faster Algorithm) is an optimization of the Bellman–Ford approach. It leverages a queue-based relaxation method to find the shortest-cost augmenting paths more efficiently in practice, especially on sparse graphs or when negative edges are rare.</p>
<section id="what-problem-are-we-solving-57" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-57">What Problem Are We Solving?</h4>
<p>We are solving the minimum-cost maximum-flow problem: Find a flow <span class="math inline">\(f\)</span> in a directed graph <span class="math inline">\(G = (V, E)\)</span> with:</p>
<ul>
<li>Capacity <span class="math inline">\(c(u, v) \ge 0\)</span></li>
<li>Cost per unit flow <span class="math inline">\(w(u, v)\)</span></li>
<li>Source <span class="math inline">\(s\)</span>, Sink <span class="math inline">\(t\)</span></li>
</ul>
<p>Subject to:</p>
<ol type="1">
<li>Capacity constraint: <span class="math inline">\(0 \le f(u, v) \le c(u, v)\)</span></li>
<li>Conservation of flow: <span class="math inline">\(\sum_v f(u,v) = \sum_v f(v,u)\)</span> for all <span class="math inline">\(u \neq s,t\)</span></li>
<li>Objective: <span class="math display">\[
\min \text{Cost}(f) = \sum_{(u,v)\in E} f(u,v),w(u,v)
\]</span></li>
</ol>
<p>We seek a maximum flow from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> that incurs the minimum total cost.</p>
</section>
<section id="how-does-it-work-plain-language-57" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-57">How Does It Work (Plain Language)?</h4>
<p>SPFA finds shortest paths by cost more efficiently than Bellman–Ford, using a queue to relax only the vertices that can still improve distances.</p>
<p>In each iteration:</p>
<ol type="1">
<li>Run SPFA on the residual graph to find the shortest-cost path.</li>
<li>Compute the bottleneck flow <span class="math inline">\(\delta\)</span> on that path.</li>
<li>Augment <span class="math inline">\(\delta\)</span> units of flow along the path.</li>
<li>Update residual capacities and reverse edges.</li>
<li>Repeat until no augmenting path remains.</li>
</ol>
<p>SPFA dynamically manages which nodes are in the queue, making it faster on average than full Bellman–Ford (though worst-case still similar).</p>
</section>
<section id="tiny-code-c-like-pseudocode-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-like-pseudocode-1">Tiny Code (C-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb111"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge <span class="op">{</span> <span class="dt">int</span> v<span class="op">,</span> cap<span class="op">,</span> cost<span class="op">,</span> rev<span class="op">;</span> <span class="op">};</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> adj<span class="op">[</span>V<span class="op">];</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dist<span class="op">[</span>V<span class="op">],</span> parent<span class="op">[</span>V<span class="op">],</span> parent_edge<span class="op">[</span>V<span class="op">];</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> in_queue<span class="op">[</span>V<span class="op">];</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> spfa<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> V<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    fill<span class="op">(</span>dist<span class="op">,</span> dist<span class="op">+</span>V<span class="op">,</span> INF<span class="op">);</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    fill<span class="op">(</span>in_queue<span class="op">,</span> in_queue<span class="op">+</span>V<span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>    queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> q<span class="op">;</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>    q<span class="op">.</span>push<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>    in_queue<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>q<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> q<span class="op">.</span>front<span class="op">();</span> q<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a>        in_queue<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> adj<span class="op">[</span>u<span class="op">].</span>size<span class="op">();</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> <span class="op">&amp;</span>e <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb111-19"><a href="#cb111-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>e<span class="op">.</span>cap <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> dist<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">&gt;</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> e<span class="op">.</span>cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-20"><a href="#cb111-20" aria-hidden="true" tabindex="-1"></a>                dist<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> e<span class="op">.</span>cost<span class="op">;</span></span>
<span id="cb111-21"><a href="#cb111-21" aria-hidden="true" tabindex="-1"></a>                parent<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb111-22"><a href="#cb111-22" aria-hidden="true" tabindex="-1"></a>                parent_edge<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb111-23"><a href="#cb111-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>in_queue<span class="op">[</span>e<span class="op">.</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb111-24"><a href="#cb111-24" aria-hidden="true" tabindex="-1"></a>                    q<span class="op">.</span>push<span class="op">(</span>e<span class="op">.</span>v<span class="op">);</span></span>
<span id="cb111-25"><a href="#cb111-25" aria-hidden="true" tabindex="-1"></a>                    in_queue<span class="op">[</span>e<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb111-26"><a href="#cb111-26" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb111-27"><a href="#cb111-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb111-28"><a href="#cb111-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb111-29"><a href="#cb111-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb111-30"><a href="#cb111-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist<span class="op">[</span>t<span class="op">]</span> <span class="op">&lt;</span> INF<span class="op">;</span></span>
<span id="cb111-31"><a href="#cb111-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb111-32"><a href="#cb111-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-33"><a href="#cb111-33" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span> min_cost_max_flow<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> V<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-34"><a href="#cb111-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> flow <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> cost <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb111-35"><a href="#cb111-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>spfa<span class="op">(</span>s<span class="op">,</span> t<span class="op">,</span> V<span class="op">))</span> <span class="op">{</span></span>
<span id="cb111-36"><a href="#cb111-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> f <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb111-37"><a href="#cb111-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> t<span class="op">;</span> v <span class="op">!=</span> s<span class="op">;</span> v <span class="op">=</span> parent<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb111-38"><a href="#cb111-38" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> parent<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb111-39"><a href="#cb111-39" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> <span class="op">&amp;</span>e <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>parent_edge<span class="op">[</span>v<span class="op">]];</span></span>
<span id="cb111-40"><a href="#cb111-40" aria-hidden="true" tabindex="-1"></a>            f <span class="op">=</span> min<span class="op">(</span>f<span class="op">,</span> e<span class="op">.</span>cap<span class="op">);</span></span>
<span id="cb111-41"><a href="#cb111-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb111-42"><a href="#cb111-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> t<span class="op">;</span> v <span class="op">!=</span> s<span class="op">;</span> v <span class="op">=</span> parent<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb111-43"><a href="#cb111-43" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> parent<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb111-44"><a href="#cb111-44" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> <span class="op">&amp;</span>e <span class="op">=</span> adj<span class="op">[</span>u<span class="op">][</span>parent_edge<span class="op">[</span>v<span class="op">]];</span></span>
<span id="cb111-45"><a href="#cb111-45" aria-hidden="true" tabindex="-1"></a>            e<span class="op">.</span>cap <span class="op">-=</span> f<span class="op">;</span></span>
<span id="cb111-46"><a href="#cb111-46" aria-hidden="true" tabindex="-1"></a>            adj<span class="op">[</span>v<span class="op">][</span>e<span class="op">.</span>rev<span class="op">].</span>cap <span class="op">+=</span> f<span class="op">;</span></span>
<span id="cb111-47"><a href="#cb111-47" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">+=</span> f <span class="op">*</span> e<span class="op">.</span>cost<span class="op">;</span></span>
<span id="cb111-48"><a href="#cb111-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb111-49"><a href="#cb111-49" aria-hidden="true" tabindex="-1"></a>        flow <span class="op">+=</span> f<span class="op">;</span></span>
<span id="cb111-50"><a href="#cb111-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb111-51"><a href="#cb111-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>flow<span class="op">,</span> cost<span class="op">};</span></span>
<span id="cb111-52"><a href="#cb111-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-57" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-57">Why It Matters</h4>
<ul>
<li>Practical speedup over Bellman–Ford, especially in sparse networks.</li>
<li>Handles negative edges safely (no negative cycles).</li>
<li>Widely used in competitive programming and network optimization.</li>
<li>Easier to implement than Dijkstra-based variants.</li>
</ul>
<p>SPFA combines the simplicity of Bellman–Ford with real-world efficiency, often reducing redundant relaxations dramatically.</p>
</section>
<section id="a-gentle-proof-why-it-works-57" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-57">A Gentle Proof (Why It Works)</h4>
<p>Each SPFA run computes a shortest-cost augmenting path. Augmenting along that path ensures:</p>
<ul>
<li>The flow remains feasible,</li>
<li>The cost strictly decreases, and</li>
<li>The process terminates after a finite number of augmentations (bounded by total flow).</li>
</ul>
<p>Because SPFA always respects shortest-path distances, the final flow is cost-optimal.</p>
</section>
<section id="try-it-yourself-57" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-57">Try It Yourself</h4>
<ol type="1">
<li>Replace Bellman–Ford in your MCMF with SPFA.</li>
<li>Compare runtime on sparse vs dense graphs.</li>
<li>Add an edge with negative cost and verify correct behavior.</li>
<li>Visualize queue contents after each relaxation.</li>
<li>Measure how many times each vertex is processed.</li>
</ol>
</section>
<section id="test-cases-57" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-57">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Min Cost</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain graph</td>
<td>4</td>
<td>12</td>
<td>Simple</td>
</tr>
<tr class="even">
<td>Sparse DAG</td>
<td>10</td>
<td>25</td>
<td>SPFA efficient</td>
</tr>
<tr class="odd">
<td>Dense graph</td>
<td>15</td>
<td>40</td>
<td>Similar to Bellman–Ford</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-57" class="level4">
<h4 class="anchored" data-anchor-id="complexity-57">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(F \cdot E)\)</span> on average, <span class="math inline">\(O(F \cdot V \cdot E)\)</span> worst-case</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>SPFA-based MCMF blends clarity, practical efficiency, and negative-cost support, making it a favorite for real-world min-cost flow implementations.</p>
</section>
</section>
<section id="circulation-with-demands" class="level3">
<h3 class="anchored" data-anchor-id="circulation-with-demands">359 Circulation with Demands</h3>
<p>The Circulation with Demands problem is a generalization of the classic flow and min-cost flow problems. Instead of having just a single source and sink, every node can demand or supply a certain amount of flow. Your goal is to find a feasible circulation—a flow that satisfies all node demands and capacity limits.</p>
<p>This formulation unifies network flow, feasibility checking, and optimization under one elegant model.</p>
<section id="what-problem-are-we-solving-58" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-58">What Problem Are We Solving?</h4>
<p>Given a directed graph <span class="math inline">\(G = (V, E)\)</span>, each edge <span class="math inline">\((u,v)\)</span> has:</p>
<ul>
<li>Lower bound <span class="math inline">\(l(u,v)\)</span></li>
<li>Upper bound (capacity) <span class="math inline">\(c(u,v)\)</span></li>
<li>Cost <span class="math inline">\(w(u,v)\)</span></li>
</ul>
<p>Each vertex <span class="math inline">\(v\)</span> may have a demand <span class="math inline">\(b(v)\)</span> (positive means it needs inflow, negative means it provides outflow).</p>
<p>We want to find a circulation (a flow satisfying <span class="math inline">\(f(u,v)\)</span> for all edges) such that:</p>
<ol type="1">
<li>Capacity constraints: <span class="math display">\[
l(u,v) \le f(u,v) \le c(u,v)
\]</span></li>
<li>Flow conservation: <span class="math display">\[
\sum_{(u,v)\in E} f(u,v) - \sum_{(v,u)\in E} f(v,u) = b(v)
\]</span></li>
<li>Optional cost minimization: <span class="math display">\[
\min \sum_{(u,v)\in E} f(u,v),w(u,v)
\]</span></li>
</ol>
<p>A feasible circulation exists if all demands can be met simultaneously.</p>
</section>
<section id="how-does-it-work-plain-language-58" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-58">How Does It Work (Plain Language)?</h4>
<p>The trick is to transform this into a standard min-cost flow problem with a super-source and super-sink.</p>
<p>Step-by-step transformation:</p>
<ol type="1">
<li><p>For each edge <span class="math inline">\((u,v)\)</span> with lower bound <span class="math inline">\(l(u,v)\)</span>:</p>
<ul>
<li>Reduce the capacity to <span class="math inline">\((c(u,v) - l(u,v))\)</span>.</li>
<li>Subtract <span class="math inline">\(l(u,v)\)</span> from the demands: <span class="math display">\[
b(u) \mathrel{{-}{=}} l(u,v), \quad b(v) \mathrel{{+}{=}} l(u,v)
\]</span></li>
</ul></li>
<li><p>Add a super-source <span class="math inline">\(S\)</span> and super-sink <span class="math inline">\(T\)</span>:</p>
<ul>
<li><p>For each node <span class="math inline">\(v\)</span>:</p>
<ul>
<li>If <span class="math inline">\(b(v) &gt; 0\)</span>, add edge <span class="math inline">\((S,v)\)</span> with capacity <span class="math inline">\(b(v)\)</span>.</li>
<li>If <span class="math inline">\(b(v) &lt; 0\)</span>, add edge <span class="math inline">\((v,T)\)</span> with capacity <span class="math inline">\(-b(v)\)</span>.</li>
</ul></li>
</ul></li>
<li><p>Solve Max Flow (or Min-Cost Flow) from <span class="math inline">\(S\)</span> to <span class="math inline">\(T\)</span>.</p></li>
<li><p>If the max flow = total demand, a feasible circulation exists. Otherwise, no circulation satisfies all constraints.</p></li>
</ol>
</section>
<section id="tiny-code-simplified-example-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-example-1">Tiny Code (Simplified Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circulation_with_demands(V, edges, demand):</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># edges: (u, v, lower, cap, cost)</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># demand: list of node demands b(v)</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>    adj <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V <span class="op">+</span> <span class="dv">2</span>)]</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>    S, T <span class="op">=</span> V, V <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> demand[:]</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, low, cap, cost <span class="kw">in</span> edges:</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>        cap <span class="op">-=</span> low</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>        b[u] <span class="op">-=</span> low</span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>        b[v] <span class="op">+=</span> low</span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>        adj[u].append((v, cap, cost))</span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>        adj[v].append((u, <span class="dv">0</span>, <span class="op">-</span>cost))</span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>    total_demand <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(V):</span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> b[i] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>            adj[S].append((i, b[i], <span class="dv">0</span>))</span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a>            total_demand <span class="op">+=</span> b[i]</span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> b[i] <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>            adj[i].append((T, <span class="op">-</span>b[i], <span class="dv">0</span>))</span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>    flow, cost <span class="op">=</span> min_cost_max_flow(adj, S, T)</span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> flow <span class="op">==</span> total_demand:</span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Feasible circulation found"</span>)</span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No feasible circulation"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-58" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-58">Why It Matters</h4>
<ul>
<li><p>Unifies multiple problems: Many flow formulations—like assignment, transportation, and scheduling—can be expressed as circulations with demands.</p></li>
<li><p>Handles lower bounds elegantly: Standard flows can’t directly enforce <span class="math inline">\(f(u,v) \ge l(u,v)\)</span>. Circulations fix that.</p></li>
<li><p>Foundation for advanced models: Cost constraints, multi-commodity flows, and balance equations all build on this.</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-58" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-58">A Gentle Proof (Why It Works)</h4>
<p>By enforcing lower bounds, we adjust the net balance of each vertex. After normalization, the system becomes equivalent to finding a flow from super-source to super-sink satisfying all balances.</p>
<p>If such a flow exists, we can reconstruct the original flow: <span class="math display">\[
f'(u,v) = f(u,v) + l(u,v)
\]</span> which satisfies all original constraints.</p>
</section>
<section id="try-it-yourself-58" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-58">Try It Yourself</h4>
<ol type="1">
<li>Model a supply-demand network (e.g., factories → warehouses → stores).</li>
<li>Add lower bounds to enforce minimum delivery.</li>
<li>Introduce node demands to balance supply/consumption.</li>
<li>Solve with min-cost flow and verify circulation.</li>
<li>Remove cost to just check feasibility.</li>
</ol>
</section>
<section id="test-cases-58" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-58">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Network</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Balanced 3-node</td>
<td>Feasible</td>
<td>Simple supply-demand</td>
</tr>
<tr class="even">
<td>Lower bounds exceed total</td>
<td>Infeasible</td>
<td>No solution</td>
</tr>
<tr class="odd">
<td>Mixed positive/negative demands</td>
<td>Feasible</td>
<td>Requires adjustment</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-58" class="level4">
<h4 class="anchored" data-anchor-id="complexity-58">Complexity</h4>
<ul>
<li>Time: depends on flow solver used (<span class="math inline">\(O(E^2V)\)</span> for Bellman–Ford variant)</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Circulation with demands gives a universal framework: any linear flow constraint can be encoded, checked, and optimized—turning balance equations into solvable graph problems.</p>
</section>
</section>
<section id="successive-shortest-path" class="level3">
<h3 class="anchored" data-anchor-id="successive-shortest-path">360 Successive Shortest Path</h3>
<p>The Successive Shortest Path (SSP) algorithm is a clean and intuitive way to solve the Minimum-Cost Maximum-Flow (MCMF) problem. It builds the optimal flow incrementally, one shortest path at a time, always sending flow along the cheapest available route until capacity or balance constraints stop it.</p>
<section id="what-problem-are-we-solving-59" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-59">What Problem Are We Solving?</h4>
<p>Given a directed graph <span class="math inline">\(G = (V, E)\)</span> with:</p>
<ul>
<li>Capacity: <span class="math inline">\(c(u,v)\)</span></li>
<li>Cost per unit flow: <span class="math inline">\(w(u,v)\)</span></li>
<li>Source: <span class="math inline">\(s\)</span> and sink: <span class="math inline">\(t\)</span></li>
</ul>
<p>We want to send the maximum flow from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> with minimum total cost:</p>
<p><span class="math display">\[
\min \sum_{(u,v)\in E} f(u,v), w(u,v)
\]</span></p>
<p>subject to:</p>
<ul>
<li><span class="math inline">\(0 \le f(u,v) \le c(u,v)\)</span></li>
<li>Flow conservation at each vertex except <span class="math inline">\(s,t\)</span></li>
</ul>
</section>
<section id="how-does-it-work-plain-language-59" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-59">How Does It Work (Plain Language)?</h4>
<p>SSP proceeds by repeatedly finding the shortest-cost augmenting path from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> in the residual graph (cost as weight). It then pushes as much flow as possible along that path. Residual edges track available capacity (forward and backward).</p>
<p>Algorithm Steps:</p>
<ol type="1">
<li><p>Initialize flow <span class="math inline">\(f(u,v) = 0\)</span> for all edges.</p></li>
<li><p>Build residual graph with edge costs <span class="math inline">\(w(u,v)\)</span>.</p></li>
<li><p>While there exists a path <span class="math inline">\(P\)</span> from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>:</p>
<ul>
<li>Find shortest path <span class="math inline">\(P\)</span> by cost (using Dijkstra or Bellman–Ford).</li>
<li>Compute bottleneck capacity <span class="math inline">\(\delta = \min_{(u,v)\in P} c_f(u,v)\)</span>.</li>
<li>Augment flow along <span class="math inline">\(P\)</span>: <span class="math display">\[
f(u,v) \mathrel{{+}{=}} \delta,\quad f(v,u) \mathrel{{-}{=}} \delta
\]</span></li>
<li>Update residual capacities and costs.</li>
</ul></li>
<li><p>Repeat until no augmenting path remains.</p></li>
<li><p>Resulting <span class="math inline">\(f\)</span> is the min-cost max-flow.</p></li>
</ol>
<p>If negative edges exist, use Bellman–Ford; otherwise Dijkstra with potentials for efficiency.</p>
</section>
<section id="tiny-code-simplified-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-python">Tiny Code (Simplified Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heapq <span class="im">import</span> heappush, heappop</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> successive_shortest_path(V, edges, s, t):</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    adj <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(V)]</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, cap, cost <span class="kw">in</span> edges:</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>        adj[u].append([v, cap, cost, <span class="bu">len</span>(adj[v])])</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>        adj[v].append([u, <span class="dv">0</span>, <span class="op">-</span>cost, <span class="bu">len</span>(adj[u]) <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>    INF <span class="op">=</span> <span class="dv">109</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>V  <span class="co"># potentials for reduced cost</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    flow <span class="op">=</span> cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">=</span> [INF]<span class="op">*</span>V</span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a>        parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>V</span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a>        parent_edge <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>V</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>        dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb113-18"><a href="#cb113-18" aria-hidden="true" tabindex="-1"></a>        pq <span class="op">=</span> [(<span class="dv">0</span>, s)]</span>
<span id="cb113-19"><a href="#cb113-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pq:</span>
<span id="cb113-20"><a href="#cb113-20" aria-hidden="true" tabindex="-1"></a>            d, u <span class="op">=</span> heappop(pq)</span>
<span id="cb113-21"><a href="#cb113-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> d <span class="op">&gt;</span> dist[u]: <span class="cf">continue</span></span>
<span id="cb113-22"><a href="#cb113-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i, (v, cap, w, rev) <span class="kw">in</span> <span class="bu">enumerate</span>(adj[u]):</span>
<span id="cb113-23"><a href="#cb113-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> cap <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dist[v] <span class="op">&gt;</span> dist[u] <span class="op">+</span> w <span class="op">+</span> pi[u] <span class="op">-</span> pi[v]:</span>
<span id="cb113-24"><a href="#cb113-24" aria-hidden="true" tabindex="-1"></a>                    dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> w <span class="op">+</span> pi[u] <span class="op">-</span> pi[v]</span>
<span id="cb113-25"><a href="#cb113-25" aria-hidden="true" tabindex="-1"></a>                    parent[v] <span class="op">=</span> u</span>
<span id="cb113-26"><a href="#cb113-26" aria-hidden="true" tabindex="-1"></a>                    parent_edge[v] <span class="op">=</span> i</span>
<span id="cb113-27"><a href="#cb113-27" aria-hidden="true" tabindex="-1"></a>                    heappush(pq, (dist[v], v))</span>
<span id="cb113-28"><a href="#cb113-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist[t] <span class="op">==</span> INF:</span>
<span id="cb113-29"><a href="#cb113-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb113-30"><a href="#cb113-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(V):</span>
<span id="cb113-31"><a href="#cb113-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dist[v] <span class="op">&lt;</span> INF:</span>
<span id="cb113-32"><a href="#cb113-32" aria-hidden="true" tabindex="-1"></a>                pi[v] <span class="op">+=</span> dist[v]</span>
<span id="cb113-33"><a href="#cb113-33" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> INF</span>
<span id="cb113-34"><a href="#cb113-34" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> t</span>
<span id="cb113-35"><a href="#cb113-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> v <span class="op">!=</span> s:</span>
<span id="cb113-36"><a href="#cb113-36" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> parent[v]</span>
<span id="cb113-37"><a href="#cb113-37" aria-hidden="true" tabindex="-1"></a>            e <span class="op">=</span> adj[u][parent_edge[v]]</span>
<span id="cb113-38"><a href="#cb113-38" aria-hidden="true" tabindex="-1"></a>            f <span class="op">=</span> <span class="bu">min</span>(f, e[<span class="dv">1</span>])</span>
<span id="cb113-39"><a href="#cb113-39" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> u</span>
<span id="cb113-40"><a href="#cb113-40" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> t</span>
<span id="cb113-41"><a href="#cb113-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> v <span class="op">!=</span> s:</span>
<span id="cb113-42"><a href="#cb113-42" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> parent[v]</span>
<span id="cb113-43"><a href="#cb113-43" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> parent_edge[v]</span>
<span id="cb113-44"><a href="#cb113-44" aria-hidden="true" tabindex="-1"></a>            e <span class="op">=</span> adj[u][i]</span>
<span id="cb113-45"><a href="#cb113-45" aria-hidden="true" tabindex="-1"></a>            e[<span class="dv">1</span>] <span class="op">-=</span> f</span>
<span id="cb113-46"><a href="#cb113-46" aria-hidden="true" tabindex="-1"></a>            adj[v][e[<span class="dv">3</span>]][<span class="dv">1</span>] <span class="op">+=</span> f</span>
<span id="cb113-47"><a href="#cb113-47" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">+=</span> f <span class="op">*</span> e[<span class="dv">2</span>]</span>
<span id="cb113-48"><a href="#cb113-48" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> u</span>
<span id="cb113-49"><a href="#cb113-49" aria-hidden="true" tabindex="-1"></a>        flow <span class="op">+=</span> f</span>
<span id="cb113-50"><a href="#cb113-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flow, cost</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-59" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-59">Why It Matters</h4>
<ul>
<li>Simple and clear logic, augment along cheapest path each time.</li>
<li>Optimal solution for min-cost max-flow when no negative cycles exist.</li>
<li>Can handle large graphs efficiently with reduced costs and potentials.</li>
<li>Forms the basis for cost-scaling and network simplex methods.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-59" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-59">A Gentle Proof (Why It Works)</h4>
<p>Each augmentation moves flow along a shortest path (minimum reduced cost). Reduced costs ensure no negative cycles arise, so each augmentation preserves optimality. Once no augmenting path exists, all reduced costs are nonnegative and <span class="math inline">\(f\)</span> is optimal.</p>
<p>Potentials <span class="math inline">\(\pi(v)\)</span> guarantee Dijkstra finds true shortest paths in transformed graph: <span class="math display">\[
w'(u,v) = w(u,v) + \pi(u) - \pi(v)
\]</span> maintaining equivalence and non-negativity.</p>
</section>
<section id="try-it-yourself-59" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-59">Try It Yourself</h4>
<ol type="1">
<li>Use a simple 4-node network and trace each path’s cost and flow.</li>
<li>Compare augmentations using Bellman–Ford vs Dijkstra.</li>
<li>Add negative edge costs and test with potential adjustments.</li>
<li>Visualize residual graphs after each iteration.</li>
<li>Measure cost convergence per iteration.</li>
</ol>
</section>
<section id="test-cases-59" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-59">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Min Cost</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple 3-node</td>
<td>5</td>
<td>10</td>
<td>one path</td>
</tr>
<tr class="even">
<td>Two parallel paths</td>
<td>10</td>
<td>15</td>
<td>chooses cheapest</td>
</tr>
<tr class="odd">
<td>With negative edge</td>
<td>7</td>
<td>5</td>
<td>potentials fix costs</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-59" class="level4">
<h4 class="anchored" data-anchor-id="complexity-59">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(F \cdot E \log V)\)</span> using Dijkstra + potentials</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>The successive shortest path algorithm is a workhorse for costed flow problems: easy to code, provably correct, and efficient with the right data structures.</p>
</section>
</section>
</section>
<section id="section-37.-cuts" class="level2">
<h2 class="anchored" data-anchor-id="section-37.-cuts">Section 37. Cuts</h2>
<section id="stoerwagner-minimum-cut" class="level3">
<h3 class="anchored" data-anchor-id="stoerwagner-minimum-cut">361 Stoer–Wagner Minimum Cut</h3>
<p>The Stoer–Wagner Minimum Cut algorithm finds the global minimum cut in an undirected weighted graph. A <em>cut</em> is a partition of vertices into two non-empty sets; its weight is the sum of edges crossing the partition. The algorithm efficiently discovers the cut with minimum total edge weight, using repeated maximum adjacency searches.</p>
<section id="what-problem-are-we-solving-60" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-60">What Problem Are We Solving?</h4>
<p>Given an undirected graph <span class="math inline">\(G = (V, E)\)</span> with non-negative weights <span class="math inline">\(w(u,v)\)</span>, find a cut <span class="math inline">\((S, V \setminus S)\)</span> such that:</p>
<p><span class="math display">\[
\text{cut}(S) = \sum_{u \in S, v \in V \setminus S} w(u,v)
\]</span></p>
<p>is minimized over all nontrivial partitions <span class="math inline">\(S \subset V\)</span>.</p>
<p>This is called the global minimum cut, distinct from the s–t minimum cut, which fixes two endpoints.</p>
</section>
<section id="how-does-it-work-plain-language-60" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-60">How Does It Work (Plain Language)?</h4>
<p>The algorithm iteratively merges vertices while keeping track of the tightest cut found along the way.</p>
<p>At each phase:</p>
<ol type="1">
<li>Pick an arbitrary starting vertex.</li>
<li>Grow a set <span class="math inline">\(A\)</span> by repeatedly adding the most strongly connected vertex (highest weight to <span class="math inline">\(A\)</span>).</li>
<li>Continue until all vertices are added.</li>
<li>The last added vertex <span class="math inline">\(t\)</span> and the second last <span class="math inline">\(s\)</span> define a cut <span class="math inline">\((A \setminus {t}, {t})\)</span>.</li>
<li>Record the cut weight, it’s a candidate for the minimum cut.</li>
<li>Merge <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> into a single vertex.</li>
<li>Repeat until only one vertex remains.</li>
</ol>
<p>The smallest recorded cut across all phases is the global minimum cut.</p>
</section>
<section id="step-by-step-example" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example">Step-by-Step Example</h4>
<p>Suppose we have 4 vertices <span class="math inline">\(A, B, C, D\)</span>. Each phase:</p>
<ol type="1">
<li>Start with <span class="math inline">\(A\)</span>.</li>
<li>Add vertex most connected to <span class="math inline">\(A\)</span>.</li>
<li>Continue until only one vertex remains.</li>
<li>Record cut weight each time the last vertex is added.</li>
<li>Merge last two vertices, repeat.</li>
</ol>
<p>After all merges, the lightest cut weight is the minimum cut value.</p>
</section>
<section id="tiny-code-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stoer_wagner_min_cut(V, weight):</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> V</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> n <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>        used <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>        weights <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>            <span class="co"># select most connected vertex not yet in A</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>            sel <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> used[j] <span class="kw">and</span> (sel <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">or</span> weights[j] <span class="op">&gt;</span> weights[sel]):</span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>                    sel <span class="op">=</span> j</span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>            used[sel] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> n <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>                <span class="co"># last vertex added, record cut</span></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> <span class="bu">min</span>(best, weights[sel])</span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a>                <span class="co"># merge prev and sel</span></span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> prev <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a>                        weight[prev][j] <span class="op">+=</span> weight[sel][j]</span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a>                        weight[j][prev] <span class="op">+=</span> weight[j][sel]</span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a>                    vertices.pop(sel)</span>
<span id="cb114-26"><a href="#cb114-26" aria-hidden="true" tabindex="-1"></a>                    weight.pop(sel)</span>
<span id="cb114-27"><a href="#cb114-27" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> row <span class="kw">in</span> weight:</span>
<span id="cb114-28"><a href="#cb114-28" aria-hidden="true" tabindex="-1"></a>                        row.pop(sel)</span>
<span id="cb114-29"><a href="#cb114-29" aria-hidden="true" tabindex="-1"></a>                n <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb114-30"><a href="#cb114-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb114-31"><a href="#cb114-31" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> sel</span>
<span id="cb114-32"><a href="#cb114-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb114-33"><a href="#cb114-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> used[j]:</span>
<span id="cb114-34"><a href="#cb114-34" aria-hidden="true" tabindex="-1"></a>                    weights[j] <span class="op">+=</span> weight[sel][j]</span>
<span id="cb114-35"><a href="#cb114-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-60" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-60">Why It Matters</h4>
<ul>
<li>Finds the global min cut without fixing <span class="math inline">\(s,t\)</span>.</li>
<li>Works directly on weighted undirected graphs.</li>
<li>Requires no flow computation.</li>
<li>Simpler and faster than <span class="math inline">\(O(VE \log V)\)</span> max-flow min-cut for global cut problems.</li>
</ul>
<p>It’s one of the few exact polynomial-time algorithms for global min cut in weighted graphs.</p>
</section>
<section id="a-gentle-proof-why-it-works-60" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-60">A Gentle Proof (Why It Works)</h4>
<p>Each phase finds a minimum <span class="math inline">\(s\)</span>–<span class="math inline">\(t\)</span> cut separating the last vertex <span class="math inline">\(t\)</span> from the rest. The merging process maintains equivalence, merging does not destroy the optimality of remaining cuts. The lightest phase cut corresponds to the global minimum.</p>
<p>By induction over merging steps, the algorithm explores all essential cuts.</p>
</section>
<section id="try-it-yourself-60" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-60">Try It Yourself</h4>
<ol type="1">
<li>Create a triangle graph with different edge weights.</li>
<li>Trace <span class="math inline">\(A\)</span>–<span class="math inline">\(B\)</span>–<span class="math inline">\(C\)</span> order additions and record cut weights.</li>
<li>Merge last two vertices, reduce matrix, repeat.</li>
<li>Verify cut corresponds to smallest crossing weight.</li>
<li>Compare with max-flow min-cut for validation.</li>
</ol>
</section>
<section id="test-cases-60" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-60">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Minimum Cut</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle <span class="math inline">\(w=1,2,3\)</span></td>
<td>3</td>
<td>Removes edge of weight 3</td>
</tr>
<tr class="even">
<td>Square equal weights</td>
<td>2</td>
<td>Any two opposite sides</td>
</tr>
<tr class="odd">
<td>Weighted complete</td>
<td>smallest edge sum</td>
<td>Dense test</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-60" class="level4">
<h4 class="anchored" data-anchor-id="complexity-60">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V^3)\)</span> using adjacency matrix</li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
</ul>
<p>Faster variants exist using adjacency lists and priority queues (<span class="math inline">\(O(VE + V^2 \log V)\)</span>).</p>
<p>The Stoer–Wagner algorithm shows that global connectivity fragility can be measured efficiently, one cut at a time, through pure merging insight.</p>
</section>
</section>
<section id="kargers-randomized-cut" class="level3">
<h3 class="anchored" data-anchor-id="kargers-randomized-cut">362 Karger’s Randomized Cut</h3>
<p>The Karger’s Algorithm is a beautifully simple randomized algorithm to find the global minimum cut of an undirected graph. Instead of deterministically exploring all partitions, it contracts edges randomly, shrinking the graph until only two supernodes remain. The sum of edges between them is (with high probability) the minimum cut.</p>
<section id="what-problem-are-we-solving-61" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-61">What Problem Are We Solving?</h4>
<p>Given an undirected, unweighted (or weighted) graph <span class="math inline">\(G = (V, E)\)</span>, a cut is a partition of <span class="math inline">\(V\)</span> into two disjoint subsets <span class="math inline">\((S, V \setminus S)\)</span>. The cut size is the total number (or weight) of edges crossing the partition.</p>
<p>We want to find the global minimum cut: <span class="math display">\[
\min_{S \subset V, S \neq \emptyset, S \neq V} \text{cut}(S)
\]</span></p>
<p>Karger’s algorithm gives a probabilistic guarantee of finding the exact minimum cut.</p>
</section>
<section id="how-does-it-work-plain-language-61" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-61">How Does It Work (Plain Language)?</h4>
<p>It’s almost magical in its simplicity:</p>
<ol type="1">
<li><p>While there are more than 2 vertices:</p>
<ul>
<li>Pick a random edge <span class="math inline">\((u, v)\)</span>.</li>
<li>Contract it, merge <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> into a single vertex.</li>
<li>Remove self-loops.</li>
</ul></li>
<li><p>When only two vertices remain,</p>
<ul>
<li>The edges between them form a cut.</li>
</ul></li>
</ol>
<p>Repeat the process multiple times to increase success probability.</p>
<p>Each run finds the true minimum cut with probability at least <span class="math display">\[
\frac{2}{n(n-1)}
\]</span></p>
<p>By repeating <span class="math inline">\(O(n^2 \log n)\)</span> times, the probability of missing it becomes negligible.</p>
</section>
<section id="example" class="level4">
<h4 class="anchored" data-anchor-id="example">Example</h4>
<p>Consider a triangle graph <span class="math inline">\((A, B, C)\)</span>:</p>
<ul>
<li>Randomly pick one edge, say <span class="math inline">\((A, B)\)</span>, contract into supernode <span class="math inline">\((AB)\)</span>.</li>
<li>Now edges: <span class="math inline">\((AB, C)\)</span> with multiplicity 2.</li>
<li>Only 2 nodes remain, cut weight = 2, the min cut.</li>
</ul>
</section>
<section id="tiny-code-python-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-1">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> copy</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> karger_min_cut(graph):</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># graph: adjacency list {u: [v1, v2, ...]}</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> <span class="bu">list</span>(graph.keys())</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> []</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> graph:</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> u <span class="op">&lt;</span> v:</span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>                edges.append((u, v))</span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> copy.deepcopy(graph)</span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(g) <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>        u, v <span class="op">=</span> random.choice(edges)</span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># merge v into u</span></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>        g[u].extend(g[v])</span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> g[v]:</span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>            g[w] <span class="op">=</span> [u <span class="cf">if</span> x <span class="op">==</span> v <span class="cf">else</span> x <span class="cf">for</span> x <span class="kw">in</span> g[w]]</span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> g[v]</span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># remove self-loops</span></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>        g[u] <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> g[u] <span class="cf">if</span> x <span class="op">!=</span> u]</span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a>        edges <span class="op">=</span> []</span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> g:</span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> y <span class="kw">in</span> g[x]:</span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> x <span class="op">&lt;</span> y:</span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a>                    edges.append((x, y))</span>
<span id="cb115-28"><a href="#cb115-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># any remaining edge list gives cut size</span></span>
<span id="cb115-29"><a href="#cb115-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(<span class="bu">list</span>(g.values())[<span class="dv">0</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-61" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-61">Why It Matters</h4>
<ul>
<li>Elegantly simple yet provably correct with probability.</li>
<li>No flows, no complex data structures.</li>
<li>Excellent pedagogical algorithm for randomized reasoning.</li>
<li>Forms base for improved variants (Karger–Stein, randomized contraction).</li>
</ul>
<p>Karger’s approach demonstrates the power of randomization, minimal logic, maximal insight.</p>
</section>
<section id="a-gentle-proof-why-it-works-61" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-61">A Gentle Proof (Why It Works)</h4>
<p>At each step, contracting a non-min-cut edge does not destroy the min cut. Since there are <span class="math inline">\(O(n^2)\)</span> edges and at least <span class="math inline">\(n-2\)</span> contractions, probability that we never contract a min-cut edge is: <span class="math display">\[
P = \prod_{i=0}^{n-3} \frac{k_i}{m_i} \ge \frac{2}{n(n-1)}
\]</span> where <span class="math inline">\(k_i\)</span> is min cut size, <span class="math inline">\(m_i\)</span> is edges remaining.</p>
<p>By repeating enough times, the failure probability decays exponentially.</p>
</section>
<section id="try-it-yourself-61" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-61">Try It Yourself</h4>
<ol type="1">
<li>Run the algorithm 1 time on a 4-node graph, note variability.</li>
<li>Repeat 50 times, collect min cut frequencies.</li>
<li>Visualize contraction steps on paper.</li>
<li>Add weights by expanding weighted edges into parallel copies.</li>
<li>Compare runtime vs Stoer–Wagner on dense graphs.</li>
</ol>
</section>
<section id="test-cases-61" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-61">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Expected Min Cut</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>2</td>
<td>always 2</td>
</tr>
<tr class="even">
<td>Square (4-cycle)</td>
<td>2</td>
<td>random paths converge</td>
</tr>
<tr class="odd">
<td>Complete <span class="math inline">\(K_4\)</span></td>
<td>3</td>
<td>dense, repeat to confirm</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-61" class="level4">
<h4 class="anchored" data-anchor-id="complexity-61">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2)\)</span> per trial</li>
<li>Space: <span class="math inline">\(O(n^2)\)</span> (for adjacency)</li>
<li>Repetitions: <span class="math inline">\(O(n^2 \log n)\)</span> for high confidence</li>
</ul>
<p>Karger’s algorithm is a landmark example: a single line, <em>“pick an edge at random and contract it”</em>, unfolds into a full-fledged, provably correct algorithm for global min-cut discovery.</p>
</section>
</section>
<section id="kargerstein-minimum-cut" class="level3">
<h3 class="anchored" data-anchor-id="kargerstein-minimum-cut">363 Karger–Stein Minimum Cut</h3>
<p>The Karger–Stein algorithm is an improved randomized divide-and-conquer version of Karger’s original contraction algorithm. It achieves a higher success probability and better expected runtime, while preserving the same beautifully simple idea: repeatedly contract random edges, but stop early and recurse instead of fully collapsing to two vertices.</p>
<section id="what-problem-are-we-solving-62" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-62">What Problem Are We Solving?</h4>
<p>Given an undirected, weighted or unweighted graph <span class="math inline">\(G = (V, E)\)</span>, the goal is to find the global minimum cut, that is:</p>
<p><span class="math display">\[
\min_{S \subset V,, S \neq \emptyset,, S \neq V} \text{cut}(S)
\]</span></p>
<p>where:</p>
<p><span class="math display">\[
\text{cut}(S) = \sum_{u \in S,, v \in V \setminus S} w(u, v)
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-62" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-62">How Does It Work (Plain Language)?</h4>
<p>Like Karger’s algorithm, we contract edges randomly, but instead of shrinking to 2 vertices immediately, we contract only until the graph has about <span class="math inline">\(\frac{n}{\sqrt{2}}\)</span> vertices, then recurse twice independently. The best cut found across recursive calls is our result.</p>
<p>This strategy amplifies success probability while maintaining efficiency.</p>
<p>Algorithm:</p>
<ol type="1">
<li><p>If <span class="math inline">\(|V| \le 6\)</span>:</p>
<ul>
<li>Compute min cut directly by brute force or basic contraction.</li>
</ul></li>
<li><p>Otherwise:</p>
<ul>
<li>Let <span class="math inline">\(t = \lceil n / \sqrt{2} + 1 \rceil\)</span>.</li>
<li>Randomly contract edges until only <span class="math inline">\(t\)</span> vertices remain.</li>
<li>Run the algorithm recursively twice on two independent contractions.</li>
</ul></li>
<li><p>Return the smaller of the two cuts.</p></li>
</ol>
<p>Each contraction phase preserves the minimum cut with good probability, and recursive repetition compounds success.</p>
</section>
<section id="example-1" class="level4">
<h4 class="anchored" data-anchor-id="example-1">Example</h4>
<p>For a graph of 16 vertices:</p>
<ul>
<li>Contract randomly down to <span class="math inline">\(\lceil 16 / \sqrt{2} \rceil = 12\)</span>.</li>
<li>Recurse twice independently.</li>
<li>Each recursion again halves vertex count until base case.</li>
<li>Return smallest cut found.</li>
</ul>
<p>Multiple recursion branches make the overall probability of keeping all min-cut edges much higher than one-shot contraction.</p>
</section>
<section id="tiny-code-python-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-2">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> copy</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> contract_random_edge(graph):</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>    u, v <span class="op">=</span> random.choice([(u, w) <span class="cf">for</span> u <span class="kw">in</span> graph <span class="cf">for</span> w <span class="kw">in</span> graph[u] <span class="cf">if</span> u <span class="op">&lt;</span> w])</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># merge v into u</span></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>    graph[u].extend(graph[v])</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> w <span class="kw">in</span> graph[v]:</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>        graph[w] <span class="op">=</span> [u <span class="cf">if</span> x <span class="op">==</span> v <span class="cf">else</span> x <span class="cf">for</span> x <span class="kw">in</span> graph[w]]</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">del</span> graph[v]</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># remove self-loops</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>    graph[u] <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> graph[u] <span class="cf">if</span> x <span class="op">!=</span> u]</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> karger_stein(graph):</span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">6</span>:</span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># base case: fall back to basic Karger</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>        g_copy <span class="op">=</span> copy.deepcopy(graph)</span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(g_copy) <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a>            contract_random_edge(g_copy)</span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="bu">list</span>(g_copy.values())[<span class="dv">0</span>])</span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> math.ceil(n <span class="op">/</span> math.sqrt(<span class="dv">2</span>)) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a>    g1 <span class="op">=</span> copy.deepcopy(graph)</span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a>    g2 <span class="op">=</span> copy.deepcopy(graph)</span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(g1) <span class="op">&gt;</span> t:</span>
<span id="cb116-28"><a href="#cb116-28" aria-hidden="true" tabindex="-1"></a>        contract_random_edge(g1)</span>
<span id="cb116-29"><a href="#cb116-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(g2) <span class="op">&gt;</span> t:</span>
<span id="cb116-30"><a href="#cb116-30" aria-hidden="true" tabindex="-1"></a>        contract_random_edge(g2)</span>
<span id="cb116-31"><a href="#cb116-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-32"><a href="#cb116-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(karger_stein(g1), karger_stein(g2))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-62" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-62">Why It Matters</h4>
<ul>
<li>Improves success probability to roughly <span class="math inline">\(1 / \log n\)</span>, vs <span class="math inline">\(1/n^2\)</span> for basic Karger.</li>
<li>Divide-and-conquer structure reduces required repetitions.</li>
<li>Demonstrates power of probability amplification in randomized algorithms.</li>
<li>Useful for large dense graphs where deterministic <span class="math inline">\(O(V^3)\)</span> algorithms are slower.</li>
</ul>
<p>It’s a near-optimal randomized min-cut algorithm, balancing simplicity and efficiency.</p>
</section>
<section id="a-gentle-proof-why-it-works-62" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-62">A Gentle Proof (Why It Works)</h4>
<p>Each contraction preserves the min cut with probability:</p>
<p><span class="math display">\[
p = \prod_{i=k+1}^n \left(1 - \frac{2}{i}\right)
\]</span></p>
<p>The early stopping at <span class="math inline">\(t = n / \sqrt{2}\)</span> keeps <span class="math inline">\(p\)</span> reasonably high. Since we recurse twice independently, overall success probability becomes:</p>
<p><span class="math display">\[
P = 1 - (1 - p)^2 \approx 2p
\]</span></p>
<p>Repeating <span class="math inline">\(O(\log^2 n)\)</span> times ensures high confidence of finding the true minimum cut.</p>
</section>
<section id="try-it-yourself-62" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-62">Try It Yourself</h4>
<ol type="1">
<li>Compare runtime and accuracy vs plain Karger.</li>
<li>Run on small graphs and collect success rate over 100 trials.</li>
<li>Visualize recursive tree of contractions.</li>
<li>Add edge weights (by expanding parallel edges).</li>
<li>Confirm returned cut matches Stoer–Wagner result.</li>
</ol>
</section>
<section id="test-cases-62" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-62">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Expected Min Cut</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>2</td>
<td>Always found</td>
</tr>
<tr class="even">
<td>4-node cycle</td>
<td>2</td>
<td>High accuracy</td>
</tr>
<tr class="odd">
<td>Dense <span class="math inline">\(K_6\)</span></td>
<td>5</td>
<td>Repeats improve confidence</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-62" class="level4">
<h4 class="anchored" data-anchor-id="complexity-62">Complexity</h4>
<ul>
<li>Expected Time: <span class="math inline">\(O(n^2 \log^3 n)\)</span></li>
<li>Space: <span class="math inline">\(O(n^2)\)</span></li>
<li>Repetitions: <span class="math inline">\(O(\log^2 n)\)</span> for high probability</li>
</ul>
<p>Karger–Stein refines the raw elegance of random contraction into a divide-and-conquer gem, faster, more reliable, and still delightfully simple.</p>
</section>
</section>
<section id="gomoryhu-tree" class="level3">
<h3 class="anchored" data-anchor-id="gomoryhu-tree">364 Gomory–Hu Tree</h3>
<p>The Gomory–Hu Tree is a remarkable data structure that compactly represents all-pairs minimum cuts in an undirected weighted graph. Instead of computing <span class="math inline">\(O(n^2)\)</span> separate cuts, it builds a single tree (with <span class="math inline">\(n-1\)</span> edges) whose edge weights capture every pair’s min-cut value.</p>
<p>This structure transforms global connectivity questions into simple tree queries, fast, exact, and elegant.</p>
<section id="what-problem-are-we-solving-63" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-63">What Problem Are We Solving?</h4>
<p>Given an undirected weighted graph <span class="math inline">\(G = (V, E, w)\)</span>, we want to find, for every pair <span class="math inline">\((s, t)\)</span>:</p>
<p><span class="math display">\[
\lambda(s, t) = \min_{S \subset V,, s \in S,, t \notin S} \sum_{u \in S, v \notin S} w(u, v)
\]</span></p>
<p>Instead of running a separate min-cut computation for each pair, we build a Gomory–Hu tree <span class="math inline">\(T\)</span>, such that:</p>
<blockquote class="blockquote">
<p>For any pair <span class="math inline">\((s, t)\)</span>, the minimum edge weight on the path between <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> in <span class="math inline">\(T\)</span> equals <span class="math inline">\(\lambda(s, t)\)</span>.</p>
</blockquote>
<p>This tree encodes all-pairs min-cuts compactly.</p>
</section>
<section id="how-does-it-work-plain-language-63" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-63">How Does It Work (Plain Language)?</h4>
<p>The Gomory–Hu tree is constructed iteratively using <span class="math inline">\(n-1\)</span> minimum-cut computations:</p>
<ol type="1">
<li><p>Choose a root <span class="math inline">\(r\)</span> (arbitrary).</p></li>
<li><p>Maintain a partition tree <span class="math inline">\(T\)</span> with vertices as nodes.</p></li>
<li><p>While there are unprocessed partitions:</p>
<ul>
<li>Pick two vertices <span class="math inline">\(s, t\)</span> in the same partition.</li>
<li>Compute the minimum <span class="math inline">\(s\)</span>–<span class="math inline">\(t\)</span> cut using any max-flow algorithm.</li>
<li>Partition vertices into two sets <span class="math inline">\((S, V \setminus S)\)</span> along that cut.</li>
<li>Add an edge <span class="math inline">\((s, t)\)</span> in the Gomory–Hu tree with weight equal to the cut value.</li>
<li>Recurse on each partition.</li>
</ul></li>
<li><p>After <span class="math inline">\(n-1\)</span> cuts, the tree is complete.</p></li>
</ol>
<p>Every edge in the tree represents a distinct partition cut in the original graph.</p>
</section>
<section id="example-2" class="level4">
<h4 class="anchored" data-anchor-id="example-2">Example</h4>
<p>Consider a graph with vertices <span class="math inline">\({A, B, C, D}\)</span> and weighted edges. We run cuts step by step:</p>
<ol type="1">
<li>Choose <span class="math inline">\(s = A, t = B\)</span> → find cut weight <span class="math inline">\(w(A,B) = 2\)</span> → Add edge <span class="math inline">\((A, B, 2)\)</span> to tree.</li>
<li>Recurse within <span class="math inline">\(A\)</span>’s and <span class="math inline">\(B\)</span>’s sides.</li>
<li>Continue until tree has <span class="math inline">\(n-1 = 3\)</span> edges.</li>
</ol>
<p>Now for any <span class="math inline">\((u,v)\)</span> pair, the min-cut = minimum edge weight along the path connecting them in <span class="math inline">\(T\)</span>.</p>
</section>
<section id="tiny-code-high-level-skeleton" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-high-level-skeleton">Tiny Code (High-Level Skeleton)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gomory_hu_tree(V, edges):</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># edges: list of (u, v, w)</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> V</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>    cut_value <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> parent[s]</span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># compute s-t min cut via max-flow</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>        mincut, partition <span class="op">=</span> min_cut(s, t, edges)</span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>        cut_value[s] <span class="op">=</span> mincut</span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="op">!=</span> s <span class="kw">and</span> parent[v] <span class="op">==</span> t <span class="kw">and</span> partition[v]:</span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>                parent[v] <span class="op">=</span> s</span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a>        tree[s].append((t, mincut))</span>
<span id="cb117-18"><a href="#cb117-18" aria-hidden="true" tabindex="-1"></a>        tree[t].append((s, mincut))</span>
<span id="cb117-19"><a href="#cb117-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> partition[t]:</span>
<span id="cb117-20"><a href="#cb117-20" aria-hidden="true" tabindex="-1"></a>            parent[s], parent[t] <span class="op">=</span> parent[t], s</span>
<span id="cb117-21"><a href="#cb117-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tree</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In practice, <code>min_cut(s, t)</code> is computed using Edmonds–Karp or Push–Relabel.</p>
</section>
<section id="why-it-matters-63" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-63">Why It Matters</h4>
<ul>
<li>Captures all-pairs min-cuts in just <span class="math inline">\(n-1\)</span> max-flow computations.</li>
<li>Transforms graph cut queries into simple tree queries.</li>
<li>Enables efficient network reliability analysis, connectivity queries, and redundancy planning.</li>
<li>Works for weighted undirected graphs.</li>
</ul>
<p>This algorithm compresses rich connectivity information into a single elegant structure.</p>
</section>
<section id="a-gentle-proof-why-it-works-63" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-63">A Gentle Proof (Why It Works)</h4>
<p>Each <span class="math inline">\(s\)</span>–<span class="math inline">\(t\)</span> min-cut partitions vertices into two sides; merging these partitions iteratively preserves all-pairs min-cut relationships.</p>
<p>By induction, every pair <span class="math inline">\((u, v)\)</span> is eventually separated by exactly one edge in the tree, with weight equal to <span class="math inline">\(\lambda(u, v)\)</span>. Thus, <span class="math display">\[
\lambda(u, v) = \min_{e \in \text{path}(u, v)} w(e)
\]</span></p>
</section>
<section id="try-it-yourself-63" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-63">Try It Yourself</h4>
<ol type="1">
<li>Run on a small 4-node weighted graph.</li>
<li>Verify each edge weight equals an actual cut value.</li>
<li>Query random pairs <span class="math inline">\((u, v)\)</span> by tree path min.</li>
<li>Compare with independent flow-based min-cut computations.</li>
<li>Draw both the original graph and the resulting tree.</li>
</ol>
</section>
<section id="test-cases-63" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-63">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Tree Edges</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>2 edges</td>
<td>Uniform weights produce equal cuts</td>
</tr>
<tr class="even">
<td>Square</td>
<td>3 edges</td>
<td>Distinct cuts form balanced tree</td>
</tr>
<tr class="odd">
<td>Complete <span class="math inline">\(K_4\)</span></td>
<td>3 edges</td>
<td>Symmetric connectivity</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-63" class="level4">
<h4 class="anchored" data-anchor-id="complexity-63">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n \cdot \text{MaxFlow}(V,E))\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
<li>Queries: <span class="math inline">\(O(\log V)\)</span> (via path min in tree)</li>
</ul>
<p>The Gomory–Hu tree elegantly transforms the cut landscape of a graph into a tree of truths, one structure, all min-cuts.</p>
</section>
</section>
<section id="max-flow-min-cut-theorem" class="level3">
<h3 class="anchored" data-anchor-id="max-flow-min-cut-theorem">365 Max-Flow Min-Cut Theorem</h3>
<p>The Max-Flow Min-Cut Theorem is one of the foundational results in graph theory and combinatorial optimization. It reveals a duality between maximum flow (what can pass through a network) and minimum cut (what blocks the network). The two are not just related, they are exactly equal.</p>
<p>This theorem underpins nearly every algorithm for flows, cuts, and network design.</p>
<section id="what-problem-are-we-solving-64" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-64">What Problem Are We Solving?</h4>
<p>We are working with a directed graph <span class="math inline">\(G = (V, E)\)</span>, a source <span class="math inline">\(s\)</span>, and a sink <span class="math inline">\(t\)</span>. Each edge <span class="math inline">\((u,v)\)</span> has a capacity <span class="math inline">\(c(u,v) \ge 0\)</span>.</p>
<p>A flow assigns values <span class="math inline">\(f(u,v)\)</span> to edges such that:</p>
<ol type="1">
<li>Capacity constraint: <span class="math inline">\(0 \le f(u,v) \le c(u,v)\)</span></li>
<li>Flow conservation: <span class="math inline">\(\sum_v f(u,v) = \sum_v f(v,u)\)</span> for all <span class="math inline">\(u \ne s, t\)</span></li>
</ol>
<p>The value of the flow is: <span class="math display">\[
|f| = \sum_{v} f(s, v)
\]</span></p>
<p>We want the maximum possible flow value from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>.</p>
<p>A cut <span class="math inline">\((S, T)\)</span> is a partition of vertices such that <span class="math inline">\(s \in S\)</span> and <span class="math inline">\(t \in T = V \setminus S\)</span>. The capacity of the cut is: <span class="math display">\[
c(S, T) = \sum_{u \in S, v \in T} c(u, v)
\]</span></p>
</section>
<section id="the-theorem" class="level4">
<h4 class="anchored" data-anchor-id="the-theorem">The Theorem</h4>
<blockquote class="blockquote">
<p>Max-Flow Min-Cut Theorem: In every flow network, the maximum value of a feasible flow equals the minimum capacity of an <span class="math inline">\(s\)</span>–<span class="math inline">\(t\)</span> cut.</p>
</blockquote>
<p>Formally, <span class="math display">\[
\max_f |f| = \min_{(S,T)} c(S, T)
\]</span></p>
<p>This is a strong duality statement, a maximum over one set equals a minimum over another.</p>
</section>
<section id="how-does-it-work-plain-language-64" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-64">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li>You try to push as much flow as possible from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>.</li>
<li>As you saturate edges, certain parts of the graph become bottlenecks.</li>
<li>The final residual graph separates reachable vertices from <span class="math inline">\(s\)</span> (via unsaturated edges) and the rest.</li>
<li>This separation <span class="math inline">\((S, T)\)</span> forms a minimum cut, whose capacity equals the total flow sent.</li>
</ol>
<p>Thus, once you can’t push any more flow, you’ve also found the tightest cut blocking you.</p>
</section>
<section id="example-3" class="level4">
<h4 class="anchored" data-anchor-id="example-3">Example</h4>
<p>Consider a small network:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge</th>
<th>Capacity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>s → a</td>
<td>3</td>
</tr>
<tr class="even">
<td>s → b</td>
<td>2</td>
</tr>
<tr class="odd">
<td>a → t</td>
<td>2</td>
</tr>
<tr class="even">
<td>b → t</td>
<td>3</td>
</tr>
<tr class="odd">
<td>a → b</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Max flow via augmenting paths:</p>
<ul>
<li><span class="math inline">\(s \to a \to t\)</span>: 2 units</li>
<li><span class="math inline">\(s \to b \to t\)</span>: 2 units</li>
<li><span class="math inline">\(s \to a \to b \to t\)</span>: 1 unit</li>
</ul>
<p>Total flow = 5.</p>
<p>Min cut: <span class="math inline">\(S = {s, a}\)</span>, <span class="math inline">\(T = {b, t}\)</span> → capacity = 5. Flow = Cut = 5 ✔</p>
</section>
<section id="tiny-code-verification-via-edmondskarp" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-verification-via-edmondskarp">Tiny Code (Verification via Edmonds–Karp)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bfs(cap, flow, s, t, parent):</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(cap)</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> [<span class="va">False</span>]<span class="op">*</span>n</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque([s])</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>    visited[s] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> q.popleft()</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> visited[v] <span class="kw">and</span> cap[u][v] <span class="op">-</span> flow[u][v] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>                parent[v] <span class="op">=</span> u</span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>                visited[v] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> v <span class="op">==</span> t: <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>                q.append(v)</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_flow_min_cut(cap, s, t):</span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(cap)</span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>    flow <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>]<span class="op">*</span>n</span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a>    max_flow <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> bfs(cap, flow, s, t, parent):</span>
<span id="cb118-24"><a href="#cb118-24" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> t</span>
<span id="cb118-25"><a href="#cb118-25" aria-hidden="true" tabindex="-1"></a>        path_flow <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb118-26"><a href="#cb118-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> v <span class="op">!=</span> s:</span>
<span id="cb118-27"><a href="#cb118-27" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> parent[v]</span>
<span id="cb118-28"><a href="#cb118-28" aria-hidden="true" tabindex="-1"></a>            path_flow <span class="op">=</span> <span class="bu">min</span>(path_flow, cap[u][v] <span class="op">-</span> flow[u][v])</span>
<span id="cb118-29"><a href="#cb118-29" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> u</span>
<span id="cb118-30"><a href="#cb118-30" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> t</span>
<span id="cb118-31"><a href="#cb118-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> v <span class="op">!=</span> s:</span>
<span id="cb118-32"><a href="#cb118-32" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> parent[v]</span>
<span id="cb118-33"><a href="#cb118-33" aria-hidden="true" tabindex="-1"></a>            flow[u][v] <span class="op">+=</span> path_flow</span>
<span id="cb118-34"><a href="#cb118-34" aria-hidden="true" tabindex="-1"></a>            flow[v][u] <span class="op">-=</span> path_flow</span>
<span id="cb118-35"><a href="#cb118-35" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> u</span>
<span id="cb118-36"><a href="#cb118-36" aria-hidden="true" tabindex="-1"></a>        max_flow <span class="op">+=</span> path_flow</span>
<span id="cb118-37"><a href="#cb118-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_flow</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The final reachable set from <span class="math inline">\(s\)</span> in the residual graph defines the minimum cut.</p>
</section>
<section id="why-it-matters-64" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-64">Why It Matters</h4>
<ul>
<li>Fundamental theorem linking optimization and combinatorics.</li>
<li>Basis for algorithms like Ford–Fulkerson, Edmonds–Karp, Dinic, Push–Relabel.</li>
<li>Used in image segmentation, network reliability, scheduling, bipartite matching, clustering, and transportation.</li>
</ul>
<p>It bridges the gap between flow maximization and cut minimization, two faces of the same coin.</p>
</section>
<section id="a-gentle-proof-why-it-works-64" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-64">A Gentle Proof (Why It Works)</h4>
<p>At termination of Ford–Fulkerson:</p>
<ul>
<li>No augmenting path exists in the residual graph.</li>
<li>Let <span class="math inline">\(S\)</span> be all vertices reachable from <span class="math inline">\(s\)</span>.</li>
<li>Then all edges <span class="math inline">\((u,v)\)</span> with <span class="math inline">\(u \in S, v \notin S\)</span> are saturated.</li>
</ul>
<p>Thus: <span class="math display">\[
|f| = \sum_{u \in S, v \notin S} f(u,v) = \sum_{u \in S, v \notin S} c(u,v) = c(S, T)
\]</span> and no cut can have smaller capacity. Therefore, <span class="math inline">\(\max |f| = \min c(S,T)\)</span>.</p>
</section>
<section id="try-it-yourself-64" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-64">Try It Yourself</h4>
<ol type="1">
<li>Build a simple 4-node network and trace augmenting paths.</li>
<li>Identify the cut <span class="math inline">\((S, T)\)</span> at termination.</li>
<li>Verify total flow equals cut capacity.</li>
<li>Test different max-flow algorithms, result remains identical.</li>
<li>Visualize cut edges in residual graph.</li>
</ol>
</section>
<section id="test-cases-64" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-64">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Min Cut</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple chain</td>
<td>5</td>
<td>5</td>
<td>identical</td>
</tr>
<tr class="even">
<td>Parallel edges</td>
<td>8</td>
<td>8</td>
<td>same result</td>
</tr>
<tr class="odd">
<td>Diamond graph</td>
<td>6</td>
<td>6</td>
<td>min cut = bottleneck edges</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-64" class="level4">
<h4 class="anchored" data-anchor-id="complexity-64">Complexity</h4>
<ul>
<li>Depends on underlying flow algorithm (e.g.&nbsp;<span class="math inline">\(O(VE^2)\)</span> for Edmonds–Karp)</li>
<li>Cut extraction: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>The Max-Flow Min-Cut Theorem is the heartbeat of network optimization, every augmenting path is a step toward equality between two fundamental perspectives: sending and separating.</p>
</section>
</section>
<section id="stoerwagner-repeated-phase" class="level3">
<h3 class="anchored" data-anchor-id="stoerwagner-repeated-phase">366 Stoer–Wagner Repeated Phase</h3>
<p>The Stoer–Wagner Repeated Phase algorithm is a refinement of the Stoer–Wagner minimum cut algorithm for undirected weighted graphs. It finds the global minimum cut by repeating a maximum adjacency search phase multiple times, progressively merging vertices and tracking cut weights.</p>
<p>This algorithm is elegant, deterministic, and runs in polynomial time, often faster than flow-based approaches for undirected graphs.</p>
<section id="what-problem-are-we-solving-65" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-65">What Problem Are We Solving?</h4>
<p>We are finding the minimum cut in an undirected, weighted graph <span class="math inline">\(G = (V, E)\)</span>, where each edge <span class="math inline">\((u, v)\)</span> has a non-negative weight <span class="math inline">\(w(u, v)\)</span>.</p>
<p>A cut <span class="math inline">\((S, V \setminus S)\)</span> partitions the vertex set into two disjoint subsets. The weight of a cut is: <span class="math display">\[
w(S, V \setminus S) = \sum_{u \in S, v \notin S} w(u, v)
\]</span></p>
<p>Our goal is to find a cut <span class="math inline">\((S, T)\)</span> that minimizes this sum.</p>
</section>
<section id="core-idea" class="level4">
<h4 class="anchored" data-anchor-id="core-idea">Core Idea</h4>
<p>The algorithm works by repeatedly performing “phases”. Each phase identifies a minimum <span class="math inline">\(s\)</span>–<span class="math inline">\(t\)</span> cut in the current contracted graph and merges the last two added vertices. Over multiple phases, the smallest cut discovered is the global minimum.</p>
<p>Each phase follows a maximum adjacency search pattern, similar to Prim’s algorithm but in reverse logic.</p>
</section>
<section id="how-it-works-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language">How It Works (Plain Language)</h4>
<p>Each phase:</p>
<ol type="1">
<li>Pick an arbitrary start vertex.</li>
<li>Maintain a set <span class="math inline">\(A\)</span> of added vertices.</li>
<li>At each step, add the most tightly connected vertex <span class="math inline">\(v\)</span> not in <span class="math inline">\(A\)</span> (the one with maximum total edge weight to <span class="math inline">\(A\)</span>).</li>
<li>Continue until all vertices are in <span class="math inline">\(A\)</span>.</li>
<li>Let <span class="math inline">\(s\)</span> be the second-to-last added vertex, and <span class="math inline">\(t\)</span> the last added.</li>
<li>The cut separating <span class="math inline">\(t\)</span> from the rest is a candidate min cut.</li>
<li>Record its weight; then merge <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> into a supervertex and repeat.</li>
</ol>
<p>After <span class="math inline">\(|V| - 1\)</span> phases, the smallest cut seen is the global minimum cut.</p>
</section>
<section id="example-4" class="level4">
<h4 class="anchored" data-anchor-id="example-4">Example</h4>
<p>Graph:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A–B</td>
<td>3</td>
</tr>
<tr class="even">
<td>A–C</td>
<td>2</td>
</tr>
<tr class="odd">
<td>B–C</td>
<td>4</td>
</tr>
<tr class="even">
<td>B–D</td>
<td>2</td>
</tr>
<tr class="odd">
<td>C–D</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Phase 1:</p>
<ul>
<li>Start with <span class="math inline">\(A = {A}\)</span></li>
<li>Add <span class="math inline">\(B\)</span> (max connected to A: 3)</li>
<li>Add <span class="math inline">\(C\)</span> (max connected to <span class="math inline">\({A,B}\)</span>: total 6)</li>
<li>Add <span class="math inline">\(D\)</span> last → Cut weight = sum of edges from D to <span class="math inline">\({A,B,C}\)</span> = 5</li>
</ul>
<p>Record min cut = 5. Merge <span class="math inline">\((C,D)\)</span> and continue.</p>
<p>Repeat phases → global min cut = 5.</p>
</section>
<section id="tiny-code-simplified-python-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-python-1">Tiny Code (Simplified Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stoer_wagner_min_cut(graph):</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    min_cut <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(vertices) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>        added <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>        weights <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(vertices)):</span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> <span class="bu">max</span>(vertices, key<span class="op">=</span><span class="kw">lambda</span> v: weights[v] <span class="cf">if</span> <span class="kw">not</span> added[v] <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>            added[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> _ <span class="op">==</span> <span class="bu">len</span>(vertices) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Last vertex added, potential cut</span></span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>                min_cut <span class="op">=</span> <span class="bu">min</span>(min_cut, weights[u])</span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Merge u into prev</span></span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> prev <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> v <span class="kw">in</span> vertices:</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> v <span class="op">!=</span> u <span class="kw">and</span> v <span class="op">!=</span> prev:</span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>                            graph[prev][v] <span class="op">+=</span> graph[u][v]</span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>                            graph[v][prev] <span class="op">=</span> graph[prev][v]</span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>                    vertices.remove(u)</span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> u</span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> vertices:</span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> added[v]:</span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>                    weights[v] <span class="op">+=</span> graph[u][v]</span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_cut</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Graph is given as an adjacency matrix. Each phase picks the tightest vertex, records the cut, and merges nodes.</p>
</section>
<section id="why-it-matters-65" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-65">Why It Matters</h4>
<ul>
<li>Deterministic and elegant for undirected weighted graphs.</li>
<li>Faster than running multiple max-flow computations.</li>
<li>Ideal for network reliability, graph partitioning, clustering, and circuit design.</li>
<li>Each phase mimics “tightening” the graph until only one supervertex remains.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-65" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-65">A Gentle Proof (Why It Works)</h4>
<p>Each phase finds the minimum <span class="math inline">\(s\)</span>–<span class="math inline">\(t\)</span> cut where <span class="math inline">\(t\)</span> is the last added vertex. By merging <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>, we preserve all other possible cuts. The smallest of these phase cuts is the global minimum, as each cut in the merged graph corresponds to one in the original graph.</p>
<p>Formally: <span class="math display">\[
\text{mincut}(G) = \min_{\text{phases}} w(S, V \setminus S)
\]</span></p>
<p>This inductive structure ensures optimality.</p>
</section>
<section id="try-it-yourself-65" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-65">Try It Yourself</h4>
<ol type="1">
<li>Run on a 4-node complete graph with random weights.</li>
<li>Trace vertex addition order in each phase.</li>
<li>Record cut weights per phase.</li>
<li>Compare with brute-force all cuts, they match.</li>
<li>Visualize contraction steps.</li>
</ol>
</section>
<section id="test-cases-65" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-65">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 39%">
<col style="width: 8%">
<col style="width: 24%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Min Cut</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle (equal weights)</td>
<td>3</td>
<td>2×weight</td>
<td>all equal</td>
</tr>
<tr class="even">
<td>Square (unit weights)</td>
<td>4</td>
<td>2</td>
<td>opposite sides</td>
</tr>
<tr class="odd">
<td>Weighted grid</td>
<td>6</td>
<td>smallest bridge</td>
<td>cut at bottleneck</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-65" class="level4">
<h4 class="anchored" data-anchor-id="complexity-65">Complexity</h4>
<ul>
<li>Each phase: <span class="math inline">\(O(V^2)\)</span></li>
<li>Total: <span class="math inline">\(O(V^3)\)</span> for adjacency matrix</li>
</ul>
<p>With Fibonacci heaps, can improve to <span class="math inline">\(O(V^2 \log V + VE)\)</span>.</p>
<p>The Stoer–Wagner repeated phase algorithm is a powerful, purely combinatorial tool, no flows, no residual graphs, just tight connectivity and precise merging toward the true global minimum cut.</p>
</section>
</section>
<section id="dynamic-min-cut" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-min-cut">367 Dynamic Min Cut</h3>
<p>The Dynamic Minimum Cut problem extends classical min-cut computation to graphs that change over time, edges can be added, deleted, or updated. Instead of recomputing from scratch after each change, we maintain data structures that update the min cut efficiently.</p>
<p>Dynamic min-cut algorithms are critical in applications like network resilience, incremental optimization, and real-time systems where connectivity evolves.</p>
<section id="what-problem-are-we-solving-66" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-66">What Problem Are We Solving?</h4>
<p>Given a graph <span class="math inline">\(G = (V, E)\)</span> with weighted edges and a current minimum cut, how do we efficiently maintain this cut when:</p>
<ul>
<li>An edge <span class="math inline">\((u, v)\)</span> is inserted</li>
<li>An edge <span class="math inline">\((u, v)\)</span> is deleted</li>
<li>An edge <span class="math inline">\((u, v)\)</span> has its weight changed</li>
</ul>
<p>The naive approach recomputes min-cut from scratch using an algorithm like Stoer–Wagner (<span class="math inline">\(O(V^3)\)</span>). Dynamic algorithms aim for faster incremental updates.</p>
</section>
<section id="core-idea-1" class="level4">
<h4 class="anchored" data-anchor-id="core-idea-1">Core Idea</h4>
<p>The min cut is sensitive only to edges crossing the cut boundary. When the graph changes, only a local region around modified edges can alter the global cut.</p>
<p>Dynamic algorithms use:</p>
<ul>
<li>Dynamic trees (e.g.&nbsp;Link-Cut Trees)</li>
<li>Fully dynamic connectivity structures</li>
<li>Randomized contraction tracking</li>
<li>Incremental recomputation of affected regions</li>
</ul>
<p>to update efficiently instead of re-running full min-cut.</p>
</section>
<section id="how-it-works-plain-language-1" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-1">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Maintain a representation of cuts, often as trees or partition sets.</p></li>
<li><p>When an edge weight changes, update connectivity info:</p>
<ul>
<li>If edge lies within one side of the cut, no change.</li>
<li>If edge crosses the cut, update cut capacity.</li>
</ul></li>
<li><p>When an edge is added or deleted, adjust affected components and recalculate locally.</p></li>
<li><p>Optionally, run periodic global recomputations to correct drift after many updates.</p></li>
</ol>
<p>These methods trade exactness for efficiency, often maintaining approximate min cuts within small error bounds.</p>
</section>
<section id="example-high-level" class="level4">
<h4 class="anchored" data-anchor-id="example-high-level">Example (High-Level)</h4>
<p>Graph has vertices <span class="math inline">\({A, B, C, D}\)</span> with current min cut <span class="math inline">\(({A, B}, {C, D})\)</span>, weight <span class="math inline">\(5\)</span>.</p>
<ol type="1">
<li><p>Add edge <span class="math inline">\((B, C)\)</span> with weight <span class="math inline">\(1\)</span>:</p>
<ul>
<li>New crossing edge, cut weight becomes <span class="math inline">\(5 + 1 = 6\)</span>.</li>
<li>Check if alternate partition gives smaller total, update if needed.</li>
</ul></li>
<li><p>Delete edge <span class="math inline">\((A, C)\)</span>:</p>
<ul>
<li>Remove from cut set.</li>
<li>If this edge was essential to connectivity, min cut might increase.</li>
<li>Recompute local cut if affected.</li>
</ul></li>
</ol>
</section>
<section id="tiny-code-sketch-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-sketch-python">Tiny Code (Sketch, Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DynamicMinCut:</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, graph):</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.graph <span class="op">=</span> graph</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.min_cut_value <span class="op">=</span> <span class="va">self</span>.compute_min_cut()</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_min_cut(<span class="va">self</span>):</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use Stoer–Wagner or flow-based method</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> stoer_wagner(<span class="va">self</span>.graph)</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_edge(<span class="va">self</span>, u, v, new_weight):</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.graph[u][v] <span class="op">=</span> new_weight</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.graph[v][u] <span class="op">=</span> new_weight</span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Locally recompute affected region</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.min_cut_value <span class="op">=</span> <span class="va">self</span>.recompute_local(u, v)</span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recompute_local(<span class="va">self</span>, u, v):</span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simplified placeholder: recompute fully if small graph</span></span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.compute_min_cut()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For large graphs, replace <code>recompute_local</code> with incremental cut update logic.</p>
</section>
<section id="why-it-matters-66" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-66">Why It Matters</h4>
<ul>
<li>Real-time systems need quick responses to network changes.</li>
<li>Streaming graphs (e.g.&nbsp;traffic, social, or power networks) evolve continuously.</li>
<li>Reliability analysis in dynamic systems relies on up-to-date min-cut values.</li>
</ul>
<p>Dynamic maintenance saves time compared to recomputing from scratch at every step.</p>
</section>
<section id="a-gentle-proof-why-it-works-66" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-66">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(C_t\)</span> be the min cut after <span class="math inline">\(t\)</span> updates. If each update affects only local structure, then: <span class="math display">\[
C_{t+1} = \min(C_t, \text{local adjustment})
\]</span> Maintaining a certificate structure (like a Gomory–Hu tree) ensures correctness since all pairwise min-cuts are preserved under local changes, except where updated edges are involved.</p>
<p>Recomputing only affected cuts guarantees correctness with amortized efficiency.</p>
</section>
<section id="try-it-yourself-66" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-66">Try It Yourself</h4>
<ol type="1">
<li>Build a small weighted graph (5–6 nodes).</li>
<li>Compute initial min cut using Stoer–Wagner.</li>
<li>Add or delete edges, one at a time.</li>
<li>Update only affected cuts manually.</li>
<li>Compare to full recomputation, results should match.</li>
</ol>
</section>
<section id="test-cases-66" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-66">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 44%">
<col style="width: 23%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Description</th>
<th>New Min Cut</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Add edge <span class="math inline">\((u,v)\)</span> with small weight</td>
<td>New crossing edge</td>
<td>Possibly smaller cut</td>
</tr>
<tr class="even">
<td>Increase edge weight</td>
<td>Strengthens bridge</td>
<td>Cut may change elsewhere</td>
</tr>
<tr class="odd">
<td>Delete edge across cut</td>
<td>Weakens connection</td>
<td>Cut may increase</td>
</tr>
<tr class="even">
<td>Delete edge inside partition</td>
<td>No change</td>
<td>,</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-66" class="level4">
<h4 class="anchored" data-anchor-id="complexity-66">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Naive recomputation</td>
<td><span class="math inline">\(O(V^3)\)</span></td>
</tr>
<tr class="even">
<td>Dynamic approach (randomized)</td>
<td><span class="math inline">\(O(V^2 \log V)\)</span> amortized</td>
</tr>
<tr class="odd">
<td>Approximate dynamic cut</td>
<td><span class="math inline">\(O(E \log^2 V)\)</span></td>
</tr>
</tbody>
</table>
<p>Dynamic min-cut algorithms balance exactness with responsiveness, maintaining near-optimal connectivity insight as graphs evolve in real time.</p>
</section>
</section>
<section id="minimum-st-cut-edmondskarp" class="level3">
<h3 class="anchored" data-anchor-id="minimum-st-cut-edmondskarp">368 Minimum s–t Cut (Edmonds–Karp)</h3>
<p>The Minimum s–t Cut problem seeks the smallest total capacity of edges that must be removed to separate a source vertex <span class="math inline">\(s\)</span> from a sink vertex <span class="math inline">\(t\)</span>. It’s the dual counterpart to maximum flow, and the Edmonds–Karp algorithm provides a clear path to compute it using BFS-based augmenting paths.</p>
<section id="what-problem-are-we-solving-67" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-67">What Problem Are We Solving?</h4>
<p>Given a directed, weighted graph <span class="math inline">\(G=(V,E)\)</span> with capacities <span class="math inline">\(c(u,v)\)</span>, find a partition of <span class="math inline">\(V\)</span> into two disjoint sets <span class="math inline">\((S, T)\)</span> such that:</p>
<ul>
<li><span class="math inline">\(s \in S\)</span>, <span class="math inline">\(t \in T\)</span></li>
<li>The sum of capacities of edges from <span class="math inline">\(S\)</span> to <span class="math inline">\(T\)</span> is minimum</li>
</ul>
<p>Formally: <span class="math display">\[
\text{min-cut}(s, t) = \min_{(S,T)} \sum_{u \in S, v \in T} c(u, v)
\]</span></p>
<p>This cut value equals the maximum flow value from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> by the Max-Flow Min-Cut Theorem.</p>
</section>
<section id="how-it-works-plain-language-2" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-2">How It Works (Plain Language)</h4>
<p>The algorithm uses Edmonds–Karp, a BFS-based version of Ford–Fulkerson, to find the maximum flow first. After computing max-flow, the reachable vertices from <span class="math inline">\(s\)</span> in the residual graph determine the min-cut.</p>
<p>Steps:</p>
<ol type="1">
<li><p>Initialize flow <span class="math inline">\(f(u, v) = 0\)</span> for all edges.</p></li>
<li><p>While there exists a BFS path from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> in the residual graph:</p>
<ul>
<li>Compute bottleneck capacity along path.</li>
<li>Augment flow along path.</li>
</ul></li>
<li><p>After no augmenting path exists:</p>
<ul>
<li>Run BFS one last time from <span class="math inline">\(s\)</span> in residual graph.</li>
<li>Vertices reachable from <span class="math inline">\(s\)</span> form set <span class="math inline">\(S\)</span>.</li>
<li>Others form <span class="math inline">\(T\)</span>.</li>
</ul></li>
<li><p>The edges crossing from <span class="math inline">\(S\)</span> to <span class="math inline">\(T\)</span> with full capacity are the min-cut edges.</p></li>
</ol>
</section>
<section id="example-5" class="level4">
<h4 class="anchored" data-anchor-id="example-5">Example</h4>
<p>Graph:</p>
<ul>
<li><p>Vertices: <span class="math inline">\({s, a, b, t}\)</span></p></li>
<li><p>Edges:</p>
<ul>
<li><span class="math inline">\((s, a) = 3\)</span></li>
<li><span class="math inline">\((s, b) = 2\)</span></li>
<li><span class="math inline">\((a, b) = 1\)</span></li>
<li><span class="math inline">\((a, t) = 2\)</span></li>
<li><span class="math inline">\((b, t) = 3\)</span></li>
</ul></li>
</ul>
<ol type="1">
<li><p>Run Edmonds–Karp to find max-flow = 4.</p></li>
<li><p>Residual graph:</p>
<ul>
<li>Reachable set from <span class="math inline">\(s\)</span>: <span class="math inline">\({s, a}\)</span></li>
<li>Unreachable set: <span class="math inline">\({b, t}\)</span></li>
</ul></li>
<li><p>Min-cut edges: <span class="math inline">\((a, t)\)</span> and <span class="math inline">\((s, b)\)</span></p></li>
<li><p>Min-cut value = <span class="math inline">\(2 + 2 = 4\)</span> Matches max-flow value.</p></li>
</ol>
</section>
<section id="tiny-code-c-like-pseudocode-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-like-pseudocode-2">Tiny Code (C-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb121"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min_st_cut<span class="op">(</span>Graph <span class="op">*</span>G<span class="op">,</span> <span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxflow <span class="op">=</span> edmonds_karp<span class="op">(</span>G<span class="op">,</span> s<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> visited<span class="op">[</span>V<span class="op">];</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    bfs_residual<span class="op">(</span>G<span class="op">,</span> s<span class="op">,</span> visited<span class="op">);</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cut_value <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>edge <span class="op">(</span>u<span class="op">,</span>v<span class="op">)</span> in G<span class="op">-&gt;</span>edges<span class="op">)</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>visited<span class="op">[</span>u<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>            cut_value <span class="op">+=</span> G<span class="op">-&gt;</span>capacity<span class="op">[</span>u<span class="op">][</span>v<span class="op">];</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cut_value<span class="op">;</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-67" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-67">Why It Matters</h4>
<ul>
<li>Reveals bottlenecks in a network.</li>
<li>Key for reliability and segmentation problems.</li>
<li>Foundational for image segmentation, network design, and flow decomposition.</li>
<li>Directly supports duality proofs between optimization problems.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-67" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-67">A Gentle Proof (Why It Works)</h4>
<p>The Max-Flow Min-Cut Theorem states:</p>
<p><span class="math display">\[
\max_{\text{flow } f} \sum_{v} f(s, v) = \min_{(S, T)} \sum_{u \in S, v \in T} c(u, v)
\]</span></p>
<p>Edmonds–Karp finds the maximum flow by repeatedly augmenting along shortest paths (BFS order). Once no more augmenting paths exist, the residual graph partitions nodes naturally into <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span>, and the edges from <span class="math inline">\(S\)</span> to <span class="math inline">\(T\)</span> define the min cut.</p>
</section>
<section id="try-it-yourself-67" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-67">Try It Yourself</h4>
<ol type="1">
<li>Build a small directed network with capacities.</li>
<li>Run Edmonds–Karp manually (trace augmenting paths).</li>
<li>Draw residual graph and find reachable set from <span class="math inline">\(s\)</span>.</li>
<li>Mark crossing edges, sum their capacities.</li>
<li>Compare with max-flow value.</li>
</ol>
</section>
<section id="test-cases-67" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-67">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 47%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Max Flow</th>
<th>Min Cut</th>
<th>Matches?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simple 4-node</td>
<td>4</td>
<td>4</td>
<td>✅</td>
</tr>
<tr class="even">
<td>Linear chain <span class="math inline">\(s \to a \to b \to t\)</span></td>
<td>min edge</td>
<td>min edge</td>
<td>✅</td>
</tr>
<tr class="odd">
<td>Parallel paths</td>
<td>sum of min caps</td>
<td>sum of min caps</td>
<td>✅</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-67" class="level4">
<h4 class="anchored" data-anchor-id="complexity-67">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BFS per augmentation</td>
<td><span class="math inline">\(O(E)\)</span></td>
</tr>
<tr class="even">
<td>Augmentations</td>
<td><span class="math inline">\(O(VE)\)</span></td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(VE^2)\)</span></td>
</tr>
</tbody>
</table>
<p>The Minimum s–t Cut via Edmonds–Karp is an elegant bridge between flow algorithms and partition reasoning, every edge in the cut tells a story of constraint, capacity, and balance.</p>
</section>
</section>
<section id="approximate-min-cut" class="level3">
<h3 class="anchored" data-anchor-id="approximate-min-cut">369 Approximate Min Cut</h3>
<p>The Approximate Minimum Cut algorithm provides a way to estimate the minimum cut of a graph faster than exact algorithms, especially when exact precision is not critical. It’s built on randomization and sampling, using probabilistic reasoning to find small cuts with high confidence in large or dynamic graphs.</p>
<section id="what-problem-are-we-solving-68" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-68">What Problem Are We Solving?</h4>
<p>Given a weighted, undirected graph <span class="math inline">\(G=(V, E)\)</span>, we want a cut <span class="math inline">\((S, T)\)</span> such that the cut capacity is close to the true minimum:</p>
<p><span class="math display">\[
w(S, T) \le (1 + \epsilon) \cdot \lambda(G)
\]</span></p>
<p>where <span class="math inline">\(\lambda(G)\)</span> is the weight of the global min cut, and <span class="math inline">\(\epsilon\)</span> is a small error tolerance (e.g.&nbsp;<span class="math inline">\(0.1\)</span>).</p>
<p>The goal is speed: approximate min-cut algorithms run in near-linear time, much faster than exact ones (<span class="math inline">\(O(V^3)\)</span>).</p>
</section>
<section id="how-it-works-plain-language-3" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-3">How It Works (Plain Language)</h4>
<p>Approximate algorithms rely on two key principles:</p>
<ol type="1">
<li><p>Random Sampling: Randomly sample edges with probability proportional to their weight. The smaller the edge capacity, the more likely it’s critical to the min cut.</p></li>
<li><p>Graph Sparsification: Build a smaller “sketch” of the graph that preserves cut weights approximately. Compute the min cut on this sparse graph, it’s close to the true value.</p></li>
</ol>
<p>By repeating sampling several times and taking the minimum found cut, we converge to a near-optimal solution.</p>
</section>
<section id="algorithm-sketch-kargers-sampling-method" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-sketch-kargers-sampling-method">Algorithm Sketch (Karger’s Sampling Method)</h4>
<ol type="1">
<li><p>Input: Graph <span class="math inline">\(G(V, E)\)</span> with <span class="math inline">\(n = |V|\)</span> and <span class="math inline">\(m = |E|\)</span></p></li>
<li><p>Choose sampling probability <span class="math inline">\(p = \frac{c \log n}{\epsilon^2 \lambda}\)</span></p></li>
<li><p>Build sampled graph <span class="math inline">\(G'\)</span>:</p>
<ul>
<li>Include each edge <span class="math inline">\((u, v)\)</span> with probability <span class="math inline">\(p\)</span></li>
<li>Scale included edge weights by <span class="math inline">\(\frac{1}{p}\)</span></li>
</ul></li>
<li><p>Run an exact min cut algorithm (Stoer–Wagner) on <span class="math inline">\(G'\)</span></p></li>
<li><p>Repeat sampling <span class="math inline">\(O(\log n)\)</span> times; take the best cut found</p></li>
</ol>
<p>The result approximates <span class="math inline">\(\lambda(G)\)</span> within factor <span class="math inline">\((1 + \epsilon)\)</span> with high probability.</p>
</section>
<section id="example-6" class="level4">
<h4 class="anchored" data-anchor-id="example-6">Example</h4>
<p>Suppose <span class="math inline">\(G\)</span> has <span class="math inline">\(10^5\)</span> edges, and exact Stoer–Wagner would be too slow.</p>
<ol type="1">
<li>Choose <span class="math inline">\(\epsilon = 0.1\)</span>, <span class="math inline">\(p = 0.02\)</span></li>
<li>Sample <span class="math inline">\(2%\)</span> of edges randomly (2000 edges)</li>
<li>Reweight sampled edges by <span class="math inline">\(\frac{1}{0.02} = 50\)</span></li>
<li>Run exact min cut on this smaller graph</li>
<li>Repeat 5–10 times; pick smallest cut</li>
</ol>
<p>Result: A cut within <span class="math inline">\(10%\)</span> of optimal, in a fraction of the time.</p>
</section>
<section id="tiny-code-python-like-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-pseudocode">Tiny Code (Python-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> approximate_min_cut(G, epsilon<span class="op">=</span><span class="fl">0.1</span>, repeats<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    best_cut <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(repeats):</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> compute_sampling_probability(G, epsilon)</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>        G_sample <span class="op">=</span> sample_graph(G, p)</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>        cut_value <span class="op">=</span> stoer_wagner(G_sample)</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>        best_cut <span class="op">=</span> <span class="bu">min</span>(best_cut, cut_value)</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_cut</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-68" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-68">Why It Matters</h4>
<ul>
<li><p>Scalability: Handles huge graphs where exact methods are infeasible</p></li>
<li><p>Speed: Near-linear time using randomization</p></li>
<li><p>Applications:</p>
<ul>
<li>Streaming graphs</li>
<li>Network reliability</li>
<li>Clustering and partitioning</li>
<li>Graph sketching and sparsification</li>
</ul></li>
</ul>
<p>Approximate min cuts are crucial when you need quick, robust decisions, not perfect answers.</p>
</section>
<section id="a-gentle-proof-why-it-works-68" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-68">A Gentle Proof (Why It Works)</h4>
<p>Karger’s analysis shows that each small cut is preserved with high probability if enough edges are sampled:</p>
<p><span class="math display">\[
\Pr[\text{cut weight preserved}] \ge 1 - \frac{1}{n^2}
\]</span></p>
<p>By repeating the process <span class="math inline">\(O(\log n)\)</span> times, we amplify confidence, ensuring that with high probability, at least one sampled graph maintains the true min-cut structure.</p>
<p>Using Chernoff bounds, the error is bounded by <span class="math inline">\((1 \pm \epsilon)\)</span>.</p>
</section>
<section id="try-it-yourself-68" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-68">Try It Yourself</h4>
<ol type="1">
<li>Generate a random graph with 50 nodes and random weights.</li>
<li>Compute exact min cut using Stoer–Wagner.</li>
<li>Sample 10%, 5%, and 2% of edges, compute approximate cuts.</li>
<li>Compare results and runtime.</li>
<li>Adjust <span class="math inline">\(\epsilon\)</span> and observe trade-off between speed and accuracy.</li>
</ol>
</section>
<section id="test-cases-68" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-68">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 37%">
<col style="width: 20%">
<col style="width: 23%">
<col style="width: 7%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Exact Min Cut</th>
<th>Approx. (ε=0.1)</th>
<th>Error</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Small dense (100 edges)</td>
<td>12</td>
<td>13</td>
<td>8%</td>
<td>5×</td>
</tr>
<tr class="even">
<td>Medium sparse (1k edges)</td>
<td>8</td>
<td>8</td>
<td>0%</td>
<td>10×</td>
</tr>
<tr class="odd">
<td>Large (100k edges)</td>
<td>30</td>
<td>33</td>
<td>10%</td>
<td>50×</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-68" class="level4">
<h4 class="anchored" data-anchor-id="complexity-68">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 37%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Time</th>
<th>Accuracy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Stoer–Wagner</td>
<td><span class="math inline">\(O(V^3)\)</span></td>
<td>Exact</td>
</tr>
<tr class="even">
<td>Karger (Randomized Exact)</td>
<td><span class="math inline">\(O(V^2 \log^3 V)\)</span></td>
<td>Exact (probabilistic)</td>
</tr>
<tr class="odd">
<td>Approximate Sampling</td>
<td><span class="math inline">\(O(E \log^2 V / \epsilon^2)\)</span></td>
<td><span class="math inline">\((1 + \epsilon)\)</span></td>
</tr>
</tbody>
</table>
<p>Approximate min-cut algorithms show that probability can replace precision when scale demands speed, they slice through massive graphs with surprising efficiency.</p>
</section>
</section>
<section id="min-k-cut" class="level3">
<h3 class="anchored" data-anchor-id="min-k-cut">370 Min k-Cut</h3>
<p>The Minimum k-Cut problem generalizes the classic min-cut idea. Instead of splitting a graph into just two parts, the goal is to partition it into k disjoint subsets while cutting edges of minimum total weight.</p>
<p>It’s a key problem in clustering, parallel processing, and network design, where you want multiple disconnected regions with minimal interconnection cost.</p>
<section id="what-problem-are-we-solving-69" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-69">What Problem Are We Solving?</h4>
<p>Given a weighted, undirected graph <span class="math inline">\(G = (V, E)\)</span> and an integer <span class="math inline">\(k\)</span>, find a partition of <span class="math inline">\(V\)</span> into <span class="math inline">\(k\)</span> subsets <span class="math inline">\({V_1, V_2, \ldots, V_k}\)</span> such that:</p>
<ul>
<li><span class="math inline">\(V_i \cap V_j = \emptyset\)</span> for all <span class="math inline">\(i \ne j\)</span></li>
<li><span class="math inline">\(\bigcup_i V_i = V\)</span></li>
<li>The sum of edge weights crossing between parts is minimized</li>
</ul>
<p>Formally:</p>
<p><span class="math display">\[
\text{min-}k\text{-cut}(G) = \min_{V_1, \ldots, V_k} \sum_{\substack{(u,v) \in E \ u \in V_i, v \in V_j, i \ne j}} w(u,v)
\]</span></p>
<p>For <span class="math inline">\(k=2\)</span>, this reduces to the standard min-cut problem.</p>
</section>
<section id="how-it-works-plain-language-4" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-4">How It Works (Plain Language)</h4>
<p>The Min k-Cut problem is NP-hard for general <span class="math inline">\(k\)</span>, but several algorithms provide exact solutions for small <span class="math inline">\(k\)</span> and approximations for larger <span class="math inline">\(k\)</span>.</p>
<p>There are two main approaches:</p>
<ol type="1">
<li><p>Greedy Iterative Cutting:</p>
<ul>
<li>Repeatedly find and remove a global min cut, splitting the graph into components one by one.</li>
<li>After <span class="math inline">\(k-1\)</span> cuts, you have <span class="math inline">\(k\)</span> components.</li>
<li>Works well but not always optimal.</li>
</ul></li>
<li><p>Dynamic Programming over Trees (Exact for small k):</p>
<ul>
<li>Use a tree decomposition of the graph.</li>
<li>Compute optimal partition by exploring edge removals in the minimum spanning tree.</li>
<li>Based on the Karger–Stein framework.</li>
</ul></li>
</ol>
</section>
<section id="example-7" class="level4">
<h4 class="anchored" data-anchor-id="example-7">Example</h4>
<p>Graph with 5 nodes and edges:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(A, B)</td>
<td>1</td>
</tr>
<tr class="even">
<td>(B, C)</td>
<td>2</td>
</tr>
<tr class="odd">
<td>(C, D)</td>
<td>3</td>
</tr>
<tr class="even">
<td>(D, E)</td>
<td>4</td>
</tr>
<tr class="odd">
<td>(A, E)</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Goal: partition into <span class="math inline">\(k=3\)</span> subsets.</p>
<ol type="1">
<li><p>Find minimum cut edges to remove:</p>
<ul>
<li>Cut <span class="math inline">\((A, B)\)</span> (weight 1)</li>
<li>Cut <span class="math inline">\((B, C)\)</span> (weight 2)</li>
</ul></li>
<li><p>Total cut weight = <span class="math inline">\(3\)</span></p></li>
<li><p>Resulting subsets: <span class="math inline">\({A}, {B}, {C, D, E}\)</span></p></li>
</ol>
</section>
<section id="tiny-code-python-like-pseudocode-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-pseudocode-1">Tiny Code (Python-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_k_cut(graph, k):</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    cuts <span class="op">=</span> []</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> graph.copy()</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>        cut_value, (S, T) <span class="op">=</span> stoer_wagner(G)</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>        cuts.append(cut_value)</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>        G <span class="op">=</span> G.subgraph(S)  <span class="co"># Keep one component, remove crossing edges</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(cuts)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For small <span class="math inline">\(k\)</span>, you can use recursive contraction (like Karger’s algorithm) or dynamic programming on tree structures.</p>
</section>
<section id="why-it-matters-69" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-69">Why It Matters</h4>
<ul>
<li>Clustering: Group nodes into <span class="math inline">\(k\)</span> balanced communities.</li>
<li>Parallel Computing: Partition workloads while minimizing communication cost.</li>
<li>Image Segmentation: Divide pixels into <span class="math inline">\(k\)</span> coherent regions.</li>
<li>Graph Simplification: Split networks into modular subgraphs.</li>
</ul>
<p>Min k-Cut transforms connectivity into structured modularity.</p>
</section>
<section id="a-gentle-proof-why-it-works-69" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-69">A Gentle Proof (Why It Works)</h4>
<p>Each cut increases the number of connected components by 1. Thus, performing <span class="math inline">\(k-1\)</span> cuts produces exactly <span class="math inline">\(k\)</span> components.</p>
<p>Let <span class="math inline">\(C_1, C_2, \ldots, C_{k-1}\)</span> be the successive minimum cuts. The sum of their weights bounds the global optimum:</p>
<p><span class="math display">\[
\text{min-}k\text{-cut} \le \sum_{i=1}^{k-1} \lambda_i
\]</span></p>
<p>where <span class="math inline">\(\lambda_i\)</span> is the <span class="math inline">\(i\)</span>-th smallest cut value. Iterative min-cuts often approximate the optimal <span class="math inline">\(k\)</span>-cut well.</p>
<p>For exact solutions, algorithms based on flow decomposition or tree contractions use recursive partitioning to explore combinations of edges.</p>
</section>
<section id="try-it-yourself-69" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-69">Try It Yourself</h4>
<ol type="1">
<li>Construct a small weighted graph with 6–8 vertices.</li>
<li>Run Stoer–Wagner to find the first min cut.</li>
<li>Remove edges, repeat for next cut.</li>
<li>Compare total cut weight to brute-force partition for <span class="math inline">\(k=3\)</span>.</li>
<li>Observe approximation quality.</li>
</ol>
</section>
<section id="test-cases-69" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-69">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>k</th>
<th>Exact</th>
<th>Greedy</th>
<th>Error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>0%</td>
</tr>
<tr class="even">
<td>Line of 5</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>0%</td>
</tr>
<tr class="odd">
<td>Dense 6-node</td>
<td>3</td>
<td>12</td>
<td>13</td>
<td>8%</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-69" class="level4">
<h4 class="anchored" data-anchor-id="complexity-69">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Time</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Brute Force</td>
<td>Exponential</td>
<td>Exact</td>
</tr>
<tr class="even">
<td>Greedy Cuts</td>
<td><span class="math inline">\(O(k \cdot V^3)\)</span></td>
<td>Approx</td>
</tr>
<tr class="odd">
<td>Tree DP</td>
<td><span class="math inline">\(O(V^{k-1})\)</span></td>
<td>Exact (small <span class="math inline">\(k\)</span>)</td>
</tr>
<tr class="even">
<td>Randomized (Karger–Stein)</td>
<td><span class="math inline">\(O(V^2 \log^3 V)\)</span></td>
<td>Approx</td>
</tr>
</tbody>
</table>
<p>The Min k-Cut problem generalizes connectivity design — it’s where graph partitioning meets optimization, balancing efficiency and modularity.</p>
</section>
</section>
</section>
<section id="section-38.-matchings" class="level2">
<h2 class="anchored" data-anchor-id="section-38.-matchings">Section 38. Matchings</h2>
<section id="bipartite-matching-dfs" class="level3">
<h3 class="anchored" data-anchor-id="bipartite-matching-dfs">371 Bipartite Matching (DFS)</h3>
<p>Bipartite Matching is one of the most fundamental problems in graph theory. Given a bipartite graph <span class="math inline">\(G=(U,V,E)\)</span>, the goal is to find the maximum number of pairings between nodes in <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> such that no two edges share a vertex. A simple and intuitive way to do this is by using DFS-based augmenting paths.</p>
<section id="what-problem-are-we-solving-70" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-70">What Problem Are We Solving?</h4>
<p>We are given a bipartite graph with two disjoint sets <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span>. We want to find the maximum matching, the largest set of edges where each vertex is matched to at most one partner.</p>
<p>Formally, find a subset <span class="math inline">\(M \subseteq E\)</span> such that:</p>
<ul>
<li>Each vertex in <span class="math inline">\(U \cup V\)</span> is incident to at most one edge in <span class="math inline">\(M\)</span></li>
<li><span class="math inline">\(|M|\)</span> is maximized</li>
</ul>
</section>
<section id="how-it-works-plain-language-5" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-5">How It Works (Plain Language)</h4>
<p>The core idea is to build matchings incrementally by finding augmenting paths — paths that start from an unmatched vertex in <span class="math inline">\(U\)</span>, alternate between unmatched and matched edges, and end at an unmatched vertex in <span class="math inline">\(V\)</span>.</p>
<p>Each time such a path is found, we flip the match status along it (matched edges become unmatched, and vice versa), increasing the total matching size by one.</p>
<p>Steps:</p>
<ol type="1">
<li><p>Start with an empty matching <span class="math inline">\(M\)</span>.</p></li>
<li><p>For each vertex <span class="math inline">\(u \in U\)</span>:</p>
<ul>
<li>Run DFS to find an augmenting path to a free vertex in <span class="math inline">\(V\)</span>.</li>
<li>If found, augment the matching along this path.</li>
</ul></li>
<li><p>Repeat until no more augmenting paths exist.</p></li>
</ol>
</section>
<section id="example-8" class="level4">
<h4 class="anchored" data-anchor-id="example-8">Example</h4>
<p>Let <span class="math inline">\(U = {u_1, u_2, u_3}\)</span>, <span class="math inline">\(V = {v_1, v_2, v_3}\)</span>, and edges:</p>
<ul>
<li><span class="math inline">\((u_1, v_1)\)</span>, <span class="math inline">\((u_1, v_2)\)</span></li>
<li><span class="math inline">\((u_2, v_2)\)</span></li>
<li><span class="math inline">\((u_3, v_3)\)</span></li>
</ul>
<ol type="1">
<li>Start with empty matching.</li>
<li>DFS from <span class="math inline">\(u_1\)</span>: finds <span class="math inline">\((u_1, v_1)\)</span> → match.</li>
<li>DFS from <span class="math inline">\(u_2\)</span>: finds <span class="math inline">\((u_2, v_2)\)</span> → match.</li>
<li>DFS from <span class="math inline">\(u_3\)</span>: finds <span class="math inline">\((u_3, v_3)\)</span> → match. All vertices matched, maximum matching size = 3.</li>
</ol>
</section>
<section id="tiny-code-c-like-pseudocode-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-like-pseudocode-3">Tiny Code (C-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb124"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXV </span><span class="dv">100</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> adj<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> matchR<span class="op">[</span>MAXV<span class="op">],</span> visited<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>visited<span class="op">[</span>v<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>        visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>matchR<span class="op">[</span>v<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">||</span> dfs<span class="op">(</span>matchR<span class="op">[</span>v<span class="op">]))</span> <span class="op">{</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>            matchR<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxBipartiteMatching<span class="op">(</span><span class="dt">int</span> U<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>matchR<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>matchR<span class="op">));</span></span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> U<span class="op">;</span> <span class="op">++</span>u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true" tabindex="-1"></a>        memset<span class="op">(</span>visited<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>visited<span class="op">));</span></span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dfs<span class="op">(</span>u<span class="op">))</span> result<span class="op">++;</span></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-70" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-70">Why It Matters</h4>
<ul>
<li>Foundation for Hungarian Algorithm and Hopcroft–Karp</li>
<li>Core tool in resource allocation, scheduling, pairing problems</li>
<li>Introduces concept of augmenting paths, a cornerstone in flow theory</li>
</ul>
<p>Used in:</p>
<ul>
<li>Assigning workers to jobs</li>
<li>Matching students to projects</li>
<li>Network flow initialization</li>
<li>Graph theory teaching and visualization</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-70" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-70">A Gentle Proof (Why It Works)</h4>
<p>If there exists an augmenting path, flipping the matching along it always increases the matching size by 1.</p>
<p>Let <span class="math inline">\(M\)</span> be a current matching. If no augmenting path exists, <span class="math inline">\(M\)</span> is maximum (Berge’s Lemma):</p>
<blockquote class="blockquote">
<p>A matching is maximum if and only if there is no augmenting path.</p>
</blockquote>
<p>Therefore, repeatedly augmenting ensures convergence to the maximum matching.</p>
</section>
<section id="try-it-yourself-70" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-70">Try It Yourself</h4>
<ol type="1">
<li>Draw a bipartite graph with 4 nodes on each side.</li>
<li>Use DFS to find augmenting paths manually.</li>
<li>Track which vertices are matched/unmatched after each augmentation.</li>
<li>Stop when no augmenting paths remain.</li>
</ol>
</section>
<section id="test-cases-70" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-70">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th><span class="math inline">\(|U|\)</span></th>
<th><span class="math inline">\(|V|\)</span></th>
<th>Max Matching</th>
<th>Steps</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Complete <span class="math inline">\(K_{3,3}\)</span></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3 DFS</td>
</tr>
<tr class="even">
<td>Chain <span class="math inline">\(u_1v_1, u_2v_2, u_3v_3\)</span></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3 DFS</td>
</tr>
<tr class="odd">
<td>Sparse graph</td>
<td>4</td>
<td>4</td>
<td>2</td>
<td>4 DFS</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-70" class="level4">
<h4 class="anchored" data-anchor-id="complexity-70">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Aspect</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DFS per vertex</td>
<td><span class="math inline">\(O(E)\)</span></td>
</tr>
<tr class="even">
<td>Total</td>
<td><span class="math inline">\(O(VE)\)</span></td>
</tr>
<tr class="odd">
<td>Space</td>
<td><span class="math inline">\(O(V+E)\)</span></td>
</tr>
</tbody>
</table>
<p>This DFS-based approach gives an intuitive baseline for bipartite matching, later improved by Hopcroft–Karp (<span class="math inline">\(O(E\sqrt{V})\)</span>) but perfect for learning and small graphs.</p>
</section>
</section>
<section id="hopcroftkarp" class="level3">
<h3 class="anchored" data-anchor-id="hopcroftkarp">372 Hopcroft–Karp</h3>
<p>The Hopcroft–Karp algorithm is a classic improvement over DFS-based bipartite matching. It uses layered BFS and DFS to find multiple augmenting paths in parallel, reducing redundant searches and achieving an optimal runtime of <span class="math inline">\(O(E\sqrt{V})\)</span>.</p>
<section id="what-problem-are-we-solving-71" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-71">What Problem Are We Solving?</h4>
<p>Given a bipartite graph <span class="math inline">\(G = (U, V, E)\)</span>, we want to find a maximum matching, the largest set of vertex-disjoint edges connecting <span class="math inline">\(U\)</span> to <span class="math inline">\(V\)</span>.</p>
<p>A matching is a subset <span class="math inline">\(M \subseteq E\)</span> such that each vertex is incident to at most one edge in <span class="math inline">\(M\)</span>. The algorithm seeks the maximum cardinality matching.</p>
</section>
<section id="how-it-works-plain-language-6" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-6">How It Works (Plain Language)</h4>
<p>Instead of finding one augmenting path at a time (like simple DFS), Hopcroft–Karp finds a layer of shortest augmenting paths, then augments all of them together. This drastically reduces the number of BFS-DFS phases.</p>
<p>Key idea:</p>
<ul>
<li>Each phase increases the matching by many paths at once.</li>
<li>The distance (layer) of unmatched vertices strictly increases after each phase.</li>
</ul>
<p>Steps:</p>
<ol type="1">
<li><p>Initialization: Start with empty matching <span class="math inline">\(M = \emptyset\)</span>.</p></li>
<li><p>Repeat until no augmenting path exists:</p>
<ol type="1">
<li><p>BFS phase:</p>
<ul>
<li>Build a layered graph (level graph) from unmatched vertices in <span class="math inline">\(U\)</span> to unmatched vertices in <span class="math inline">\(V\)</span>.</li>
<li>Each layer increases by 1 hop.</li>
</ul></li>
<li><p>DFS phase:</p>
<ul>
<li>Find vertex-disjoint augmenting paths in this layered graph.</li>
<li>Augment along all of them simultaneously.</li>
</ul></li>
</ol></li>
<li><p>Return the total matching size.</p></li>
</ol>
</section>
<section id="example-9" class="level4">
<h4 class="anchored" data-anchor-id="example-9">Example</h4>
<p>Let <span class="math inline">\(U = {u_1, u_2, u_3}\)</span>, <span class="math inline">\(V = {v_1, v_2, v_3}\)</span>, edges:</p>
<ul>
<li><span class="math inline">\(u_1 \to v_1, v_2\)</span></li>
<li><span class="math inline">\(u_2 \to v_2\)</span></li>
<li><span class="math inline">\(u_3 \to v_3\)</span></li>
</ul>
<ol type="1">
<li><p>Initial matching: empty</p></li>
<li><p>BFS builds layers:</p>
<ul>
<li>Level 0: <span class="math inline">\(u_1, u_2, u_3\)</span></li>
<li>Level 1: <span class="math inline">\(v_1, v_2, v_3\)</span> All are reachable.</li>
</ul></li>
<li><p>DFS finds 3 augmenting paths:</p>
<ul>
<li><span class="math inline">\(u_1 \to v_1\)</span>, <span class="math inline">\(u_2 \to v_2\)</span>, <span class="math inline">\(u_3 \to v_3\)</span></li>
</ul></li>
<li><p>Augment all → Matching size = 3 No more augmenting paths → Maximum matching = 3</p></li>
</ol>
</section>
<section id="tiny-code-c-like-pseudocode-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-like-pseudocode-4">Tiny Code (C-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb125"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> adj<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> pairU<span class="op">[</span>MAXV<span class="op">],</span> pairV<span class="op">[</span>MAXV<span class="op">],</span> dist<span class="op">[</span>MAXV<span class="op">];</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> NIL <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> INF <span class="op">=</span> <span class="fl">1e9</span><span class="op">;</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bfs<span class="op">(</span><span class="dt">int</span> U<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>    queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> q<span class="op">;</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> u <span class="op">&lt;=</span> U<span class="op">;</span> u<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pairU<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> NIL<span class="op">)</span> <span class="op">{</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> q<span class="op">.</span>push<span class="op">(</span>u<span class="op">);</span> <span class="op">}</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>NIL<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>q<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> q<span class="op">.</span>front<span class="op">();</span> q<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">&lt;</span> dist<span class="op">[</span>NIL<span class="op">])</span> <span class="op">{</span></span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>pairV<span class="op">[</span>v<span class="op">]]</span> <span class="op">==</span> INF<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a>                    dist<span class="op">[</span>pairV<span class="op">[</span>v<span class="op">]]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a>                    q<span class="op">.</span>push<span class="op">(</span>pairV<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb125-21"><a href="#cb125-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb125-22"><a href="#cb125-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-23"><a href="#cb125-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist<span class="op">[</span>NIL<span class="op">]</span> <span class="op">!=</span> INF<span class="op">;</span></span>
<span id="cb125-24"><a href="#cb125-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-25"><a href="#cb125-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-26"><a href="#cb125-26" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-27"><a href="#cb125-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>u <span class="op">==</span> NIL<span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb125-28"><a href="#cb125-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb125-29"><a href="#cb125-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>pairV<span class="op">[</span>v<span class="op">]]</span> <span class="op">==</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> dfs<span class="op">(</span>pairV<span class="op">[</span>v<span class="op">]))</span> <span class="op">{</span></span>
<span id="cb125-30"><a href="#cb125-30" aria-hidden="true" tabindex="-1"></a>            pairV<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span> pairU<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb125-31"><a href="#cb125-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb125-32"><a href="#cb125-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb125-33"><a href="#cb125-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-34"><a href="#cb125-34" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb125-35"><a href="#cb125-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb125-36"><a href="#cb125-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-37"><a href="#cb125-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-38"><a href="#cb125-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> hopcroftKarp<span class="op">(</span><span class="dt">int</span> U<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-39"><a href="#cb125-39" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>pairU<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>pairU<span class="op">));</span></span>
<span id="cb125-40"><a href="#cb125-40" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>pairV<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>pairV<span class="op">));</span></span>
<span id="cb125-41"><a href="#cb125-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> matching <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb125-42"><a href="#cb125-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>bfs<span class="op">(</span>U<span class="op">))</span> <span class="op">{</span></span>
<span id="cb125-43"><a href="#cb125-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> u <span class="op">&lt;=</span> U<span class="op">;</span> u<span class="op">++)</span></span>
<span id="cb125-44"><a href="#cb125-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>pairU<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> NIL <span class="op">&amp;&amp;</span> dfs<span class="op">(</span>u<span class="op">))</span></span>
<span id="cb125-45"><a href="#cb125-45" aria-hidden="true" tabindex="-1"></a>                matching<span class="op">++;</span></span>
<span id="cb125-46"><a href="#cb125-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-47"><a href="#cb125-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matching<span class="op">;</span></span>
<span id="cb125-48"><a href="#cb125-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-71" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-71">Why It Matters</h4>
<ul>
<li><p>Efficient: <span class="math inline">\(O(E\sqrt{V})\)</span>, ideal for large graphs</p></li>
<li><p>Foundational in:</p>
<ul>
<li>Job assignment</li>
<li>Resource allocation</li>
<li>Stable match foundations</li>
<li>Network optimization</li>
</ul></li>
</ul>
<p>It’s the standard method for maximum bipartite matching in competitive programming and real systems.</p>
</section>
<section id="a-gentle-proof-why-it-works-71" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-71">A Gentle Proof (Why It Works)</h4>
<p>Each BFS-DFS phase finds a set of shortest augmenting paths. After augmenting, no shorter path remains.</p>
<p>Let <span class="math inline">\(d\)</span> = distance to the nearest unmatched vertex in BFS. Every phase increases the minimum augmenting path length, and the number of phases is at most <span class="math inline">\(O(\sqrt{V})\)</span> (Hopcroft–Karp Lemma).</p>
<p>Each BFS-DFS costs <span class="math inline">\(O(E)\)</span>, so total = <span class="math inline">\(O(E\sqrt{V})\)</span>.</p>
</section>
<section id="try-it-yourself-71" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-71">Try It Yourself</h4>
<ol type="1">
<li>Draw a bipartite graph with 5 nodes on each side.</li>
<li>Run one BFS layer build.</li>
<li>Use DFS to find all shortest augmenting paths.</li>
<li>Augment all, track matching size per phase.</li>
</ol>
</section>
<section id="test-cases-71" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-71">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th><span class="math inline">\(|U|\)</span></th>
<th><span class="math inline">\(|V|\)</span></th>
<th>Matching Size</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(K_{3,3}\)</span></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>Fast</td>
</tr>
<tr class="even">
<td>Chain graph</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>Linear</td>
</tr>
<tr class="odd">
<td>Sparse graph</td>
<td>10</td>
<td>10</td>
<td>6</td>
<td>Sublinear phases</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-71" class="level4">
<h4 class="anchored" data-anchor-id="complexity-71">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BFS (build layers)</td>
<td><span class="math inline">\(O(E)\)</span></td>
</tr>
<tr class="even">
<td>DFS (augment paths)</td>
<td><span class="math inline">\(O(E)\)</span></td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(E\sqrt{V})\)</span></td>
</tr>
</tbody>
</table>
<p>Hopcroft–Karp is the benchmark for bipartite matching, balancing elegance, efficiency, and theoretical depth.</p>
</section>
</section>
<section id="hungarian-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="hungarian-algorithm">373 Hungarian Algorithm</h3>
<p>The Hungarian Algorithm (also known as the Kuhn–Munkres Algorithm) solves the assignment problem, finding the minimum-cost perfect matching in a weighted bipartite graph. It’s a cornerstone in optimization, turning complex allocation tasks into elegant linear-time computations on cost matrices.</p>
<section id="what-problem-are-we-solving-72" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-72">What Problem Are We Solving?</h4>
<p>Given a bipartite graph <span class="math inline">\(G = (U, V, E)\)</span> with <span class="math inline">\(|U| = |V| = n\)</span>, and a cost function <span class="math inline">\(c(u,v)\)</span> for each edge, we want to find a matching <span class="math inline">\(M\)</span> such that:</p>
<ul>
<li>Every <span class="math inline">\(u \in U\)</span> is matched to exactly one <span class="math inline">\(v \in V\)</span></li>
<li>Total cost is minimized:</li>
</ul>
<p><span class="math display">\[
\text{Minimize } \sum_{(u,v) \in M} c(u, v)
\]</span></p>
<p>This is the assignment problem, a special case of linear programming that can be solved exactly in polynomial time.</p>
</section>
<section id="how-it-works-plain-language-7" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-7">How It Works (Plain Language)</h4>
<p>The Hungarian Algorithm treats the cost matrix like a grid puzzle — you systematically reduce, label, and cover rows and columns to reveal a set of zeros corresponding to the optimal assignment.</p>
<p>Core idea: Transform the cost matrix so that at least one optimal solution lies among zeros.</p>
<p>Steps:</p>
<ol type="1">
<li><p>Row Reduction Subtract the smallest element in each row from all elements in that row.</p></li>
<li><p>Column Reduction Subtract the smallest element in each column from all elements in that column.</p></li>
<li><p>Covering Zeros Use the minimum number of lines (horizontal + vertical) to cover all zeros.</p></li>
<li><p>Adjust Matrix If the number of covering lines &lt; <span class="math inline">\(n\)</span>:</p>
<ul>
<li>Find smallest uncovered value <span class="math inline">\(m\)</span></li>
<li>Subtract <span class="math inline">\(m\)</span> from all uncovered elements</li>
<li>Add <span class="math inline">\(m\)</span> to elements covered twice</li>
<li>Repeat from step 3</li>
</ul></li>
<li><p>Assignment Once <span class="math inline">\(n\)</span> lines are used, pick one zero per row/column → that’s the optimal matching.</p></li>
</ol>
</section>
<section id="example-10" class="level4">
<h4 class="anchored" data-anchor-id="example-10">Example</h4>
<p>Cost matrix:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>v1</th>
<th>v2</th>
<th>v3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u1</td>
<td>4</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>u2</td>
<td>2</td>
<td>0</td>
<td>5</td>
</tr>
<tr class="odd">
<td>u3</td>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>Row Reduction: subtract min in each row | u1 | 3 | 0 | 2 | | u2 | 2 | 0 | 5 | | u3 | 1 | 0 | 0 |</p></li>
<li><p>Column Reduction: subtract min in each column | u1 | 2 | 0 | 2 | | u2 | 1 | 0 | 5 | | u3 | 0 | 0 | 0 |</p></li>
<li><p>Cover zeros with 3 lines → feasible.</p></li>
<li><p>Assignment: pick <span class="math inline">\((u1,v2)\)</span>, <span class="math inline">\((u2,v1)\)</span>, <span class="math inline">\((u3,v3)\)</span> → total cost = <span class="math inline">\(1+2+2=5\)</span></p></li>
</ol>
<p>Optimal assignment found.</p>
</section>
<section id="tiny-code-python-like-pseudocode-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-pseudocode-2">Tiny Code (Python-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> linear_sum_assignment</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hungarian(cost_matrix):</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>    row_ind, col_ind <span class="op">=</span> linear_sum_assignment(cost_matrix)</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> cost_matrix[row_ind, col_ind].<span class="bu">sum</span>()</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">zip</span>(row_ind, col_ind)), total_cost</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>cost <span class="op">=</span> np.array([[<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">2</span>]])</span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>match, cost <span class="op">=</span> hungarian(cost)</span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match, cost)  <span class="co"># [(0,1), (1,0), (2,2)], 5</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-72" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-72">Why It Matters</h4>
<ul>
<li><p>Exact and efficient: <span class="math inline">\(O(n^3)\)</span> complexity</p></li>
<li><p>Fundamental in operations research and AI (task allocation, scheduling, tracking)</p></li>
<li><p>Used in:</p>
<ul>
<li>Job–worker assignment</li>
<li>Optimal resource allocation</li>
<li>Matching predictions to ground truth (e.g.&nbsp;Hungarian loss in object detection)</li>
</ul></li>
</ul>
<p>The algorithm balances combinatorics and linear algebra, a rare blend of elegance and utility.</p>
</section>
<section id="a-gentle-proof-why-it-works-72" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-72">A Gentle Proof (Why It Works)</h4>
<p>The algorithm maintains dual feasibility and complementary slackness at each step. By reducing rows and columns, we ensure at least one zero in each row and column, creating a reduced cost matrix where zeros correspond to feasible assignments.</p>
<p>Each iteration moves closer to a perfect matching in the equality graph (edges where reduced cost = 0). Once all vertices are matched, the solution satisfies optimality conditions.</p>
</section>
<section id="try-it-yourself-72" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-72">Try It Yourself</h4>
<ol type="1">
<li>Create a 3×3 or 4×4 cost matrix.</li>
<li>Perform row and column reductions manually.</li>
<li>Cover zeros and count lines.</li>
<li>Adjust and repeat until <span class="math inline">\(n\)</span> lines used.</li>
<li>Assign one zero per row/column.</li>
</ol>
</section>
<section id="test-cases-72" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-72">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Matrix Size</th>
<th>Cost Matrix Type</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3×3</td>
<td>Random integers</td>
<td>Minimum cost assignment</td>
</tr>
<tr class="even">
<td>4×4</td>
<td>Diagonal dominance</td>
<td>Diagonal chosen</td>
</tr>
<tr class="odd">
<td>5×5</td>
<td>Symmetric</td>
<td>Matching pairs found</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-72" class="level4">
<h4 class="anchored" data-anchor-id="complexity-72">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Row/column reductions</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="even">
<td>Iterative covering</td>
<td><span class="math inline">\(O(n^3)\)</span></td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(n^3)\)</span></td>
</tr>
</tbody>
</table>
<p>The Hungarian Algorithm transforms a cost matrix into structure, revealing an optimal matching hidden within zeros, one line at a time.</p>
</section>
</section>
<section id="kuhnmunkres-max-weight-matching" class="level3">
<h3 class="anchored" data-anchor-id="kuhnmunkres-max-weight-matching">374 Kuhn–Munkres (Max-Weight Matching)</h3>
<p>The Kuhn–Munkres Algorithm, also known as the Hungarian Algorithm for Maximum Weight Matching, solves the maximum-weight bipartite matching problem. While the standard Hungarian method minimizes total cost, this version maximizes total reward or utility, making it ideal for assignment optimization when bigger is better.</p>
<section id="what-problem-are-we-solving-73" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-73">What Problem Are We Solving?</h4>
<p>Given a complete bipartite graph <span class="math inline">\(G = (U, V, E)\)</span> with <span class="math inline">\(|U| = |V| = n\)</span>, and weights <span class="math inline">\(w(u, v)\)</span> on each edge, find a perfect matching <span class="math inline">\(M \subseteq E\)</span> such that:</p>
<p><span class="math display">\[
\text{maximize } \sum_{(u,v) \in M} w(u,v)
\]</span></p>
<p>Each vertex is matched to exactly one partner on the opposite side, and total weight is as large as possible.</p>
</section>
<section id="how-it-works-plain-language-8" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-8">How It Works (Plain Language)</h4>
<p>The algorithm treats the weight matrix like a profit grid. It constructs a labeling on vertices and maintains equality edges (where label sums equal edge weight). By building and augmenting matchings within this equality graph, it converges to the optimal maximum-weight matching.</p>
<p>Key ideas:</p>
<ul>
<li>Maintain vertex labels <span class="math inline">\(l(u)\)</span> and <span class="math inline">\(l(v)\)</span> that satisfy <span class="math inline">\(l(u) + l(v) \ge w(u, v)\)</span> (dual feasibility)</li>
<li>Build equality graph where equality holds</li>
<li>Find augmenting paths in equality graph</li>
<li>Update labels when stuck to reveal new equality edges</li>
</ul>
<p>Steps:</p>
<ol type="1">
<li><p>Initialize labels</p>
<ul>
<li><span class="math inline">\(l(u) = \max_{v} w(u, v)\)</span> for each <span class="math inline">\(u \in U\)</span></li>
<li><span class="math inline">\(l(v) = 0\)</span> for each <span class="math inline">\(v \in V\)</span></li>
</ul></li>
<li><p>Repeat for each <span class="math inline">\(u\)</span>:</p>
<ul>
<li>Build alternating tree using BFS</li>
<li>If no augmenting path, update labels to expose new equality edges</li>
<li>Augment matching along found path</li>
</ul></li>
<li><p>Continue until all vertices are matched.</p></li>
</ol>
</section>
<section id="example-11" class="level4">
<h4 class="anchored" data-anchor-id="example-11">Example</h4>
<p>Weights:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>v1</th>
<th>v2</th>
<th>v3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u1</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr class="even">
<td>u2</td>
<td>2</td>
<td>4</td>
<td>6</td>
</tr>
<tr class="odd">
<td>u3</td>
<td>3</td>
<td>5</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Goal: maximize total weight</p>
<p>Optimal matching:</p>
<ul>
<li><span class="math inline">\(u1 \to v1\)</span> (3)</li>
<li><span class="math inline">\(u2 \to v3\)</span> (6)</li>
<li><span class="math inline">\(u3 \to v2\)</span> (5)</li>
</ul>
<p>Total weight = <span class="math inline">\(3 + 6 + 5 = 14\)</span></p>
</section>
<section id="tiny-code-python-like-pseudocode-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-pseudocode-3">Tiny Code (Python-like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> linear_sum_assignment</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kuhn_munkres(weight_matrix):</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to cost by negation (Hungarian solves minimization)</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> <span class="op">-</span>weight_matrix</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>    row_ind, col_ind <span class="op">=</span> linear_sum_assignment(cost)</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> weight_matrix[row_ind, col_ind].<span class="bu">sum</span>()</span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">zip</span>(row_ind, col_ind)), total</span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> np.array([[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>],[<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">3</span>]])</span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>match, total <span class="op">=</span> kuhn_munkres(W)</span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match, total)  <span class="co"># [(0,0),(1,2),(2,1)], 14</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-73" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-73">Why It Matters</h4>
<ul>
<li><p>Solves maximum reward assignments in polynomial time</p></li>
<li><p>Fundamental in:</p>
<ul>
<li>Job–task allocation</li>
<li>Optimal pairing problems</li>
<li>Machine learning (e.g.&nbsp;Hungarian loss)</li>
<li>Game theory and economics</li>
</ul></li>
</ul>
<p>Many systems use this algorithm to maximize overall efficiency when assigning limited resources.</p>
</section>
<section id="a-gentle-proof-why-it-works-73" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-73">A Gentle Proof (Why It Works)</h4>
<ul>
<li>Maintain dual feasibility: <span class="math inline">\(l(u) + l(v) \ge w(u, v)\)</span></li>
<li>Maintain complementary slackness: matched edges satisfy equality</li>
<li>By alternating updates between equality graph expansion and label adjustments, the algorithm ensures eventual feasibility and optimality</li>
<li>The final matching satisfies strong duality, achieving maximum weight</li>
</ul>
</section>
<section id="try-it-yourself-73" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-73">Try It Yourself</h4>
<ol type="1">
<li>Build a <span class="math inline">\(3 \times 3\)</span> profit matrix.</li>
<li>Initialize <span class="math inline">\(l(u)\)</span> as row maxima, <span class="math inline">\(l(v)=0\)</span>.</li>
<li>Draw equality edges (<span class="math inline">\(l(u)+l(v)=w(u,v)\)</span>).</li>
<li>Find augmenting path → augment → update labels.</li>
<li>Repeat until matching is perfect.</li>
</ol>
</section>
<section id="test-cases-73" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-73">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Size</th>
<th>Max Weight</th>
<th>Matching</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3×3</td>
<td>Random weights</td>
<td>14</td>
<td>[(0,0),(1,2),(2,1)]</td>
</tr>
<tr class="even">
<td>4×4</td>
<td>Diagonal high</td>
<td>sum(diag)</td>
<td>Diagonal</td>
</tr>
<tr class="odd">
<td>5×5</td>
<td>Uniform</td>
<td>5×max weight</td>
<td>any</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-73" class="level4">
<h4 class="anchored" data-anchor-id="complexity-73">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Label updates</td>
<td><span class="math inline">\(O(V^2)\)</span></td>
</tr>
<tr class="even">
<td>Matching phases</td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(V^3)\)</span></td>
</tr>
</tbody>
</table>
<p>The Kuhn–Munkres algorithm is the ultimate tool for maximum-weight assignments, blending geometry, duality, and combinatorics into one powerful optimization engine.</p>
</section>
</section>
<section id="blossom-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="blossom-algorithm">375 Blossom Algorithm</h3>
<p>The Blossom Algorithm, developed by Jack Edmonds, is the foundational algorithm for finding maximum matchings in general graphs, including non-bipartite ones. It introduced the concept of blossoms (odd-length cycles) and showed that maximum matching is solvable in polynomial time, a landmark in combinatorial optimization.</p>
<section id="what-problem-are-we-solving-74" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-74">What Problem Are We Solving?</h4>
<p>Given a general (not necessarily bipartite) graph <span class="math inline">\(G = (V, E)\)</span>, find a maximum matching, a largest set of edges such that no two share a vertex.</p>
<p>Unlike bipartite graphs, odd-length cycles can block progress in standard augmenting path searches. The Blossom Algorithm contracts these cycles so that augmenting paths can still be found.</p>
<p>Formally, find <span class="math inline">\(M \subseteq E\)</span> maximizing <span class="math inline">\(|M|\)</span> such that each vertex is incident to at most one edge in <span class="math inline">\(M\)</span>.</p>
</section>
<section id="how-it-works-plain-language-9" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-9">How It Works (Plain Language)</h4>
<p>The algorithm extends the augmenting path approach (used in bipartite matching) by adding one powerful idea: When you hit an odd-length cycle, treat it as a single vertex, a blossom.</p>
<p>Steps:</p>
<ol type="1">
<li><p>Initialize with an empty matching <span class="math inline">\(M = \emptyset\)</span>.</p></li>
<li><p>Search for augmenting paths using BFS/DFS in the alternating tree:</p>
<ul>
<li>Alternate between matched and unmatched edges.</li>
<li>If you reach a free vertex, augment (flip matched/unmatched edges).</li>
</ul></li>
<li><p>If you encounter an odd cycle (a blossom), contract it into a single super-vertex.</p>
<ul>
<li>Continue the search in the contracted graph.</li>
<li>Once an augmenting path is found, expand blossoms and update the matching.</li>
</ul></li>
<li><p>Repeat until no augmenting path exists.</p></li>
</ol>
<p>Each augmentation increases <span class="math inline">\(|M|\)</span> by 1. When no augmenting path remains, the matching is maximum.</p>
</section>
<section id="example-12" class="level4">
<h4 class="anchored" data-anchor-id="example-12">Example</h4>
<p>Graph:</p>
<ul>
<li>Vertices: <span class="math inline">\({A, B, C, D, E}\)</span></li>
<li>Edges: <span class="math inline">\((A, B), (B, C), (C, A), (B, D), (C, E)\)</span></li>
</ul>
<ol type="1">
<li>Start matching: empty</li>
<li>Build alternating tree: <span class="math inline">\(A \to B \to C \to A\)</span> forms an odd cycle</li>
<li>Contract blossom <span class="math inline">\((A, B, C)\)</span> into one node</li>
<li>Continue search → find augmenting path through blossom</li>
<li>Expand blossom, adjust matching</li>
<li>Result: maximum matching includes edges <span class="math inline">\((A,B), (C,E), (D,...)\)</span></li>
</ol>
</section>
<section id="tiny-code-python-like-pseudocode-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-pseudocode-4">Tiny Code (Python-Like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using networkx for simplicity</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> blossom_maximum_matching(G):</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nx.max_weight_matching(G, maxcardinality<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.Graph()</span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>G.add_edges_from([(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>)])</span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>match <span class="op">=</span> blossom_maximum_matching(G)</span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match)  <span class="co"># {(0,1), (2,4)}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-74" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-74">Why It Matters</h4>
<ul>
<li><p>General graphs (non-bipartite) are common in real-world systems:</p>
<ul>
<li>Social networks (friend pairings)</li>
<li>Molecular structure matching</li>
<li>Scheduling with constraints</li>
<li>Graph-theoretic proofs and optimization</li>
</ul></li>
</ul>
<p>The Blossom Algorithm proved that matching is polynomial-time solvable, a key milestone in algorithmic theory.</p>
</section>
<section id="a-gentle-proof-why-it-works-74" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-74">A Gentle Proof (Why It Works)</h4>
<p>By Berge’s Lemma, a matching is maximum iff there’s no augmenting path. The challenge is that augmenting paths can be hidden inside odd cycles.</p>
<p>Blossom contraction ensures that every augmenting path in the contracted graph corresponds to one in the original. After each augmentation, <span class="math inline">\(|M|\)</span> strictly increases, so the algorithm terminates in polynomial time.</p>
<p>Correctness follows from maintaining:</p>
<ul>
<li>Alternating trees with consistent parity</li>
<li>Contraction invariants (augmenting path preservation)</li>
<li>Berge’s condition across contractions and expansions</li>
</ul>
</section>
<section id="try-it-yourself-74" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-74">Try It Yourself</h4>
<ol type="1">
<li>Draw a triangle graph (3-cycle).</li>
<li>Run augmenting path search, find blossom.</li>
<li>Contract it into one node.</li>
<li>Continue search and expand after finding path.</li>
<li>Verify maximum matching.</li>
</ol>
</section>
<section id="test-cases-74" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-74">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph Type</th>
<th>Matching Size</th>
<th>Method</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>1</td>
<td>Blossom contraction</td>
</tr>
<tr class="even">
<td>Square with diagonal</td>
<td>2</td>
<td>Augmentation</td>
</tr>
<tr class="odd">
<td>Pentagonal odd cycle</td>
<td>2</td>
<td>Blossom</td>
</tr>
<tr class="even">
<td>Bipartite (sanity check)</td>
<td>As usual</td>
<td>Matches Hopcroft–Karp</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-74" class="level4">
<h4 class="anchored" data-anchor-id="complexity-74">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Phase</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search (per augmentation)</td>
<td><span class="math inline">\(O(VE)\)</span></td>
</tr>
<tr class="even">
<td>Augmentations</td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(V^3)\)</span></td>
</tr>
</tbody>
</table>
<p>The Blossom Algorithm was a revelation, showing how to tame odd cycles and extending matchings to all graphs, bridging combinatorics and optimization theory.</p>
</section>
</section>
<section id="edmonds-blossom-shrinking" class="level3">
<h3 class="anchored" data-anchor-id="edmonds-blossom-shrinking">376 Edmonds’ Blossom Shrinking</h3>
<p>Edmonds’ Blossom Shrinking is the core subroutine that powers the Blossom Algorithm, enabling augmenting-path search in non-bipartite graphs. It provides the crucial mechanism for contracting odd-length cycles (blossoms) so that hidden augmenting paths can be revealed and exploited.</p>
<section id="what-problem-are-we-solving-75" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-75">What Problem Are We Solving?</h4>
<p>In non-bipartite graphs, augmenting paths can be obscured by odd-length cycles. Standard matching algorithms fail because they assume bipartite structure.</p>
<p>We need a way to handle odd cycles during search so that the algorithm can progress without missing valid augmentations.</p>
<p>Goal: Detect blossoms, shrink them into single vertices, and continue the search efficiently.</p>
<p>Given a matching <span class="math inline">\(M\)</span> in graph <span class="math inline">\(G = (V, E)\)</span>, and an alternating tree grown during a search, when a blossom is found:</p>
<ul>
<li>Shrink the blossom into a super-vertex</li>
<li>Continue the search in the contracted graph</li>
<li>Expand the blossom when an augmenting path is found</li>
</ul>
</section>
<section id="how-it-works-plain-language-10" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-10">How It Works (Plain Language)</h4>
<p>Imagine running a BFS/DFS from a free vertex. You alternate between matched and unmatched edges to build an alternating tree.</p>
<p>If you find an edge connecting two vertices at the same level (both even depth):</p>
<ul>
<li>You’ve detected an odd cycle.</li>
<li>That cycle is a blossom.</li>
</ul>
<p>To handle it:</p>
<ol type="1">
<li>Identify the blossom (odd-length alternating cycle)</li>
<li>Shrink all its vertices into a single super-node</li>
<li>Continue the augmenting path search on this contracted graph</li>
<li>Once an augmenting path is discovered, expand the blossom and adjust the path accordingly</li>
<li>Augment along the expanded path</li>
</ol>
<p>This shrinking maintains all valid augmenting paths and allows the algorithm to operate as if the blossom were one vertex.</p>
</section>
<section id="example-13" class="level4">
<h4 class="anchored" data-anchor-id="example-13">Example</h4>
<p>Graph: Vertices: <span class="math inline">\({A, B, C, D, E}\)</span> Edges: <span class="math inline">\((A,B), (B,C), (C,A), (B,D), (C,E)\)</span></p>
<p>Suppose <span class="math inline">\(A, B, C\)</span> form an odd cycle discovered during search.</p>
<ol type="1">
<li>Detect blossom: <span class="math inline">\((A, B, C)\)</span></li>
<li>Contract into a single vertex <span class="math inline">\(X\)</span></li>
<li>Continue search on reduced graph</li>
<li>If augmenting path passes through <span class="math inline">\(X\)</span>, expand back</li>
<li>Alternate edges within blossom to integrate path correctly</li>
</ol>
<p>Result: A valid augmenting path is found and matching increases by one.</p>
</section>
<section id="tiny-code-python-like" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like">Tiny Code (Python-Like)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_blossom(u, v, parent):</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find common ancestor</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    path_u, path_v <span class="op">=</span> <span class="bu">set</span>(), <span class="bu">set</span>()</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> u <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>        path_u.add(u)</span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> parent[u]</span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> v <span class="kw">not</span> <span class="kw">in</span> path_u:</span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>        path_v.add(v)</span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> parent[v]</span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>    lca <span class="op">=</span> v</span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Shrink blossom (conceptually)</span></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lca</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In practical implementations (like Edmonds’ algorithm), this logic merges all nodes in the blossom into a single node and adjusts parent/child relationships.</p>
</section>
<section id="why-it-matters-75" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-75">Why It Matters</h4>
<p>This is the heart of general-graph matching. Without shrinking, the search may loop infinitely or fail to detect valid augmentations.</p>
<p>Blossom shrinking allows:</p>
<ul>
<li>Handling odd-length cycles</li>
<li>Maintaining augmenting path invariants</li>
<li>Guaranteeing polynomial time behavior</li>
</ul>
<p>It is also one of the earliest uses of graph contraction in combinatorial optimization.</p>
</section>
<section id="a-gentle-proof-why-it-works-75" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-75">A Gentle Proof (Why It Works)</h4>
<p>By Berge’s Lemma, a matching is maximum iff there is no augmenting path. If an augmenting path exists in <span class="math inline">\(G\)</span>, then one exists in any contracted version of <span class="math inline">\(G\)</span>.</p>
<p>Shrinking a blossom preserves augmentability:</p>
<ul>
<li>Every augmenting path in the original graph corresponds to one in the contracted graph.</li>
<li>After expansion, the alternating pattern is restored correctly.</li>
</ul>
<p>Therefore, contraction does not lose information, it simply simplifies the search.</p>
</section>
<section id="try-it-yourself-75" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-75">Try It Yourself</h4>
<ol type="1">
<li>Draw a triangle <span class="math inline">\(A, B, C\)</span> connected to other vertices <span class="math inline">\(D, E\)</span>.</li>
<li>Build an alternating tree starting from a free vertex.</li>
<li>When you find an edge connecting two even-level vertices, mark the odd cycle.</li>
<li>Shrink the blossom, continue search, then expand once path is found.</li>
</ol>
<p>Observe how this allows discovery of an augmenting path that was previously hidden.</p>
</section>
<section id="test-cases-75" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-75">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Description</th>
<th>Augmentable After Shrink?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle</td>
<td>Single odd cycle</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Triangle + tail</td>
<td>Cycle + path</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Bipartite</td>
<td>No odd cycle</td>
<td>Shrink not needed</td>
</tr>
<tr class="even">
<td>Pentagon</td>
<td>Blossom of length 5</td>
<td>Yes</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-75" class="level4">
<h4 class="anchored" data-anchor-id="complexity-75">Complexity</h4>
<p>Shrinking can be done in linear time relative to blossom size. Total algorithm remains <span class="math inline">\(O(V^3)\)</span> when integrated into full matching search.</p>
<p>Edmonds’ Blossom Shrinking is the conceptual leap that made maximum matching in general graphs tractable, transforming an intractable maze of cycles into a solvable structure through careful contraction and expansion.</p>
</section>
</section>
<section id="greedy-matching" class="level3">
<h3 class="anchored" data-anchor-id="greedy-matching">377 Greedy Matching</h3>
<p>Greedy Matching is the simplest way to approximate a maximum matching in a graph. Instead of exploring augmenting paths, it just keeps picking available edges that don’t conflict, a fast, intuitive baseline for matching problems.</p>
<section id="what-problem-are-we-solving-76" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-76">What Problem Are We Solving?</h4>
<p>In many real-world settings, job assignment, pairing users, scheduling, we need a set of edges such that no two share a vertex. This is a matching.</p>
<p>Finding the maximum matching exactly (especially in general graphs) can be expensive. But sometimes, we only need a good enough answer quickly.</p>
<p>A Greedy Matching algorithm provides a fast approximation:</p>
<ul>
<li>It won’t always find the largest matching</li>
<li>But it runs in <span class="math inline">\(O(E)\)</span> and often gives a decent solution</li>
</ul>
<p>Goal: Quickly build a maximal matching (no edge can be added).</p>
</section>
<section id="how-it-works-plain-language-11" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-11">How It Works (Plain Language)</h4>
<p>Start with an empty set <span class="math inline">\(M\)</span> (the matching). Go through the edges one by one:</p>
<ol type="1">
<li>For each edge <span class="math inline">\((u, v)\)</span></li>
<li>If neither <span class="math inline">\(u\)</span> nor <span class="math inline">\(v\)</span> is already matched</li>
<li>Add <span class="math inline">\((u, v)\)</span> to <span class="math inline">\(M\)</span></li>
</ol>
<p>Continue until all edges have been checked.</p>
<p>This ensures no vertex appears in more than one edge, a valid matching. The result is maximal: you can’t add any other edge without breaking the matching rule.</p>
</section>
<section id="example-14" class="level4">
<h4 class="anchored" data-anchor-id="example-14">Example</h4>
<p>Graph edges: <span class="math display">\[
E = {(A,B), (B,C), (C,D), (D,E)}
\]</span></p>
<ul>
<li>Start: <span class="math inline">\(M = \emptyset\)</span></li>
<li>Pick <span class="math inline">\((A,B)\)</span> → mark <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> as matched</li>
<li>Skip <span class="math inline">\((B,C)\)</span> → <span class="math inline">\(B\)</span> is matched</li>
<li>Pick <span class="math inline">\((C,D)\)</span> → mark <span class="math inline">\(C\)</span>, <span class="math inline">\(D\)</span></li>
<li>Skip <span class="math inline">\((D,E)\)</span> → <span class="math inline">\(D\)</span> is matched</li>
</ul>
<p>Result: <span class="math display">\[
M = {(A,B), (C,D)}
\]</span></p>
</section>
<section id="tiny-code-python-like-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-1">Tiny Code (Python-Like)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_matching(graph):</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    matched <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    matching <span class="op">=</span> []</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> graph.edges:</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> matched <span class="kw">and</span> v <span class="kw">not</span> <span class="kw">in</span> matched:</span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>            matching.append((u, v))</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>            matched.add(u)</span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>            matched.add(v)</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matching</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This simple loop runs in linear time over edges.</p>
</section>
<section id="why-it-matters-76" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-76">Why It Matters</h4>
<ul>
<li>Fast: runs in <span class="math inline">\(O(E)\)</span></li>
<li>Simple: easy to implement</li>
<li>Useful baseline: good starting point for heuristic or hybrid approaches</li>
<li>Guaranteed maximality: no edge can be added without breaking matching condition</li>
</ul>
<p>Although it’s not optimal, its result is at least half the size of a maximum matching: <span class="math display">\[
|M_{\text{greedy}}| \ge \frac{1}{2}|M_{\text{max}}|
\]</span></p>
</section>
<section id="a-gentle-proof-why-it-works-76" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-76">A Gentle Proof (Why It Works)</h4>
<p>Each greedy edge <span class="math inline">\((u,v)\)</span> blocks at most one edge from <span class="math inline">\(M_{\text{max}}\)</span> (since both <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are used). So for every chosen edge, we lose at most one from the optimal. Thus: <span class="math display">\[
2|M_{\text{greedy}}| \ge |M_{\text{max}}|
\]</span> ⇒ Greedy achieves a 1/2-approximation.</p>
</section>
<section id="try-it-yourself-76" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-76">Try It Yourself</h4>
<ol type="1">
<li>Create a graph with 6 vertices and 7 edges.</li>
<li>Run greedy matching in different edge orders.</li>
<li>Observe how results differ, order can affect the final set.</li>
<li>Compare with an exact maximum matching (e.g., Hopcroft–Karp).</li>
</ol>
<p>You’ll see how simple decisions early can influence outcome size.</p>
</section>
<section id="test-cases-76" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-76">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 35%">
<col style="width: 21%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Greedy Matching</th>
<th>Maximum Matching</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Path of 4</td>
<td><span class="math inline">\((A,B),(B,C),(C,D)\)</span></td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>Triangle</td>
<td><span class="math inline">\((A,B),(B,C),(C,A)\)</span></td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Square</td>
<td><span class="math inline">\((A,B),(B,C),(C,D),(D,A)\)</span></td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>Star (5 leaves)</td>
<td><span class="math inline">\((C,1)...(C,5)\)</span></td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-76" class="level4">
<h4 class="anchored" data-anchor-id="complexity-76">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E)\)</span></li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
</ul>
<p>Works for any undirected graph. For directed graphs, edges must be treated as undirected or symmetric.</p>
<p>Greedy matching is a quick and practical approach when you need speed over perfection, a simple handshake strategy that pairs as many as possible before the clock runs out.</p>
</section>
</section>
<section id="stable-marriage-galeshapley" class="level3">
<h3 class="anchored" data-anchor-id="stable-marriage-galeshapley">378 Stable Marriage (Gale–Shapley)</h3>
<p>Stable Marriage (or the Stable Matching Problem) is a cornerstone of combinatorial optimization, where two equal-sized sets (e.g.&nbsp;men and women, jobs and applicants, hospitals and residents) must be paired so that no two participants prefer each other over their assigned partners. The Gale–Shapley algorithm finds such a stable matching in <span class="math inline">\(O(n^2)\)</span> time.</p>
<section id="what-problem-are-we-solving-77" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-77">What Problem Are We Solving?</h4>
<p>Given two sets:</p>
<ul>
<li>Set <span class="math inline">\(A = {a_1, a_2, ..., a_n}\)</span></li>
<li>Set <span class="math inline">\(B = {b_1, b_2, ..., b_n}\)</span></li>
</ul>
<p>Each member ranks all members of the other set in order of preference. We want to find a matching (a one-to-one pairing) such that:</p>
<p>There is no pair <span class="math inline">\((a_i, b_j)\)</span> where:</p>
<ul>
<li><span class="math inline">\(a_i\)</span> prefers <span class="math inline">\(b_j\)</span> over their current match, and</li>
<li><span class="math inline">\(b_j\)</span> prefers <span class="math inline">\(a_i\)</span> over their current match.</li>
</ul>
<p>Such a pair would be unstable, since they would rather be matched together.</p>
<p>Our goal: find a stable configuration, no incentive to switch partners.</p>
</section>
<section id="how-it-works-plain-language-12" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-12">How It Works (Plain Language)</h4>
<p>The Gale–Shapley algorithm uses proposals and rejections:</p>
<ol type="1">
<li><p>All <span class="math inline">\(a_i\)</span> start unmatched.</p></li>
<li><p>While some <span class="math inline">\(a_i\)</span> is free:</p>
<ul>
<li><span class="math inline">\(a_i\)</span> proposes to the most-preferred <span class="math inline">\(b_j\)</span> not yet proposed to.</li>
<li>If <span class="math inline">\(b_j\)</span> is free, accept the proposal.</li>
<li>If <span class="math inline">\(b_j\)</span> is matched but prefers <span class="math inline">\(a_i\)</span> over current partner, she “trades up” and rejects the old one.</li>
<li>Otherwise, she rejects <span class="math inline">\(a_i\)</span>.</li>
</ul></li>
<li><p>Continue until everyone is matched.</p></li>
</ol>
<p>The process always terminates with a stable matching.</p>
</section>
<section id="example-15" class="level4">
<h4 class="anchored" data-anchor-id="example-15">Example</h4>
<p>Let’s say we have:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>Preference List</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A1</td>
<td>B1, B2, B3</td>
</tr>
<tr class="even">
<td>A2</td>
<td>B2, B1, B3</td>
</tr>
<tr class="odd">
<td>A3</td>
<td>B3, B1, B2</td>
</tr>
</tbody>
</table>
<table class="caption-top table">
<thead>
<tr class="header">
<th>B</th>
<th>Preference List</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B1</td>
<td>A2, A1, A3</td>
</tr>
<tr class="even">
<td>B2</td>
<td>A1, A2, A3</td>
</tr>
<tr class="odd">
<td>B3</td>
<td>A1, A2, A3</td>
</tr>
</tbody>
</table>
<p>Step by step:</p>
<ul>
<li>A1 → B1, B1 free → match (A1, B1)</li>
<li>A2 → B2, B2 free → match (A2, B2)</li>
<li>A3 → B3, B3 free → match (A3, B3)</li>
</ul>
<p>Stable matching: {(A1, B1), (A2, B2), (A3, B3)}</p>
<p>No two prefer each other over current partners → Stable.</p>
</section>
<section id="tiny-code-python-like-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-2">Tiny Code (Python-Like)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gale_shapley(A_prefs, B_prefs):</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    free_A <span class="op">=</span> <span class="bu">list</span>(A_prefs.keys())</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    engaged <span class="op">=</span> {}</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    next_choice <span class="op">=</span> {a: <span class="dv">0</span> <span class="cf">for</span> a <span class="kw">in</span> A_prefs}</span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> free_A:</span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> free_A.pop(<span class="dv">0</span>)</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> A_prefs[a][next_choice[a]]</span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a>        next_choice[a] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> b <span class="kw">not</span> <span class="kw">in</span> engaged:</span>
<span id="cb131-12"><a href="#cb131-12" aria-hidden="true" tabindex="-1"></a>            engaged[b] <span class="op">=</span> a</span>
<span id="cb131-13"><a href="#cb131-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb131-14"><a href="#cb131-14" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> engaged[b]</span>
<span id="cb131-15"><a href="#cb131-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> B_prefs[b].index(a) <span class="op">&lt;</span> B_prefs[b].index(current):</span>
<span id="cb131-16"><a href="#cb131-16" aria-hidden="true" tabindex="-1"></a>                engaged[b] <span class="op">=</span> a</span>
<span id="cb131-17"><a href="#cb131-17" aria-hidden="true" tabindex="-1"></a>                free_A.append(current)</span>
<span id="cb131-18"><a href="#cb131-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb131-19"><a href="#cb131-19" aria-hidden="true" tabindex="-1"></a>                free_A.append(a)</span>
<span id="cb131-20"><a href="#cb131-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {v: k <span class="cf">for</span> k, v <span class="kw">in</span> engaged.items()}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-77" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-77">Why It Matters</h4>
<ul>
<li>Guarantees a stable solution.</li>
<li>Always terminates after at most <span class="math inline">\(n^2\)</span> proposals.</li>
<li>If one side proposes (say <span class="math inline">\(A\)</span>), the result is optimal for <span class="math inline">\(A\)</span> and pessimal for <span class="math inline">\(B\)</span>.</li>
<li>Forms the foundation of real-world systems like the National Residency Matching Program (NRMP) and school assignments.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-77" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-77">A Gentle Proof (Why It Works)</h4>
<p>Each proposal is made once per pair → at most <span class="math inline">\(n^2\)</span> proposals.</p>
<p>No cycles:</p>
<ul>
<li><span class="math inline">\(b\)</span> always stays with the best proposer so far</li>
<li>Once rejected, <span class="math inline">\(a\)</span> cannot improve, ensuring termination</li>
</ul>
<p>Stability: Suppose <span class="math inline">\((a_i, b_j)\)</span> is a blocking pair. Then <span class="math inline">\(a_i\)</span> must have proposed to <span class="math inline">\(b_j\)</span> and was rejected. That means <span class="math inline">\(b_j\)</span> preferred her current match. So <span class="math inline">\((a_i, b_j)\)</span> cannot be blocking → contradiction.</p>
<p>Thus, the final matching is stable.</p>
</section>
<section id="try-it-yourself-77" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-77">Try It Yourself</h4>
<ol type="1">
<li>Create two sets of 3 elements with ranked lists.</li>
<li>Run Gale–Shapley twice, once with A proposing, once with B proposing.</li>
<li>Compare the two matchings, see who benefits.</li>
<li>Explore what happens if preference lists are incomplete.</li>
</ol>
</section>
<section id="test-cases-77" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-77">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Result</th>
<th>Stable?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Equal preferences</td>
<td>Multiple stable matchings</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Cyclic preferences</td>
<td>Algorithm converges</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>One-sided identical</td>
<td>Deterministic output</td>
<td>Yes</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-77" class="level4">
<h4 class="anchored" data-anchor-id="complexity-77">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n^2)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Scalable for small to medium systems, widely used in practice.</p>
<p>Stable marriage shows how simple local rules (propose, reject, keep best) can produce global stability, a harmony of preference and fairness.</p>
</section>
</section>
<section id="weighted-b-matching" class="level3">
<h3 class="anchored" data-anchor-id="weighted-b-matching">379 Weighted b-Matching</h3>
<p>Weighted b-Matching generalizes standard matching by allowing each node to be matched to up to <span class="math inline">\(b(v)\)</span> partners instead of just one. When edges carry weights, the goal is to find a maximum-weight subset of edges such that the degree of each vertex does not exceed its capacity <span class="math inline">\(b(v)\)</span>.</p>
<section id="what-problem-are-we-solving-78" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-78">What Problem Are We Solving?</h4>
<p>Given a graph <span class="math inline">\(G = (V, E)\)</span> with:</p>
<ul>
<li>Edge weights <span class="math inline">\(w(e)\)</span> for each <span class="math inline">\(e \in E\)</span></li>
<li>Capacity constraint <span class="math inline">\(b(v)\)</span> for each vertex <span class="math inline">\(v \in V\)</span></li>
</ul>
<p>Find a subset <span class="math inline">\(M \subseteq E\)</span> that:</p>
<ul>
<li>Maximizes total weight <span class="math display">\[W(M) = \sum_{e \in M} w(e)\]</span></li>
<li>Satisfies degree constraints <span class="math display">\[\forall v \in V,\quad \deg_M(v) \le b(v)\]</span></li>
</ul>
<p>If <span class="math inline">\(b(v) = 1\)</span> for all <span class="math inline">\(v\)</span>, this becomes the standard maximum-weight matching.</p>
</section>
<section id="how-it-works-plain-language-13" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-13">How It Works (Plain Language)</h4>
<p>Think of each vertex <span class="math inline">\(v\)</span> as having b(v) slots available for connections. We want to pick edges to fill these slots to maximize total edge weight, without exceeding any vertex’s limit.</p>
<p>The weighted b-matching problem can be solved by:</p>
<ol type="1">
<li><p>Reduction to flow: Convert matching to a network flow problem:</p>
<ul>
<li>Each edge becomes a flow connection with capacity 1 and cost = <span class="math inline">\(-w(e)\)</span></li>
<li>Vertex capacities become flow limits</li>
<li>Solve via min-cost max-flow</li>
</ul></li>
<li><p>Linear Programming: Relax constraints and solve with LP or primal-dual algorithms</p></li>
<li><p>Approximation: For large sparse graphs, greedy heuristics can achieve near-optimal solutions</p></li>
</ol>
</section>
<section id="example-16" class="level4">
<h4 class="anchored" data-anchor-id="example-16">Example</h4>
<p>Suppose:</p>
<ul>
<li>Vertices: <span class="math inline">\(V = {A, B, C}\)</span></li>
<li>Edges and weights: <span class="math inline">\(w(A,B)=5,; w(A,C)=4,; w(B,C)=3\)</span></li>
<li>Capacities: <span class="math inline">\(b(A)=2,; b(B)=1,; b(C)=1\)</span></li>
</ul>
<p>We can pick:</p>
<ul>
<li><span class="math inline">\((A,B)\)</span> weight 5</li>
<li><span class="math inline">\((A,C)\)</span> weight 4</li>
</ul>
<p>Total weight = <span class="math inline">\(9\)</span> Valid since <span class="math inline">\(\deg(A)=2,\deg(B)=1,\deg(C)=1\)</span></p>
<p>If <span class="math inline">\(b(A)=1\)</span>, we’d pick only <span class="math inline">\((A,B)\)</span> → weight <span class="math inline">\(5\)</span></p>
</section>
<section id="tiny-code-python-like-pseudocode-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-like-pseudocode-5">Tiny Code (Python-Like Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> weighted_b_matching(G, b):</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to flow network</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    flow_net <span class="op">=</span> nx.DiGraph()</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    source, sink <span class="op">=</span> <span class="st">'s'</span>, <span class="st">'t'</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> G.nodes:</span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>        flow_net.add_edge(source, v, capacity<span class="op">=</span>b[v], weight<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>        flow_net.add_edge(v, sink, capacity<span class="op">=</span>b[v], weight<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (u, v, data) <span class="kw">in</span> G.edges(data<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> <span class="op">-</span>data[<span class="st">'weight'</span>]  <span class="co"># negate for min-cost</span></span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>        flow_net.add_edge(u, v, capacity<span class="op">=</span><span class="dv">1</span>, weight<span class="op">=</span>w)</span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>        flow_net.add_edge(v, u, capacity<span class="op">=</span><span class="dv">1</span>, weight<span class="op">=</span>w)</span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>    flow_dict <span class="op">=</span> nx.max_flow_min_cost(flow_net, source, sink)</span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract edges with flow=1 between vertex pairs</span></span>
<span id="cb132-19"><a href="#cb132-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [(u, v) <span class="cf">for</span> u, nbrs <span class="kw">in</span> flow_dict.items() <span class="cf">for</span> v, f <span class="kw">in</span> nbrs.items() <span class="cf">if</span> f <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> u <span class="kw">in</span> G.nodes <span class="kw">and</span> v <span class="kw">in</span> G.nodes]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-78" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-78">Why It Matters</h4>
<ul>
<li><p>Models resource allocation with limits (e.g.&nbsp;each worker can handle <span class="math inline">\(b\)</span> tasks)</p></li>
<li><p>Extends classic matchings to capacitated networks</p></li>
<li><p>Foundation for:</p>
<ul>
<li>Task assignment with quotas</li>
<li>Scheduling with multi-capacity</li>
<li>Clustering with degree constraints</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-78" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-78">A Gentle Proof (Why It Works)</h4>
<p>Each vertex <span class="math inline">\(v\)</span> has degree constraint <span class="math inline">\(b(v)\)</span>: <span class="math display">\[\sum_{e \ni v} x_e \le b(v)\]</span></p>
<p>Each edge is chosen at most once: <span class="math display">\[x_e \in {0, 1}\]</span></p>
<p>The optimization: <span class="math display">\[\max \sum_{e \in E} w(e) x_e\]</span></p>
<p>subject to constraints above, forms an integer linear program. Relaxation via network flow ensures optimal integral solution for bipartite graphs.</p>
</section>
<section id="try-it-yourself-78" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-78">Try It Yourself</h4>
<ol type="1">
<li>Build a triangle graph with different edge weights.</li>
<li>Set <span class="math inline">\(b(v)=2\)</span> for one vertex, 1 for others.</li>
<li>Compute by hand which edges yield maximum weight.</li>
<li>Implement with a flow solver and verify.</li>
</ol>
</section>
<section id="test-cases-78" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-78">Test Cases</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 16%">
<col style="width: 28%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Graph</th>
<th>Capacities</th>
<th>Result</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Triangle (5,4,3)</td>
<td>{2,1,1}</td>
<td>{(A,B),(A,C)}</td>
<td>9</td>
</tr>
<tr class="even">
<td>Square</td>
<td>{1,1,1,1}</td>
<td>Standard matching</td>
<td>Max weight sum</td>
</tr>
<tr class="odd">
<td>Line (A-B-C)</td>
<td>{2,1,2}</td>
<td>{(A,B),(B,C)}</td>
<td>Sum of both edges</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-78" class="level4">
<h4 class="anchored" data-anchor-id="complexity-78">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V^3)\)</span> using min-cost max-flow</li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Efficient for medium graphs; scalable via heuristics for larger ones.</p>
<p>Weighted b-matching balances optimality and flexibility, allowing richer allocation models than one-to-one pairings.</p>
</section>
</section>
<section id="maximal-matching" class="level3">
<h3 class="anchored" data-anchor-id="maximal-matching">380 Maximal Matching</h3>
<p>Maximal Matching is a greedy approach that builds a matching by adding edges one by one until no more can be added without breaking the matching condition. Unlike <em>maximum matchings</em> (which maximize size or weight), a <em>maximal</em> matching simply ensures no edge can be added, it’s locally optimal, not necessarily globally optimal.</p>
<section id="what-problem-are-we-solving-79" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-79">What Problem Are We Solving?</h4>
<p>We want to select a set of edges <span class="math inline">\(M \subseteq E\)</span> such that:</p>
<ol type="1">
<li>No two edges in <span class="math inline">\(M\)</span> share a vertex <span class="math display">\[\forall (u,v), (x,y) \in M,; {u,v} \cap {x,y} = \emptyset\]</span></li>
<li><span class="math inline">\(M\)</span> is maximal: no additional edge from <span class="math inline">\(E\)</span> can be added without violating (1).</li>
</ol>
<p>Goal: Find any maximal matching, not necessarily the largest one.</p>
</section>
<section id="how-it-works-plain-language-14" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-14">How It Works (Plain Language)</h4>
<p>The algorithm is greedy and simple:</p>
<ol type="1">
<li>Start with an empty matching <span class="math inline">\(M = \emptyset\)</span></li>
<li>Iterate through edges <span class="math inline">\((u,v)\)</span></li>
<li>If neither <span class="math inline">\(u\)</span> nor <span class="math inline">\(v\)</span> are matched yet, add <span class="math inline">\((u,v)\)</span> to <span class="math inline">\(M\)</span></li>
<li>Continue until all edges are processed</li>
</ol>
<p>At the end, <span class="math inline">\(M\)</span> is maximal: every unmatched edge touches a vertex already matched.</p>
</section>
<section id="example-17" class="level4">
<h4 class="anchored" data-anchor-id="example-17">Example</h4>
<p>Graph:</p>
<pre><code>A -- B -- C
|         
D</code></pre>
<p>Edges: <span class="math inline">\((A,B)\)</span>, <span class="math inline">\((B,C)\)</span>, <span class="math inline">\((A,D)\)</span></p>
<p>Step-by-step:</p>
<ul>
<li>Pick <span class="math inline">\((A,B)\)</span> → mark A, B matched</li>
<li>Skip <span class="math inline">\((B,C)\)</span> (B already matched)</li>
<li>Skip <span class="math inline">\((A,D)\)</span> (A already matched)</li>
</ul>
<p>Result: <span class="math inline">\(M = {(A,B)}\)</span></p>
<p>Another valid maximal matching: <span class="math inline">\({(A,D), (B,C)}\)</span> Not unique, but all maximal sets share the property that no more edges can be added.</p>
</section>
<section id="tiny-code-python-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-3">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maximal_matching(edges):</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    matched <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> []</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> matched <span class="kw">and</span> v <span class="kw">not</span> <span class="kw">in</span> matched:</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>            M.append((u, v))</span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>            matched.add(u)</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>            matched.add(v)</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> M</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="st">'A'</span>,<span class="st">'B'</span>), (<span class="st">'B'</span>,<span class="st">'C'</span>), (<span class="st">'A'</span>,<span class="st">'D'</span>)]</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maximal_matching(edges))  <span class="co"># [('A','B')]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-79" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-79">Why It Matters</h4>
<ul>
<li>Fast approximation: Maximal matching is a 2-approximation for the maximum matching (it’s at least half as large).</li>
<li>Building block: Used in distributed and parallel algorithms where global optimization is too expensive.</li>
<li>Preprocessing step: Reduces problem size in flow, scheduling, and network design.</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-79" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-79">A Gentle Proof (Why It Works)</h4>
<p>If an edge <span class="math inline">\((u,v)\)</span> is not in <span class="math inline">\(M\)</span>, at least one of its endpoints is already matched. Thus, adding <span class="math inline">\((u,v)\)</span> would break the matching condition. This ensures maximality, no more edges can be safely added.</p>
<p>Formally, for every <span class="math inline">\((u,v) \notin M\)</span>: <span class="math display">\[u \in V_M \lor v \in V_M\]</span> where <span class="math inline">\(V_M\)</span> is the set of matched vertices.</p>
<p>Therefore, <span class="math inline">\(M\)</span> is maximal.</p>
</section>
<section id="try-it-yourself-79" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-79">Try It Yourself</h4>
<ol type="1">
<li>Draw a small graph with 4–6 vertices.</li>
<li>Apply the greedy process in different edge orders.</li>
<li>Compare resulting matchings, note they may differ in size, but all are maximal.</li>
<li>Try to add an extra edge, see why it violates matching rules.</li>
</ol>
</section>
<section id="test-cases-79" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-79">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Graph</th>
<th>Edges</th>
<th>Maximal Matching</th>
<th>Size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Path A–B–C</td>
<td>{(A,B),(B,C)}</td>
<td>{(A,B)}</td>
<td>1</td>
</tr>
<tr class="even">
<td>Star A–B,C,D</td>
<td>{(A,B),(A,C),(A,D)}</td>
<td>{(A,B)}</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Square A–B–C–D</td>
<td>{(A,B),(B,C),(C,D),(D,A)}</td>
<td>{(A,B),(C,D)}</td>
<td>2</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-79" class="level4">
<h4 class="anchored" data-anchor-id="complexity-79">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(E)\)</span>, single pass through edges</li>
<li>Space: <span class="math inline">\(O(V)\)</span> for vertex match tracking</li>
</ul>
<p>Fast, simple, and effective for large graphs where optimal matchings are too expensive.</p>
<p>Maximal matching gives you a quick and safe pairing, not always perfect, but always <em>done</em>.</p>
</section>
</section>
</section>
<section id="section-39.-tree-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="section-39.-tree-algorithms">Section 39. Tree Algorithms</h2>
<section id="euler-tour-lca" class="level3">
<h3 class="anchored" data-anchor-id="euler-tour-lca">381 Euler Tour LCA</h3>
<p>Euler Tour LCA transforms the problem of finding the Lowest Common Ancestor (LCA) into a Range Minimum Query (RMQ) problem by recording an Euler tour of the tree. It’s elegant, precomputable, and fast, perfect for multiple LCA queries.</p>
<section id="what-problem-are-we-solving-80" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-80">What Problem Are We Solving?</h4>
<p>Given a rooted tree and two nodes <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, we want to find their lowest common ancestor, the deepest node that is an ancestor of both.</p>
<p>For example, in a tree rooted at <span class="math inline">\(1\)</span>:</p>
<pre><code>      1
    /   \
   2     3
  / \   /
 4  5  6</code></pre>
<p>The LCA of <span class="math inline">\((4,5)\)</span> is <span class="math inline">\(2\)</span>, and LCA of <span class="math inline">\((4,6)\)</span> is <span class="math inline">\(1\)</span>.</p>
<p>We want to answer many such queries efficiently.</p>
</section>
<section id="how-it-works-plain-language-15" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-15">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Perform a DFS traversal (Euler tour):</p>
<ul>
<li>Record each node when you enter it.</li>
<li>When you backtrack, record it again.</li>
</ul></li>
<li><p>Store the depth of each node when visited.</p></li>
<li><p>For each node, remember its first occurrence in the Euler tour.</p></li>
<li><p>For query <span class="math inline">\((u, v)\)</span>:</p>
<ul>
<li>Find the first occurrences of <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> in the tour.</li>
<li>Take the range between them.</li>
<li>The node with minimum depth in that range is the LCA.</li>
</ul></li>
</ol>
<p>So, LCA reduces to an RMQ over depths.</p>
</section>
<section id="example-18" class="level4">
<h4 class="anchored" data-anchor-id="example-18">Example</h4>
<p>Tree (root = 1):</p>
<pre><code>1
├── 2
│   ├── 4
│   └── 5
└── 3
    └── 6</code></pre>
<p>Euler tour: <span class="math inline">\([1,2,4,2,5,2,1,3,6,3,1]\)</span></p>
<p>Depth array: <span class="math inline">\([0,1,2,1,2,1,0,1,2,1,0]\)</span></p>
<p>First occurrences: <span class="math inline">\(1\to0,;2\to1,;3\to7,;4\to2,;5\to4,;6\to8\)</span></p>
<p>Query: LCA(4,5)</p>
<ul>
<li>First(4) = 2, First(5) = 4</li>
<li>Depth range [2..4] = [2,1,2]</li>
<li>Minimum depth = 1 → node = 2</li>
</ul>
<p>So LCA(4,5) = 2.</p>
</section>
<section id="tiny-code-python-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-4">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euler_tour_lca(graph, root):</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    euler, depth, first <span class="op">=</span> [], [], {}</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(u, d):</span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>        first.setdefault(u, <span class="bu">len</span>(euler))</span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>        euler.append(u)</span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>        depth.append(d)</span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>            dfs(v, d <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>            euler.append(u)</span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>            depth.append(d)</span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a>    dfs(root, <span class="dv">0</span>)</span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> euler, depth, first</span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_rmq(depth):</span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(depth)</span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a>    log <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>        log[i] <span class="op">=</span> log[i <span class="op">//</span> <span class="dv">2</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> log[n]</span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>    st <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>        st[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j) <span class="op">&lt;=</span> n:</span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">+</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j) <span class="op">&lt;=</span> n:</span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> st[i][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> st[i <span class="op">+</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (j <span class="op">-</span> <span class="dv">1</span>))][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb137-32"><a href="#cb137-32" aria-hidden="true" tabindex="-1"></a>            st[i][j] <span class="op">=</span> left <span class="cf">if</span> depth[left] <span class="op">&lt;</span> depth[right] <span class="cf">else</span> right</span>
<span id="cb137-33"><a href="#cb137-33" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb137-34"><a href="#cb137-34" aria-hidden="true" tabindex="-1"></a>        j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb137-35"><a href="#cb137-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> st, log</span>
<span id="cb137-36"><a href="#cb137-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-37"><a href="#cb137-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> query_lca(u, v, euler, depth, first, st, log):</span>
<span id="cb137-38"><a href="#cb137-38" aria-hidden="true" tabindex="-1"></a>    l, r <span class="op">=</span> first[u], first[v]</span>
<span id="cb137-39"><a href="#cb137-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> l <span class="op">&gt;</span> r:</span>
<span id="cb137-40"><a href="#cb137-40" aria-hidden="true" tabindex="-1"></a>        l, r <span class="op">=</span> r, l</span>
<span id="cb137-41"><a href="#cb137-41" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> log[r <span class="op">-</span> l <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb137-42"><a href="#cb137-42" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> st[l][j]</span>
<span id="cb137-43"><a href="#cb137-43" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> st[r <span class="op">-</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j) <span class="op">+</span> <span class="dv">1</span>][j]</span>
<span id="cb137-44"><a href="#cb137-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> euler[left] <span class="cf">if</span> depth[left] <span class="op">&lt;</span> depth[right] <span class="cf">else</span> euler[right]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-80" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-80">Why It Matters</h4>
<ul>
<li><p>Reduces LCA to RMQ, allowing <span class="math inline">\(O(1)\)</span> query with <span class="math inline">\(O(n \log n)\)</span> preprocessing</p></li>
<li><p>Easy to combine with Segment Trees, Sparse Tables, or Cartesian Trees</p></li>
<li><p>Essential for:</p>
<ul>
<li>Tree DP with ancestor relationships</li>
<li>Distance queries: <span class="math display">\[\text{dist}(u,v) = \text{depth}(u) + \text{depth}(v) - 2 \times \text{depth}(\text{LCA}(u,v))\]</span></li>
<li>Path queries in heavy-light decomposition</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-80" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-80">A Gentle Proof (Why It Works)</h4>
<p>In DFS traversal:</p>
<ul>
<li>Every ancestor appears before and after descendants.</li>
<li>The first common ancestor to reappear between two nodes’ first occurrences is their LCA.</li>
</ul>
<p>Therefore, the node with minimum depth between the first appearances corresponds exactly to the lowest common ancestor.</p>
</section>
<section id="try-it-yourself-80" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-80">Try It Yourself</h4>
<ol type="1">
<li>Construct a tree and perform an Euler tour manually.</li>
<li>Write down depth and first occurrence arrays.</li>
<li>Pick pairs <span class="math inline">\((u,v)\)</span>, find the minimum depth in their range.</li>
<li>Confirm LCA correctness.</li>
</ol>
</section>
<section id="test-cases-80" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-80">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query</th>
<th>Expected</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LCA(4,5)</td>
<td>2</td>
<td>Both under 2</td>
</tr>
<tr class="even">
<td>LCA(4,6)</td>
<td>1</td>
<td>Root is common ancestor</td>
</tr>
<tr class="odd">
<td>LCA(2,3)</td>
<td>1</td>
<td>Different subtrees</td>
</tr>
<tr class="even">
<td>LCA(6,3)</td>
<td>3</td>
<td>One is ancestor</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-80" class="level4">
<h4 class="anchored" data-anchor-id="complexity-80">Complexity</h4>
<ul>
<li>Preprocessing: <span class="math inline">\(O(n \log n)\)</span></li>
<li>Query: <span class="math inline">\(O(1)\)</span></li>
<li>Space: <span class="math inline">\(O(n \log n)\)</span></li>
</ul>
<p>Euler Tour LCA shows how tree problems become array problems, a perfect example of structural transformation in algorithms.</p>
</section>
</section>
<section id="binary-lifting-lca" class="level3">
<h3 class="anchored" data-anchor-id="binary-lifting-lca">382 Binary Lifting LCA</h3>
<p>Binary Lifting is a fast and elegant technique to find the Lowest Common Ancestor (LCA) of two nodes in a tree using precomputed jumps to ancestors at powers of two. It turns ancestor queries into simple bit operations, giving <span class="math inline">\(O(\log n)\)</span> per query.</p>
<section id="what-problem-are-we-solving-81" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-81">What Problem Are We Solving?</h4>
<p>Given a rooted tree and two nodes <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, we want to find their lowest common ancestor (LCA), the deepest node that is an ancestor of both.</p>
<p>Naively, we could walk up one node at a time, but that’s <span class="math inline">\(O(n)\)</span> per query. With binary lifting, we jump exponentially up the tree, reducing the cost to <span class="math inline">\(O(\log n)\)</span>.</p>
</section>
<section id="how-it-works-plain-language-16" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-16">How It Works (Plain Language)</h4>
<p>Binary lifting precomputes for each node:</p>
<p><span class="math display">\[\text{up}[v][k] = \text{the } 2^k \text{-th ancestor of } v\]</span></p>
<p>So <span class="math inline">\(\text{up}[v][0]\)</span> is the parent, <span class="math inline">\(\text{up}[v][1]\)</span> is the grandparent, <span class="math inline">\(\text{up}[v][2]\)</span> is the ancestor 4 levels up, and so on.</p>
<p>The algorithm proceeds in three steps:</p>
<ol type="1">
<li><p>Preprocess:</p>
<ul>
<li>Run DFS from the root.</li>
<li>Record each node’s depth.</li>
<li>Fill table <code>up[v][k]</code>.</li>
</ul></li>
<li><p>Equalize Depths:</p>
<ul>
<li>If one node is deeper, lift it up to match the shallower one.</li>
</ul></li>
<li><p>Lift Together:</p>
<ul>
<li>Jump both nodes up together (largest powers first) until their ancestors match.</li>
</ul></li>
</ol>
<p>The meeting point is the LCA.</p>
</section>
<section id="example-19" class="level4">
<h4 class="anchored" data-anchor-id="example-19">Example</h4>
<p>Tree:</p>
<pre><code>      1
    /   \
   2     3
  / \   /
 4  5  6</code></pre>
<p>Binary lifting table (<code>up[v][k]</code>):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>v</th>
<th>up[v][0]</th>
<th>up[v][1]</th>
<th>up[v][2]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td>3</td>
<td>1</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td>4</td>
<td>2</td>
<td>1</td>
<td>-</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2</td>
<td>1</td>
<td>-</td>
</tr>
<tr class="even">
<td>6</td>
<td>3</td>
<td>1</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Query: LCA(4,5)</p>
<ul>
<li>Depth(4)=2, Depth(5)=2</li>
<li>Lift 4,5 together → parents (2,2) match → LCA = 2</li>
</ul>
<p>Query: LCA(4,6)</p>
<ul>
<li>Depth(4)=2, Depth(6)=2</li>
<li>Lift 4→2, 6→3 → not equal</li>
<li>Lift 2→1, 3→1 → LCA = 1</li>
</ul>
</section>
<section id="tiny-code-python-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-5">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>LOG <span class="op">=</span> <span class="dv">20</span>  <span class="co"># enough for n up to ~1e6</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> preprocess(graph, root):</span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>    up <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> LOG <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>    depth <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(u, p):</span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>        up[u][<span class="dv">0</span>] <span class="op">=</span> p</span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, LOG):</span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> up[u][k<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>                up[u][k] <span class="op">=</span> up[up[u][k<span class="op">-</span><span class="dv">1</span>]][k<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="op">!=</span> p:</span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>                depth[v] <span class="op">=</span> depth[u] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a>                dfs(v, u)</span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a>    dfs(root, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb139-18"><a href="#cb139-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> up, depth</span>
<span id="cb139-19"><a href="#cb139-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-20"><a href="#cb139-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lca(u, v, up, depth):</span>
<span id="cb139-21"><a href="#cb139-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth[u] <span class="op">&lt;</span> depth[v]:</span>
<span id="cb139-22"><a href="#cb139-22" aria-hidden="true" tabindex="-1"></a>        u, v <span class="op">=</span> v, u</span>
<span id="cb139-23"><a href="#cb139-23" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> depth[u] <span class="op">-</span> depth[v]</span>
<span id="cb139-24"><a href="#cb139-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(LOG):</span>
<span id="cb139-25"><a href="#cb139-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> diff <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> k):</span>
<span id="cb139-26"><a href="#cb139-26" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> up[u][k]</span>
<span id="cb139-27"><a href="#cb139-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u <span class="op">==</span> v:</span>
<span id="cb139-28"><a href="#cb139-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u</span>
<span id="cb139-29"><a href="#cb139-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(LOG)):</span>
<span id="cb139-30"><a href="#cb139-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> up[u][k] <span class="op">!=</span> up[v][k]:</span>
<span id="cb139-31"><a href="#cb139-31" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> up[u][k]</span>
<span id="cb139-32"><a href="#cb139-32" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> up[v][k]</span>
<span id="cb139-33"><a href="#cb139-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> up[u][<span class="dv">0</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-81" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-81">Why It Matters</h4>
<ul>
<li>Handles large trees with many queries efficiently</li>
<li>Enables ancestor jumps, k-th ancestor queries, distance queries, etc.</li>
<li>Fundamental in competitive programming, tree DP, and path queries</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-81" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-81">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> have different depths, lifting the deeper node by <span class="math inline">\(2^k\)</span> steps ensures we equalize their depth quickly.</p>
<p>Once aligned, lifting both simultaneously ensures we never skip the LCA, since jumps are made only when ancestors differ.</p>
<p>Eventually, both meet at their lowest shared ancestor.</p>
</section>
<section id="try-it-yourself-81" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-81">Try It Yourself</h4>
<ol type="1">
<li>Build a small tree with 7 nodes.</li>
<li>Compute <span class="math inline">\(\text{up}[v][k]\)</span> manually.</li>
<li>Pick pairs and simulate lifting step-by-step.</li>
<li>Verify with naive path-to-root comparison.</li>
</ol>
</section>
<section id="test-cases-81" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-81">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query</th>
<th>Expected</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LCA(4,5)</td>
<td>2</td>
<td>same parent</td>
</tr>
<tr class="even">
<td>LCA(4,6)</td>
<td>1</td>
<td>across subtrees</td>
</tr>
<tr class="odd">
<td>LCA(2,3)</td>
<td>1</td>
<td>root ancestor</td>
</tr>
<tr class="even">
<td>LCA(6,3)</td>
<td>3</td>
<td>ancestor</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-81" class="level4">
<h4 class="anchored" data-anchor-id="complexity-81">Complexity</h4>
<ul>
<li>Preprocessing: <span class="math inline">\(O(n \log n)\)</span></li>
<li>Query: <span class="math inline">\(O(\log n)\)</span></li>
<li>Space: <span class="math inline">\(O(n \log n)\)</span></li>
</ul>
<p>Binary lifting turns tree ancestry into bitwise jumping, offering a clear path from root to ancestor in logarithmic time.</p>
</section>
</section>
<section id="tarjans-lca-offline-dsu" class="level3">
<h3 class="anchored" data-anchor-id="tarjans-lca-offline-dsu">383 Tarjan’s LCA (Offline DSU)</h3>
<p>Tarjan’s LCA algorithm answers multiple LCA queries offline using Disjoint Set Union (DSU) with path compression. It traverses the tree once (DFS) and merges subtrees, answering all queries in <span class="math inline">\(O(n + q \alpha(n))\)</span> time.</p>
<section id="what-problem-are-we-solving-82" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-82">What Problem Are We Solving?</h4>
<p>Given a rooted tree and multiple queries <span class="math inline">\((u, v)\)</span>, we want the lowest common ancestor of each pair.</p>
<p>Unlike binary lifting (which works online), Tarjan’s algorithm works offline:</p>
<ul>
<li>We know all queries in advance.</li>
<li>We answer them in one DFS traversal using a union-find structure.</li>
</ul>
</section>
<section id="how-it-works-plain-language-17" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-17">How It Works (Plain Language)</h4>
<p>We process the tree bottom-up:</p>
<ol type="1">
<li><p>Start a DFS from the root.</p></li>
<li><p>Each node begins as its own set in DSU.</p></li>
<li><p>After visiting a child, union it with its parent.</p></li>
<li><p>When a node is fully processed, mark it as visited.</p></li>
<li><p>For each query <span class="math inline">\((u,v)\)</span>:</p>
<ul>
<li>If the other node has been visited, then <span class="math inline">\(\text{find}(v)\)</span> (or <span class="math inline">\(\text{find}(u)\)</span>) gives the LCA.</li>
</ul></li>
</ol>
<p>This works because the DSU structure merges all processed ancestors, so <span class="math inline">\(\text{find}(v)\)</span> always points to the lowest processed ancestor common to both.</p>
</section>
<section id="example-20" class="level4">
<h4 class="anchored" data-anchor-id="example-20">Example</h4>
<p>Tree (root = 1):</p>
<pre><code>1
├── 2
│   ├── 4
│   └── 5
└── 3
    └── 6</code></pre>
<p>Queries: <span class="math inline">\((4,5), (4,6), (3,6)\)</span></p>
<p>Process:</p>
<ul>
<li><p>DFS(1): visit 2, visit 4</p>
<ul>
<li>Query(4,5): 5 not visited → skip</li>
<li>Backtrack → union(4,2)</li>
</ul></li>
<li><p>DFS(5): mark visited, union(5,2)</p>
<ul>
<li>Query(4,5): 4 visited → <span class="math inline">\(\text{find}(4)=2\)</span> → LCA(4,5)=2</li>
</ul></li>
<li><p>DFS(3), visit 6 → union(6,3)</p>
<ul>
<li>Query(4,6): 4 visited, <span class="math inline">\(\text{find}(4)=2\)</span>, <span class="math inline">\(\text{find}(6)=3\)</span> → no LCA yet</li>
<li>Query(3,6): both visited → <span class="math inline">\(\text{find}(3)=3\)</span> → LCA(3,6)=3</li>
</ul></li>
<li><p>Backtrack 2→1, 3→1 → LCA(4,6)=1</p></li>
</ul>
</section>
<section id="tiny-code-python-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-6">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DSU:</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, x):</span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.parent[x] <span class="op">!=</span> x:</span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parent[x] <span class="op">=</span> <span class="va">self</span>.find(<span class="va">self</span>.parent[x])</span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.parent[x]</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(<span class="va">self</span>, a, b):</span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent[<span class="va">self</span>.find(a)] <span class="op">=</span> <span class="va">self</span>.find(b)</span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tarjan_lca(tree, root, queries):</span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(tree)</span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>    dsu <span class="op">=</span> DSU(n)</span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>    ancestor <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> {}</span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>    qmap <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> queries:</span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a>        qmap[u].append(v)</span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>        qmap[v].append(u)</span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(u):</span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a>        ancestor[u] <span class="op">=</span> u</span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> tree[u]:</span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a>            dfs(v)</span>
<span id="cb141-27"><a href="#cb141-27" aria-hidden="true" tabindex="-1"></a>            dsu.union(v, u)</span>
<span id="cb141-28"><a href="#cb141-28" aria-hidden="true" tabindex="-1"></a>            ancestor[dsu.find(u)] <span class="op">=</span> u</span>
<span id="cb141-29"><a href="#cb141-29" aria-hidden="true" tabindex="-1"></a>        visited[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb141-30"><a href="#cb141-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> qmap[u]:</span>
<span id="cb141-31"><a href="#cb141-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> visited[v]:</span>
<span id="cb141-32"><a href="#cb141-32" aria-hidden="true" tabindex="-1"></a>                ans[(u, v)] <span class="op">=</span> ancestor[dsu.find(v)]</span>
<span id="cb141-33"><a href="#cb141-33" aria-hidden="true" tabindex="-1"></a>    dfs(root)</span>
<span id="cb141-34"><a href="#cb141-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-82" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-82">Why It Matters</h4>
<ul>
<li>Handles many LCA queries efficiently in one traversal</li>
<li>No need for depth or binary lifting table</li>
<li>Ideal for offline batch queries</li>
</ul>
<p>Applications:</p>
<ul>
<li>Tree queries in competitive programming</li>
<li>Offline graph analysis</li>
<li>Dynamic connectivity in rooted structures</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-82" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-82">A Gentle Proof (Why It Works)</h4>
<p>Once a node <span class="math inline">\(u\)</span> is processed:</p>
<ul>
<li>All its descendants are merged into its DSU set.</li>
<li><span class="math inline">\(\text{find}(u)\)</span> always returns the lowest ancestor processed so far.</li>
</ul>
<p>When visiting query <span class="math inline">\((u,v)\)</span>:</p>
<ul>
<li>If <span class="math inline">\(v\)</span> is already visited, then <span class="math inline">\(\text{find}(v)\)</span> is the lowest common ancestor of <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>.</li>
</ul>
<p>The invariant: <span class="math display">\[
\text{ancestor}[\text{find}(v)] = \text{LCA}(u, v)
\]</span> is maintained by post-order traversal and union operations.</p>
</section>
<section id="try-it-yourself-82" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-82">Try It Yourself</h4>
<ol type="1">
<li>Draw a small tree and list all queries.</li>
<li>Perform DFS manually.</li>
<li>Track unions and ancestor updates.</li>
<li>Record LCA when both nodes visited.</li>
</ol>
</section>
<section id="test-cases-82" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-82">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query</th>
<th>Expected</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(4,5)</td>
<td>2</td>
<td>same subtree</td>
</tr>
<tr class="even">
<td>(4,6)</td>
<td>1</td>
<td>across subtrees</td>
</tr>
<tr class="odd">
<td>(3,6)</td>
<td>3</td>
<td>ancestor</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-82" class="level4">
<h4 class="anchored" data-anchor-id="complexity-82">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n + q \alpha(n))\)</span></li>
<li>Space: <span class="math inline">\(O(n + q)\)</span></li>
</ul>
<p>Efficient for batch queries; each union and find is nearly constant-time.</p>
<p>Tarjan’s LCA transforms the problem into a union-find dance, answering all ancestor questions in a single elegant DFS sweep.</p>
</section>
</section>
<section id="heavy-light-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="heavy-light-decomposition">384 Heavy-Light Decomposition</h3>
<p>Heavy-Light Decomposition (HLD) splits a tree into heavy paths and light edges so that any path between two nodes can be broken into <span class="math inline">\(O(\log n)\)</span> segments. It’s the backbone for path queries, sum, max, min, or updates, using segment trees or Fenwick trees.</p>
<section id="what-problem-are-we-solving-83" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-83">What Problem Are We Solving?</h4>
<p>In many problems, we need to answer queries like:</p>
<ul>
<li>What’s the sum or max on the path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>?</li>
<li>How to update values along a path?</li>
<li>What’s the minimum edge weight between two nodes?</li>
</ul>
<p>Naively, walking the path is <span class="math inline">\(O(n)\)</span> per query. With HLD, we decompose paths into few contiguous segments, reducing queries to <span class="math inline">\(O(\log^2 n)\)</span> (or better with LCA precomputation).</p>
</section>
<section id="how-it-works-plain-language-18" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-18">How It Works (Plain Language)</h4>
<p>Every node chooses one heavy child (the one with largest subtree). All other edges are light. This guarantees:</p>
<ul>
<li>Each node is part of exactly one heavy path.</li>
<li>Every root-to-leaf path crosses <span class="math inline">\(O(\log n)\)</span> light edges.</li>
</ul>
<p>So we can represent each heavy path as a contiguous segment in an array, and map tree queries → array range queries.</p>
<section id="steps" class="level5">
<h5 class="anchored" data-anchor-id="steps">Steps</h5>
<ol type="1">
<li><p>DFS 1:</p>
<ul>
<li>Compute subtree size for each node.</li>
<li>Mark heavy child = largest subtree child.</li>
</ul></li>
<li><p>DFS 2:</p>
<ul>
<li>Assign head of heavy path.</li>
<li>Map each node to a position in linear order.</li>
</ul></li>
<li><p>Path Query (u, v):</p>
<ul>
<li><p>While <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are not in same heavy path:</p>
<ul>
<li>Always move the deeper head upward.</li>
<li>Query segment tree on that segment.</li>
<li>Jump <span class="math inline">\(u\)</span> to parent of its head.</li>
</ul></li>
<li><p>When in same path: query segment from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> (in order).</p></li>
</ul></li>
</ol>
</section>
</section>
<section id="example-21" class="level4">
<h4 class="anchored" data-anchor-id="example-21">Example</h4>
<p>Tree:</p>
<pre><code>1
├── 2
│   ├── 4
│   └── 5
└── 3
    ├── 6
    └── 7</code></pre>
<ul>
<li><p>Subtree sizes: <span class="math inline">\(size(2)=3,; size(3)=3\)</span> Heavy edges: <span class="math inline">\((1,2)\)</span>, <span class="math inline">\((2,4)\)</span>, <span class="math inline">\((3,6)\)</span></p></li>
<li><p>Heavy paths: Path 1: 1 → 2 → 4 Path 2: 3 → 6 Light edges: <span class="math inline">\((1,3), (2,5), (3,7)\)</span></p></li>
</ul>
<p>Any query path <span class="math inline">\((4,7)\)</span> crosses at most <span class="math inline">\(\log n\)</span> segments:</p>
<pre><code>4→2→1 | 1→3 | 3→7</code></pre>
</section>
<section id="tiny-code-python-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-7">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs1(u, p, g, size, heavy):</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    size[u] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    max_sub <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>        dfs1(v, u, g, size, heavy)</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>        size[u] <span class="op">+=</span> size[v]</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> size[v] <span class="op">&gt;</span> max_sub:</span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>            max_sub <span class="op">=</span> size[v]</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>            heavy[u] <span class="op">=</span> v</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs2(u, p, g, head, pos, cur_head, order, heavy):</span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>    head[u] <span class="op">=</span> cur_head</span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>    pos[u] <span class="op">=</span> <span class="bu">len</span>(order)</span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a>    order.append(u)</span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> heavy[u] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a>        dfs2(heavy[u], u, g, head, pos, cur_head, order, heavy)</span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> g[u]:</span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p <span class="kw">or</span> v <span class="op">==</span> heavy[u]:</span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true" tabindex="-1"></a>        dfs2(v, u, g, head, pos, v, order, heavy)</span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> query_path(u, v, head, pos, depth, segtree, lca):</span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> head[u] <span class="op">!=</span> head[v]:</span>
<span id="cb144-26"><a href="#cb144-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> depth[head[u]] <span class="op">&lt;</span> depth[head[v]]:</span>
<span id="cb144-27"><a href="#cb144-27" aria-hidden="true" tabindex="-1"></a>            u, v <span class="op">=</span> v, u</span>
<span id="cb144-28"><a href="#cb144-28" aria-hidden="true" tabindex="-1"></a>        res <span class="op">+=</span> segtree.query(pos[head[u]], pos[u])</span>
<span id="cb144-29"><a href="#cb144-29" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> parent[head[u]]</span>
<span id="cb144-30"><a href="#cb144-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth[u] <span class="op">&gt;</span> depth[v]:</span>
<span id="cb144-31"><a href="#cb144-31" aria-hidden="true" tabindex="-1"></a>        u, v <span class="op">=</span> v, u</span>
<span id="cb144-32"><a href="#cb144-32" aria-hidden="true" tabindex="-1"></a>    res <span class="op">+=</span> segtree.query(pos[u], pos[v])</span>
<span id="cb144-33"><a href="#cb144-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-83" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-83">Why It Matters</h4>
<ul>
<li><p>Turns path queries into range queries</p></li>
<li><p>Pairs beautifully with segment trees or Fenwick trees</p></li>
<li><p>Core for:</p>
<ul>
<li>Path sum / max / min</li>
<li>Path updates</li>
<li>Lowest edge weight</li>
<li>Subtree queries (with Euler mapping)</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-83" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-83">A Gentle Proof (Why It Works)</h4>
<p>Every node moves at most <span class="math inline">\(\log n\)</span> times up light edges, since subtree size at least halves each time. Within a heavy path, nodes form contiguous segments, so path queries can be broken into <span class="math inline">\(O(\log n)\)</span> contiguous intervals.</p>
<p>Thus, overall query time is <span class="math inline">\(O(\log^2 n)\)</span> (or <span class="math inline">\(O(\log n)\)</span> with segment tree optimization).</p>
</section>
<section id="try-it-yourself-83" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-83">Try It Yourself</h4>
<ol type="1">
<li>Draw a tree, compute subtree sizes.</li>
<li>Mark heavy edges to largest subtrees.</li>
<li>Assign head nodes and linear indices.</li>
<li>Try a query <span class="math inline">\((u,v)\)</span> → decompose into path segments.</li>
<li>Observe each segment is contiguous in linear order.</li>
</ol>
</section>
<section id="test-cases-83" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-83">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Query</th>
<th>Path</th>
<th>Segments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(4,5)</td>
<td>4→2→5</td>
<td>2</td>
</tr>
<tr class="even">
<td>(4,7)</td>
<td>4→2→1→3→7</td>
<td>3</td>
</tr>
<tr class="odd">
<td>(6,7)</td>
<td>6→3→7</td>
<td>2</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-83" class="level4">
<h4 class="anchored" data-anchor-id="complexity-83">Complexity</h4>
<ul>
<li>Preprocessing: <span class="math inline">\(O(n)\)</span></li>
<li>Query: <span class="math inline">\(O(\log^2 n)\)</span> (or <span class="math inline">\(O(\log n)\)</span> with optimized segment tree)</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Heavy-Light Decomposition bridges tree topology and array queries, enabling logarithmic-time operations on paths.</p>
</section>
</section>
<section id="centroid-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="centroid-decomposition">385 Centroid Decomposition</h3>
<p>Centroid Decomposition is a divide-and-conquer method that recursively breaks a tree into smaller parts using centroids, nodes that balance the tree when removed. It transforms tree problems into logarithmic-depth recursion, enabling fast queries, updates, and path counting.</p>
<section id="what-problem-are-we-solving-84" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-84">What Problem Are We Solving?</h4>
<p>For certain tree problems (distance queries, path sums, subtree coverage, etc.), we need to repeatedly split the tree into manageable pieces.</p>
<p>A centroid of a tree is a node such that, if removed, no resulting component has more than <span class="math inline">\(n/2\)</span> nodes.</p>
<p>By recursively decomposing the tree using centroids, we build a centroid tree, a hierarchical structure capturing the balance of the original tree.</p>
</section>
<section id="how-it-works-plain-language-19" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-19">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Find the centroid:</p>
<ul>
<li>Compute subtree sizes.</li>
<li>Pick the node whose largest child subtree ≤ <span class="math inline">\(n/2\)</span>.</li>
</ul></li>
<li><p>Record it as the root of this level’s decomposition.</p></li>
<li><p>Remove the centroid from the tree.</p></li>
<li><p>Recurse on each remaining component (subtree).</p></li>
</ol>
<p>Each node appears in <span class="math inline">\(O(\log n)\)</span> levels, so queries or updates using this structure become logarithmic.</p>
</section>
<section id="example-22" class="level4">
<h4 class="anchored" data-anchor-id="example-22">Example</h4>
<p>Tree (7 nodes):</p>
<pre><code>      1
    / | \
   2  3  4
  / \
 5   6
      \
       7</code></pre>
<p>Step 1: <span class="math inline">\(n=7\)</span>. Subtree sizes → pick 2 (its largest child subtree ≤ 4). Centroid = 2.</p>
<p>Step 2: Remove 2 → split into components:</p>
<ul>
<li>{5}, {6,7}, {1,3,4}</li>
</ul>
<p>Step 3: Recursively find centroids in each component.</p>
<ul>
<li>{6,7} → centroid = 6</li>
<li>{1,3,4} → centroid = 1</li>
</ul>
<p>Centroid tree hierarchy:</p>
<pre><code>     2
   / | \
  5  6  1
       \
        3</code></pre>
</section>
<section id="tiny-code-python-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-8">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_centroid_tree(graph):</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    removed <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs_size(u, p):</span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>        size[u] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="op">==</span> p <span class="kw">or</span> removed[v]:</span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>            dfs_size(v, u)</span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a>            size[u] <span class="op">+=</span> size[v]</span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_centroid(u, p, n):</span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="op">!=</span> p <span class="kw">and</span> <span class="kw">not</span> removed[v] <span class="kw">and</span> size[v] <span class="op">&gt;</span> n <span class="op">//</span> <span class="dv">2</span>:</span>
<span id="cb147-18"><a href="#cb147-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> find_centroid(v, u, n)</span>
<span id="cb147-19"><a href="#cb147-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u</span>
<span id="cb147-20"><a href="#cb147-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-21"><a href="#cb147-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> decompose(u, p):</span>
<span id="cb147-22"><a href="#cb147-22" aria-hidden="true" tabindex="-1"></a>        dfs_size(u, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb147-23"><a href="#cb147-23" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> find_centroid(u, <span class="op">-</span><span class="dv">1</span>, size[u])</span>
<span id="cb147-24"><a href="#cb147-24" aria-hidden="true" tabindex="-1"></a>        removed[c] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb147-25"><a href="#cb147-25" aria-hidden="true" tabindex="-1"></a>        parent[c] <span class="op">=</span> p</span>
<span id="cb147-26"><a href="#cb147-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[c]:</span>
<span id="cb147-27"><a href="#cb147-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> removed[v]:</span>
<span id="cb147-28"><a href="#cb147-28" aria-hidden="true" tabindex="-1"></a>                decompose(v, c)</span>
<span id="cb147-29"><a href="#cb147-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> c</span>
<span id="cb147-30"><a href="#cb147-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-31"><a href="#cb147-31" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> decompose(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb147-32"><a href="#cb147-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parent  <span class="co"># parent[c] is centroid parent</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-84" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-84">Why It Matters</h4>
<p>Centroid decomposition allows efficient solutions to many tree problems:</p>
<ul>
<li>Path queries: distance sums, min/max weights</li>
<li>Point updates: affect only <span class="math inline">\(O(\log n)\)</span> centroids</li>
<li>Distance-based search: find nearest node of a type</li>
<li>Divide-and-conquer DP on trees</li>
</ul>
<p>It’s especially powerful in competitive programming for problems like <em>count pairs within distance k</em>, <em>color-based queries</em>, or <em>centroid tree construction</em>.</p>
</section>
<section id="a-gentle-proof-why-it-works-84" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-84">A Gentle Proof (Why It Works)</h4>
<p>Every decomposition step removes one centroid. By definition, each remaining subtree ≤ <span class="math inline">\(n/2\)</span>. Thus, recursion depth is <span class="math inline">\(O(\log n)\)</span>, and every node participates in at most <span class="math inline">\(O(\log n)\)</span> subproblems.</p>
<p>Total complexity: <span class="math display">\[
T(n) = T(n_1) + T(n_2) + \cdots + O(n) \le O(n \log n)
\]</span></p>
</section>
<section id="try-it-yourself-84" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-84">Try It Yourself</h4>
<ol type="1">
<li>Draw a small tree.</li>
<li>Compute subtree sizes.</li>
<li>Pick centroid (largest child ≤ <span class="math inline">\(n/2\)</span>).</li>
<li>Remove and recurse.</li>
<li>Build centroid tree hierarchy.</li>
</ol>
</section>
<section id="test-cases-84" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-84">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree</th>
<th>Centroid</th>
<th>Components</th>
<th>Depth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line (1–2–3–4–5)</td>
<td>3</td>
<td>{1,2}, {4,5}</td>
<td>2</td>
</tr>
<tr class="even">
<td>Star (1 center)</td>
<td>1</td>
<td>leaves</td>
<td>1</td>
</tr>
<tr class="odd">
<td>Balanced tree (7 nodes)</td>
<td>2</td>
<td>3 components</td>
<td>2</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-84" class="level4">
<h4 class="anchored" data-anchor-id="complexity-84">Complexity</h4>
<ul>
<li>Preprocessing: <span class="math inline">\(O(n \log n)\)</span></li>
<li>Query/Update (per node): <span class="math inline">\(O(\log n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Centroid Decomposition turns trees into balanced recursive hierarchies, a universal tool for logarithmic-time query and update systems.</p>
</section>
</section>
<section id="tree-diameter-dfs-twice" class="level3">
<h3 class="anchored" data-anchor-id="tree-diameter-dfs-twice">386 Tree Diameter (DFS Twice)</h3>
<p>The tree diameter is the longest path between any two nodes in a tree. A simple and elegant method to find it is to perform two DFS traversals, one to find the farthest node, and another to measure the longest path length.</p>
<section id="what-problem-are-we-solving-85" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-85">What Problem Are We Solving?</h4>
<p>In a tree (an acyclic connected graph), we want to find the diameter, defined as:</p>
<p><span class="math display">\[
\text{diameter} = \max_{u,v \in V} \text{dist}(u, v)
\]</span></p>
<p>where <span class="math inline">\(\text{dist}(u,v)\)</span> is the length (in edges or weights) of the shortest path between <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>.</p>
<p>This path always lies between two leaf nodes, and can be found using two DFS/BFS traversals.</p>
</section>
<section id="how-it-works-plain-language-20" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-20">How It Works (Plain Language)</h4>
<ol type="1">
<li>Pick any node (say 1).</li>
<li>Run DFS to find the farthest node from it → call it <span class="math inline">\(A\)</span>.</li>
<li>Run DFS again from <span class="math inline">\(A\)</span> → find the farthest node from <span class="math inline">\(A\)</span> → call it <span class="math inline">\(B\)</span>.</li>
<li>The distance between <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is the diameter length.</li>
</ol>
<p>Why this works:</p>
<ul>
<li>The first DFS ensures you start one end of the diameter.</li>
<li>The second DFS stretches to the opposite end.</li>
</ul>
</section>
<section id="example-23" class="level4">
<h4 class="anchored" data-anchor-id="example-23">Example</h4>
<p>Tree:</p>
<pre><code>1
├── 2
│   └── 4
└── 3
    ├── 5
    └── 6</code></pre>
<ol type="1">
<li>DFS(1): farthest node = 4 (distance 2)</li>
<li>DFS(4): farthest node = 6 (distance 4)</li>
</ol>
<p>So diameter = 4 → path: <span class="math inline">\(4 \to 2 \to 1 \to 3 \to 6\)</span></p>
</section>
<section id="tiny-code-python-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-9">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p, dist, graph):</span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>    farthest <span class="op">=</span> (u, dist)</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v, w <span class="kw">in</span> graph[u]:</span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p:</span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>        cand <span class="op">=</span> dfs(v, u, dist <span class="op">+</span> w, graph)</span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cand[<span class="dv">1</span>] <span class="op">&gt;</span> farthest[<span class="dv">1</span>]:</span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>            farthest <span class="op">=</span> cand</span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> farthest</span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tree_diameter(graph):</span>
<span id="cb149-14"><a href="#cb149-14" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb149-15"><a href="#cb149-15" aria-hidden="true" tabindex="-1"></a>    a, _ <span class="op">=</span> dfs(start, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, graph)</span>
<span id="cb149-16"><a href="#cb149-16" aria-hidden="true" tabindex="-1"></a>    b, diameter <span class="op">=</span> dfs(a, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, graph)</span>
<span id="cb149-17"><a href="#cb149-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> diameter, (a, b)</span>
<span id="cb149-18"><a href="#cb149-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-19"><a href="#cb149-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Example:</span></span>
<span id="cb149-20"><a href="#cb149-20" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb149-21"><a href="#cb149-21" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">1</span>)]</span>
<span id="cb149-22"><a href="#cb149-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v,w <span class="kw">in</span> edges:</span>
<span id="cb149-23"><a href="#cb149-23" aria-hidden="true" tabindex="-1"></a>    graph[u].append((v,w))</span>
<span id="cb149-24"><a href="#cb149-24" aria-hidden="true" tabindex="-1"></a>    graph[v].append((u,w))</span>
<span id="cb149-25"><a href="#cb149-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-26"><a href="#cb149-26" aria-hidden="true" tabindex="-1"></a>d, (a,b) <span class="op">=</span> tree_diameter(graph)</span>
<span id="cb149-27"><a href="#cb149-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(d, (a,b))  <span class="co"># 4, path (3,5)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-85" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-85">Why It Matters</h4>
<ul>
<li><p>Simple and linear time: <span class="math inline">\(O(n)\)</span></p></li>
<li><p>Works for weighted and unweighted trees</p></li>
<li><p>Core for:</p>
<ul>
<li>Tree center finding</li>
<li>Dynamic programming on trees</li>
<li>Network analysis (longest delay, max latency path)</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-85" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-85">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\((u, v)\)</span> be the true diameter endpoints. Any DFS from any node <span class="math inline">\(x\)</span> finds a farthest node <span class="math inline">\(A\)</span>. By triangle inequality on trees, <span class="math inline">\(A\)</span> must be one endpoint of a diameter path. A second DFS from <span class="math inline">\(A\)</span> finds the other endpoint <span class="math inline">\(B\)</span>, ensuring <span class="math inline">\(\text{dist}(A,B)\)</span> is the maximum possible.</p>
</section>
<section id="try-it-yourself-85" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-85">Try It Yourself</h4>
<ol type="1">
<li>Draw a small tree.</li>
<li>Pick any starting node, run DFS to find farthest.</li>
<li>From that node, run DFS again.</li>
<li>Trace the path between these two nodes, it’s always the longest.</li>
</ol>
</section>
<section id="test-cases-85" class="level4">
<h4 class="anchored" data-anchor-id="test-cases-85">Test Cases</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Tree Type</th>
<th>Diameter</th>
<th>Path</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Line (1–2–3–4)</td>
<td>3</td>
<td>(1,4)</td>
</tr>
<tr class="even">
<td>Star (1 center + leaves)</td>
<td>2</td>
<td>(leaf₁, leaf₂)</td>
</tr>
<tr class="odd">
<td>Balanced binary</td>
<td>4</td>
<td>leftmost to rightmost leaf</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-85" class="level4">
<h4 class="anchored" data-anchor-id="complexity-85">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span> recursion stack</li>
</ul>
<p>Tree Diameter via two DFS is one of the cleanest tricks in graph theory, from any point, go far, then farther.</p>
</section>
</section>
<section id="tree-dp-subtree-based-optimization" class="level3">
<h3 class="anchored" data-anchor-id="tree-dp-subtree-based-optimization">387 Tree DP (Subtree-Based Optimization)</h3>
<p>Tree Dynamic Programming (Tree DP) is a technique that solves problems on trees by combining results from subtrees. Each node’s result depends on its children, following a recursive pattern much like divide and conquer but on a tree.</p>
<section id="what-problem-are-we-solving-86" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-86">What Problem Are We Solving?</h4>
<p>Many problems on trees ask for optimal values (sum, min, max, count) that depend on child subtrees, for example:</p>
<ul>
<li>Maximum path sum in a tree</li>
<li>Size of largest independent set</li>
<li>Number of ways to color a tree</li>
<li>Sum of distances to all nodes</li>
</ul>
<p>Tree DP provides a bottom-up approach where we compute results for each subtree and merge them upwards.</p>
</section>
<section id="how-it-works-plain-language-21" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-21">How It Works (Plain Language)</h4>
<ol type="1">
<li>Root the tree at an arbitrary node (often 1 or 0).</li>
<li>Define a DP state at each node based on its subtree.</li>
<li>Combine children’s results recursively.</li>
<li>Return the result to the parent.</li>
</ol>
<p>Example state: <span class="math display">\[
dp[u] = f(dp[v_1], dp[v_2], \dots, dp[v_k])
\]</span> where <span class="math inline">\(v_i\)</span> are children of <span class="math inline">\(u\)</span>.</p>
</section>
<section id="example-problem" class="level4">
<h4 class="anchored" data-anchor-id="example-problem">Example Problem</h4>
<p>Find the size of the largest independent set (no two adjacent nodes chosen).</p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[u][0] = \sum_{v \in children(u)} \max(dp[v][0], dp[v][1])
\]</span></p>
<p><span class="math display">\[
dp[u][1] = 1 + \sum_{v \in children(u)} dp[v][0]
\]</span></p>
</section>
<section id="tiny-code-python-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-10">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">4</span>)]</span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>    graph[u].append(v)</span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>    graph[v].append(u)</span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>    incl <span class="op">=</span> <span class="dv">1</span>  <span class="co"># include u</span></span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>    excl <span class="op">=</span> <span class="dv">0</span>  <span class="co"># exclude u</span></span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p:</span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb150-15"><a href="#cb150-15" aria-hidden="true" tabindex="-1"></a>        inc_v, exc_v <span class="op">=</span> dfs(v, u)</span>
<span id="cb150-16"><a href="#cb150-16" aria-hidden="true" tabindex="-1"></a>        incl <span class="op">+=</span> exc_v</span>
<span id="cb150-17"><a href="#cb150-17" aria-hidden="true" tabindex="-1"></a>        excl <span class="op">+=</span> <span class="bu">max</span>(inc_v, exc_v)</span>
<span id="cb150-18"><a href="#cb150-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> incl, excl</span>
<span id="cb150-19"><a href="#cb150-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-20"><a href="#cb150-20" aria-hidden="true" tabindex="-1"></a>incl, excl <span class="op">=</span> dfs(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb150-21"><a href="#cb150-21" aria-hidden="true" tabindex="-1"></a>ans <span class="op">=</span> <span class="bu">max</span>(incl, excl)</span>
<span id="cb150-22"><a href="#cb150-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ans)  <span class="co"># 3</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This finds the largest independent set size (3 nodes).</p>
</section>
<section id="why-it-matters-86" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-86">Why It Matters</h4>
<p>Tree DP is foundational for:</p>
<ul>
<li>Counting: number of ways to assign labels, colors, or states</li>
<li>Optimization: maximize or minimize cost over paths or sets</li>
<li>Combinatorics: solve partition or constraint problems</li>
<li>Game theory: compute win/loss states recursively</li>
</ul>
<p>It turns global tree problems into local merges.</p>
</section>
<section id="a-gentle-proof-why-it-works-86" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-86">A Gentle Proof (Why It Works)</h4>
<p>Each node’s subtree is independent once you know whether its parent is included or not. By processing children before parents (post-order DFS), we ensure all necessary data is ready when merging. This guarantees correctness via structural induction on tree size.</p>
</section>
<section id="try-it-yourself-86" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-86">Try It Yourself</h4>
<ol type="1">
<li>Define a simple property (sum, count, max).</li>
<li>Write recurrence for a node in terms of its children.</li>
<li>Traverse via DFS, merge children’s results.</li>
<li>Return value to parent, combine at root.</li>
</ol>
</section>
<section id="template-generic" class="level4">
<h4 class="anchored" data-anchor-id="template-generic">Template (Generic)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs(u, p):</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> base_case()</span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> children(u):</span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">!=</span> p:</span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>            child <span class="op">=</span> dfs(v, u)</span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>            res <span class="op">=</span> merge(res, child)</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> finalize(res)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="complexity-86" class="level4">
<h4 class="anchored" data-anchor-id="complexity-86">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span></li>
<li>Space: <span class="math inline">\(O(n)\)</span> (recursion)</li>
</ul>
<p>Tree DP transforms recursive thinking into structured computation, one subtree at a time, building the answer from the leaves to the root.</p>
</section>
</section>
<section id="rerooting-dp-compute-all-roots-answers" class="level3">
<h3 class="anchored" data-anchor-id="rerooting-dp-compute-all-roots-answers">388 Rerooting DP (Compute All Roots’ Answers)</h3>
<p>Rerooting DP is an advanced tree dynamic programming technique that computes answers for every possible root efficiently. Instead of recomputing from scratch, we reuse results by propagating information down and up the tree.</p>
<section id="what-problem-are-we-solving-87" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-87">What Problem Are We Solving?</h4>
<p>Suppose we want the same value for every node as if that node were the root. Examples:</p>
<ul>
<li>Sum of distances from each node to all others</li>
<li>Number of nodes in each subtree</li>
<li>DP value that depends on subtree structure</li>
</ul>
<p>A naive approach runs <span class="math inline">\(O(n)\)</span> DP per root → <span class="math inline">\(O(n^2)\)</span> total. Rerooting reduces this to <span class="math inline">\(O(n)\)</span> total.</p>
</section>
<section id="how-it-works-plain-language-22" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-22">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>First pass (downward DP): Compute answers for each subtree assuming root = 0.</p></li>
<li><p>Second pass (rerooting): Use parent’s info to update child’s answer — effectively “rerooting” the DP at each node.</p></li>
</ol>
<p>The key is combining results from children excluding the child itself, often using prefix–suffix merges.</p>
</section>
<section id="example-problem-1" class="level4">
<h4 class="anchored" data-anchor-id="example-problem-1">Example Problem</h4>
<p>Compute sum of distances from each node to all others.</p>
<p>Recurrence:</p>
<ul>
<li><code>subtree_size[u]</code> = number of nodes in subtree of <code>u</code></li>
<li><code>dp[u]</code> = sum of distances from <code>u</code> to nodes in its subtree</li>
</ul>
<p>First pass: <span class="math display">\[
dp[u] = \sum_{v \in children(u)} (dp[v] + subtree_size[v])
\]</span></p>
<p>Second pass: When moving root from <code>u</code> to <code>v</code>: <span class="math display">\[
dp[v] = dp[u] - subtree_size[v] + (n - subtree_size[v])
\]</span></p>
</section>
<section id="tiny-code-python-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-11">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb152"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">4</span>)]</span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u,v <span class="kw">in</span> edges:</span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>    graph[u].append(v)</span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>    graph[v].append(u)</span>
<span id="cb152-8"><a href="#cb152-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-9"><a href="#cb152-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb152-10"><a href="#cb152-10" aria-hidden="true" tabindex="-1"></a>size <span class="op">=</span> [<span class="dv">1</span>]<span class="op">*</span>n</span>
<span id="cb152-11"><a href="#cb152-11" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb152-12"><a href="#cb152-12" aria-hidden="true" tabindex="-1"></a>ans <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb152-13"><a href="#cb152-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-14"><a href="#cb152-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs1(u, p):</span>
<span id="cb152-15"><a href="#cb152-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb152-16"><a href="#cb152-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb152-17"><a href="#cb152-17" aria-hidden="true" tabindex="-1"></a>        dfs1(v, u)</span>
<span id="cb152-18"><a href="#cb152-18" aria-hidden="true" tabindex="-1"></a>        size[u] <span class="op">+=</span> size[v]</span>
<span id="cb152-19"><a href="#cb152-19" aria-hidden="true" tabindex="-1"></a>        dp[u] <span class="op">+=</span> dp[v] <span class="op">+</span> size[v]</span>
<span id="cb152-20"><a href="#cb152-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-21"><a href="#cb152-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dfs2(u, p):</span>
<span id="cb152-22"><a href="#cb152-22" aria-hidden="true" tabindex="-1"></a>    ans[u] <span class="op">=</span> dp[u]</span>
<span id="cb152-23"><a href="#cb152-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb152-24"><a href="#cb152-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> p: <span class="cf">continue</span></span>
<span id="cb152-25"><a href="#cb152-25" aria-hidden="true" tabindex="-1"></a>        pu, pv <span class="op">=</span> dp[u], dp[v]</span>
<span id="cb152-26"><a href="#cb152-26" aria-hidden="true" tabindex="-1"></a>        su, sv <span class="op">=</span> size[u], size[v]</span>
<span id="cb152-27"><a href="#cb152-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-28"><a href="#cb152-28" aria-hidden="true" tabindex="-1"></a>        dp[u] <span class="op">-=</span> dp[v] <span class="op">+</span> size[v]</span>
<span id="cb152-29"><a href="#cb152-29" aria-hidden="true" tabindex="-1"></a>        size[u] <span class="op">-=</span> size[v]</span>
<span id="cb152-30"><a href="#cb152-30" aria-hidden="true" tabindex="-1"></a>        dp[v] <span class="op">+=</span> dp[u] <span class="op">+</span> size[u]</span>
<span id="cb152-31"><a href="#cb152-31" aria-hidden="true" tabindex="-1"></a>        size[v] <span class="op">+=</span> size[u]</span>
<span id="cb152-32"><a href="#cb152-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-33"><a href="#cb152-33" aria-hidden="true" tabindex="-1"></a>        dfs2(v, u)</span>
<span id="cb152-34"><a href="#cb152-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-35"><a href="#cb152-35" aria-hidden="true" tabindex="-1"></a>        dp[u], dp[v] <span class="op">=</span> pu, pv</span>
<span id="cb152-36"><a href="#cb152-36" aria-hidden="true" tabindex="-1"></a>        size[u], size[v] <span class="op">=</span> su, sv</span>
<span id="cb152-37"><a href="#cb152-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-38"><a href="#cb152-38" aria-hidden="true" tabindex="-1"></a>dfs1(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb152-39"><a href="#cb152-39" aria-hidden="true" tabindex="-1"></a>dfs2(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb152-40"><a href="#cb152-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-41"><a href="#cb152-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ans)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This computes the sum of distances for each node.</p>
</section>
<section id="why-it-matters-87" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-87">Why It Matters</h4>
<ul>
<li>Efficiently derive all-root answers</li>
<li>Common in centroid problems, sum of distances, rerooting sums</li>
<li>Reduces redundant recomputation dramatically</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-87" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-87">A Gentle Proof (Why It Works)</h4>
<p>Every DP depends only on local merges of subtrees. By removing a child subtree and adding the rest, we adjust the parent’s value to reflect a new root. Induction over tree structure ensures correctness.</p>
</section>
<section id="try-it-yourself-87" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-87">Try It Yourself</h4>
<ol type="1">
<li>Write your DP recurrence for a single root.</li>
<li>Identify what changes when rerooting to a child.</li>
<li>Apply push–pull updates using stored subtree info.</li>
<li>Collect final answers after traversal.</li>
</ol>
</section>
<section id="complexity-87" class="level4">
<h4 class="anchored" data-anchor-id="complexity-87">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(n)\)</span> (two DFS passes)</li>
<li>Space: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Rerooting DP turns a global rerooting problem into a pair of local transformations, computing every node’s perspective with elegant reuse.</p>
</section>
</section>
<section id="binary-search-on-tree-edge-weight-constraints" class="level3">
<h3 class="anchored" data-anchor-id="binary-search-on-tree-edge-weight-constraints">389 Binary Search on Tree (Edge Weight Constraints)</h3>
<p>Binary Search on Tree is a versatile strategy used to solve problems where we must find a threshold edge weight or path condition that satisfies a constraint. It combines DFS or BFS traversal with binary search over a numeric property, often edge weights or limits.</p>
<section id="what-problem-are-we-solving-88" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-88">What Problem Are We Solving?</h4>
<p>Given a tree with weighted edges, we might want to answer questions like:</p>
<ul>
<li>What is the minimum edge weight so that the path between two nodes satisfies some property?</li>
<li>What is the maximum allowed cost under which the tree remains connected?</li>
<li>What is the smallest threshold that allows at least <span class="math inline">\(k\)</span> nodes to be reachable?</li>
</ul>
<p>A naive approach checks each possible weight. We can do better by binary searching over sorted edge weights.</p>
</section>
<section id="how-it-works-plain-language-23" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-23">How It Works (Plain Language)</h4>
<ol type="1">
<li>Sort the edge weights or define a numeric search range.</li>
<li>Binary search over possible threshold <span class="math inline">\(T\)</span>.</li>
<li>For each mid value, traverse the tree (via DFS/BFS/Union-Find) including only edges satisfying a condition (e.g., weight ≤ T).</li>
<li>Check if the property holds.</li>
<li>Narrow the search interval.</li>
</ol>
<p>The key is monotonicity: if a property holds for <span class="math inline">\(T\)</span>, it holds for all larger/smaller values.</p>
</section>
<section id="example-problem-2" class="level4">
<h4 class="anchored" data-anchor-id="example-problem-2">Example Problem</h4>
<p>Find the minimum edge weight threshold <span class="math inline">\(T\)</span> so that all nodes become connected.</p>
<p>Algorithm:</p>
<ol type="1">
<li>Sort edges by weight.</li>
<li>Binary search <span class="math inline">\(T\)</span> in <span class="math inline">\([min_weight, max_weight]\)</span>.</li>
<li>For each <span class="math inline">\(T\)</span>, include edges with <span class="math inline">\(w \le T\)</span>.</li>
<li>Check if resulting graph is connected.</li>
<li>Adjust bounds accordingly.</li>
</ol>
</section>
<section id="tiny-code-python-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-12">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_connected(n, edges, limit):</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(x):</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parent[x] <span class="op">!=</span> x:</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>            parent[x] <span class="op">=</span> find(parent[x])</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> parent[x]</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(a, b):</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>        pa, pb <span class="op">=</span> find(a), find(b)</span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pa <span class="op">!=</span> pb:</span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a>            parent[pb] <span class="op">=</span> pa</span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v, w <span class="kw">in</span> edges:</span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> w <span class="op">&lt;=</span> limit:</span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a>            union(u, v)</span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>({find(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)}) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb153-16"><a href="#cb153-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-17"><a href="#cb153-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binary_search_tree_threshold(n, edges):</span>
<span id="cb153-18"><a href="#cb153-18" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">set</span>(w <span class="cf">for</span> _,_,w <span class="kw">in</span> edges))</span>
<span id="cb153-19"><a href="#cb153-19" aria-hidden="true" tabindex="-1"></a>    lo, hi <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(weights)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb153-20"><a href="#cb153-20" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> weights[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb153-21"><a href="#cb153-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> lo <span class="op">&lt;=</span> hi:</span>
<span id="cb153-22"><a href="#cb153-22" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> (lo <span class="op">+</span> hi) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb153-23"><a href="#cb153-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_connected(n, edges, weights[mid]):</span>
<span id="cb153-24"><a href="#cb153-24" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">=</span> weights[mid]</span>
<span id="cb153-25"><a href="#cb153-25" aria-hidden="true" tabindex="-1"></a>            hi <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb153-26"><a href="#cb153-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb153-27"><a href="#cb153-27" aria-hidden="true" tabindex="-1"></a>            lo <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb153-28"><a href="#cb153-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans</span>
<span id="cb153-29"><a href="#cb153-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-30"><a href="#cb153-30" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>),(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">5</span>)]</span>
<span id="cb153-31"><a href="#cb153-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(binary_search_tree_threshold(<span class="dv">3</span>, edges))  <span class="co"># Output: 4</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-88" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-88">Why It Matters</h4>
<ul>
<li>Reduces complex “threshold” problems to logarithmic searches</li>
<li>Works when solution space is monotonic</li>
<li>Combines structural traversal with decision logic</li>
</ul>
<p>Common applications:</p>
<ul>
<li>Path feasibility with limit</li>
<li>Edge filtering by cost</li>
<li>Tree queries with weight bounds</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-88" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-88">A Gentle Proof (Why It Works)</h4>
<p>Let property <span class="math inline">\(P(T)\)</span> be true if condition holds for threshold <span class="math inline">\(T\)</span>. If <span class="math inline">\(P(T)\)</span> is monotonic (either always true beyond some point, or always false before), then binary search correctly converges to the minimal/maximal satisfying <span class="math inline">\(T\)</span>.</p>
</section>
<section id="try-it-yourself-88" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-88">Try It Yourself</h4>
<ol type="1">
<li>Define a monotonic property on weights (e.g.&nbsp;“connected under limit”).</li>
<li>Implement a decision function checking <span class="math inline">\(P(T)\)</span>.</li>
<li>Wrap it in a binary search loop.</li>
<li>Return the minimal/maximal valid <span class="math inline">\(T\)</span>.</li>
</ol>
</section>
<section id="complexity-88" class="level4">
<h4 class="anchored" data-anchor-id="complexity-88">Complexity</h4>
<ul>
<li>Sorting edges: <span class="math inline">\(O(E \log E)\)</span></li>
<li>Binary search: <span class="math inline">\(O(\log E)\)</span> checks</li>
<li>Each check: <span class="math inline">\(O(E \alpha(V))\)</span> (Union-Find)</li>
<li>Overall: <span class="math inline">\(O(E \log^2 E)\)</span> or better</li>
</ul>
<p>Binary search on trees is not about searching <em>within</em> the tree, but <em>over constraints</em> defined on the tree, a sharp technique for threshold-based reasoning.</p>
</section>
</section>
<section id="virtual-tree-query-subset-construction" class="level3">
<h3 class="anchored" data-anchor-id="virtual-tree-query-subset-construction">390 Virtual Tree (Query Subset Construction)</h3>
<p>A Virtual Tree is a compressed representation of a tree built from a selected subset of nodes, along with their Lowest Common Ancestors (LCAs), connected in the same hierarchical order as the original tree. It’s used in query problems where we only need to reason about a small subset of nodes rather than the full tree.</p>
<section id="what-problem-are-we-solving-89" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-89">What Problem Are We Solving?</h4>
<p>Suppose we have a large tree and a query gives us a small set <span class="math inline">\(S\)</span> of nodes. We need to compute some property among nodes in <span class="math inline">\(S\)</span> (like sum of distances, coverage, or DP over their paths). Traversing the entire tree each time is inefficient.</p>
<p>A Virtual Tree shrinks the full tree down to just the nodes in <span class="math inline">\(S\)</span> plus their LCAs, keeping ancestry relationships intact.</p>
<p>This reduces the problem to a much smaller tree, often <span class="math inline">\(O(|S|\log |S|)\)</span> nodes instead of <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="how-it-works-plain-language-24" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-24">How It Works (Plain Language)</h4>
<ol type="1">
<li>Collect the query nodes <span class="math inline">\(S\)</span>.</li>
<li>Sort <span class="math inline">\(S\)</span> by Euler Tour order (entry time in DFS).</li>
<li>Insert LCAs of consecutive nodes to maintain structure.</li>
<li>Build edges between consecutive ancestors to form a tree.</li>
<li>Now process queries on this mini-tree instead of the full one.</li>
</ol>
</section>
<section id="example-24" class="level4">
<h4 class="anchored" data-anchor-id="example-24">Example</h4>
<p>Given tree:</p>
<pre><code>       1
     / | \
    2  3  4
      / \
     5   6</code></pre>
<p>Query nodes <span class="math inline">\(S = {2, 5, 6}\)</span>.</p>
<p>Their LCAs:</p>
<ul>
<li><span class="math inline">\(\text{LCA}(5,6)=3\)</span></li>
<li><span class="math inline">\(\text{LCA}(2,3)=1\)</span></li>
</ul>
<p>Virtual Tree Nodes = <span class="math inline">\({1,2,3,5,6}\)</span> Connect them according to parent-child relations: 1 → 2 1 → 3 3 → 5 3 → 6</p>
<p>This is your Virtual Tree.</p>
</section>
<section id="tiny-code-c-style-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-style-pseudocode">Tiny Code (C++ Style Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb155"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> build_virtual_tree<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> S<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> tin<span class="op">,</span> <span class="kw">auto</span> lca<span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>S<span class="op">.</span>begin<span class="op">(),</span> S<span class="op">.</span>end<span class="op">(),</span> <span class="op">[&amp;](</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> tin<span class="op">[</span>a<span class="op">]</span> <span class="op">&lt;</span> tin<span class="op">[</span>b<span class="op">];</span> <span class="op">});</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nodes <span class="op">=</span> S<span class="op">;</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>S<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>        nodes<span class="op">.</span>push_back<span class="op">(</span>lca<span class="op">(</span>S<span class="op">[</span>i<span class="op">],</span> S<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]));</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>nodes<span class="op">.</span>begin<span class="op">(),</span> nodes<span class="op">.</span>end<span class="op">(),</span> <span class="op">[&amp;](</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> tin<span class="op">[</span>a<span class="op">]</span> <span class="op">&lt;</span> tin<span class="op">[</span>b<span class="op">];</span> <span class="op">});</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>    nodes<span class="op">.</span>erase<span class="op">(</span>unique<span class="op">(</span>nodes<span class="op">.</span>begin<span class="op">(),</span> nodes<span class="op">.</span>end<span class="op">()),</span> nodes<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> st<span class="op">;</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> vt_adj<span class="op">(</span>nodes<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">:</span> nodes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(!</span>st<span class="op">.</span>empty<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>is_ancestor<span class="op">(</span>st<span class="op">.</span>top<span class="op">(),</span> u<span class="op">))</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>            st<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>st<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a>            vt_adj<span class="op">[</span>st<span class="op">.</span>top<span class="op">()].</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb155-15"><a href="#cb155-15" aria-hidden="true" tabindex="-1"></a>        st<span class="op">.</span>push<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb155-16"><a href="#cb155-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb155-17"><a href="#cb155-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nodes<span class="op">;</span></span>
<span id="cb155-18"><a href="#cb155-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This builds adjacency for the virtual tree using stack ancestry.</p>
</section>
<section id="why-it-matters-89" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-89">Why It Matters</h4>
<ul>
<li>Reduces large-tree queries to small subproblems</li>
<li>Essential in problems with multiple subset queries</li>
<li>Common in offline processing, rerooting DP, distance sum problems</li>
<li>Works perfectly with LCA precomputation</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-89" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-89">A Gentle Proof (Why It Works)</h4>
<p>Each node in <span class="math inline">\(S\)</span> must connect through its LCAs. By sorting in Euler order and maintaining a stack of ancestors, we ensure that:</p>
<ul>
<li>Parent-child relations are consistent</li>
<li>No cycles or duplicates</li>
<li>The resulting tree preserves ancestry</li>
</ul>
<p>So the virtual tree is a minimal subtree connecting all nodes in <span class="math inline">\(S\)</span>.</p>
</section>
<section id="try-it-yourself-89" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-89">Try It Yourself</h4>
<ol type="1">
<li>Implement Euler Tour (get <code>tin[u]</code>).</li>
<li>Implement LCA (Binary Lifting or RMQ).</li>
<li>Build Virtual Tree for given <span class="math inline">\(S\)</span>.</li>
<li>Apply your query logic (sum, count, DP).</li>
</ol>
</section>
<section id="complexity-89" class="level4">
<h4 class="anchored" data-anchor-id="complexity-89">Complexity</h4>
<ul>
<li>Sorting <span class="math inline">\(S\)</span>: <span class="math inline">\(O(|S|\log|S|)\)</span></li>
<li>LCA calls: <span class="math inline">\(O(|S|)\)</span></li>
<li>Building structure: <span class="math inline">\(O(|S|)\)</span></li>
<li>Overall: <span class="math inline">\(O(|S|\log|S|)\)</span> per query</li>
</ul>
<p>A Virtual Tree is your “query-scaled tree”, a precise projection of the big tree onto the small world of your problem.</p>
</section>
</section>
</section>
<section id="section-40.-advanced-graph-algorithms-and-tricks" class="level2">
<h2 class="anchored" data-anchor-id="section-40.-advanced-graph-algorithms-and-tricks">Section 40. Advanced Graph Algorithms and Tricks</h2>
<section id="topological-dp-dynamic-programming-on-dag" class="level3">
<h3 class="anchored" data-anchor-id="topological-dp-dynamic-programming-on-dag">391 Topological DP (Dynamic Programming on DAG)</h3>
<p>Topological DP is a dynamic programming technique on Directed Acyclic Graphs (DAGs). It computes values in dependency order, ensuring each node’s state is calculated only after all its prerequisites. This method is a core tool for problems involving partial orders, longest paths, counting paths, and propagation across dependencies.</p>
<section id="what-problem-are-we-solving-90" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-90">What Problem Are We Solving?</h4>
<p>In DAGs, some nodes depend on others (edges point from dependencies to dependents). We often want to compute a DP value like:</p>
<ul>
<li>Longest path ending at each node</li>
<li>Number of ways to reach a node</li>
<li>Minimum cost to reach a node</li>
<li>Accumulated value through dependencies</li>
</ul>
<p>Because DAGs have no cycles, a topological order exists, allowing linear-time evaluation.</p>
</section>
<section id="how-it-works-plain-language-25" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-25">How It Works (Plain Language)</h4>
<ol type="1">
<li>Topologically sort the DAG.</li>
<li>Initialize base cases (e.g.&nbsp;sources = 0 or 1).</li>
<li>Iterate in topo order, updating each node based on incoming edges.</li>
<li>Each node’s value is final once processed.</li>
</ol>
<p>This guarantees each dependency is resolved before use.</p>
</section>
<section id="example-longest-path-in-dag" class="level4">
<h4 class="anchored" data-anchor-id="example-longest-path-in-dag">Example: Longest Path in DAG</h4>
<p>Given DAG with edge weights <span class="math inline">\(w(u,v)\)</span>, define DP:</p>
<p><span class="math display">\[
dp[v] = \max_{(u,v)\in E}(dp[u] + w(u,v))
\]</span></p>
<p>Base case: <span class="math inline">\(dp[source] = 0\)</span></p>
</section>
<section id="example-dag" class="level4">
<h4 class="anchored" data-anchor-id="example-dag">Example DAG</h4>
<pre><code>1 → 2 → 4
 ↘︎ 3 ↗︎</code></pre>
<p>Edges:</p>
<ul>
<li>1 → 2 (1)</li>
<li>1 → 3 (2)</li>
<li>2 → 4 (1)</li>
<li>3 → 4 (3)</li>
</ul>
<p>Topological order: [1, 2, 3, 4]</p>
<p>Compute:</p>
<ul>
<li>dp[1] = 0</li>
<li>dp[2] = max(dp[1] + 1) = 1</li>
<li>dp[3] = max(dp[1] + 2) = 2</li>
<li>dp[4] = max(dp[2] + 1, dp[3] + 3) = max(2, 5) = 5</li>
</ul>
<p>Result: Longest path length = 5</p>
</section>
<section id="tiny-code-c-style" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-style">Tiny Code (C++ Style)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb157"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> topo_sort<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> adj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> indeg<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">),</span> topo<span class="op">;</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> u <span class="op">:</span> adj<span class="op">)</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> u<span class="op">)</span> indeg<span class="op">[</span>v<span class="op">]++;</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>    queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> q<span class="op">;</span></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="cf">if</span> <span class="op">(</span>indeg<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> q<span class="op">.</span>push<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>q<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> q<span class="op">.</span>front<span class="op">();</span> q<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>        topo<span class="op">.</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(--</span>indeg<span class="op">[</span>v<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> q<span class="op">.</span>push<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> topo<span class="op">;</span></span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb157-15"><a href="#cb157-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-16"><a href="#cb157-16" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> topo_dp<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;&gt;&gt;&amp;</span> adj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb157-17"><a href="#cb157-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> order <span class="op">=</span> topo_sort<span class="op">(</span>n<span class="op">,</span> <span class="op">...);</span></span>
<span id="cb157-18"><a href="#cb157-18" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> INT_MIN<span class="op">);</span></span>
<span id="cb157-19"><a href="#cb157-19" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb157-20"><a href="#cb157-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">:</span> order<span class="op">)</span></span>
<span id="cb157-21"><a href="#cb157-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">[</span>v<span class="op">,</span> w<span class="op">]</span> <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb157-22"><a href="#cb157-22" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>v<span class="op">],</span> dp<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w<span class="op">);</span></span>
<span id="cb157-23"><a href="#cb157-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">;</span></span>
<span id="cb157-24"><a href="#cb157-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-90" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-90">Why It Matters</h4>
<ul>
<li>Converts recursive dependencies into iterative computation</li>
<li>Avoids redundant work</li>
<li>Enables linear-time solutions for many DAG problems</li>
<li>Works for counting, min/max, aggregation tasks</li>
</ul>
<p>Common uses:</p>
<ul>
<li>Longest path in DAG</li>
<li>Counting number of paths</li>
<li>Minimum cost scheduling</li>
<li>Project dependency planning</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-90" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-90">A Gentle Proof (Why It Works)</h4>
<p>A topological order guarantees:</p>
<ul>
<li>For every edge <span class="math inline">\((u,v)\)</span>, <span class="math inline">\(u\)</span> appears before <span class="math inline">\(v\)</span> Thus when processing <span class="math inline">\(v\)</span>, all <span class="math inline">\(dp[u]\)</span> for predecessors <span class="math inline">\(u\)</span> are ready. This ensures correctness for any DP formula of the form:</li>
</ul>
<p><span class="math display">\[
dp[v] = f({dp[u]\ |\ (u,v)\in E})
\]</span></p>
</section>
<section id="try-it-yourself-90" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-90">Try It Yourself</h4>
<ol type="1">
<li>Compute number of paths from source to each node: <span class="math inline">\(dp[v] = \sum_{(u,v)} dp[u]\)</span></li>
<li>Compute minimum cost if edges have weights</li>
<li>Build a longest chain of tasks with dependencies</li>
<li>Apply topological DP on SCC DAG (meta-graph)</li>
</ol>
</section>
<section id="complexity-90" class="level4">
<h4 class="anchored" data-anchor-id="complexity-90">Complexity</h4>
<ul>
<li>Topo sort: <span class="math inline">\(O(V+E)\)</span></li>
<li>DP propagation: <span class="math inline">\(O(V+E)\)</span></li>
<li>Total: <span class="math inline">\(O(V+E)\)</span> time, <span class="math inline">\(O(V)\)</span> space</li>
</ul>
<p>Topological DP is how you bring order to dependency chaos, one layer, one node, one dependency at a time.</p>
</section>
</section>
<section id="scc-condensed-graph-dp-dynamic-programming-on-meta-graph" class="level3">
<h3 class="anchored" data-anchor-id="scc-condensed-graph-dp-dynamic-programming-on-meta-graph">392 SCC Condensed Graph DP (Dynamic Programming on Meta-Graph)</h3>
<p>SCC Condensed Graph DP applies dynamic programming to the condensation of a directed graph into a Directed Acyclic Graph (DAG), where each node represents a strongly connected component (SCC). This transforms a cyclic graph into an acyclic one, enabling topological reasoning, path aggregation, and value propagation across components.</p>
<section id="what-problem-are-we-solving-91" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-91">What Problem Are We Solving?</h4>
<p>Many problems on directed graphs become complex due to cycles. Within each SCC, every node can reach every other, they are strongly connected. By condensing SCCs into single nodes, we obtain a DAG:</p>
<p><span class="math display">\[
G' = (V', E')
\]</span></p>
<p>where each <span class="math inline">\(v' \in V'\)</span> is an SCC, and edges <span class="math inline">\((u', v')\)</span> represent transitions between components.</p>
<p>Once the graph is acyclic, we can run Topological DP to compute:</p>
<ul>
<li>Maximum or minimum value reaching each SCC</li>
<li>Number of paths between components</li>
<li>Aggregated scores, weights, or costs</li>
</ul>
</section>
<section id="how-it-works-plain-language-26" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-26">How It Works (Plain Language)</h4>
<ol type="1">
<li>Find SCCs (using Tarjan or Kosaraju).</li>
<li>Build Condensed DAG: each SCC becomes a single node.</li>
<li>Aggregate initial values for each SCC (e.g.&nbsp;sum of weights).</li>
<li>Run DP over DAG in topological order, combining contributions from incoming edges.</li>
<li>Map back results to original nodes if needed.</li>
</ol>
<p>This isolates cycles (internal SCCs) and manages dependencies cleanly.</p>
</section>
<section id="example-25" class="level4">
<h4 class="anchored" data-anchor-id="example-25">Example</h4>
<p>Original graph <span class="math inline">\(G\)</span>:</p>
<pre><code>1 → 2 → 3
↑    ↓
5 ← 4</code></pre>
<p>SCCs:</p>
<ul>
<li>C₁ = {1,2,4,5}</li>
<li>C₂ = {3}</li>
</ul>
<p>Condensed graph:</p>
<pre><code>C₁ → C₂</code></pre>
<p>If each node has weight <span class="math inline">\(w[i]\)</span>, then:</p>
<p><span class="math display">\[
dp[C₂] = \max_{(C₁,C₂)}(dp[C₁] + \text{aggregate}(C₁))
\]</span></p>
</section>
<section id="tiny-code-c-style-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-style-1">Tiny Code (C++ Style)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb160"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> comp<span class="op">,</span> order<span class="op">;</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> vis<span class="op">;</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="cf">if</span> <span class="op">(!</span>vis<span class="op">[</span>v<span class="op">])</span> dfs1<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>    order<span class="op">.</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> c<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> radj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a>    comp<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> radj<span class="op">[</span>u<span class="op">])</span> <span class="cf">if</span> <span class="op">(</span>comp<span class="op">[</span>v<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> dfs2<span class="op">(</span>v<span class="op">,</span> c<span class="op">,</span> radj<span class="op">);</span></span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb160-16"><a href="#cb160-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-17"><a href="#cb160-17" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scc_condense<span class="op">()</span> <span class="op">{</span></span>
<span id="cb160-18"><a href="#cb160-18" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> radj<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb160-19"><a href="#cb160-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u<span class="op">=</span><span class="dv">0</span><span class="op">;</span> u<span class="op">&lt;</span>n<span class="op">;</span> <span class="op">++</span>u<span class="op">)</span></span>
<span id="cb160-20"><a href="#cb160-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> radj<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb160-21"><a href="#cb160-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-22"><a href="#cb160-22" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">.</span>assign<span class="op">(</span>n<span class="op">,</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb160-23"><a href="#cb160-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="cf">if</span> <span class="op">(!</span>vis<span class="op">[</span>i<span class="op">])</span> dfs1<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb160-24"><a href="#cb160-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-25"><a href="#cb160-25" aria-hidden="true" tabindex="-1"></a>    comp<span class="op">.</span>assign<span class="op">(</span>n<span class="op">,-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb160-26"><a href="#cb160-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cid<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb160-27"><a href="#cb160-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;--</span>i<span class="op">){</span></span>
<span id="cb160-28"><a href="#cb160-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> order<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb160-29"><a href="#cb160-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>comp<span class="op">[</span>u<span class="op">]==-</span><span class="dv">1</span><span class="op">)</span> dfs2<span class="op">(</span>u<span class="op">,</span>cid<span class="op">++,</span>radj<span class="op">);</span></span>
<span id="cb160-30"><a href="#cb160-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb160-31"><a href="#cb160-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-32"><a href="#cb160-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> comp<span class="op">;</span></span>
<span id="cb160-33"><a href="#cb160-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Then build condensed graph:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb161"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dag<span class="op">(</span>cid<span class="op">);</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u<span class="op">=</span><span class="dv">0</span><span class="op">;</span>u<span class="op">&lt;</span>n<span class="op">;++</span>u<span class="op">)</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v<span class="op">:</span>adj<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>comp<span class="op">[</span>u<span class="op">]!=</span>comp<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>      dag<span class="op">[</span>comp<span class="op">[</span>u<span class="op">]].</span>push_back<span class="op">(</span>comp<span class="op">[</span>v<span class="op">]);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Run Topological DP on <code>dag</code>.</p>
</section>
<section id="why-it-matters-91" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-91">Why It Matters</h4>
<ul>
<li><p>Turns cyclic graphs into acyclic DAGs</p></li>
<li><p>Allows DP, path counting, and aggregation in cyclic contexts</p></li>
<li><p>Simplifies reasoning about reachability and influence</p></li>
<li><p>Forms the basis for:</p>
<ul>
<li>Dynamic condensation</li>
<li>Meta-graph optimization</li>
<li>Modular graph analysis</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-91" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-91">A Gentle Proof (Why It Works)</h4>
<ol type="1">
<li>Within each SCC, all nodes are mutually reachable.</li>
<li>Condensation merges these into single nodes, ensuring no cycles.</li>
<li>Edges between SCCs define a partial order, enabling topological sorting.</li>
<li>Any property defined recursively over dependencies can now be solved via DP on this order.</li>
</ol>
<p>Formally, for each <span class="math inline">\(C_i\)</span>:</p>
<p><span class="math display">\[
dp[C_i] = f({dp[C_j] \mid (C_j, C_i) \in E'}, \text{value}(C_i))
\]</span></p>
</section>
<section id="try-it-yourself-91" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-91">Try It Yourself</h4>
<ol type="1">
<li><p>Assign a weight to each node; compute max sum path over SCC DAG.</p></li>
<li><p>Count distinct paths between SCCs.</p></li>
<li><p>Combine SCC detection + DP for weighted reachability.</p></li>
<li><p>Solve problems like:</p>
<ul>
<li>“Maximum gold in a dungeon with teleport cycles”</li>
<li>“Dependency graph with feedback loops”</li>
</ul></li>
</ol>
</section>
<section id="complexity-91" class="level4">
<h4 class="anchored" data-anchor-id="complexity-91">Complexity</h4>
<ul>
<li>SCC computation: <span class="math inline">\(O(V+E)\)</span></li>
<li>DAG construction: <span class="math inline">\(O(V+E)\)</span></li>
<li>Topo DP: <span class="math inline">\(O(V'+E')\)</span></li>
<li>Total: <span class="math inline">\(O(V+E)\)</span></li>
</ul>
<p>SCC Condensed Graph DP is the art of shrinking cycles into certainty, revealing a clean DAG beneath the tangled surface.</p>
</section>
</section>
<section id="eulerian-path" class="level3">
<h3 class="anchored" data-anchor-id="eulerian-path">393 Eulerian Path</h3>
<p>An Eulerian Path is a trail in a graph that visits every edge exactly once. If the path starts and ends at the same vertex, it is called an Eulerian Circuit. This concept lies at the heart of route planning, graph traversals, and network analysis.</p>
<section id="what-problem-are-we-solving-92" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-92">What Problem Are We Solving?</h4>
<p>We want to find a path that uses every edge once, no repeats, no omissions.</p>
<p>In an undirected graph, an Eulerian Path exists if and only if:</p>
<ul>
<li>Exactly 0 or 2 vertices have odd degree</li>
<li>The graph is connected</li>
</ul>
<p>In a directed graph, it exists if and only if:</p>
<ul>
<li>At most one vertex has <code>outdegree - indegree = 1</code> (start)</li>
<li>At most one vertex has <code>indegree - outdegree = 1</code> (end)</li>
<li>All other vertices have equal in-degree and out-degree</li>
<li>The graph is strongly connected (or connected when ignoring direction)</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-65" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-65">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Check degree conditions (undirected) or in/out-degree balance (directed).</p></li>
<li><p>Choose a start vertex:</p>
<ul>
<li>For undirected: any odd-degree vertex (if exists), otherwise any vertex.</li>
<li>For directed: vertex with <code>outdeg = indeg + 1</code>, else any.</li>
</ul></li>
<li><p>Apply Hierholzer’s algorithm:</p>
<ul>
<li>Walk edges greedily until stuck.</li>
<li>Backtrack and merge cycles into one path.</li>
</ul></li>
<li><p>Reverse the constructed order for the final path.</p></li>
</ol>
</section>
<section id="example-undirected" class="level4">
<h4 class="anchored" data-anchor-id="example-undirected">Example (Undirected)</h4>
<p>Graph edges:</p>
<pre><code>1—2, 2—3, 3—1, 2—4</code></pre>
<p>Degrees:</p>
<ul>
<li>deg(1)=2, deg(2)=3, deg(3)=2, deg(4)=1 Odd vertices: 2, 4 → path exists (starts at 2, ends at 4)</li>
</ul>
<p>Eulerian Path: <code>2 → 1 → 3 → 2 → 4</code></p>
</section>
<section id="example-directed" class="level4">
<h4 class="anchored" data-anchor-id="example-directed">Example (Directed)</h4>
<p>Edges:</p>
<pre><code>A → B, B → C, C → A, C → D</code></pre>
<p>Degrees:</p>
<ul>
<li>A: out=1, in=1</li>
<li>B: out=1, in=1</li>
<li>C: out=2, in=1</li>
<li>D: out=0, in=1</li>
</ul>
<p>Start: C (<code>out=in+1</code>), End: D (<code>in=out+1</code>)</p>
<p>Eulerian Path: <code>C → A → B → C → D</code></p>
</section>
<section id="tiny-code-c" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c">Tiny Code (C++)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb164"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> path<span class="op">;</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>adj<span class="op">[</span>u<span class="op">].</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">].</span>back<span class="op">();</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>u<span class="op">].</span>pop_back<span class="op">();</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    path<span class="op">.</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Run from the start vertex, then reverse <code>path</code>.</p>
</section>
<section id="tiny-code-python-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-13">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eulerian_path(graph, start):</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>    stack, path <span class="op">=</span> [start], []</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stack:</span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> stack[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> graph[u]:</span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> graph[u].pop()</span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>            stack.append(v)</span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>            path.append(stack.pop())</span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-92" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-92">Why It Matters</h4>
<ul>
<li><p>Foundational for graph traversal problems</p></li>
<li><p>Used in:</p>
<ul>
<li>DNA sequencing (De Bruijn graph reconstruction)</li>
<li>Route planning (postal delivery, garbage collection)</li>
<li>Network diagnostics (tracing all connections)</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-92" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-92">A Gentle Proof (Why It Works)</h4>
<p>Each edge must appear exactly once. At every vertex (except possibly start/end), every entry must be matched with an exit. This requires balanced degrees.</p>
<p>In an Eulerian Circuit: <span class="math display">\[
\text{in}(v) = \text{out}(v) \quad \forall v
\]</span></p>
<p>In an Eulerian Path: <span class="math display">\[
\exists \text{start with } \text{out}(v)=\text{in}(v)+1 \
\exists \text{end with } \text{in}(v)=\text{out}(v)+1
\]</span></p>
<p>Hierholzer’s algorithm constructs the path by merging cycles and ensuring all edges are consumed.</p>
</section>
<section id="try-it-yourself-92" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-92">Try It Yourself</h4>
<ol type="1">
<li>Build a small graph and test parity conditions.</li>
<li>Implement Hierholzer’s algorithm and trace each step.</li>
<li>Verify correctness by counting traversed edges.</li>
<li>Explore both directed and undirected variants.</li>
<li>Modify to detect Eulerian circuit vs path.</li>
</ol>
</section>
<section id="complexity-92" class="level4">
<h4 class="anchored" data-anchor-id="complexity-92">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V+E)\)</span></li>
<li>Space: <span class="math inline">\(O(V+E)\)</span></li>
</ul>
<p>Eulerian paths are elegant because they cover every connection exactly once, perfect order in perfect traversal.</p>
</section>
</section>
<section id="hamiltonian-path" class="level3">
<h3 class="anchored" data-anchor-id="hamiltonian-path">394 Hamiltonian Path</h3>
<p>A Hamiltonian Path is a path in a graph that visits every vertex exactly once. If it starts and ends at the same vertex, it forms a Hamiltonian Cycle. Unlike the Eulerian Path (which focuses on edges), the Hamiltonian Path focuses on vertices.</p>
<p>Finding one is a classic NP-complete problem, there’s no known polynomial-time algorithm for general graphs.</p>
<section id="what-problem-are-we-solving-93" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-93">What Problem Are We Solving?</h4>
<p>We want to determine if there exists a path that visits every vertex exactly once, no repetition, no omission.</p>
<p>In formal terms: Given a graph <span class="math inline">\(G = (V, E)\)</span>, find a sequence of vertices <span class="math display">\[v_1, v_2, \ldots, v_n\]</span> such that <span class="math inline">\((v_i, v_{i+1}) \in E\)</span> for all <span class="math inline">\(i\)</span>, and all vertices are distinct.</p>
<p>For a Hamiltonian Cycle, additionally <span class="math inline">\((v_n, v_1) \in E\)</span>.</p>
</section>
<section id="how-does-it-work-plain-language-66" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-66">How Does It Work (Plain Language)</h4>
<p>There’s no simple parity or degree condition like in Eulerian paths. We usually solve it by backtracking, bitmask DP, or heuristics (for large graphs):</p>
<ol type="1">
<li>Pick a start vertex.</li>
<li>Recursively explore all unvisited neighbors.</li>
<li>Mark visited vertices.</li>
<li>If all vertices are visited → found a Hamiltonian Path.</li>
<li>Otherwise, backtrack.</li>
</ol>
<p>For small graphs, this brute force works; for large graphs, it’s impractical.</p>
</section>
<section id="example-undirected-graph" class="level4">
<h4 class="anchored" data-anchor-id="example-undirected-graph">Example (Undirected Graph)</h4>
<p>Graph:</p>
<pre><code>1, 2, 3
|    \   |
4 ———— 5</code></pre>
<p>One Hamiltonian Path: <code>1 → 2 → 3 → 5 → 4</code> One Hamiltonian Cycle: <code>1 → 2 → 3 → 5 → 4 → 1</code></p>
</section>
<section id="example-directed-graph" class="level4">
<h4 class="anchored" data-anchor-id="example-directed-graph">Example (Directed Graph)</h4>
<pre><code>A → B → C
↑       ↓
E ← D ← </code></pre>
<p>Possible Hamiltonian Path: <code>A → B → C → D → E</code></p>
</section>
<section id="tiny-code-backtracking-c" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-backtracking-c">Tiny Code (Backtracking – C++)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb168"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> hamiltonianPath<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> adj<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&amp;</span> visited<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> path<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>path<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> n<span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>            visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>            path<span class="op">.</span>push_back<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>hamiltonianPath<span class="op">(</span>v<span class="op">,</span> adj<span class="op">,</span> visited<span class="op">,</span> path<span class="op">,</span> n<span class="op">))</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a>            visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a>            path<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Call with each vertex as a potential start.</p>
</section>
<section id="tiny-code-dp-bitmask-c" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-dp-bitmask-c">Tiny Code (DP Bitmask – C++)</h4>
<p>Used for TSP-style Hamiltonian search:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb169"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> INF<span class="op">));</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mask <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> mask <span class="op">&lt;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> n<span class="op">);</span> <span class="op">++</span>mask<span class="op">)</span> <span class="op">{</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>u<span class="op">)</span> <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> u<span class="op">))</span> <span class="op">{</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>v<span class="op">)</span> <span class="cf">if</span> <span class="op">(!(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> v<span class="op">))</span> <span class="op">&amp;&amp;</span> adj<span class="op">[</span>u<span class="op">][</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>mask <span class="op">|</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> v<span class="op">)][</span>v<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>mask <span class="op">|</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> v<span class="op">)][</span>v<span class="op">],</span> dp<span class="op">[</span>mask<span class="op">][</span>u<span class="op">]</span> <span class="op">+</span> cost<span class="op">[</span>u<span class="op">][</span>v<span class="op">]);</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-93" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-93">Why It Matters</h4>
<ul>
<li><p>Models ordering problems:</p>
<ul>
<li>Traveling Salesman (TSP)</li>
<li>Job sequencing with constraints</li>
<li>Genome assembly paths</li>
</ul></li>
<li><p>Fundamental in theoretical computer science, cornerstone NP-complete problem.</p></li>
<li><p>Helps distinguish easy (Eulerian) vs hard (Hamiltonian) traversal.</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-its-hard" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-its-hard">A Gentle Proof (Why It’s Hard)</h4>
<p>Hamiltonian Path existence is NP-complete:</p>
<ol type="1">
<li>Verification is easy (given a path, check in <span class="math inline">\(O(V)\)</span>).</li>
<li>No known polynomial algorithm (unless <span class="math inline">\(P=NP\)</span>).</li>
<li>Many problems reduce to it (like TSP).</li>
</ol>
<p>This means it likely requires exponential time in general: <span class="math display">\[
O(n!)
\]</span> in naive form, or <span class="math display">\[
O(2^n n)
\]</span> using bitmask DP.</p>
</section>
<section id="try-it-yourself-93" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-93">Try It Yourself</h4>
<ol type="1">
<li>Build small graphs (4–6 vertices) and trace paths.</li>
<li>Compare with Eulerian path conditions.</li>
<li>Implement backtracking search.</li>
<li>Extend to cycle detection (check edge back to start).</li>
<li>Try bitmask DP for small <span class="math inline">\(n \le 20\)</span>.</li>
</ol>
</section>
<section id="complexity-93" class="level4">
<h4 class="anchored" data-anchor-id="complexity-93">Complexity</h4>
<ul>
<li>Time (backtracking): <span class="math inline">\(O(n!)\)</span></li>
<li>Time (DP bitmask): <span class="math inline">\(O(2^n \cdot n^2)\)</span></li>
<li>Space: <span class="math inline">\(O(2^n \cdot n)\)</span></li>
</ul>
<p>Hamiltonian paths capture the essence of combinatorial explosion, simple to state, hard to solve, yet central to understanding computational limits.</p>
</section>
</section>
<section id="chinese-postman-problem-route-inspection" class="level3">
<h3 class="anchored" data-anchor-id="chinese-postman-problem-route-inspection">395 Chinese Postman Problem (Route Inspection)</h3>
<p>The Chinese Postman Problem (CPP), also known as the Route Inspection Problem, asks for the shortest closed path that traverses every edge of a graph at least once. It generalizes the Eulerian Circuit, allowing edge repetitions when necessary.</p>
<section id="what-problem-are-we-solving-94" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-94">What Problem Are We Solving?</h4>
<p>Given a weighted graph <span class="math inline">\(G = (V, E)\)</span>, we want to find a minimum-cost tour that covers all edges at least once and returns to the start.</p>
<p>If <span class="math inline">\(G\)</span> is Eulerian (all vertices have even degree), the answer is simple, the Eulerian Circuit itself. Otherwise, we must duplicate edges strategically to make the graph Eulerian, minimizing total added cost.</p>
</section>
<section id="how-it-works-plain-language-27" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-27">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Check vertex degrees:</p>
<ul>
<li>Count how many have odd degree.</li>
</ul></li>
<li><p>If all even → just find Eulerian Circuit.</p></li>
<li><p>If some odd →</p>
<ul>
<li>Pair up odd vertices in such a way that the sum of shortest path distances between paired vertices is minimal.</li>
<li>Duplicate edges along those shortest paths.</li>
</ul></li>
<li><p>The resulting graph is Eulerian, so an Eulerian Circuit can be constructed.</p></li>
<li><p>The cost of this circuit is the sum of all edges + added edges.</p></li>
</ol>
</section>
<section id="example-26" class="level4">
<h4 class="anchored" data-anchor-id="example-26">Example</h4>
<p>Graph edges (with weights):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Edge</th>
<th>Weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1–2</td>
<td>3</td>
</tr>
<tr class="even">
<td>2–3</td>
<td>2</td>
</tr>
<tr class="odd">
<td>3–4</td>
<td>4</td>
</tr>
<tr class="even">
<td>4–1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>2–4</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Degrees:</p>
<ul>
<li>deg(1)=2, deg(2)=3, deg(3)=2, deg(4)=3 → odd vertices: 2, 4 Shortest path between 2–4: 1 Add that again → now all even</li>
</ul>
<p>Total cost = (3 + 2 + 4 + 3 + 1) + 1 = 14</p>
</section>
<section id="algorithm-steps" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-steps">Algorithm (Steps)</h4>
<ol type="1">
<li>Identify odd-degree vertices</li>
<li>Compute shortest path matrix (Floyd–Warshall)</li>
<li>Solve minimum-weight perfect matching among odd vertices</li>
<li>Duplicate edges in the matching</li>
<li>Perform Eulerian Circuit traversal (Hierholzer’s algorithm)</li>
</ol>
</section>
<section id="tiny-code-pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-pseudocode">Tiny Code (Pseudocode)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chinese_postman(G):</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>    odd <span class="op">=</span> [v <span class="cf">for</span> v <span class="kw">in</span> G <span class="cf">if</span> degree(v) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> odd:</span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> eulerian_circuit(G)</span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> floyd_warshall(G)</span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>    pairs <span class="op">=</span> minimum_weight_matching(odd, dist)</span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (u, v) <span class="kw">in</span> pairs:</span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>        add_path(G, u, v, dist)</span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> eulerian_circuit(G)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-94" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-94">Why It Matters</h4>
<ul>
<li><p>Core algorithm in network optimization</p></li>
<li><p>Used in:</p>
<ul>
<li>Postal route planning</li>
<li>Garbage collection routing</li>
<li>Snow plow scheduling</li>
<li>Street sweeping</li>
</ul></li>
<li><p>Demonstrates how graph augmentation can solve traversal problems efficiently</p></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-93" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-93">A Gentle Proof (Why It Works)</h4>
<p>To traverse every edge, all vertices must have even degree (Eulerian condition). When vertices with odd degree exist, we must pair them up to restore evenness.</p>
<p>The minimal duplication set is a minimum-weight perfect matching among odd vertices:</p>
<p><span class="math display">\[
\text{Extra cost} = \min_{\text{pairing } M} \sum_{(u,v) \in M} \text{dist}(u,v)
\]</span></p>
<p>Thus, the optimal path cost:</p>
<p><span class="math display">\[
C = \sum_{e \in E} w(e) + \text{Extra cost}
\]</span></p>
</section>
<section id="try-it-yourself-94" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-94">Try It Yourself</h4>
<ol type="1">
<li>Draw a graph with odd-degree vertices.</li>
<li>Identify odd vertices and shortest pair distances.</li>
<li>Compute minimal matching manually.</li>
<li>Add duplicated edges and find Eulerian Circuit.</li>
<li>Compare total cost before and after duplication.</li>
</ol>
</section>
<section id="complexity-94" class="level4">
<h4 class="anchored" data-anchor-id="complexity-94">Complexity</h4>
<ul>
<li>Floyd–Warshall: <span class="math inline">\(O(V^3)\)</span></li>
<li>Minimum Matching: <span class="math inline">\(O(V^3)\)</span></li>
<li>Eulerian traversal: <span class="math inline">\(O(E)\)</span></li>
<li>Total: <span class="math inline">\(O(V^3)\)</span></li>
</ul>
<p>The Chinese Postman Problem transforms messy graphs into elegant tours, balancing degrees, minimizing effort, and ensuring every edge gets its due.</p>
</section>
</section>
<section id="hierholzers-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="hierholzers-algorithm">396 Hierholzer’s Algorithm</h3>
<p>Hierholzer’s Algorithm is the classical method for finding an Eulerian Path or Eulerian Circuit in a graph. It constructs the path by merging cycles until all edges are used exactly once.</p>
<section id="what-problem-are-we-solving-95" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-95">What Problem Are We Solving?</h4>
<p>We want to find an Eulerian trail, a path or circuit that visits every edge exactly once.</p>
<ul>
<li>For an Eulerian Circuit (closed trail): All vertices have even degree.</li>
<li>For an Eulerian Path (open trail): Exactly two vertices have odd degree.</li>
</ul>
<p>The algorithm efficiently constructs the path in linear time relative to the number of edges.</p>
</section>
<section id="how-it-works-plain-language-28" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-28">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Check Eulerian conditions:</p>
<ul>
<li>0 odd-degree vertices → Eulerian Circuit</li>
<li>2 odd-degree vertices → Eulerian Path (start at one odd)</li>
</ul></li>
<li><p>Start from a valid vertex (odd if path, any if circuit)</p></li>
<li><p>Traverse edges greedily:</p>
<ul>
<li>Follow edges until you return to the start or cannot continue.</li>
</ul></li>
<li><p>Backtrack and merge:</p>
<ul>
<li>When stuck, backtrack to a vertex with unused edges, start a new cycle, and merge it into the current path.</li>
</ul></li>
<li><p>Continue until all edges are used.</p></li>
</ol>
<p>The final sequence of vertices is the Eulerian trail.</p>
</section>
<section id="example-undirected-graph-1" class="level4">
<h4 class="anchored" data-anchor-id="example-undirected-graph-1">Example (Undirected Graph)</h4>
<p>Graph:</p>
<pre><code>1, 2
|   |
4, 3</code></pre>
<p>All vertices have even degree, so an Eulerian Circuit exists.</p>
<p>Start at 1:</p>
<p>1 → 2 → 3 → 4 → 1</p>
<p>Result: Eulerian Circuit = [1, 2, 3, 4, 1]</p>
</section>
<section id="example-with-odd-vertices" class="level4">
<h4 class="anchored" data-anchor-id="example-with-odd-vertices">Example (With Odd Vertices)</h4>
<p>Graph:</p>
<pre><code>1, 2, 3</code></pre>
<p>deg(1)=1, deg(2)=2, deg(3)=1 → Eulerian Path exists Start at 1:</p>
<p>1 → 2 → 3</p>
</section>
<section id="tiny-code-c-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-1">Tiny Code (C++)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb173"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> path<span class="op">;</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>adj<span class="op">[</span>u<span class="op">].</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> adj<span class="op">[</span>u<span class="op">].</span>back<span class="op">();</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>u<span class="op">].</span>pop_back<span class="op">();</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a>    path<span class="op">.</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>After DFS, <code>path</code> will contain vertices in reverse order. Reverse it to get the Eulerian path or circuit.</p>
</section>
<section id="tiny-code-python-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-14">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hierholzer(graph, start):</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>    stack, path <span class="op">=</span> [start], []</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> stack:</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> stack[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> graph[u]:</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> graph[u].pop()</span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a>            graph[v].remove(u)  <span class="co"># remove both directions for undirected</span></span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>            stack.append(v)</span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a>            path.append(stack.pop())</span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path[::<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-95" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-95">Why It Matters</h4>
<ul>
<li><p>Efficiently constructs Eulerian Paths in <span class="math inline">\(O(V + E)\)</span></p></li>
<li><p>Backbone for:</p>
<ul>
<li>Chinese Postman Problem</li>
<li>Eulerian Circuit detection</li>
<li>DNA sequencing (De Bruijn graphs)</li>
<li>Route design and network analysis</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-94" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-94">A Gentle Proof (Why It Works)</h4>
<ul>
<li>Every time you traverse an edge, it’s removed (used once).</li>
<li>Each vertex retains balanced degree (entries = exits).</li>
<li>When you get stuck, the subpath formed is a cycle.</li>
<li>Merging all such cycles yields a single complete traversal.</li>
</ul>
<p>Thus, every edge appears exactly once in the final route.</p>
</section>
<section id="try-it-yourself-95" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-95">Try It Yourself</h4>
<ol type="1">
<li>Draw small Eulerian graphs.</li>
<li>Manually trace Hierholzer’s algorithm.</li>
<li>Identify start vertex (odd-degree or any).</li>
<li>Verify path covers all edges exactly once.</li>
<li>Apply to both directed and undirected graphs.</li>
</ol>
</section>
<section id="complexity-95" class="level4">
<h4 class="anchored" data-anchor-id="complexity-95">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V + E)\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Hierholzer’s Algorithm elegantly builds order from connectivity, ensuring each edge finds its place in a perfect traversal.</p>
</section>
</section>
<section id="johnsons-cycle-finding-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="johnsons-cycle-finding-algorithm">397 Johnson’s Cycle Finding Algorithm</h3>
<p>Johnson’s Algorithm is a powerful method for enumerating all simple cycles (elementary circuits) in a directed graph. A <em>simple cycle</em> is one that visits no vertex more than once, except the starting/ending vertex.</p>
<p>Unlike DFS-based approaches that can miss or duplicate cycles, Johnson’s method systematically lists each cycle exactly once, running in O((V + E)(C + 1)), where C is the number of cycles.</p>
<section id="what-problem-are-we-solving-96" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-96">What Problem Are We Solving?</h4>
<p>We want to find all simple cycles in a directed graph <span class="math inline">\(G = (V, E)\)</span>.</p>
<p>That is, find all vertex sequences <span class="math display">\[v_1 \to v_2 \to \ldots \to v_k \to v_1\]</span> where each <span class="math inline">\(v_i\)</span> is distinct and edges exist between consecutive vertices.</p>
<p>Enumerating all cycles is fundamental for:</p>
<ul>
<li>Dependency analysis</li>
<li>Feedback detection</li>
<li>Circuit design</li>
<li>Graph motif analysis</li>
</ul>
</section>
<section id="how-it-works-plain-language-29" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-29">How It Works (Plain Language)</h4>
<p>Johnson’s algorithm is based on backtracking with smart pruning and SCC decomposition:</p>
<ol type="1">
<li><p>Process vertices in order</p>
<ul>
<li>Consider vertices <span class="math inline">\(1, 2, \dots, n\)</span>.</li>
</ul></li>
<li><p>For each vertex <span class="math inline">\(s\)</span>:</p>
<ul>
<li>Consider the subgraph induced by vertices ≥ s.</li>
<li>Find strongly connected components (SCCs) in this subgraph.</li>
<li>If <span class="math inline">\(s\)</span> belongs to a nontrivial SCC, explore all simple cycles starting at <span class="math inline">\(s\)</span>.</li>
</ul></li>
<li><p>Use a blocked set to avoid redundant exploration:</p>
<ul>
<li>Once a vertex leads to a dead-end, mark it blocked.</li>
<li>Unblock when a valid cycle is found through it.</li>
</ul></li>
</ol>
<p>This avoids exploring the same path multiple times.</p>
</section>
<section id="example-27" class="level4">
<h4 class="anchored" data-anchor-id="example-27">Example</h4>
<p>Graph:</p>
<pre><code>A → B → C
↑   ↓   |
└── D ←─┘</code></pre>
<p>Cycles:</p>
<ol type="1">
<li>A → B → C → D → A</li>
<li>B → C → D → B</li>
</ol>
<p>Johnson’s algorithm will find both efficiently, without duplication.</p>
</section>
<section id="pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="pseudocode">Pseudocode</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> johnson(G):</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    blocked <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> {v: <span class="bu">set</span>() <span class="cf">for</span> v <span class="kw">in</span> G}</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>    stack <span class="op">=</span> []</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> circuit(v, s):</span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a>        f <span class="op">=</span> <span class="va">False</span></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>        stack.append(v)</span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>        blocked.add(v)</span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> G[v]:</span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="op">==</span> s:</span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>                result.append(stack.copy())</span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> <span class="va">True</span></span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> w <span class="kw">not</span> <span class="kw">in</span> blocked:</span>
<span id="cb176-16"><a href="#cb176-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> circuit(w, s):</span>
<span id="cb176-17"><a href="#cb176-17" aria-hidden="true" tabindex="-1"></a>                    f <span class="op">=</span> <span class="va">True</span></span>
<span id="cb176-18"><a href="#cb176-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> f:</span>
<span id="cb176-19"><a href="#cb176-19" aria-hidden="true" tabindex="-1"></a>            unblock(v)</span>
<span id="cb176-20"><a href="#cb176-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb176-21"><a href="#cb176-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> w <span class="kw">in</span> G[v]:</span>
<span id="cb176-22"><a href="#cb176-22" aria-hidden="true" tabindex="-1"></a>                B[w].add(v)</span>
<span id="cb176-23"><a href="#cb176-23" aria-hidden="true" tabindex="-1"></a>        stack.pop()</span>
<span id="cb176-24"><a href="#cb176-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> f</span>
<span id="cb176-25"><a href="#cb176-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-26"><a href="#cb176-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> unblock(u):</span>
<span id="cb176-27"><a href="#cb176-27" aria-hidden="true" tabindex="-1"></a>        blocked.discard(u)</span>
<span id="cb176-28"><a href="#cb176-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> B[u]:</span>
<span id="cb176-29"><a href="#cb176-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> w <span class="kw">in</span> blocked:</span>
<span id="cb176-30"><a href="#cb176-30" aria-hidden="true" tabindex="-1"></a>                unblock(w)</span>
<span id="cb176-31"><a href="#cb176-31" aria-hidden="true" tabindex="-1"></a>        B[u].clear()</span>
<span id="cb176-32"><a href="#cb176-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-33"><a href="#cb176-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">sorted</span>(G.keys()):</span>
<span id="cb176-34"><a href="#cb176-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># consider subgraph of nodes &gt;= s</span></span>
<span id="cb176-35"><a href="#cb176-35" aria-hidden="true" tabindex="-1"></a>        subG <span class="op">=</span> {v: [w <span class="cf">for</span> w <span class="kw">in</span> G[v] <span class="cf">if</span> w <span class="op">&gt;=</span> s] <span class="cf">for</span> v <span class="kw">in</span> G <span class="cf">if</span> v <span class="op">&gt;=</span> s}</span>
<span id="cb176-36"><a href="#cb176-36" aria-hidden="true" tabindex="-1"></a>        SCCs <span class="op">=</span> strongly_connected_components(subG)</span>
<span id="cb176-37"><a href="#cb176-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> SCCs:</span>
<span id="cb176-38"><a href="#cb176-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb176-39"><a href="#cb176-39" aria-hidden="true" tabindex="-1"></a>        scc <span class="op">=</span> <span class="bu">min</span>(SCCs, key<span class="op">=</span><span class="kw">lambda</span> S: <span class="bu">min</span>(S))</span>
<span id="cb176-40"><a href="#cb176-40" aria-hidden="true" tabindex="-1"></a>        s_node <span class="op">=</span> <span class="bu">min</span>(scc)</span>
<span id="cb176-41"><a href="#cb176-41" aria-hidden="true" tabindex="-1"></a>        circuit(s_node, s_node)</span>
<span id="cb176-42"><a href="#cb176-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-96" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-96">Why It Matters</h4>
<ul>
<li><p>Enumerates all simple cycles without duplicates</p></li>
<li><p>Works for directed graphs (unlike many undirected-only algorithms)</p></li>
<li><p>Key in:</p>
<ul>
<li>Deadlock detection</li>
<li>Cycle basis computation</li>
<li>Feedback arc set analysis</li>
<li>Subgraph pattern mining</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-95" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-95">A Gentle Proof (Why It Works)</h4>
<p>Each recursive search begins from the smallest vertex in an SCC. By restricting search to vertices <span class="math inline">\(\ge s\)</span>, every cycle is discovered exactly once (at its least-numbered vertex). The blocked set prevents repeated exploration of dead ends. Unblocking ensures vertices re-enter search space when part of a valid cycle.</p>
<p>This guarantees:</p>
<ul>
<li>No cycle is missed</li>
<li>No cycle is duplicated</li>
</ul>
</section>
<section id="try-it-yourself-96" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-96">Try It Yourself</h4>
<ol type="1">
<li>Draw a small directed graph with 3–5 vertices.</li>
<li>Identify SCCs manually.</li>
<li>Apply the algorithm step-by-step, noting <code>blocked</code> updates.</li>
<li>Record each cycle when returning to start.</li>
<li>Compare with naive DFS enumeration.</li>
</ol>
</section>
<section id="complexity-96" class="level4">
<h4 class="anchored" data-anchor-id="complexity-96">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O((V + E)(C + 1))\)</span></li>
<li>Space: <span class="math inline">\(O(V + E)\)</span></li>
</ul>
<p>Johnson’s algorithm reveals the hidden loops inside directed graphs, one by one, exhaustively and elegantly.</p>
</section>
</section>
<section id="transitive-closure-floydwarshall" class="level3">
<h3 class="anchored" data-anchor-id="transitive-closure-floydwarshall">398 Transitive Closure (Floyd–Warshall)</h3>
<p>The Transitive Closure of a directed graph captures reachability: it tells us, for every pair of vertices <span class="math inline">\((u, v)\)</span>, whether there exists a path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>.</p>
<p>It’s often represented as a boolean matrix <span class="math inline">\(R\)</span>, where <span class="math display">\[
R[u][v] = 1 \text{ if and only if there is a path from } u \text{ to } v
\]</span></p>
<p>This can be computed efficiently using a modified version of the Floyd–Warshall algorithm.</p>
<section id="what-problem-are-we-solving-97" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-97">What Problem Are We Solving?</h4>
<p>Given a directed graph <span class="math inline">\(G = (V, E)\)</span>, we want to determine for every pair <span class="math inline">\((u, v)\)</span> whether:</p>
<p><span class="math display">\[
u \leadsto v
\]</span></p>
<p>That is, can we reach <span class="math inline">\(v\)</span> from <span class="math inline">\(u\)</span> through a sequence of directed edges?</p>
<p>The output is a reachability matrix, useful in:</p>
<ul>
<li>Dependency analysis</li>
<li>Access control and authorization graphs</li>
<li>Program call graphs</li>
<li>Database query optimization</li>
</ul>
</section>
<section id="how-it-works-plain-language-30" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-30">How It Works (Plain Language)</h4>
<p>We apply the Floyd–Warshall dynamic programming idea, but instead of distances, we propagate reachability.</p>
<p>Let <span class="math inline">\(R[u][v] = 1\)</span> if <span class="math inline">\(u \to v\)</span> (direct edge), otherwise <span class="math inline">\(0\)</span>. Then for each vertex <span class="math inline">\(k\)</span> (intermediate node), we update:</p>
<p><span class="math display">\[
R[u][v] = R[u][v] \lor (R[u][k] \land R[k][v])
\]</span></p>
<p>Intuitively: “<span class="math inline">\(u\)</span> can reach <span class="math inline">\(v\)</span> if <span class="math inline">\(u\)</span> can reach <span class="math inline">\(k\)</span> and <span class="math inline">\(k\)</span> can reach <span class="math inline">\(v\)</span>.”</p>
</section>
<section id="example-28" class="level4">
<h4 class="anchored" data-anchor-id="example-28">Example</h4>
<p>Graph:</p>
<pre><code>A → B → C
↑         |
└─────────┘</code></pre>
<p>Initial reachability (direct edges):</p>
<pre><code>A B C
A 0 1 0
B 0 0 1
C 1 0 0</code></pre>
<p>After applying transitive closure:</p>
<pre><code>A B C
A 1 1 1
B 1 1 1
C 1 1 1</code></pre>
<p>Every vertex is reachable from every other, the graph is strongly connected.</p>
</section>
<section id="tiny-code-c-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-2">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb180"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N </span><span class="dv">100</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> R<span class="op">[</span>N<span class="op">][</span>N<span class="op">];</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> floyd_warshall_tc<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>                R<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> R<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">||</span> <span class="op">(</span>R<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">&amp;&amp;</span> R<span class="op">[</span>k<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-python-15" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-15">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transitive_closure(R):</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(R)</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>                R[i][j] <span class="op">=</span> R[i][j] <span class="kw">or</span> (R[i][k] <span class="kw">and</span> R[k][j])</span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> R</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-97" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-97">Why It Matters</h4>
<ul>
<li><p>Converts a graph into a reachability matrix</p></li>
<li><p>Enables constant-time queries: “Can <span class="math inline">\(u\)</span> reach <span class="math inline">\(v\)</span>?”</p></li>
<li><p>Used in:</p>
<ul>
<li>Compilers (call dependencies)</li>
<li>Databases (recursive queries)</li>
<li>Security graphs</li>
<li>Network analysis</li>
</ul></li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-96" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-96">A Gentle Proof (Why It Works)</h4>
<p>We extend reachability step by step:</p>
<ul>
<li>Base: <span class="math inline">\(R^{(0)}\)</span> = direct edges</li>
<li>Step: <span class="math inline">\(R^{(k)}\)</span> = paths using vertices <span class="math inline">\({1, 2, \dots, k}\)</span> as intermediates</li>
</ul>
<p>By induction: <span class="math display">\[
R^{(k)}[i][j] = 1 \iff \text{there exists a path } i \to j \text{ using vertices } \le k
\]</span></p>
<p>At the end (<span class="math inline">\(k = n\)</span>), <span class="math inline">\(R^{(n)}\)</span> contains all possible paths.</p>
</section>
<section id="try-it-yourself-97" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-97">Try It Yourself</h4>
<ol type="1">
<li>Create a directed graph with 4–5 nodes.</li>
<li>Build its adjacency matrix.</li>
<li>Apply the algorithm by hand.</li>
<li>Observe how new reachabilities emerge after each <span class="math inline">\(k\)</span>.</li>
<li>Compare with paths you can see visually.</li>
</ol>
</section>
<section id="complexity-97" class="level4">
<h4 class="anchored" data-anchor-id="complexity-97">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V^3)\)</span></li>
<li>Space: <span class="math inline">\(O(V^2)\)</span></li>
</ul>
<p>Transitive closure transforms reachability into certainty, mapping every potential path into a single clear view of what connects to what.</p>
</section>
</section>
<section id="graph-coloring-backtracking" class="level3">
<h3 class="anchored" data-anchor-id="graph-coloring-backtracking">399 Graph Coloring (Backtracking)</h3>
<p>Graph Coloring is the problem of assigning colors to vertices of a graph so that no two adjacent vertices share the same color. The smallest number of colors required is called the chromatic number of the graph.</p>
<p>This classic constraint satisfaction problem lies at the heart of scheduling, register allocation, and pattern assignment.</p>
<section id="what-problem-are-we-solving-98" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-98">What Problem Are We Solving?</h4>
<p>Given a graph <span class="math inline">\(G = (V, E)\)</span> and an integer <span class="math inline">\(k\)</span>, determine whether it is possible to color all vertices using at most <span class="math inline">\(k\)</span> colors such that:</p>
<p><span class="math display">\[
\forall (u, v) \in E, ; \text{color}(u) \ne \text{color}(v)
\]</span></p>
<p>If such a coloring exists, <span class="math inline">\(G\)</span> is <span class="math inline">\(k\)</span>-colorable.</p>
</section>
<section id="how-it-works-plain-language-31" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-31">How It Works (Plain Language)</h4>
<p>We solve this using backtracking:</p>
<ol type="1">
<li><p>Assign a color to the first vertex.</p></li>
<li><p>Move to the next vertex.</p></li>
<li><p>Try all available colors (from <span class="math inline">\(1\)</span> to <span class="math inline">\(k\)</span>).</p></li>
<li><p>If a color assignment violates adjacency constraints, skip it.</p></li>
<li><p>If a vertex cannot be colored, backtrack to previous vertex and change its color.</p></li>
<li><p>Continue until:</p>
<ul>
<li>all vertices are colored (success), or</li>
<li>no valid assignment exists (failure).</li>
</ul></li>
</ol>
</section>
<section id="example-29" class="level4">
<h4 class="anchored" data-anchor-id="example-29">Example</h4>
<p>Graph:</p>
<pre><code>1, 2
|   |
3, 4</code></pre>
<p>A square requires at least 2 colors:</p>
<ul>
<li>color(1) = 1</li>
<li>color(2) = 2</li>
<li>color(3) = 2</li>
<li>color(4) = 1</li>
</ul>
<p>Valid 2-coloring.</p>
<p>Try 1 color → fails (adjacent nodes same color) Try 2 colors → success → chromatic number = 2</p>
</section>
<section id="tiny-code-c-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-3">Tiny Code (C++)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb183"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span> k<span class="op">;</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> color<span class="op">;</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isSafe<span class="op">(</span><span class="dt">int</span> v<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">:</span> adj<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>color<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> c<span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> solve<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> n<span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> c <span class="op">&lt;=</span> k<span class="op">;</span> <span class="op">++</span>c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>isSafe<span class="op">(</span>v<span class="op">,</span> c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a>            color<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>solve<span class="op">(</span>v <span class="op">+</span> <span class="dv">1</span><span class="op">))</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb183-17"><a href="#cb183-17" aria-hidden="true" tabindex="-1"></a>            color<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb183-18"><a href="#cb183-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb183-19"><a href="#cb183-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb183-20"><a href="#cb183-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb183-21"><a href="#cb183-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-python-16" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-16">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> graph_coloring(graph, k):</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> safe(v, c):</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">all</span>(color[u] <span class="op">!=</span> c <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(n) <span class="cf">if</span> graph[v][u])</span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> backtrack(v):</span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">==</span> n:</span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> safe(v, c):</span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>                color[v] <span class="op">=</span> c</span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> backtrack(v <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a>                color[v] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb184-18"><a href="#cb184-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-19"><a href="#cb184-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> backtrack(<span class="dv">0</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-98" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-98">Why It Matters</h4>
<p>Graph coloring captures the essence of constraint-based allocation:</p>
<ul>
<li>Scheduling: assign time slots to tasks</li>
<li>Register allocation: map variables to CPU registers</li>
<li>Map coloring: color regions with shared boundaries</li>
<li>Frequency assignment: allocate channels in wireless networks</li>
</ul>
</section>
<section id="a-gentle-proof-why-it-works-97" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-97">A Gentle Proof (Why It Works)</h4>
<p>We explore all possible assignments (depth-first search) under the rule: <span class="math display">\[
\forall (u, v) \in E, ; \text{color}(u) \ne \text{color}(v)
\]</span></p>
<p>Backtracking prunes partial solutions that cannot lead to valid full assignments. When a full coloring is found, constraints are satisfied by construction.</p>
<p>By completeness of backtracking, if a valid <span class="math inline">\(k\)</span>-coloring exists, it will be found.</p>
</section>
<section id="try-it-yourself-98" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-98">Try It Yourself</h4>
<ol type="1">
<li>Draw small graphs (triangle, square, pentagon).</li>
<li>Attempt coloring with <span class="math inline">\(k = 2, 3, 4\)</span>.</li>
<li>Observe where conflicts force backtracking.</li>
<li>Try greedy coloring and compare with backtracking.</li>
<li>Identify the chromatic number experimentally.</li>
</ol>
</section>
<section id="complexity-98" class="level4">
<h4 class="anchored" data-anchor-id="complexity-98">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(k^V)\)</span> (exponential worst case)</li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
</ul>
<p>Graph coloring blends search and logic, a careful dance through the constraints, discovering harmony one color at a time.</p>
</section>
</section>
<section id="articulation-points-bridges" class="level3">
<h3 class="anchored" data-anchor-id="articulation-points-bridges">400 Articulation Points &amp; Bridges</h3>
<p>Articulation Points and Bridges identify weak spots in a graph, nodes or edges whose removal increases the number of connected components. They are essential in analyzing network resilience, communication reliability, and biconnected components.</p>
<section id="what-problem-are-we-solving-99" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-99">What Problem Are We Solving?</h4>
<p>Given an undirected graph <span class="math inline">\(G = (V, E)\)</span>, find:</p>
<ul>
<li><p>Articulation Points (Cut Vertices): Vertices whose removal disconnects the graph.</p></li>
<li><p>Bridges (Cut Edges): Edges whose removal disconnects the graph.</p></li>
</ul>
<p>We want efficient algorithms to detect these in <span class="math inline">\(O(V + E)\)</span> time.</p>
</section>
<section id="how-it-works-plain-language-32" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-32">How It Works (Plain Language)</h4>
<p>We use a single DFS traversal (Tarjan’s algorithm) with two key arrays:</p>
<ul>
<li><code>disc[v]</code>: discovery time of vertex <span class="math inline">\(v\)</span></li>
<li><code>low[v]</code>: the lowest discovery time reachable from <span class="math inline">\(v\)</span> (including back edges)</li>
</ul>
<p>During DFS:</p>
<ul>
<li><p>A vertex <span class="math inline">\(u\)</span> is an articulation point if:</p>
<ul>
<li><span class="math inline">\(u\)</span> is root and has more than one child, or</li>
<li><span class="math inline">\(\exists\)</span> child <span class="math inline">\(v\)</span> such that <code>low[v] ≥ disc[u]</code></li>
</ul></li>
<li><p>An edge <span class="math inline">\((u, v)\)</span> is a bridge if:</p>
<ul>
<li><code>low[v] &gt; disc[u]</code></li>
</ul></li>
</ul>
<p>These conditions detect when no back-edge connects a subtree back to an ancestor.</p>
</section>
<section id="example-30" class="level4">
<h4 class="anchored" data-anchor-id="example-30">Example</h4>
<p>Graph:</p>
<pre><code>  1
 / \
2   3
|   |
4   5</code></pre>
<p>Remove node 2 → node 4 becomes isolated → 2 is an articulation point. Remove edge (2, 4) → increases components → (2, 4) is a bridge.</p>
</section>
<section id="tiny-code-c-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-4">Tiny Code (C++)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb186"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> disc<span class="op">,</span> low<span class="op">,</span> parent<span class="op">;</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> ap<span class="op">;</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> timer <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>    disc<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>timer<span class="op">;</span></span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> children <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>disc<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>            parent<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>children<span class="op">;</span></span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>            dfs<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span> low<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb186-16"><a href="#cb186-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-17"><a href="#cb186-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>parent<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">&amp;&amp;</span> children <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb186-18"><a href="#cb186-18" aria-hidden="true" tabindex="-1"></a>                ap<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb186-19"><a href="#cb186-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>parent<span class="op">[</span>u<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">&amp;&amp;</span> low<span class="op">[</span>v<span class="op">]</span> <span class="op">&gt;=</span> disc<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb186-20"><a href="#cb186-20" aria-hidden="true" tabindex="-1"></a>                ap<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb186-21"><a href="#cb186-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>low<span class="op">[</span>v<span class="op">]</span> <span class="op">&gt;</span> disc<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb186-22"><a href="#cb186-22" aria-hidden="true" tabindex="-1"></a>                cout <span class="op">&lt;&lt;</span> <span class="st">"Bridge: "</span> <span class="op">&lt;&lt;</span> u <span class="op">&lt;&lt;</span> <span class="st">" - "</span> <span class="op">&lt;&lt;</span> v <span class="op">&lt;&lt;</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb186-23"><a href="#cb186-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>v <span class="op">!=</span> parent<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb186-24"><a href="#cb186-24" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span> disc<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb186-25"><a href="#cb186-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-26"><a href="#cb186-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb186-27"><a href="#cb186-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tiny-code-python-17" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-17">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb187"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> articulation_points_and_bridges(graph):</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>    disc <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>    low <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>    parent <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>    ap <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>    bridges <span class="op">=</span> []</span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>    time <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(u):</span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> time</span>
<span id="cb187-12"><a href="#cb187-12" aria-hidden="true" tabindex="-1"></a>        disc[u] <span class="op">=</span> low[u] <span class="op">=</span> time</span>
<span id="cb187-13"><a href="#cb187-13" aria-hidden="true" tabindex="-1"></a>        time <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb187-14"><a href="#cb187-14" aria-hidden="true" tabindex="-1"></a>        children <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb187-15"><a href="#cb187-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb187-16"><a href="#cb187-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> disc[v]:</span>
<span id="cb187-17"><a href="#cb187-17" aria-hidden="true" tabindex="-1"></a>                parent[v] <span class="op">=</span> u</span>
<span id="cb187-18"><a href="#cb187-18" aria-hidden="true" tabindex="-1"></a>                children <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb187-19"><a href="#cb187-19" aria-hidden="true" tabindex="-1"></a>                dfs(v)</span>
<span id="cb187-20"><a href="#cb187-20" aria-hidden="true" tabindex="-1"></a>                low[u] <span class="op">=</span> <span class="bu">min</span>(low[u], low[v])</span>
<span id="cb187-21"><a href="#cb187-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-22"><a href="#cb187-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> parent[u] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">and</span> children <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb187-23"><a href="#cb187-23" aria-hidden="true" tabindex="-1"></a>                    ap[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb187-24"><a href="#cb187-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> parent[u] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">and</span> low[v] <span class="op">&gt;=</span> disc[u]:</span>
<span id="cb187-25"><a href="#cb187-25" aria-hidden="true" tabindex="-1"></a>                    ap[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb187-26"><a href="#cb187-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> low[v] <span class="op">&gt;</span> disc[u]:</span>
<span id="cb187-27"><a href="#cb187-27" aria-hidden="true" tabindex="-1"></a>                    bridges.append((u, v))</span>
<span id="cb187-28"><a href="#cb187-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> v <span class="op">!=</span> parent[u]:</span>
<span id="cb187-29"><a href="#cb187-29" aria-hidden="true" tabindex="-1"></a>                low[u] <span class="op">=</span> <span class="bu">min</span>(low[u], disc[v])</span>
<span id="cb187-30"><a href="#cb187-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-31"><a href="#cb187-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb187-32"><a href="#cb187-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> disc[i]:</span>
<span id="cb187-33"><a href="#cb187-33" aria-hidden="true" tabindex="-1"></a>            dfs(i)</span>
<span id="cb187-34"><a href="#cb187-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-35"><a href="#cb187-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [i <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(ap) <span class="cf">if</span> x], bridges</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-99" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-99">Why It Matters</h4>
<p>Articulation points and bridges reveal critical nodes and links in:</p>
<ul>
<li>Network design: identify weak links in infrastructure</li>
<li>Social networks: find influencers whose removal splits communities</li>
<li>Compiler dependency graphs: locate critical connections</li>
<li>Transport systems: ensure robust routing</li>
</ul>
<p>Understanding where a graph breaks helps us design systems that don’t.</p>
</section>
<section id="a-gentle-proof-why-it-works-98" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-98">A Gentle Proof (Why It Works)</h4>
<p>For each node <span class="math inline">\(u\)</span>, <code>low[u]</code> captures the earliest discovered vertex reachable via DFS or a back edge. If a child subtree cannot reach an ancestor of <span class="math inline">\(u\)</span>, then <span class="math inline">\(u\)</span> is a bottleneck, removing it splits the graph.</p>
<p>The inequalities: <span class="math display">\[
low[v] \ge disc[u] \implies u \text{ is articulation point}
\]</span> <span class="math display">\[
low[v] &gt; disc[u] \implies (u,v) \text{ is bridge}
\]</span></p>
<p>are derived from whether a subtree is connected back to an ancestor.</p>
</section>
<section id="try-it-yourself-99" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-99">Try It Yourself</h4>
<ol type="1">
<li>Draw small graphs (triangle, line, star).</li>
<li>Manually run DFS and record <code>disc</code> and <code>low</code>.</li>
<li>Identify articulation points and bridges.</li>
<li>Try adding edges, see how redundancy removes articulation points.</li>
</ol>
</section>
<section id="complexity-99" class="level4">
<h4 class="anchored" data-anchor-id="complexity-99">Complexity</h4>
<ul>
<li>Time: <span class="math inline">\(O(V + E)\)</span></li>
<li>Space: <span class="math inline">\(O(V)\)</span></li>
</ul>
<p>Finding articulation points and bridges transforms structure into insight, helping you build networks that stay connected even when parts fail.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../books/en-us/list-3.html" class="pagination-link" aria-label="Chapter 3. Data Structure in Action">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Chapter 3. Data Structure in Action</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../books/en-us/list-5.html" class="pagination-link" aria-label="Chapter 5. Dynamic Programming">
        <span class="nav-page-text"><span class="chapter-title">Chapter 5. Dynamic Programming</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Chapter 7. Strings and Text Algorithms – The Little Book of Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../books/en-us/list-8.html" rel="next">
<link href="../../books/en-us/list-6.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-27c261d06b905028a18691de25d09dde.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../books/en-us/list-7.html"><span class="chapter-title">Chapter 7. Strings and Text Algorithms</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">The Little Book of Algorithms</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Content</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/cheatsheet.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Cheatsheet</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/book.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/plan.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">The Plan</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-1.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 1. Foundations of Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-2.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 2. Sorting and searching</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-3.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 3. Data Structure in Action</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-4.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 4. Graph Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-5.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 5. Dynamic Programming</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-6.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 6. Mathematics for Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-7.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Chapter 7. Strings and Text Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-8.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 8. Geometry, Graphics and Spatial Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-9.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 9. Systems, Databases and Distributed Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../books/en-us/list-10.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Chapter 10. AI, ML and Optimization</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#section-61.-string-matching" id="toc-section-61.-string-matching" class="nav-link active" data-scroll-target="#section-61.-string-matching">Section 61. String Matching</a>
  <ul class="collapse">
  <li><a href="#naive-string-matching" id="toc-naive-string-matching" class="nav-link" data-scroll-target="#naive-string-matching">601 Naive String Matching</a></li>
  <li><a href="#knuthmorrispratt-kmp" id="toc-knuthmorrispratt-kmp" class="nav-link" data-scroll-target="#knuthmorrispratt-kmp">602 Knuth–Morris–Pratt (KMP)</a></li>
  <li><a href="#z-algorithm" id="toc-z-algorithm" class="nav-link" data-scroll-target="#z-algorithm">603 Z-Algorithm</a></li>
  <li><a href="#rabinkarp" id="toc-rabinkarp" class="nav-link" data-scroll-target="#rabinkarp">604 Rabin–Karp</a></li>
  <li><a href="#boyermoore" id="toc-boyermoore" class="nav-link" data-scroll-target="#boyermoore">605 Boyer–Moore</a></li>
  <li><a href="#boyermoorehorspool" id="toc-boyermoorehorspool" class="nav-link" data-scroll-target="#boyermoorehorspool">606 Boyer–Moore–Horspool</a></li>
  <li><a href="#sunday-algorithm" id="toc-sunday-algorithm" class="nav-link" data-scroll-target="#sunday-algorithm">607 Sunday Algorithm</a></li>
  <li><a href="#finite-automaton-matching" id="toc-finite-automaton-matching" class="nav-link" data-scroll-target="#finite-automaton-matching">608 Finite Automaton Matching</a></li>
  <li><a href="#bitap-algorithm" id="toc-bitap-algorithm" class="nav-link" data-scroll-target="#bitap-algorithm">609 Bitap Algorithm</a></li>
  <li><a href="#two-way-algorithm" id="toc-two-way-algorithm" class="nav-link" data-scroll-target="#two-way-algorithm">610 Two-Way Algorithm</a></li>
  </ul></li>
  <li><a href="#section-62.-multi-patterns-search" id="toc-section-62.-multi-patterns-search" class="nav-link" data-scroll-target="#section-62.-multi-patterns-search">Section 62. Multi-Patterns Search</a>
  <ul class="collapse">
  <li><a href="#ahocorasick-automaton" id="toc-ahocorasick-automaton" class="nav-link" data-scroll-target="#ahocorasick-automaton">611 Aho–Corasick Automaton</a></li>
  <li><a href="#trie-construction" id="toc-trie-construction" class="nav-link" data-scroll-target="#trie-construction">612 Trie Construction</a></li>
  <li><a href="#failure-link-computation" id="toc-failure-link-computation" class="nav-link" data-scroll-target="#failure-link-computation">613 Failure Link Computation</a></li>
  <li><a href="#output-link-management" id="toc-output-link-management" class="nav-link" data-scroll-target="#output-link-management">614 Output Link Management</a></li>
  <li><a href="#multi-pattern-search" id="toc-multi-pattern-search" class="nav-link" data-scroll-target="#multi-pattern-search">615 Multi-Pattern Search</a></li>
  <li><a href="#dictionary-matching" id="toc-dictionary-matching" class="nav-link" data-scroll-target="#dictionary-matching">616 Dictionary Matching</a></li>
  <li><a href="#dynamic-ahocorasick" id="toc-dynamic-ahocorasick" class="nav-link" data-scroll-target="#dynamic-ahocorasick">617 Dynamic Aho–Corasick</a></li>
  <li><a href="#parallel-ahocorasick-search" id="toc-parallel-ahocorasick-search" class="nav-link" data-scroll-target="#parallel-ahocorasick-search">618 Parallel Aho–Corasick Search</a></li>
  <li><a href="#parallel-ahocorasick-search-1" id="toc-parallel-ahocorasick-search-1" class="nav-link" data-scroll-target="#parallel-ahocorasick-search-1">618 Parallel Aho–Corasick Search</a></li>
  <li><a href="#compressed-ahocorasick-automaton" id="toc-compressed-ahocorasick-automaton" class="nav-link" data-scroll-target="#compressed-ahocorasick-automaton">619 Compressed Aho–Corasick Automaton</a></li>
  <li><a href="#extended-ahocorasick-with-wildcards" id="toc-extended-ahocorasick-with-wildcards" class="nav-link" data-scroll-target="#extended-ahocorasick-with-wildcards">620 Extended Aho–Corasick with Wildcards</a></li>
  </ul></li>
  <li><a href="#section-63.-suffix-structure" id="toc-section-63.-suffix-structure" class="nav-link" data-scroll-target="#section-63.-suffix-structure">Section 63. Suffix Structure</a>
  <ul class="collapse">
  <li><a href="#suffix-array-naive" id="toc-suffix-array-naive" class="nav-link" data-scroll-target="#suffix-array-naive">621 Suffix Array (Naive)</a></li>
  <li><a href="#suffix-array-doubling-algorithm" id="toc-suffix-array-doubling-algorithm" class="nav-link" data-scroll-target="#suffix-array-doubling-algorithm">622 Suffix Array (Doubling Algorithm)</a></li>
  <li><a href="#kasais-lcp-algorithm" id="toc-kasais-lcp-algorithm" class="nav-link" data-scroll-target="#kasais-lcp-algorithm">623 Kasai’s LCP Algorithm</a></li>
  <li><a href="#suffix-tree-ukkonens-algorithm" id="toc-suffix-tree-ukkonens-algorithm" class="nav-link" data-scroll-target="#suffix-tree-ukkonens-algorithm">624 Suffix Tree (Ukkonen’s Algorithm)</a></li>
  <li><a href="#suffix-automaton" id="toc-suffix-automaton" class="nav-link" data-scroll-target="#suffix-automaton">625 Suffix Automaton</a></li>
  <li><a href="#sa-is-algorithm-linear-time-suffix-array-construction" id="toc-sa-is-algorithm-linear-time-suffix-array-construction" class="nav-link" data-scroll-target="#sa-is-algorithm-linear-time-suffix-array-construction">626 SA-IS Algorithm (Linear-Time Suffix Array Construction)</a></li>
  <li><a href="#lcp-rmq-query-range-minimum-query-on-lcp-array" id="toc-lcp-rmq-query-range-minimum-query-on-lcp-array" class="nav-link" data-scroll-target="#lcp-rmq-query-range-minimum-query-on-lcp-array">627 LCP RMQ Query (Range Minimum Query on LCP Array)</a></li>
  <li><a href="#generalized-suffix-array-multiple-strings" id="toc-generalized-suffix-array-multiple-strings" class="nav-link" data-scroll-target="#generalized-suffix-array-multiple-strings">628 Generalized Suffix Array (Multiple Strings)</a></li>
  <li><a href="#enhanced-suffix-array-sa-lcp-rmq" id="toc-enhanced-suffix-array-sa-lcp-rmq" class="nav-link" data-scroll-target="#enhanced-suffix-array-sa-lcp-rmq">629 Enhanced Suffix Array (SA + LCP + RMQ)</a></li>
  <li><a href="#sparse-suffix-tree-space-efficient-variant" id="toc-sparse-suffix-tree-space-efficient-variant" class="nav-link" data-scroll-target="#sparse-suffix-tree-space-efficient-variant">630 Sparse Suffix Tree (Space-Efficient Variant)</a></li>
  </ul></li>
  <li><a href="#section-64.-palindromes-and-periodicity" id="toc-section-64.-palindromes-and-periodicity" class="nav-link" data-scroll-target="#section-64.-palindromes-and-periodicity">Section 64. Palindromes and Periodicity</a>
  <ul class="collapse">
  <li><a href="#naive-palindrome-check" id="toc-naive-palindrome-check" class="nav-link" data-scroll-target="#naive-palindrome-check">631 Naive Palindrome Check</a></li>
  <li><a href="#manachers-algorithm" id="toc-manachers-algorithm" class="nav-link" data-scroll-target="#manachers-algorithm">632 Manacher’s Algorithm</a></li>
  <li><a href="#longest-palindromic-substring-center-expansion" id="toc-longest-palindromic-substring-center-expansion" class="nav-link" data-scroll-target="#longest-palindromic-substring-center-expansion">633 Longest Palindromic Substring (Center Expansion)</a></li>
  <li><a href="#palindrome-dp-table-dynamic-programming-approach" id="toc-palindrome-dp-table-dynamic-programming-approach" class="nav-link" data-scroll-target="#palindrome-dp-table-dynamic-programming-approach">634 Palindrome DP Table (Dynamic Programming Approach)</a></li>
  <li><a href="#palindromic-tree-eertree" id="toc-palindromic-tree-eertree" class="nav-link" data-scroll-target="#palindromic-tree-eertree">635 Palindromic Tree (Eertree)</a></li>
  <li><a href="#prefix-function-periodicity" id="toc-prefix-function-periodicity" class="nav-link" data-scroll-target="#prefix-function-periodicity">636 Prefix Function Periodicity</a></li>
  <li><a href="#z-function-periodicity" id="toc-z-function-periodicity" class="nav-link" data-scroll-target="#z-function-periodicity">637 Z-Function Periodicity</a></li>
  <li><a href="#kmp-prefix-period-check-shortest-repeating-unit" id="toc-kmp-prefix-period-check-shortest-repeating-unit" class="nav-link" data-scroll-target="#kmp-prefix-period-check-shortest-repeating-unit">638 KMP Prefix Period Check (Shortest Repeating Unit)</a></li>
  <li><a href="#lyndon-factorization-chenfoxlyndon-decomposition" id="toc-lyndon-factorization-chenfoxlyndon-decomposition" class="nav-link" data-scroll-target="#lyndon-factorization-chenfoxlyndon-decomposition">639 Lyndon Factorization (Chen–Fox–Lyndon Decomposition)</a></li>
  <li><a href="#minimal-rotation-booths-algorithm" id="toc-minimal-rotation-booths-algorithm" class="nav-link" data-scroll-target="#minimal-rotation-booths-algorithm">640 Minimal Rotation (Booth’s Algorithm)</a></li>
  </ul></li>
  <li><a href="#section-65.-edit-distance-and-alignment" id="toc-section-65.-edit-distance-and-alignment" class="nav-link" data-scroll-target="#section-65.-edit-distance-and-alignment">Section 65. Edit Distance and Alignment</a>
  <ul class="collapse">
  <li><a href="#levenshtein-distance" id="toc-levenshtein-distance" class="nav-link" data-scroll-target="#levenshtein-distance">641 Levenshtein Distance</a></li>
  <li><a href="#dameraulevenshtein-distance" id="toc-dameraulevenshtein-distance" class="nav-link" data-scroll-target="#dameraulevenshtein-distance">642 Damerau–Levenshtein Distance</a></li>
  <li><a href="#hamming-distance" id="toc-hamming-distance" class="nav-link" data-scroll-target="#hamming-distance">643 Hamming Distance</a></li>
  <li><a href="#needlemanwunsch-algorithm" id="toc-needlemanwunsch-algorithm" class="nav-link" data-scroll-target="#needlemanwunsch-algorithm">644 Needleman–Wunsch Algorithm</a></li>
  <li><a href="#smithwaterman-algorithm" id="toc-smithwaterman-algorithm" class="nav-link" data-scroll-target="#smithwaterman-algorithm">645 Smith–Waterman Algorithm</a></li>
  <li><a href="#hirschbergs-algorithm" id="toc-hirschbergs-algorithm" class="nav-link" data-scroll-target="#hirschbergs-algorithm">646 Hirschberg’s Algorithm</a></li>
  <li><a href="#edit-script-reconstruction" id="toc-edit-script-reconstruction" class="nav-link" data-scroll-target="#edit-script-reconstruction">647 Edit Script Reconstruction</a></li>
  <li><a href="#affine-gap-penalty-dynamic-programming" id="toc-affine-gap-penalty-dynamic-programming" class="nav-link" data-scroll-target="#affine-gap-penalty-dynamic-programming">648 Affine Gap Penalty Dynamic Programming</a></li>
  <li><a href="#myers-bit-vector-algorithm" id="toc-myers-bit-vector-algorithm" class="nav-link" data-scroll-target="#myers-bit-vector-algorithm">649 Myers Bit-Vector Algorithm</a></li>
  <li><a href="#longest-common-subsequence-lcs" id="toc-longest-common-subsequence-lcs" class="nav-link" data-scroll-target="#longest-common-subsequence-lcs">650 Longest Common Subsequence (LCS)</a></li>
  </ul></li>
  <li><a href="#section-66.-compression" id="toc-section-66.-compression" class="nav-link" data-scroll-target="#section-66.-compression">Section 66. Compression</a>
  <ul class="collapse">
  <li><a href="#huffman-coding" id="toc-huffman-coding" class="nav-link" data-scroll-target="#huffman-coding">651 Huffman Coding</a></li>
  <li><a href="#canonical-huffman-coding" id="toc-canonical-huffman-coding" class="nav-link" data-scroll-target="#canonical-huffman-coding">652 Canonical Huffman Coding</a></li>
  <li><a href="#arithmetic-coding" id="toc-arithmetic-coding" class="nav-link" data-scroll-target="#arithmetic-coding">653 Arithmetic Coding</a></li>
  <li><a href="#shannonfano-coding" id="toc-shannonfano-coding" class="nav-link" data-scroll-target="#shannonfano-coding">654 Shannon–Fano Coding</a></li>
  <li><a href="#run-length-encoding-rle" id="toc-run-length-encoding-rle" class="nav-link" data-scroll-target="#run-length-encoding-rle">655 Run-Length Encoding (RLE)</a></li>
  <li><a href="#lz77-sliding-window-compression" id="toc-lz77-sliding-window-compression" class="nav-link" data-scroll-target="#lz77-sliding-window-compression">656 LZ77 (Sliding-Window Compression)</a></li>
  <li><a href="#lz78-dictionary-building" id="toc-lz78-dictionary-building" class="nav-link" data-scroll-target="#lz78-dictionary-building">657 LZ78 (Dictionary Building)</a></li>
  <li><a href="#lzw-lempelzivwelch" id="toc-lzw-lempelzivwelch" class="nav-link" data-scroll-target="#lzw-lempelzivwelch">658 LZW (Lempel–Ziv–Welch)</a></li>
  <li><a href="#burrowswheeler-transform-bwt" id="toc-burrowswheeler-transform-bwt" class="nav-link" data-scroll-target="#burrowswheeler-transform-bwt">659 Burrows–Wheeler Transform (BWT)</a></li>
  <li><a href="#move-to-front-mtf-encoding" id="toc-move-to-front-mtf-encoding" class="nav-link" data-scroll-target="#move-to-front-mtf-encoding">660 Move-to-Front (MTF) Encoding</a></li>
  </ul></li>
  <li><a href="#section-67.-cryptographic-hashes-and-checksum" id="toc-section-67.-cryptographic-hashes-and-checksum" class="nav-link" data-scroll-target="#section-67.-cryptographic-hashes-and-checksum">Section 67. Cryptographic Hashes and Checksum</a>
  <ul class="collapse">
  <li><a href="#rolling-hash" id="toc-rolling-hash" class="nav-link" data-scroll-target="#rolling-hash">661 Rolling Hash</a></li>
  <li><a href="#crc32-cyclic-redundancy-check" id="toc-crc32-cyclic-redundancy-check" class="nav-link" data-scroll-target="#crc32-cyclic-redundancy-check">662 CRC32 (Cyclic Redundancy Check)</a></li>
  <li><a href="#adler-32-checksum" id="toc-adler-32-checksum" class="nav-link" data-scroll-target="#adler-32-checksum">663 Adler-32 Checksum</a></li>
  <li><a href="#md5-message-digest-5" id="toc-md5-message-digest-5" class="nav-link" data-scroll-target="#md5-message-digest-5">664 MD5 (Message Digest 5)</a></li>
  <li><a href="#sha-1-secure-hash-algorithm-1" id="toc-sha-1-secure-hash-algorithm-1" class="nav-link" data-scroll-target="#sha-1-secure-hash-algorithm-1">665 SHA-1 (Secure Hash Algorithm 1)</a></li>
  <li><a href="#sha-256-secure-hash-algorithm-256-bit" id="toc-sha-256-secure-hash-algorithm-256-bit" class="nav-link" data-scroll-target="#sha-256-secure-hash-algorithm-256-bit">666 SHA-256 (Secure Hash Algorithm 256-bit)</a></li>
  <li><a href="#sha-3-keccak" id="toc-sha-3-keccak" class="nav-link" data-scroll-target="#sha-3-keccak">667 SHA-3 (Keccak)</a></li>
  <li><a href="#hmac-hash-based-message-authentication-code" id="toc-hmac-hash-based-message-authentication-code" class="nav-link" data-scroll-target="#hmac-hash-based-message-authentication-code">668 HMAC (Hash-Based Message Authentication Code)</a></li>
  <li><a href="#merkle-tree-hash-tree" id="toc-merkle-tree-hash-tree" class="nav-link" data-scroll-target="#merkle-tree-hash-tree">669 Merkle Tree (Hash Tree)</a></li>
  <li><a href="#hash-collision-detection-birthday-bound-simulation" id="toc-hash-collision-detection-birthday-bound-simulation" class="nav-link" data-scroll-target="#hash-collision-detection-birthday-bound-simulation">670 Hash Collision Detection (Birthday Bound Simulation)</a></li>
  </ul></li>
  <li><a href="#section-68.-approximate-and-streaming-matching" id="toc-section-68.-approximate-and-streaming-matching" class="nav-link" data-scroll-target="#section-68.-approximate-and-streaming-matching">Section 68. Approximate and Streaming Matching</a>
  <ul class="collapse">
  <li><a href="#k-approximate-string-matching" id="toc-k-approximate-string-matching" class="nav-link" data-scroll-target="#k-approximate-string-matching">671 K-Approximate String Matching</a></li>
  <li><a href="#bitap-algorithm-bitwise-dynamic-programming" id="toc-bitap-algorithm-bitwise-dynamic-programming" class="nav-link" data-scroll-target="#bitap-algorithm-bitwise-dynamic-programming">672 Bitap Algorithm (Bitwise Dynamic Programming)</a></li>
  <li><a href="#landauvishkin-algorithm-edit-distance-k" id="toc-landauvishkin-algorithm-edit-distance-k" class="nav-link" data-scroll-target="#landauvishkin-algorithm-edit-distance-k">673 Landau–Vishkin Algorithm (Edit Distance ≤ k)</a></li>
  <li><a href="#filtering-algorithm-fast-approximate-search" id="toc-filtering-algorithm-fast-approximate-search" class="nav-link" data-scroll-target="#filtering-algorithm-fast-approximate-search">674 Filtering Algorithm (Fast Approximate Search)</a></li>
  <li><a href="#wumanber-algorithm-multi-pattern-approximate-search" id="toc-wumanber-algorithm-multi-pattern-approximate-search" class="nav-link" data-scroll-target="#wumanber-algorithm-multi-pattern-approximate-search">675 Wu–Manber Algorithm (Multi-Pattern Approximate Search)</a></li>
  <li><a href="#streaming-kmp-online-prefix-updates" id="toc-streaming-kmp-online-prefix-updates" class="nav-link" data-scroll-target="#streaming-kmp-online-prefix-updates">676 Streaming KMP (Online Prefix Updates)</a></li>
  <li><a href="#rolling-hash-sketch-sliding-window-hashing" id="toc-rolling-hash-sketch-sliding-window-hashing" class="nav-link" data-scroll-target="#rolling-hash-sketch-sliding-window-hashing">677 Rolling Hash Sketch (Sliding Window Hashing)</a></li>
  <li><a href="#sketch-based-similarity-minhash-and-lsh" id="toc-sketch-based-similarity-minhash-and-lsh" class="nav-link" data-scroll-target="#sketch-based-similarity-minhash-and-lsh">678 Sketch-Based Similarity (MinHash and LSH)</a></li>
  <li><a href="#weighted-edit-distance-weighted-operations" id="toc-weighted-edit-distance-weighted-operations" class="nav-link" data-scroll-target="#weighted-edit-distance-weighted-operations">679 Weighted Edit Distance (Weighted Operations)</a></li>
  <li><a href="#online-levenshtein-dynamic-stream-update" id="toc-online-levenshtein-dynamic-stream-update" class="nav-link" data-scroll-target="#online-levenshtein-dynamic-stream-update">680 Online Levenshtein (Dynamic Stream Update)</a></li>
  </ul></li>
  <li><a href="#section-69.-bioinformatics-alignment" id="toc-section-69.-bioinformatics-alignment" class="nav-link" data-scroll-target="#section-69.-bioinformatics-alignment">Section 69. Bioinformatics Alignment</a>
  <ul class="collapse">
  <li><a href="#needlemanwunsch-global-sequence-alignment" id="toc-needlemanwunsch-global-sequence-alignment" class="nav-link" data-scroll-target="#needlemanwunsch-global-sequence-alignment">681 Needleman–Wunsch (Global Sequence Alignment)</a></li>
  <li><a href="#smithwaterman-local-sequence-alignment" id="toc-smithwaterman-local-sequence-alignment" class="nav-link" data-scroll-target="#smithwaterman-local-sequence-alignment">682 Smith–Waterman (Local Sequence Alignment)</a></li>
  <li><a href="#gotoh-algorithm-affine-gap-penalties" id="toc-gotoh-algorithm-affine-gap-penalties" class="nav-link" data-scroll-target="#gotoh-algorithm-affine-gap-penalties">683 Gotoh Algorithm (Affine Gap Penalties)</a></li>
  <li><a href="#hirschberg-alignment-linear-space-global-alignment" id="toc-hirschberg-alignment-linear-space-global-alignment" class="nav-link" data-scroll-target="#hirschberg-alignment-linear-space-global-alignment">684 Hirschberg Alignment (Linear-Space Global Alignment)</a></li>
  <li><a href="#multiple-sequence-alignment-msa" id="toc-multiple-sequence-alignment-msa" class="nav-link" data-scroll-target="#multiple-sequence-alignment-msa">685 Multiple Sequence Alignment (MSA)</a></li>
  <li><a href="#profile-alignment-sequence-to-profile-and-profile-to-profile" id="toc-profile-alignment-sequence-to-profile-and-profile-to-profile" class="nav-link" data-scroll-target="#profile-alignment-sequence-to-profile-and-profile-to-profile">686 Profile Alignment (Sequence-to-Profile and Profile-to-Profile)</a></li>
  <li><a href="#hidden-markov-model-hmm-alignment" id="toc-hidden-markov-model-hmm-alignment" class="nav-link" data-scroll-target="#hidden-markov-model-hmm-alignment">687 Hidden Markov Model (HMM) Alignment</a></li>
  <li><a href="#blast-basic-local-alignment-search-tool" id="toc-blast-basic-local-alignment-search-tool" class="nav-link" data-scroll-target="#blast-basic-local-alignment-search-tool">688 BLAST (Basic Local Alignment Search Tool)</a></li>
  <li><a href="#fasta-word-based-local-alignment" id="toc-fasta-word-based-local-alignment" class="nav-link" data-scroll-target="#fasta-word-based-local-alignment">689 FASTA (Word-Based Local Alignment)</a></li>
  <li><a href="#pairwise-dynamic-programming-alignment" id="toc-pairwise-dynamic-programming-alignment" class="nav-link" data-scroll-target="#pairwise-dynamic-programming-alignment">690 Pairwise Dynamic Programming Alignment</a></li>
  </ul></li>
  <li><a href="#section-70.-text-indexing-and-search-structure" id="toc-section-70.-text-indexing-and-search-structure" class="nav-link" data-scroll-target="#section-70.-text-indexing-and-search-structure">Section 70. Text Indexing and Search Structure</a>
  <ul class="collapse">
  <li><a href="#inverted-index-build" id="toc-inverted-index-build" class="nav-link" data-scroll-target="#inverted-index-build">691 Inverted Index Build</a></li>
  <li><a href="#positional-index" id="toc-positional-index" class="nav-link" data-scroll-target="#positional-index">692 Positional Index</a></li>
  <li><a href="#tfidf-weighting" id="toc-tfidf-weighting" class="nav-link" data-scroll-target="#tfidf-weighting">693 TF–IDF Weighting</a></li>
  <li><a href="#bm25-ranking" id="toc-bm25-ranking" class="nav-link" data-scroll-target="#bm25-ranking">694 BM25 Ranking</a></li>
  <li><a href="#trie-index" id="toc-trie-index" class="nav-link" data-scroll-target="#trie-index">695 Trie Index</a></li>
  <li><a href="#suffix-array-index" id="toc-suffix-array-index" class="nav-link" data-scroll-target="#suffix-array-index">696 Suffix Array Index</a></li>
  <li><a href="#compressed-suffix-array" id="toc-compressed-suffix-array" class="nav-link" data-scroll-target="#compressed-suffix-array">697 Compressed Suffix Array</a></li>
  <li><a href="#fm-index" id="toc-fm-index" class="nav-link" data-scroll-target="#fm-index">698 FM-Index</a></li>
  <li><a href="#directed-acyclic-word-graph-dawg" id="toc-directed-acyclic-word-graph-dawg" class="nav-link" data-scroll-target="#directed-acyclic-word-graph-dawg">699 Directed Acyclic Word Graph (DAWG)</a></li>
  <li><a href="#wavelet-tree-for-text" id="toc-wavelet-tree-for-text" class="nav-link" data-scroll-target="#wavelet-tree-for-text">700 Wavelet Tree for Text</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Chapter 7. Strings and Text Algorithms</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="section-61.-string-matching" class="level1">
<h1>Section 61. String Matching</h1>
<section id="naive-string-matching" class="level3">
<h3 class="anchored" data-anchor-id="naive-string-matching">601 Naive String Matching</h3>
<p>Naive string matching is the simplest way to find a pattern inside a text. It checks every possible position in the text to see if the pattern fits. Though not the fastest, it’s the most intuitive, perfect for understanding how pattern matching begins.</p>
<section id="what-problem-are-we-solving" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving">What Problem Are We Solving?</h4>
<p>We’re given:</p>
<ul>
<li>A text <code>T</code> of length <code>n</code></li>
<li>A pattern <code>P</code> of length <code>m</code></li>
</ul>
<p>We want to find all occurrences of <code>P</code> inside <code>T</code>.</p>
<p>Example: Text: <code>"ABABABCABABABCAB"</code> Pattern: <code>"ABABC"</code></p>
<p>We need to check every possible starting position in <code>T</code> to see if all characters match.</p>
</section>
<section id="how-does-it-work-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language">How Does It Work (Plain Language)?</h4>
<p>Imagine sliding the pattern across the text one character at a time. At each position:</p>
<ol type="1">
<li>Compare all characters of the pattern with the text.</li>
<li>If all match, record a hit.</li>
<li>If a mismatch happens, slide one step and try again.</li>
</ol>
<p>It’s like looking through a magnifying glass, shift one letter, scan again.</p>
<p>Step-by-step example:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Shift</th>
<th>Text Window</th>
<th>Match?</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>ABABA</td>
<td>No</td>
<td>mismatch at 5th char</td>
</tr>
<tr class="even">
<td>1</td>
<td>BABAB</td>
<td>No</td>
<td>mismatch at 1st char</td>
</tr>
<tr class="odd">
<td>2</td>
<td>ABABC</td>
<td>Ok</td>
<td>full match</td>
</tr>
<tr class="even">
<td>3</td>
<td>BABCA</td>
<td>No</td>
<td>mismatch at 1st char</td>
</tr>
</tbody>
</table>
<p>We repeat until we reach the last valid window (n - m).</p>
</section>
<section id="tiny-code-easy-versions" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> naive_search<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>pattern<span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>j <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span> text<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">==</span> pattern<span class="op">[</span>j<span class="op">])</span> j<span class="op">++;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> m<span class="op">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match found at index </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern <span class="op">=</span> <span class="st">"ABABC"</span><span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    naive_search<span class="op">(</span>text<span class="op">,</span> pattern<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> naive_search(text, pattern):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pattern)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> text[i:i<span class="op">+</span>m] <span class="op">==</span> pattern:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"ABABC"</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>naive_search(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters">Why It Matters</h4>
<ul>
<li>Builds intuition for pattern matching.</li>
<li>Basis for more advanced algorithms (KMP, Z, Rabin–Karp).</li>
<li>Easy to implement and debug.</li>
<li>Useful when <code>n</code> and <code>m</code> are small or comparisons are cheap.</li>
</ul>
</section>
<section id="complexity" class="level4">
<h4 class="anchored" data-anchor-id="complexity">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Description</th>
<th>Comparisons</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Best</td>
<td>First char mismatch each time</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td>Worst</td>
<td>Almost full match each shift</td>
<td>O(n·m)</td>
<td>O(nm)</td>
</tr>
<tr class="odd">
<td>Space</td>
<td>Only indexes and counters</td>
<td>O(1)</td>
<td></td>
</tr>
</tbody>
</table>
<p>The naive method has O(nm) worst-case time, slow for large texts, but simple and deterministic.</p>
</section>
<section id="try-it-yourself" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself">Try It Yourself</h4>
<ol type="1">
<li>Run the code on <code>"AAAAAA"</code> with pattern <code>"AAA"</code>. How many matches do you find?</li>
<li>Try <code>"ABCDE"</code> with pattern <code>"FG"</code>. How fast does it fail?</li>
<li>Measure number of comparisons for <code>n=10</code>, <code>m=3</code>.</li>
<li>Modify code to stop after the first match.</li>
<li>Extend it to case-insensitive matching.</li>
</ol>
<p>Naive string matching is your first lens into the world of text algorithms. Simple, honest, and tireless, it checks every corner until it finds what you seek.</p>
</section>
</section>
<section id="knuthmorrispratt-kmp" class="level3">
<h3 class="anchored" data-anchor-id="knuthmorrispratt-kmp">602 Knuth–Morris–Pratt (KMP)</h3>
<p>Knuth–Morris–Pratt (KMP) is how we match patterns without backtracking. Instead of rechecking characters we’ve already compared, KMP uses prefix knowledge to skip ahead smartly. It’s the first big leap from brute force to linear-time searching.</p>
<section id="what-problem-are-we-solving-1" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-1">What Problem Are We Solving?</h4>
<p>In naive search, when a mismatch happens, we move just one position and start over, wasting time re-checking prefixes. KMP fixes that.</p>
<p>We’re solving:</p>
<blockquote class="blockquote">
<p>How can we reuse past comparisons to avoid redundant work?</p>
</blockquote>
<p>Given:</p>
<ul>
<li>Text <code>T</code> of length <code>n</code></li>
<li>Pattern <code>P</code> of length <code>m</code></li>
</ul>
<p>We want all starting positions of <code>P</code> in <code>T</code>, in O(n + m) time.</p>
<p>Example: Text: <code>"ABABABCABABABCAB"</code> Pattern: <code>"ABABC"</code></p>
<p>When mismatch happens at <code>P[j]</code>, we shift pattern using what we already know about its prefix and suffix.</p>
</section>
<section id="how-does-it-work-plain-language-1" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-1">How Does It Work (Plain Language)?</h4>
<p>KMP has two main steps:</p>
<ol type="1">
<li><p>Preprocess Pattern (Build Prefix Table): Compute <code>lps[]</code> (longest proper prefix which is also suffix) for each prefix of <code>P</code>. This table tells us <em>how much we can safely skip</em> after a mismatch.</p></li>
<li><p>Scan Text Using Prefix Table: Compare text and pattern characters. When mismatch occurs at <code>j</code>, instead of restarting, jump <code>j = lps[j-1]</code>.</p></li>
</ol>
<p>Think of <code>lps</code> as a “memory”, it remembers how far we matched before the mismatch.</p>
<p>Example pattern: <code>"ABABC"</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>P[i]</th>
<th>LPS[i]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>A</td>
<td>0</td>
<td>no prefix-suffix match</td>
</tr>
<tr class="even">
<td>1</td>
<td>B</td>
<td>0</td>
<td>“A”≠“B”</td>
</tr>
<tr class="odd">
<td>2</td>
<td>A</td>
<td>1</td>
<td>“A”</td>
</tr>
<tr class="even">
<td>3</td>
<td>B</td>
<td>2</td>
<td>“AB”</td>
</tr>
<tr class="odd">
<td>4</td>
<td>C</td>
<td>0</td>
<td>no match</td>
</tr>
</tbody>
</table>
<p>So <code>lps = [0, 0, 1, 2, 0]</code></p>
<p>When mismatch happens at position 4 (<code>C</code>), we skip to index 2 in the pattern, no re-check needed.</p>
</section>
<section id="tiny-code-easy-versions-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-1">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compute_lps<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pat<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>lps<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    lps<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pat<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> pat<span class="op">[</span>len<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            lps<span class="op">[</span>i<span class="op">++]</span> <span class="op">=</span> <span class="op">++</span>len<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>len <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            len <span class="op">=</span> lps<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            lps<span class="op">[</span>i<span class="op">++]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> kmp_search<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pat<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>pat<span class="op">);</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lps<span class="op">[</span>m<span class="op">];</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    compute_lps<span class="op">(</span>pat<span class="op">,</span> m<span class="op">,</span> lps<span class="op">);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>text<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> pat<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span> i<span class="op">++;</span> j<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match found at index </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i <span class="op">-</span> j<span class="op">);</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> lps<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> text<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> pat<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> j <span class="op">=</span> lps<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> i<span class="op">++;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span><span class="op">;</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern <span class="op">=</span> <span class="st">"ABABC"</span><span class="op">;</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    kmp_search<span class="op">(</span>text<span class="op">,</span> pattern<span class="op">);</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_lps(p):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(p)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    lps <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>m</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> m:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p[i] <span class="op">==</span> p[length]:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            length <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            lps[i] <span class="op">=</span> length</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> length <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            length <span class="op">=</span> lps[length <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            lps[i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lps</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kmp_search(text, pat):</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pat)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    lps <span class="op">=</span> compute_lps(pat)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> n:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> text[i] <span class="op">==</span> pat[j]:</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">==</span> m:</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i <span class="op">-</span> j)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> lps[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">&lt;</span> n <span class="kw">and</span> text[i] <span class="op">!=</span> pat[j]:</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> lps[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> j <span class="cf">else</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">-</span> (i <span class="op">-</span> j)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span>: i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"ABABC"</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>kmp_search(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-1" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-1">Why It Matters</h4>
<ul>
<li>Avoids re-checking, true linear time.</li>
<li>Foundation for fast text search (editors, grep).</li>
<li>Inspires other algorithms (Z-Algorithm, Aho–Corasick).</li>
<li>Teaches preprocessing patterns, not just texts.</li>
</ul>
</section>
<section id="complexity-1" class="level4">
<h4 class="anchored" data-anchor-id="complexity-1">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Phase</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LPS preprocessing</td>
<td>O(m)</td>
<td>O(m)</td>
</tr>
<tr class="even">
<td>Search</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="odd">
<td>Total</td>
<td>O(n + m)</td>
<td>O(m)</td>
</tr>
</tbody>
</table>
<p>Worst-case linear, every character checked once.</p>
</section>
<section id="try-it-yourself-1" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-1">Try It Yourself</h4>
<ol type="1">
<li>Build <code>lps</code> for <code>"AAAA"</code>, <code>"ABABAC"</code>, and <code>"AABAACAABAA"</code>.</li>
<li>Modify code to count total matches instead of printing.</li>
<li>Compare with naive search, count comparisons.</li>
<li>Visualize the <code>lps</code> table with arrows showing skips.</li>
<li>Search <code>"AAAAAB"</code> in <code>"AAAAAAAAB"</code>, notice the skip efficiency.</li>
</ol>
<p>KMP is your first clever matcher, it never looks back, always remembers what it’s learned, and glides across the text with confidence.</p>
</section>
</section>
<section id="z-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="z-algorithm">603 Z-Algorithm</h3>
<p>The Z-Algorithm is a fast way to find pattern matches by precomputing how much of the prefix matches at every position. It builds a “Z-array” that measures prefix overlap, a clever mirror trick for string searching.</p>
<section id="what-problem-are-we-solving-2" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-2">What Problem Are We Solving?</h4>
<p>We want to find all occurrences of a pattern <code>P</code> in a text <code>T</code>, but without extra scanning or repeated comparisons.</p>
<p>Idea: If we know how many characters match from the beginning of the string at each position, we can detect pattern matches instantly.</p>
<p>So we build a helper string:</p>
<pre><code>S = P + '$' + T</code></pre>
<p>and compute <code>Z[i]</code> = length of longest substring starting at <code>i</code> that matches prefix of <code>S</code>.</p>
<p>If <code>Z[i]</code> equals length of <code>P</code>, we found a match in <code>T</code>.</p>
<p>Example: P = <code>"ABABC"</code> T = <code>"ABABABCABABABCAB"</code> S = <code>"ABABC$ABABABCABABABCAB"</code></p>
<p>Whenever <code>Z[i] = len(P) = 5</code>, that’s a full match.</p>
</section>
<section id="how-does-it-work-plain-language-2" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-2">How Does It Work (Plain Language)?</h4>
<p>The Z-array encodes how much the string matches itself starting from each index.</p>
<p>We scan through <code>S</code> and maintain a window [L, R] representing the current rightmost match segment. For each position <code>i</code>:</p>
<ol type="1">
<li>If <code>i &gt; R</code>, compare from scratch.</li>
<li>Else, copy information from <code>Z[i-L]</code> inside the window.</li>
<li>Extend match beyond <code>R</code> if possible.</li>
</ol>
<p>It’s like using a mirror, if you already know a window of matches, you can skip redundant checks inside it.</p>
<p>Example for <code>"aabxaayaab"</code>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>S[i]</th>
<th>Z[i]</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>a</td>
<td>0</td>
<td>(always 0)</td>
</tr>
<tr class="even">
<td>1</td>
<td>a</td>
<td>1</td>
<td>matches “a”</td>
</tr>
<tr class="odd">
<td>2</td>
<td>b</td>
<td>0</td>
<td>mismatch</td>
</tr>
<tr class="even">
<td>3</td>
<td>x</td>
<td>0</td>
<td>mismatch</td>
</tr>
<tr class="odd">
<td>4</td>
<td>a</td>
<td>2</td>
<td>matches “aa”</td>
</tr>
<tr class="even">
<td>5</td>
<td>a</td>
<td>1</td>
<td>matches “a”</td>
</tr>
<tr class="odd">
<td>6</td>
<td>y</td>
<td>0</td>
<td>mismatch</td>
</tr>
<tr class="even">
<td>7</td>
<td>a</td>
<td>3</td>
<td>matches “aab”</td>
</tr>
<tr class="odd">
<td>8</td>
<td>a</td>
<td>2</td>
<td>matches “aa”</td>
</tr>
<tr class="even">
<td>9</td>
<td>b</td>
<td>1</td>
<td>matches “a”</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-easy-versions-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-2">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compute_z<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> z<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> L <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> R <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    z<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;=</span> R<span class="op">)</span> z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>R <span class="op">-</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> z<span class="op">[</span>i <span class="op">-</span> L<span class="op">])</span> <span class="op">?</span> <span class="op">(</span>R <span class="op">-</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">:</span> z<span class="op">[</span>i <span class="op">-</span> L<span class="op">];</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>i <span class="op">+</span> z<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> s<span class="op">[</span>z<span class="op">[</span>i<span class="op">]]</span> <span class="op">==</span> s<span class="op">[</span>i <span class="op">+</span> z<span class="op">[</span>i<span class="op">]])</span> z<span class="op">[</span>i<span class="op">]++;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">+</span> z<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;</span> R<span class="op">)</span> <span class="op">{</span> L <span class="op">=</span> i<span class="op">;</span> R <span class="op">=</span> i <span class="op">+</span> z<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> z_search<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pat<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> s<span class="op">[</span><span class="dv">1000</span><span class="op">];</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    sprintf<span class="op">(</span>s<span class="op">,</span> <span class="st">"</span><span class="sc">%s</span><span class="st">$</span><span class="sc">%s</span><span class="st">"</span><span class="op">,</span> pat<span class="op">,</span> text<span class="op">);</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> z<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    compute_z<span class="op">(</span>s<span class="op">,</span> z<span class="op">);</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>pat<span class="op">);</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>z<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> m<span class="op">)</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match found at index </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i <span class="op">-</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span><span class="op">;</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern <span class="op">=</span> <span class="st">"ABABC"</span><span class="op">;</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    z_search<span class="op">(</span>text<span class="op">,</span> pattern<span class="op">);</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_z(s):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> R <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;=</span> R:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            z[i] <span class="op">=</span> <span class="bu">min</span>(R <span class="op">-</span> i <span class="op">+</span> <span class="dv">1</span>, z[i <span class="op">-</span> L])</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">+</span> z[i] <span class="op">&lt;</span> n <span class="kw">and</span> s[z[i]] <span class="op">==</span> s[i <span class="op">+</span> z[i]]:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            z[i] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">+</span> z[i] <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;</span> R:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            L, R <span class="op">=</span> i, i <span class="op">+</span> z[i] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> z_search(text, pat):</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> pat <span class="op">+</span> <span class="st">'$'</span> <span class="op">+</span> text</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> compute_z(s)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pat)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(z)):</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> z[i] <span class="op">==</span> m:</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i <span class="op">-</span> m <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"ABABC"</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>z_search(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-2" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-2">Why It Matters</h4>
<ul>
<li>Linear-time pattern matching (O(n + m)).</li>
<li>Builds intuition for prefix overlap and self-similarity.</li>
<li>Used in pattern detection, DNA analysis, compression.</li>
<li>Related to KMP, but often simpler to implement.</li>
</ul>
</section>
<section id="complexity-2" class="level4">
<h4 class="anchored" data-anchor-id="complexity-2">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compute Z-array</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td>Search</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Total complexity: O(n + m)</p>
</section>
<section id="try-it-yourself-2" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-2">Try It Yourself</h4>
<ol type="1">
<li>Compute Z-array for <code>"AAABAAA"</code>.</li>
<li>Change <code>$</code> separator to other symbols, why must it differ?</li>
<li>Compare Z-array of <code>"abcabcabc"</code> and <code>"aaaaa"</code>.</li>
<li>Count how many positions have <code>Z[i] &gt; 0</code>.</li>
<li>Visualize Z-box sliding across the string.</li>
</ol>
<p>The Z-Algorithm reads strings like a mirror reads light, matching prefixes, skipping repetition, and revealing structure hidden in plain sight.</p>
</section>
</section>
<section id="rabinkarp" class="level3">
<h3 class="anchored" data-anchor-id="rabinkarp">604 Rabin–Karp</h3>
<p>Rabin–Karp is a clever algorithm that matches patterns using rolling hashes instead of character-by-character comparison. It turns strings into numbers, so comparing substrings becomes comparing integers. Fast, simple, and great for multi-pattern search.</p>
<section id="what-problem-are-we-solving-3" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-3">What Problem Are We Solving?</h4>
<p>We want to find all occurrences of a pattern <code>P</code> (length <code>m</code>) inside a text <code>T</code> (length <code>n</code>).</p>
<p>The naive approach compares substrings character by character. Rabin–Karp instead compares hashes, if two substrings share the same hash, we only compare characters to confirm.</p>
<p>The trick is a rolling hash: We can compute the hash of the next substring in O(1) time from the previous one.</p>
<p>Example: Text: <code>"ABABABCABABABCAB"</code> Pattern: <code>"ABABC"</code> Instead of checking every 5-letter window, we roll a hash across the text, checking only when hashes match.</p>
</section>
<section id="how-does-it-work-plain-language-3" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-3">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Choose a base and modulus. Use a base <code>b</code> (like 256) and a large prime modulus <code>M</code> to reduce collisions.</p></li>
<li><p>Compute pattern hash. Compute hash of <code>P[0..m-1]</code>.</p></li>
<li><p>Compute first window hash in text. Hash <code>T[0..m-1]</code>.</p></li>
<li><p>Slide the window. For each shift <code>i</code>:</p>
<ul>
<li><p>If <code>hash(T[i..i+m-1]) == hash(P)</code>, verify with character check.</p></li>
<li><p>Compute next hash efficiently:</p>
<pre><code>new_hash = (b * (old_hash - T[i]*b^(m-1)) + T[i+m]) mod M</code></pre></li>
</ul></li>
</ol>
<p>It’s like checking fingerprints: If fingerprints match, then check the faces to confirm.</p>
</section>
<section id="example" class="level4">
<h4 class="anchored" data-anchor-id="example">Example</h4>
<p>Let’s match <code>"AB"</code> in <code>"ABAB"</code>:</p>
<ul>
<li><p>base = 256, M = 101</p></li>
<li><p>hash(“AB”) = (65×256 + 66) mod 101</p></li>
<li><p>Slide window across <code>"ABAB"</code>:</p>
<ul>
<li>window 0: <code>"AB"</code> → same hash → match</li>
<li>window 1: <code>"BA"</code> → different hash → skip</li>
<li>window 2: <code>"AB"</code> → same hash → match</li>
</ul></li>
</ul>
<p>Only two character checks total!</p>
</section>
<section id="tiny-code-easy-versions-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-3">Tiny Code (Easy Versions)</h4>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BASE </span><span class="dv">256</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MOD </span><span class="dv">101</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rabin_karp<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pat<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>pat<span class="op">);</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> h <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> h <span class="op">=</span> <span class="op">(</span>h <span class="op">*</span> BASE<span class="op">)</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> t <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="op">(</span>BASE <span class="op">*</span> p <span class="op">+</span> pat<span class="op">[</span>i<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> <span class="op">(</span>BASE <span class="op">*</span> t <span class="op">+</span> text<span class="op">[</span>i<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>p <span class="op">==</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> match <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>text<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">!=</span> pat<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span> match <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>match<span class="op">)</span> printf<span class="op">(</span><span class="st">"Match found at index </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> n <span class="op">-</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> <span class="op">(</span>BASE <span class="op">*</span> <span class="op">(</span>t <span class="op">-</span> text<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> h<span class="op">)</span> <span class="op">+</span> text<span class="op">[</span>i <span class="op">+</span> m<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>t <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> t <span class="op">+=</span> MOD<span class="op">;</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span><span class="op">;</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern <span class="op">=</span> <span class="st">"ABABC"</span><span class="op">;</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    rabin_karp<span class="op">(</span>text<span class="op">,</span> pattern<span class="op">);</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rabin_karp(text, pat, base<span class="op">=</span><span class="dv">256</span>, mod<span class="op">=</span><span class="dv">101</span>):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pat)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> <span class="bu">pow</span>(base, m<span class="op">-</span><span class="dv">1</span>, mod)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    p_hash <span class="op">=</span> t_hash <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        p_hash <span class="op">=</span> (base <span class="op">*</span> p_hash <span class="op">+</span> <span class="bu">ord</span>(pat[i])) <span class="op">%</span> mod</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        t_hash <span class="op">=</span> (base <span class="op">*</span> t_hash <span class="op">+</span> <span class="bu">ord</span>(text[i])) <span class="op">%</span> mod</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p_hash <span class="op">==</span> t_hash:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> text[i:i<span class="op">+</span>m] <span class="op">==</span> pat:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> n <span class="op">-</span> m:</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            t_hash <span class="op">=</span> (base <span class="op">*</span> (t_hash <span class="op">-</span> <span class="bu">ord</span>(text[i]) <span class="op">*</span> h) <span class="op">+</span> <span class="bu">ord</span>(text[i<span class="op">+</span>m])) <span class="op">%</span> mod</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> t_hash <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>                t_hash <span class="op">+=</span> mod</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABABABCABABABCAB"</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"ABABC"</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>rabin_karp(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-3" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-3">Why It Matters</h4>
<ul>
<li>Enables efficient substring search with hashing.</li>
<li>Supports multiple patterns (hash each pattern).</li>
<li>Useful in plagiarism detection, data deduplication, bioinformatics.</li>
<li>Introduces rolling hash, foundational for many algorithms (Karp–Rabin, Z, string fingerprints, Rabin fingerprints, Bloom filters).</li>
</ul>
</section>
<section id="complexity-3" class="level4">
<h4 class="anchored" data-anchor-id="complexity-3">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Average</td>
<td>O(n + m)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>Worst (many hash collisions)</td>
<td>O(nm)</td>
<td>O(1)</td>
</tr>
<tr class="odd">
<td>Expected (good hash)</td>
<td>O(n + m)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Rolling hash makes it <em>fast in practice</em>.</p>
</section>
<section id="try-it-yourself-3" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-3">Try It Yourself</h4>
<ol type="1">
<li>Use base = 10 and mod = 13, match <code>"31"</code> in <code>"313131"</code>.</li>
<li>Print hash values for each window, spot collisions.</li>
<li>Replace mod = 101 with a small number, what happens?</li>
<li>Try multiple patterns (like <code>"AB"</code>, <code>"ABC"</code>) together.</li>
<li>Compare Rabin–Karp’s speed with naive search on large input.</li>
</ol>
<p>Rabin–Karp turns text into numbers, matching becomes math. Slide the window, roll the hash, and let arithmetic guide your search.</p>
</section>
</section>
<section id="boyermoore" class="level3">
<h3 class="anchored" data-anchor-id="boyermoore">605 Boyer–Moore</h3>
<p>Boyer–Moore is one of the fastest practical string search algorithms. It reads the text backward from the end of the pattern and skips large chunks of text on mismatches. It’s built on two key insights: bad character rule and good suffix rule.</p>
<section id="what-problem-are-we-solving-4" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-4">What Problem Are We Solving?</h4>
<p>In naive and KMP algorithms, we move the pattern only one position when a mismatch occurs. But what if we could skip multiple positions safely?</p>
<p>Boyer–Moore does exactly that, it looks from right to left, and when a mismatch happens, it uses precomputed tables to decide how far to shift.</p>
<p>Given:</p>
<ul>
<li>Text <code>T</code> of length <code>n</code></li>
<li>Pattern <code>P</code> of length <code>m</code></li>
</ul>
<p>We want to find all positions where <code>P</code> appears in <code>T</code>, with fewer comparisons.</p>
<p>Example: Text: <code>"HERE IS A SIMPLE EXAMPLE"</code> Pattern: <code>"EXAMPLE"</code></p>
<p>Instead of scanning every position, Boyer–Moore might skip entire words.</p>
</section>
<section id="how-does-it-work-plain-language-4" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-4">How Does It Work (Plain Language)?</h4>
<ol type="1">
<li><p>Preprocess pattern to build shift tables:</p>
<ul>
<li><p>Bad Character Table: When mismatch at <code>P[j]</code> occurs, shift so that the last occurrence of <code>T[i]</code> in <code>P</code> aligns with position <code>j</code>. If <code>T[i]</code> not in pattern, skip whole length <code>m</code>.</p></li>
<li><p>Good Suffix Table: When suffix matches but mismatch happens before it, shift pattern to align with next occurrence of that suffix.</p></li>
</ul></li>
<li><p>Search:</p>
<ul>
<li>Align pattern with text.</li>
<li>Compare from right to left.</li>
<li>On mismatch, apply max shift from both tables.</li>
</ul></li>
</ol>
<p>It’s like reading the text in reverse, you jump quickly when you know the mismatch tells you more than a match.</p>
</section>
<section id="example-bad-character-rule" class="level4">
<h4 class="anchored" data-anchor-id="example-bad-character-rule">Example (Bad Character Rule)</h4>
<p>Pattern: <code>"ABCD"</code> Text: <code>"ZZABCXABCD"</code></p>
<ol type="1">
<li>Compare <code>"ABCD"</code> with text segment ending at position 3</li>
<li>Mismatch at <code>X</code></li>
<li><code>X</code> not in pattern → shift by 4</li>
<li>New alignment starts at next possible match</li>
</ol>
<p>Fewer comparisons, smarter skipping.</p>
</section>
<section id="tiny-code-easy-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version">Tiny Code (Easy Version)</h4>
<p>Python (Bad Character Rule Only)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bad_char_table(pat):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    table <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="dv">256</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(pat):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        table[<span class="bu">ord</span>(ch)] <span class="op">=</span> i</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> table</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> boyer_moore(text, pat):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pat)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    bad <span class="op">=</span> bad_char_table(pat)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;=</span> n <span class="op">-</span> m:</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> m <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> pat[j] <span class="op">==</span> text[i <span class="op">+</span> j]:</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> (m <span class="op">-</span> bad[<span class="bu">ord</span>(text[i <span class="op">+</span> m])] <span class="cf">if</span> i <span class="op">+</span> m <span class="op">&lt;</span> n <span class="cf">else</span> <span class="dv">1</span>)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="bu">max</span>(<span class="dv">1</span>, j <span class="op">-</span> bad[<span class="bu">ord</span>(text[i <span class="op">+</span> j])])</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"HERE IS A SIMPLE EXAMPLE"</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"EXAMPLE"</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>boyer_moore(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This version uses only the bad character rule, which already gives strong performance for general text.</p>
</section>
<section id="why-it-matters-4" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-4">Why It Matters</h4>
<ul>
<li><p>Skips large portions of text.</p></li>
<li><p>Sublinear average time, often faster than O(n).</p></li>
<li><p>Foundation for advanced variants:</p>
<ul>
<li>Boyer–Moore–Horspool</li>
<li>Sunday algorithm</li>
</ul></li>
<li><p>Widely used in text editors, grep, search engines.</p></li>
</ul>
</section>
<section id="complexity-4" class="level4">
<h4 class="anchored" data-anchor-id="complexity-4">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Best</td>
<td>O(n / m)</td>
<td>O(m + σ)</td>
</tr>
<tr class="even">
<td>Average</td>
<td>Sublinear</td>
<td>O(m + σ)</td>
</tr>
<tr class="odd">
<td>Worst</td>
<td>O(nm)</td>
<td>O(m + σ)</td>
</tr>
</tbody>
</table>
<p>(σ = alphabet size)</p>
<p>In practice, one of the fastest algorithms for searching long patterns in long texts.</p>
</section>
<section id="try-it-yourself-4" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-4">Try It Yourself</h4>
<ol type="1">
<li>Trace <code>"ABCD"</code> in <code>"ZZABCXABCD"</code> step by step.</li>
<li>Print the bad character table, check shift values.</li>
<li>Add good suffix rule (advanced).</li>
<li>Compare with naive search for <code>"needle"</code> in <code>"haystack"</code>.</li>
<li>Measure comparisons, how many are skipped?</li>
</ol>
<p>Boyer–Moore searches with hindsight. It looks backward, learns from mismatches, and leaps ahead, a masterclass in efficient searching.</p>
</section>
</section>
<section id="boyermoorehorspool" class="level3">
<h3 class="anchored" data-anchor-id="boyermoorehorspool">606 Boyer–Moore–Horspool</h3>
<p>The Boyer–Moore–Horspool algorithm is a streamlined version of Boyer–Moore. It drops the good-suffix rule and focuses on a single bad-character skip table, making it shorter, simpler, and often faster in practice for average cases.</p>
<section id="what-problem-are-we-solving-5" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-5">What Problem Are We Solving?</h4>
<p>Classic Boyer–Moore is powerful but complex, two tables, multiple rules, tricky to implement.</p>
<p>Boyer–Moore–Horspool keeps the essence of Boyer–Moore (right-to-left scanning and skipping) but simplifies logic so anyone can code it easily and get sublinear performance on average.</p>
<p>Given:</p>
<ul>
<li>Text <code>T</code> of length <code>n</code></li>
<li>Pattern <code>P</code> of length <code>m</code></li>
</ul>
<p>We want to find every occurrence of <code>P</code> in <code>T</code> with fewer comparisons than naive search, but with easy implementation.</p>
</section>
<section id="how-does-it-work-plain-language-5" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-5">How Does It Work (Plain Language)?</h4>
<p>It scans the text right to left inside each alignment and uses a single skip table.</p>
<ol type="1">
<li><p>Preprocess pattern: For each character <code>c</code> in the alphabet:</p>
<ul>
<li><code>shift[c] = m</code> Then, for each pattern position <code>i</code> (0 to m−2):</li>
<li><code>shift[P[i]] = m - i - 1</code></li>
</ul></li>
<li><p>Search phase:</p>
<ul>
<li>Align pattern with text at position <code>i</code></li>
<li>Compare pattern backward from <code>P[m-1]</code></li>
<li>If mismatch, shift window by <code>shift[text[i + m - 1]]</code></li>
<li>If match, report position and shift same way</li>
</ul></li>
</ol>
<p>Each mismatch may skip several characters at once.</p>
</section>
<section id="example-1" class="level4">
<h4 class="anchored" data-anchor-id="example-1">Example</h4>
<p>Text: <code>"EXAMPLEEXAMPLES"</code> Pattern: <code>"EXAMPLE"</code></p>
<p>Pattern length <code>m = 7</code></p>
<p>Skip table (m−i−1 rule):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Char</th>
<th>Shift</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E</td>
<td>6</td>
</tr>
<tr class="even">
<td>X</td>
<td>5</td>
</tr>
<tr class="odd">
<td>A</td>
<td>4</td>
</tr>
<tr class="even">
<td>M</td>
<td>3</td>
</tr>
<tr class="odd">
<td>P</td>
<td>2</td>
</tr>
<tr class="even">
<td>L</td>
<td>1</td>
</tr>
<tr class="odd">
<td>others</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>Scan right-to-left:</p>
<ul>
<li>Align <code>"EXAMPLE"</code> over text, compare from <code>L</code> backward</li>
<li>On mismatch, look at last char under window → skip accordingly</li>
</ul>
<p>Skips quickly over non-promising segments.</p>
</section>
<section id="tiny-code-easy-versions-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-4">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> horspool(text, pat):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pat)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    shift <span class="op">=</span> {ch: m <span class="cf">for</span> ch <span class="kw">in</span> <span class="bu">set</span>(text)}</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        shift[pat[i]] <span class="op">=</span> m <span class="op">-</span> i <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;=</span> n <span class="op">-</span> m:</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> m <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> pat[j] <span class="op">==</span> text[i <span class="op">+</span> j]:</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> shift.get(text[i <span class="op">+</span> m <span class="op">-</span> <span class="dv">1</span>], m)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> shift.get(text[i <span class="op">+</span> m <span class="op">-</span> <span class="dv">1</span>], m)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"EXAMPLEEXAMPLES"</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"EXAMPLE"</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>horspool(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (Simplified Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ALPHABET </span><span class="dv">256</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> horspool<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pat<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>pat<span class="op">);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> shift<span class="op">[</span>ALPHABET<span class="op">];</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ALPHABET<span class="op">;</span> i<span class="op">++)</span> shift<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> m<span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        shift<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>pat<span class="op">[</span>i<span class="op">]]</span> <span class="op">=</span> m <span class="op">-</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;=</span> n <span class="op">-</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> pat<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> text<span class="op">[</span>i <span class="op">+</span> j<span class="op">])</span> j<span class="op">--;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match found at index </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> shift<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>text<span class="op">[</span>i <span class="op">+</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">]];</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    horspool<span class="op">(</span><span class="st">"EXAMPLEEXAMPLES"</span><span class="op">,</span> <span class="st">"EXAMPLE"</span><span class="op">);</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-5" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-5">Why It Matters</h4>
<ul>
<li>Simpler than full Boyer–Moore.</li>
<li>Fast in practice, especially on random text.</li>
<li>Great choice when you need quick implementation and good performance.</li>
<li>Used in editors and search tools for medium-length patterns.</li>
</ul>
</section>
<section id="complexity-5" class="level4">
<h4 class="anchored" data-anchor-id="complexity-5">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Best</td>
<td>O(n / m)</td>
<td>O(σ)</td>
</tr>
<tr class="even">
<td>Average</td>
<td>Sublinear</td>
<td>O(σ)</td>
</tr>
<tr class="odd">
<td>Worst</td>
<td>O(nm)</td>
<td>O(σ)</td>
</tr>
</tbody>
</table>
<p>σ = alphabet size (e.g., 256)</p>
<p>Most texts produce few comparisons per window → often faster than KMP.</p>
</section>
<section id="try-it-yourself-5" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-5">Try It Yourself</h4>
<ol type="1">
<li>Print skip table for <code>"ABCDAB"</code>.</li>
<li>Compare number of shifts with KMP on <code>"ABABABCABABABCAB"</code>.</li>
<li>Change one letter in pattern, how do skips change?</li>
<li>Count comparisons vs naive algorithm.</li>
<li>Implement skip table with dictionary vs array, measure speed.</li>
</ol>
<p>Boyer–Moore–Horspool is like a lean racer, it skips ahead with confidence, cutting the weight but keeping the power.</p>
</section>
</section>
<section id="sunday-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="sunday-algorithm">607 Sunday Algorithm</h3>
<p>The Sunday algorithm is a lightweight, intuitive string search method that looks ahead, instead of focusing on mismatches inside the current window, it peeks at the next character in the text to decide how far to jump. It’s simple, elegant, and often faster than more complex algorithms in practice.</p>
<section id="what-problem-are-we-solving-6" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-6">What Problem Are We Solving?</h4>
<p>In naive search, we shift the pattern one step at a time. In Boyer–Moore, we look backward at mismatched characters. But what if we could peek one step forward instead, and skip the maximum possible distance?</p>
<p>The Sunday algorithm asks:</p>
<blockquote class="blockquote">
<p>“What’s the character right after my current window?” If that character isn’t in the pattern, skip the whole window.</p>
</blockquote>
<p>Given:</p>
<ul>
<li>Text <code>T</code> (length <code>n</code>)</li>
<li>Pattern <code>P</code> (length <code>m</code>)</li>
</ul>
<p>We want to find all occurrences of <code>P</code> in <code>T</code> with fewer shifts, guided by the next unseen character.</p>
</section>
<section id="how-does-it-work-plain-language-6" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-6">How Does It Work (Plain Language)?</h4>
<p>Think of sliding a magnifier over the text. Each time you check a window, peek at the character just after it.</p>
<p>If it’s not in the pattern, shift the pattern past it (by <code>m + 1</code>). If it is in the pattern, align that character in the text with its last occurrence in the pattern.</p>
<p>Steps:</p>
<ol type="1">
<li>Precompute shift table: for each character <code>c</code> in the alphabet, <code>shift[c] = m - last_index(c)</code> Default shift for unseen characters: <code>m + 1</code></li>
<li>Compare text and pattern left-to-right inside window.</li>
<li>If mismatch or no match, check the next character <code>T[i + m]</code> and shift accordingly.</li>
</ol>
<p>It skips based on future information, not past mismatches, that’s its charm.</p>
</section>
<section id="example-2" class="level4">
<h4 class="anchored" data-anchor-id="example-2">Example</h4>
<p>Text: <code>"EXAMPLEEXAMPLES"</code> Pattern: <code>"EXAMPLE"</code></p>
<p>m = 7</p>
<p>Shift table (from last occurrence):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Char</th>
<th>Shift</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E</td>
<td>1</td>
</tr>
<tr class="even">
<td>X</td>
<td>2</td>
</tr>
<tr class="odd">
<td>A</td>
<td>3</td>
</tr>
<tr class="even">
<td>M</td>
<td>4</td>
</tr>
<tr class="odd">
<td>P</td>
<td>5</td>
</tr>
<tr class="even">
<td>L</td>
<td>6</td>
</tr>
<tr class="odd">
<td>Others</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Steps:</p>
<ul>
<li>Compare <code>"EXAMPLE"</code> with <code>"EXAMPLE"</code> → match at 0</li>
<li>Next char: <code>E</code> → shift by 1</li>
<li>Compare next window → match again Quick, forward-looking, efficient.</li>
</ul>
</section>
<section id="tiny-code-easy-versions-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-5">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sunday(text, pat):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pat)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    shift <span class="op">=</span> {ch: m <span class="op">-</span> i <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(pat)}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    default <span class="op">=</span> m <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;=</span> n <span class="op">-</span> m:</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&lt;</span> m <span class="kw">and</span> pat[j] <span class="op">==</span> text[i <span class="op">+</span> j]:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">==</span> m:</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        next_char <span class="op">=</span> text[i <span class="op">+</span> m] <span class="cf">if</span> i <span class="op">+</span> m <span class="op">&lt;</span> n <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> shift.get(next_char, default)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"EXAMPLEEXAMPLES"</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"EXAMPLE"</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>sunday(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ALPHABET </span><span class="dv">256</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sunday<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pat<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>pat<span class="op">);</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> shift<span class="op">[</span>ALPHABET<span class="op">];</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ALPHABET<span class="op">;</span> i<span class="op">++)</span> shift<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> m <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        shift<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>pat<span class="op">[</span>i<span class="op">]]</span> <span class="op">=</span> m <span class="op">-</span> i<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;=</span> n <span class="op">-</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>j <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span> pat<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> text<span class="op">[</span>i <span class="op">+</span> j<span class="op">])</span> j<span class="op">++;</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> m<span class="op">)</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match found at index </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">char</span> next <span class="op">=</span> <span class="op">(</span>i <span class="op">+</span> m <span class="op">&lt;</span> n<span class="op">)</span> <span class="op">?</span> text<span class="op">[</span>i <span class="op">+</span> m<span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> shift<span class="op">[</span>next<span class="op">];</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    sunday<span class="op">(</span><span class="st">"EXAMPLEEXAMPLES"</span><span class="op">,</span> <span class="st">"EXAMPLE"</span><span class="op">);</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-6" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-6">Why It Matters</h4>
<ul>
<li>Simple: one shift table, no backward comparisons.</li>
<li>Fast in practice, especially for longer alphabets.</li>
<li>Great balance between clarity and speed.</li>
<li>Common in text editors, grep-like tools, and search libraries.</li>
</ul>
</section>
<section id="complexity-6" class="level4">
<h4 class="anchored" data-anchor-id="complexity-6">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Best</td>
<td>O(n / m)</td>
<td>O(σ)</td>
</tr>
<tr class="even">
<td>Average</td>
<td>Sublinear</td>
<td>O(σ)</td>
</tr>
<tr class="odd">
<td>Worst</td>
<td>O(nm)</td>
<td>O(σ)</td>
</tr>
</tbody>
</table>
<p>σ = alphabet size</p>
<p>On random text, very few comparisons per window.</p>
</section>
<section id="try-it-yourself-6" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-6">Try It Yourself</h4>
<ol type="1">
<li>Build shift table for <code>"HELLO"</code>.</li>
<li>Search <code>"LO"</code> in <code>"HELLOHELLO"</code>, trace each shift.</li>
<li>Compare skip lengths with Boyer–Moore–Horspool.</li>
<li>Try searching <code>"AAAB"</code> in <code>"AAAAAAAAAA"</code>, worst case?</li>
<li>Count total comparisons for <code>"ABCD"</code> in <code>"ABCDEABCD"</code>.</li>
</ol>
<p>The Sunday algorithm looks to tomorrow, one step ahead, always skipping what it can see coming.</p>
</section>
</section>
<section id="finite-automaton-matching" class="level3">
<h3 class="anchored" data-anchor-id="finite-automaton-matching">608 Finite Automaton Matching</h3>
<p>Finite Automaton Matching turns pattern searching into state transitions. It precomputes a deterministic finite automaton (DFA) that recognizes exactly the strings ending with the pattern, then simply runs the automaton over the text. Every step is constant time, every match is guaranteed.</p>
<section id="what-problem-are-we-solving-7" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-7">What Problem Are We Solving?</h4>
<p>We want to match a pattern <code>P</code> in a text <code>T</code> efficiently, with no backtracking and no re-checking.</p>
<p>Idea: Instead of comparing manually, we let a machine do the work, one that reads each character and updates its internal state until a match is found.</p>
<p>This algorithm builds a DFA where:</p>
<ul>
<li>Each state = how many characters of the pattern matched so far</li>
<li>Each transition = what happens when we read a new character</li>
</ul>
<p>Whenever the automaton enters the final state, a full match has been recognized.</p>
</section>
<section id="how-does-it-work-plain-language-7" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-7">How Does It Work (Plain Language)?</h4>
<p>Think of it like a “pattern-reading machine.” Each time we read a character, we move to the next state, or fall back if it breaks the pattern.</p>
<p>Steps:</p>
<ol type="1">
<li>Preprocess the pattern: Build a DFA table: <code>dfa[state][char]</code> = next state</li>
<li>Scan the text: Start at state 0, feed each character of the text. Each character moves you to a new state using the table. If you reach state <code>m</code> (pattern length), that’s a match.</li>
</ol>
<p>Every character is processed exactly once, no backtracking.</p>
</section>
<section id="example-3" class="level4">
<h4 class="anchored" data-anchor-id="example-3">Example</h4>
<p>Pattern: <code>"ABAB"</code></p>
<p>States: 0 → 1 → 2 → 3 → 4 Final state = 4 (full match)</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>State</th>
<th>on ‘A’</th>
<th>on ‘B’</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>start → A</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>2</td>
<td>after ‘A’, next ‘B’</td>
</tr>
<tr class="odd">
<td>2</td>
<td>3</td>
<td>0</td>
<td>after ‘AB’, next ‘A’</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>4</td>
<td>after ‘ABA’, next ‘B’</td>
</tr>
<tr class="odd">
<td>4</td>
<td>-</td>
<td>-</td>
<td>match found</td>
</tr>
</tbody>
</table>
<p>Feed the text <code>"ABABAB"</code> into this machine:</p>
<ul>
<li>Steps: 0→1→2→3→4 → match at index 0</li>
<li>Continue: 2→3→4 → match at index 2</li>
</ul>
<p>Every transition is O(1).</p>
</section>
<section id="tiny-code-easy-versions-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-6">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_dfa(pat, alphabet):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pat)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    dfa <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span><span class="bu">len</span>(alphabet) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    alpha_index <span class="op">=</span> {ch: i <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(alphabet)}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    dfa[<span class="dv">0</span>][alpha_index[pat[<span class="dv">0</span>]]] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> alphabet:</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>            dfa[j][alpha_index[c]] <span class="op">=</span> dfa[x][alpha_index[c]]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">&lt;</span> m:</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            dfa[j][alpha_index[pat[j]]] <span class="op">=</span> j <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> dfa[x][alpha_index[pat[j]]]</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfa</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> automaton_search(text, pat, alphabet):</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    dfa <span class="op">=</span> build_dfa(pat, alphabet)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pat)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ch <span class="kw">in</span> alphabet:</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> dfa[state][alphabet.index(ch)]</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> m:</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i <span class="op">-</span> m <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>alphabet <span class="op">=</span> <span class="bu">list</span>(<span class="st">"AB"</span>)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>automaton_search(<span class="st">"ABABAB"</span>, <span class="st">"ABAB"</span>, alphabet)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This builds a DFA and simulates it across the text.</p>
</section>
<section id="why-it-matters-7" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-7">Why It Matters</h4>
<ul>
<li>No backtracking, linear time search.</li>
<li>Perfect for fixed alphabet and repeated queries.</li>
<li>Basis for lexical analyzers and regex engines (under the hood).</li>
<li>Great example of automata theory in action.</li>
</ul>
</section>
<section id="complexity-7" class="level4">
<h4 class="anchored" data-anchor-id="complexity-7">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build DFA</td>
<td>O(m × σ)</td>
<td>O(m × σ)</td>
</tr>
<tr class="even">
<td>Search</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>σ = alphabet size Best for small alphabets (e.g., DNA, ASCII).</p>
</section>
<section id="try-it-yourself-7" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-7">Try It Yourself</h4>
<ol type="1">
<li>Draw DFA for <code>"ABA"</code>.</li>
<li>Simulate transitions for <code>"ABABA"</code>.</li>
<li>Add alphabet <code>{A, B, C}</code>, what changes?</li>
<li>Compare states with KMP’s prefix table.</li>
<li>Modify code to print state transitions.</li>
</ol>
<p>Finite Automaton Matching is like building a tiny machine that <em>knows your pattern by heart</em>, feed it text, and it will raise its hand every time it recognizes your word.</p>
</section>
</section>
<section id="bitap-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="bitap-algorithm">609 Bitap Algorithm</h3>
<p>The Bitap algorithm (also known as Shift-Or or Shift-And) matches patterns using bitwise operations. It treats the pattern as a bitmask and processes the text character by character, updating a single integer that represents the match state. Fast, compact, and perfect for approximate or fuzzy matching too.</p>
<section id="what-problem-are-we-solving-8" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-8">What Problem Are We Solving?</h4>
<p>We want to find a pattern <code>P</code> in a text <code>T</code> efficiently using bit-level parallelism.</p>
<p>Rather than comparing characters in loops, Bitap packs comparisons into a single machine word, updating all positions in one go. It’s like running multiple match states in parallel, using the bits of an integer.</p>
<p>Given:</p>
<ul>
<li><code>T</code> of length <code>n</code></li>
<li><code>P</code> of length <code>m</code> (≤ word size) We’ll find matches in O(n) time with bitwise magic.</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-8" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-8">How Does It Work (Plain Language)?</h4>
<p>Each bit in a word represents whether a prefix of the pattern matches the current suffix of the text.</p>
<p>We keep:</p>
<ul>
<li><code>R</code>: current match state bitmask (1 = mismatch, 0 = match so far)</li>
<li><code>mask[c]</code>: precomputed bitmask for character <code>c</code> in pattern</li>
</ul>
<p>At each step:</p>
<ol type="1">
<li>Shift <code>R</code> left (to include next char)</li>
<li>Combine with mask for current text char</li>
<li>Check if lowest bit is 0 → full match found</li>
</ol>
<p>So instead of managing loops for each prefix, we update all match prefixes at once.</p>
</section>
<section id="example-4" class="level4">
<h4 class="anchored" data-anchor-id="example-4">Example</h4>
<p>Pattern: <code>"AB"</code> Text: <code>"CABAB"</code></p>
<p>Precompute masks (for 2-bit word):</p>
<pre><code>mask['A'] = 0b10
mask['B'] = 0b01</code></pre>
<p>Initialize <code>R = 0b11</code> (all ones)</p>
<p>Now slide through <code>"CABAB"</code>:</p>
<ul>
<li>C: <code>R = (R &lt;&lt; 1 | 1) &amp; mask['C']</code> → stays 1s</li>
<li>A: shifts left, combine mask[‘A’]</li>
<li>B: shift, combine mask[‘B’] → match bit goes 0 → found match</li>
</ul>
<p>All done in bitwise ops.</p>
</section>
<section id="tiny-code-easy-versions-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-7">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bitap_search(text, pat):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pat)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">&gt;</span> <span class="dv">63</span>:</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Pattern too long for 64-bit Bitap"</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build bitmask for pattern</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> {<span class="bu">chr</span>(i): <span class="op">~</span><span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">256</span>)}</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(pat):</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        mask[c] <span class="op">&amp;=</span> <span class="op">~</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> <span class="op">~</span><span class="dv">1</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        R <span class="op">=</span> (R <span class="op">&lt;&lt;</span> <span class="dv">1</span>) <span class="op">|</span> mask.get(c, <span class="op">~</span><span class="dv">0</span>)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (R <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> m)) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found ending at index"</span>, i)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (64-bit Version)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bitap<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pat<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>pat<span class="op">);</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">&gt;</span> <span class="dv">63</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span> <span class="co">// fits in 64-bit mask</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> mask<span class="op">[</span><span class="dv">256</span><span class="op">];</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">256</span><span class="op">;</span> i<span class="op">++)</span> mask<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">~</span><span class="dv">0</span><span class="bu">ULL</span><span class="op">;</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        mask<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>pat<span class="op">[</span>i<span class="op">]]</span> <span class="op">&amp;=</span> <span class="op">~(</span><span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> i<span class="op">);</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> R <span class="op">=</span> <span class="op">~</span><span class="dv">1</span><span class="bu">ULL</span><span class="op">;</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        R <span class="op">=</span> <span class="op">(</span>R <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">|</span> mask<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>text<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>R <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> m<span class="op">))</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match found ending at index </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    bitap<span class="op">(</span><span class="st">"CABAB"</span><span class="op">,</span> <span class="st">"AB"</span><span class="op">);</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-8" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-8">Why It Matters</h4>
<ul>
<li>Bit-parallel search, leverages CPU-level operations.</li>
<li>Excellent for short patterns and fixed word size.</li>
<li>Extendable to approximate matching (with edits).</li>
<li>Core of tools like agrep (approximate grep) and bitap fuzzy search in editors.</li>
</ul>
</section>
<section id="complexity-8" class="level4">
<h4 class="anchored" data-anchor-id="complexity-8">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Case</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Typical</td>
<td>O(n)</td>
<td>O(σ)</td>
</tr>
<tr class="even">
<td>Preprocessing</td>
<td>O(m + σ)</td>
<td>O(σ)</td>
</tr>
<tr class="odd">
<td>Constraint</td>
<td>m ≤ word size</td>
<td></td>
</tr>
</tbody>
</table>
<p>Bitap is <em>linear</em>, but limited by machine word length (e.g., ≤ 64 chars).</p>
</section>
<section id="try-it-yourself-8" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-8">Try It Yourself</h4>
<ol type="1">
<li>Search <code>"ABC"</code> in <code>"ZABCABC"</code>.</li>
<li>Print <code>R</code> in binary after each step.</li>
<li>Extend mask for ASCII or DNA alphabet.</li>
<li>Test with <code>"AAA"</code>, see overlapping matches.</li>
<li>Try fuzzy version: allow 1 mismatch (edit distance ≤ 1).</li>
</ol>
<p>Bitap is like a bitwise orchestra, each bit plays its note, and together they tell you exactly when the pattern hits.</p>
</section>
</section>
<section id="two-way-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="two-way-algorithm">610 Two-Way Algorithm</h3>
<p>The Two-Way algorithm is a linear-time string search method that combines prefix analysis and modular shifting. It divides the pattern into two parts and uses critical factorization to decide how far to skip after mismatches. Elegant and optimal, it guarantees O(n + m) time without heavy preprocessing.</p>
<section id="what-problem-are-we-solving-9" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-9">What Problem Are We Solving?</h4>
<p>We want a deterministic linear-time search that’s:</p>
<ul>
<li>Faster than KMP on average</li>
<li>Simpler than Boyer–Moore</li>
<li>Provably optimal in worst case</li>
</ul>
<p>The Two-Way algorithm achieves this by analyzing the pattern’s periodicity before searching, so during scanning, it shifts intelligently, sometimes by the pattern’s period, sometimes by the full length.</p>
<p>Given:</p>
<ul>
<li>Text <code>T</code> (length <code>n</code>)</li>
<li>Pattern <code>P</code> (length <code>m</code>)</li>
</ul>
<p>We’ll find all matches with no backtracking and no redundant comparisons.</p>
</section>
<section id="how-does-it-work-plain-language-9" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-9">How Does It Work (Plain Language)?</h4>
<p>The secret lies in critical factorization:</p>
<ol type="1">
<li><p>Preprocessing (Find Critical Position): Split <code>P</code> into <code>u</code> and <code>v</code> at a critical index such that:</p>
<ul>
<li><code>u</code> and <code>v</code> represent the lexicographically smallest rotation of <code>P</code></li>
<li>They reveal the pattern’s period</li>
</ul>
<p>This ensures efficient skips.</p></li>
<li><p>Search Phase: Scan <code>T</code> with a moving window.</p>
<ul>
<li><p>Compare from left to right (forward pass).</p></li>
<li><p>On mismatch, shift by:</p>
<ul>
<li>The pattern’s period if partial match</li>
<li>The full pattern length if mismatch early</li>
</ul></li>
</ul></li>
</ol>
<p>By alternating two-way scanning, it guarantees that no position is checked twice.</p>
<p>Think of it as KMP’s structure + Boyer–Moore’s skip, merged with mathematical precision.</p>
</section>
<section id="example-5" class="level4">
<h4 class="anchored" data-anchor-id="example-5">Example</h4>
<p>Pattern: <code>"ABABAA"</code></p>
<ol type="1">
<li><p>Compute critical position, index 2 (between “AB” | “ABAA”)</p></li>
<li><p>Pattern period = 2 (<code>"AB"</code>)</p></li>
<li><p>Start scanning <code>T = "ABABAABABAA"</code>:</p>
<ul>
<li>Compare <code>"AB"</code> forward → match</li>
<li>Mismatch after <code>"AB"</code> → shift by period = 2</li>
<li>Continue scanning, guaranteed no recheck</li>
</ul></li>
</ol>
<p>This strategy leverages the internal structure of the pattern, skips are based on known repetition.</p>
</section>
<section id="tiny-code-simplified-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-version">Tiny Code (Simplified Version)</h4>
<p>Python (High-Level Idea)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> critical_factorization(pat):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pat)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    i, j, k <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">+</span> k <span class="op">&lt;</span> m <span class="kw">and</span> j <span class="op">+</span> k <span class="op">&lt;</span> m:</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pat[i <span class="op">+</span> k] <span class="op">==</span> pat[j <span class="op">+</span> k]:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>            k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> pat[i <span class="op">+</span> k] <span class="op">&gt;</span> pat[j <span class="op">+</span> k]:</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> i <span class="op">+</span> k <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&lt;=</span> j:</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>                i <span class="op">=</span> j <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> j <span class="op">+</span> k <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">&lt;=</span> i:</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>                j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(i, j)</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> two_way_search(text, pat):</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pat)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> critical_factorization(pat)</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    period <span class="op">=</span> <span class="bu">max</span>(pos, m <span class="op">-</span> pos)</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;=</span> n <span class="op">-</span> m:</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&lt;</span> m <span class="kw">and</span> text[i <span class="op">+</span> j] <span class="op">==</span> pat[j]:</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">==</span> m:</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Match found at index"</span>, i)</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> period <span class="cf">if</span> j <span class="op">&gt;=</span> pos <span class="cf">else</span> <span class="bu">max</span>(<span class="dv">1</span>, j <span class="op">-</span> pos <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABABAABABAA"</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="st">"ABABAA"</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>two_way_search(text, pattern)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This implementation finds the critical index first, then applies forward scanning with period-based shifts.</p>
</section>
<section id="why-it-matters-9" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-9">Why It Matters</h4>
<ul>
<li>Linear time (worst case)</li>
<li>No preprocessing tables needed</li>
<li>Elegant use of periodicity theory</li>
<li>Foundation for C standard library’s strstr() implementation</li>
<li>Handles both periodic and aperiodic patterns efficiently</li>
</ul>
</section>
<section id="complexity-9" class="level4">
<h4 class="anchored" data-anchor-id="complexity-9">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Preprocessing (critical factorization)</td>
<td>O(m)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>Search</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr class="odd">
<td>Total</td>
<td>O(n + m)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Optimal deterministic complexity, no randomness, no collisions.</p>
</section>
<section id="try-it-yourself-9" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-9">Try It Yourself</h4>
<ol type="1">
<li>Find the critical index for <code>"ABCABD"</code>.</li>
<li>Visualize shifts for <code>"ABAB"</code> in <code>"ABABABAB"</code>.</li>
<li>Compare skip lengths with KMP and Boyer–Moore.</li>
<li>Trace state changes step by step.</li>
<li>Implement <code>critical_factorization</code> manually and confirm.</li>
</ol>
<p>The Two-Way algorithm is a blend of theory and pragmatism, it learns the rhythm of your pattern, then dances across the text in perfect time.</p>
</section>
</section>
</section>
<section id="section-62.-multi-patterns-search" class="level1">
<h1>Section 62. Multi-Patterns Search</h1>
<section id="ahocorasick-automaton" class="level3">
<h3 class="anchored" data-anchor-id="ahocorasick-automaton">611 Aho–Corasick Automaton</h3>
<p>The Aho–Corasick algorithm is a classic solution for multi-pattern search. Instead of searching each keyword separately, it builds a single automaton that recognizes all patterns at once. Each character of the text advances the automaton, reporting every match immediately, multiple keywords, one pass.</p>
<section id="what-problem-are-we-solving-10" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-10">What Problem Are We Solving?</h4>
<p>We want to find all occurrences of multiple patterns within a given text.</p>
<p>Given:</p>
<ul>
<li>A set of patterns ( P = {p_1, p_2, , p_k} )</li>
<li>A text ( T ) of length ( n )</li>
</ul>
<p>We aim to find all positions ( i ) in ( T ) such that <span class="math display">\[
T[i : i + |p_j|] = p_j
\]</span> for some ( p_j P ).</p>
<p>Naive solution: <span class="math display">\[
O\Big(n \times \sum_{j=1}^{k} |p_j|\Big)
\]</span> Aho–Corasick improves this to: <span class="math display">\[
O(n + \sum_{j=1}^{k} |p_j| + \text{output\_count})
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-10" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-10">How Does It Work (Plain Language)?</h4>
<p>Aho–Corasick constructs a deterministic finite automaton (DFA) that recognizes all given patterns simultaneously.</p>
<p>The construction involves three steps:</p>
<ol type="1">
<li><p>Trie Construction Insert all patterns into a prefix tree. Each edge represents a character; each node represents a prefix.</p></li>
<li><p>Failure Links For each node, build a failure link to the longest proper suffix that is also a prefix in the trie. Similar to the fallback mechanism in KMP.</p></li>
<li><p>Output Links When a node represents a complete pattern, record it. If the failure link points to another terminal node, merge their outputs.</p></li>
</ol>
<p>Search Phase: Process the text character by character:</p>
<ul>
<li>If a transition for the current character exists, follow it.</li>
<li>Otherwise, follow failure links until a valid transition is found.</li>
<li>At each node, output all patterns ending here.</li>
</ul>
<p>Result: one pass through the text, reporting all matches.</p>
</section>
<section id="example-6" class="level4">
<h4 class="anchored" data-anchor-id="example-6">Example</h4>
<p>Patterns: <span class="math display">\[
P = {\text{"he"}, \text{"she"}, \text{"his"}, \text{"hers"}}
\]</span> Text: <span class="math display">\[
T = \text{"ushers"}
\]</span></p>
<p>Trie structure (simplified):</p>
<pre><code>(root)
 ├─ h ─ i ─ s*
 │    └─ e*
 │         └─ r ─ s*
 └─ s ─ h ─ e*</code></pre>
<p>(* denotes a pattern endpoint)</p>
<p>Failure links:</p>
<ul>
<li>( )</li>
<li>( ) (via root)</li>
<li>( )</li>
<li>( )</li>
</ul>
<p>Text scanning:</p>
<ul>
<li><code>u</code> → no edge, stay at root</li>
<li><code>s</code> → follow <code>s</code></li>
<li><code>h</code> → <code>sh</code></li>
<li><code>e</code> → <code>she</code> → report “she”, “he”</li>
<li><code>r</code> → move to <code>her</code></li>
<li><code>s</code> → <code>hers</code> → report “hers”</li>
</ul>
<p>All patterns found in a single traversal.</p>
</section>
<section id="tiny-code-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AhoCorasick:</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, patterns):</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trie <span class="op">=</span> [{}]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fail <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output <span class="op">=</span> [<span class="bu">set</span>()]</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pat <span class="kw">in</span> patterns:</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._insert(pat)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._build()</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _insert(<span class="va">self</span>, pat):</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> pat:</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie[node][ch] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.trie)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie.append({})</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail.append(<span class="dv">0</span>)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output.append(<span class="bu">set</span>())</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node][ch]</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output[node].add(pat)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _build(<span class="va">self</span>):</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> deque()</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, nxt <span class="kw">in</span> <span class="va">self</span>.trie[<span class="dv">0</span>].items():</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            q.append(nxt)</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> q:</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> q.popleft()</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ch, s <span class="kw">in</span> <span class="va">self</span>.trie[r].items():</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>                q.append(s)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> <span class="va">self</span>.fail[r]</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[f]:</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>                    f <span class="op">=</span> <span class="va">self</span>.fail[f]</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail[s] <span class="op">=</span> <span class="va">self</span>.trie[f].get(ch, <span class="dv">0</span>)</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output[s] <span class="op">|=</span> <span class="va">self</span>.output[<span class="va">self</span>.fail[s]]</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, text):</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="va">self</span>.fail[node]</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node].get(ch, <span class="dv">0</span>)</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pat <span class="kw">in</span> <span class="va">self</span>.output[node]:</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Match '</span><span class="sc">{</span>pat<span class="sc">}</span><span class="ss">' at index </span><span class="sc">{</span>i <span class="op">-</span> <span class="bu">len</span>(pat) <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>patterns <span class="op">=</span> [<span class="st">"he"</span>, <span class="st">"she"</span>, <span class="st">"his"</span>, <span class="st">"hers"</span>]</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> AhoCorasick(patterns)</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>ac.search(<span class="st">"ushers"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Match 'she' at index 1
Match 'he' at index 2
Match 'hers' at index 2</code></pre>
</section>
<section id="why-it-matters-10" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-10">Why It Matters</h4>
<ul>
<li><p>Multiple patterns found in a single pass</p></li>
<li><p>No redundant comparisons or backtracking</p></li>
<li><p>Used in:</p>
<ul>
<li>Spam and malware detection</li>
<li>Intrusion detection systems (IDS)</li>
<li>Search engines and keyword scanners</li>
<li>DNA and protein sequence analysis</li>
</ul></li>
</ul>
</section>
<section id="complexity-10" class="level4">
<h4 class="anchored" data-anchor-id="complexity-10">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 40%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build Trie</td>
<td><span class="math inline">\(O\!\left(\sum |p_i|\right)\)</span></td>
<td><span class="math inline">\(O\!\left(\sum |p_i|\right)\)</span></td>
</tr>
<tr class="even">
<td>Build Failure Links</td>
<td><span class="math inline">\(O\!\left(\sum |p_i| \cdot \sigma\right)\)</span></td>
<td><span class="math inline">\(O\!\left(\sum |p_i|\right)\)</span></td>
</tr>
<tr class="odd">
<td>Search</td>
<td><span class="math inline">\(O(n + \text{output\_count})\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(\sigma\)</span> is the alphabet size.</p>
<p>Overall: <span class="math display">\[
O\!\left(n + \sum |p_i| + \text{output\_count}\right)
\]</span></p>
</section>
<section id="try-it-yourself-10" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-10">Try It Yourself</h4>
<ol type="1">
<li>Build the trie for <span class="math inline">\(\{\text{"a"}, \text{"ab"}, \text{"bab"}\}\)</span>.</li>
<li>Trace failure links for <code>"ababbab"</code>.</li>
<li>Add patterns with shared prefixes, noting trie compression.</li>
<li>Print all outputs per node to understand overlaps.</li>
<li>Compare runtime with launching multiple KMP searches.</li>
</ol>
<p>Aho–Corasick unites all patterns under one automaton, a single traversal, complete recognition, and perfect efficiency.</p>
</section>
</section>
<section id="trie-construction" class="level3">
<h3 class="anchored" data-anchor-id="trie-construction">612 Trie Construction</h3>
<p>A trie (pronounced <em>try</em>) is a prefix tree that organizes strings by their prefixes. Each edge represents a character, and each path from the root encodes a word. In multi-pattern search, the trie is the foundation of the Aho–Corasick automaton, capturing all keywords in a shared structure.</p>
<section id="what-problem-are-we-solving-11" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-11">What Problem Are We Solving?</h4>
<p>We want to store and query a set of strings efficiently, especially for prefix-based operations.</p>
<p>Given a pattern set <span class="math display">\[
P = {p_1, p_2, \ldots, p_k}
\]</span></p>
<p>we want a data structure that can:</p>
<ul>
<li>Insert all patterns in <span class="math inline">\(O\left(\sum_{i=1}^{k} |p_i|\right)\)</span></li>
<li>Query whether a word or prefix exists</li>
<li>Share common prefixes to save memory and time</li>
</ul>
<p>Example If <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"his"}, \texttt{"hers"}}
\]</span> we can store them in a single prefix tree, sharing overlapping paths like <code>h → e</code>.</p>
</section>
<section id="how-does-it-work-plain-language-11" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-11">How Does It Work (Plain Language)</h4>
<p>A trie is built incrementally, one character at a time:</p>
<ol type="1">
<li><p>Start from the root node (empty prefix).</p></li>
<li><p>For each pattern <span class="math inline">\(p\)</span>:</p>
<ul>
<li>Traverse existing edges that match current characters.</li>
<li>Create new nodes if edges don’t exist.</li>
</ul></li>
<li><p>Mark the final node of each word as a terminal node.</p></li>
</ol>
<p>Each node represents a prefix of one or more patterns. Each leaf or terminal node marks a complete pattern.</p>
<p>It’s like a branching roadmap, words share their starting path, then split where they differ.</p>
</section>
<section id="example-7" class="level4">
<h4 class="anchored" data-anchor-id="example-7">Example</h4>
<p>For <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"his"}, \texttt{"hers"}}
\]</span></p>
<p>Trie structure:</p>
<pre><code>(root)
 ├── h ── e* ── r ── s*
 │     └── i ── s*
 └── s ── h ── e*</code></pre>
<p>(* marks end of word)</p>
<ul>
<li>Prefix <code>"he"</code> is shared by <code>"he"</code>, <code>"hers"</code>, and <code>"his"</code>.</li>
<li><code>"she"</code> branches separately under <code>"s"</code>.</li>
</ul>
</section>
<section id="tiny-code-easy-versions-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-8">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TrieNode:</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> {}</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.is_end <span class="op">=</span> <span class="va">False</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Trie:</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> TrieNode()</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, word):</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> node.children:</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>                node.children[ch] <span class="op">=</span> TrieNode()</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.children[ch]</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        node.is_end <span class="op">=</span> <span class="va">True</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, word):</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> node.children:</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.children[ch]</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node.is_end</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> starts_with(<span class="va">self</span>, prefix):</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> prefix:</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> node.children:</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.children[ch]</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>patterns <span class="op">=</span> [<span class="st">"he"</span>, <span class="st">"she"</span>, <span class="st">"his"</span>, <span class="st">"hers"</span>]</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>trie <span class="op">=</span> Trie()</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> patterns:</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    trie.insert(p)</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(trie.search(<span class="st">"he"</span>))       <span class="co"># True</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(trie.starts_with(<span class="st">"sh"</span>))  <span class="co"># True</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(trie.search(<span class="st">"her"</span>))      <span class="co"># False</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C (Simplified)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ALPHABET </span><span class="dv">26</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Trie <span class="op">{</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Trie <span class="op">*</span>children<span class="op">[</span>ALPHABET<span class="op">];</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_end<span class="op">;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Trie<span class="op">;</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>Trie<span class="op">*</span> new_node<span class="op">()</span> <span class="op">{</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    Trie <span class="op">*</span>node <span class="op">=</span> calloc<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Trie<span class="op">));</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    node<span class="op">-&gt;</span>is_end <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> insert<span class="op">(</span>Trie <span class="op">*</span>root<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>word<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    Trie <span class="op">*</span>node <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> word<span class="op">[</span>i<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> idx <span class="op">=</span> word<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="ch">'a'</span><span class="op">;</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>node<span class="op">-&gt;</span>children<span class="op">[</span>idx<span class="op">])</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>            node<span class="op">-&gt;</span>children<span class="op">[</span>idx<span class="op">]</span> <span class="op">=</span> new_node<span class="op">();</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> node<span class="op">-&gt;</span>children<span class="op">[</span>idx<span class="op">];</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>    node<span class="op">-&gt;</span>is_end <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> search<span class="op">(</span>Trie <span class="op">*</span>root<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>word<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>    Trie <span class="op">*</span>node <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> word<span class="op">[</span>i<span class="op">];</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> idx <span class="op">=</span> word<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="ch">'a'</span><span class="op">;</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>node<span class="op">-&gt;</span>children<span class="op">[</span>idx<span class="op">])</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> node<span class="op">-&gt;</span>children<span class="op">[</span>idx<span class="op">];</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node<span class="op">-&gt;</span>is_end<span class="op">;</span></span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a>    Trie <span class="op">*</span>root <span class="op">=</span> new_node<span class="op">();</span></span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a>    insert<span class="op">(</span>root<span class="op">,</span> <span class="st">"he"</span><span class="op">);</span></span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a>    insert<span class="op">(</span>root<span class="op">,</span> <span class="st">"she"</span><span class="op">);</span></span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a>    insert<span class="op">(</span>root<span class="op">,</span> <span class="st">"his"</span><span class="op">);</span></span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true" tabindex="-1"></a>    insert<span class="op">(</span>root<span class="op">,</span> <span class="st">"hers"</span><span class="op">);</span></span>
<span id="cb26-45"><a href="#cb26-45" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> search<span class="op">(</span>root<span class="op">,</span> <span class="st">"she"</span><span class="op">));</span>  <span class="co">// 1 (True)</span></span>
<span id="cb26-46"><a href="#cb26-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-11" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-11">Why It Matters</h4>
<ul>
<li><p>Enables fast prefix queries and shared storage</p></li>
<li><p>Core component of:</p>
<ul>
<li>Aho–Corasick automaton</li>
<li>Autocomplete and suggestion engines</li>
<li>Spell checkers</li>
<li>Dictionary compression</li>
</ul></li>
</ul>
<p>Tries are also the basis for suffix trees, ternary search trees, and radix trees.</p>
</section>
<section id="complexity-11" class="level4">
<h4 class="anchored" data-anchor-id="complexity-11">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 21%">
<col style="width: 15%">
<col style="width: 7%">
<col style="width: 21%">
<col style="width: 2%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert word of length <span class="math inline">\(m\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(\sigma m)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Search word</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Prefix query</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Build from <span class="math inline">\(k\)</span> patterns</td>
<td><span class="math inline">\(O\left(\sum_{i=1}^{k} | p_i              | \right)\)</span></td>
<td><span class="math inline">\(O\left(\sum_{i=1}^{k} | p_i | \right)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(\sigma\)</span> is the alphabet size (e.g.&nbsp;26 for lowercase letters).</p>
</section>
<section id="try-it-yourself-11" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-11">Try It Yourself</h4>
<ol type="1">
<li>Build a trie for <span class="math display">\[
P = {\texttt{"a"}, \texttt{"ab"}, \texttt{"abc"}, \texttt{"b"}}
\]</span></li>
<li>Trace the path for <code>"abc"</code>.</li>
<li>Modify code to print all words in lexicographic order.</li>
<li>Compare with a hash table, how does prefix lookup differ?</li>
<li>Extend each node to store frequency counts or document IDs.</li>
</ol>
<p>Trie construction is the first step in multi-pattern search, a shared tree of prefixes that transforms a list of words into a single searchable structure.</p>
</section>
</section>
<section id="failure-link-computation" class="level3">
<h3 class="anchored" data-anchor-id="failure-link-computation">613 Failure Link Computation</h3>
<p>In the Aho–Corasick automaton, failure links are what give the structure its power. They allow the search to continue efficiently when a mismatch occurs, much like how the prefix function in KMP prevents redundant comparisons. Each failure link connects a node to the longest proper suffix of its path that is also a prefix in the trie.</p>
<section id="what-problem-are-we-solving-12" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-12">What Problem Are We Solving?</h4>
<p>When scanning the text, a mismatch might occur at some node in the trie. Naively, we would return all the way to the root and restart.</p>
<p>Failure links fix this by telling us:</p>
<blockquote class="blockquote">
<p>“If the current path fails, what’s the next best place to continue matching?”</p>
</blockquote>
<p>In other words, they allow the automaton to reuse partial matches, skipping redundant work while staying in valid prefix states.</p>
</section>
<section id="how-does-it-work-plain-language-12" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-12">How Does It Work (Plain Language)</h4>
<p>Every node in the trie represents a prefix of some pattern. If we can’t extend with the next character, we follow a failure link to the next longest prefix that might still match.</p>
<p>Algorithm overview:</p>
<ol type="1">
<li><p>Initialize</p>
<ul>
<li>Root’s failure link = 0 (root)</li>
<li>Children of root → failure = 0</li>
</ul></li>
<li><p>BFS Traversal Process the trie level by level:</p>
<ul>
<li><p>For each node <code>u</code> and each outgoing edge labeled <code>c</code> to node <code>v</code>:</p>
<ol type="1">
<li>Follow failure links from <code>u</code> until you find a node with edge <code>c</code></li>
<li>Set <code>fail[v]</code> = next node on that edge</li>
<li>Merge outputs: <span class="math display">\[
\text{output}[v] \gets \text{output}[v] \cup \text{output}[\text{fail}[v]]
\]</span></li>
</ol></li>
</ul></li>
</ol>
<p>This ensures every node knows where to jump after mismatch, similar to KMP’s prefix fallback, but generalized for all patterns.</p>
</section>
<section id="example-8" class="level4">
<h4 class="anchored" data-anchor-id="example-8">Example</h4>
<p>Let <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"his"}, \texttt{"hers"}}
\]</span></p>
<p>Step 1, Build Trie</p>
<pre><code>(root)
 ├── h ── e* ── r ── s*
 │     └── i ── s*
 └── s ── h ── e*</code></pre>
<p>(* marks end of word)</p>
<p>Step 2, Compute Failure Links</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Node</th>
<th>String</th>
<th>Failure Link</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>root</td>
<td>ε</td>
<td>root</td>
<td>base case</td>
</tr>
<tr class="even">
<td>h</td>
<td>“h”</td>
<td>root</td>
<td>no prefix</td>
</tr>
<tr class="odd">
<td>s</td>
<td>“s”</td>
<td>root</td>
<td>no prefix</td>
</tr>
<tr class="even">
<td>he</td>
<td>“he”</td>
<td>root</td>
<td>no suffix of “he” matches</td>
</tr>
<tr class="odd">
<td>hi</td>
<td>“hi”</td>
<td>root</td>
<td>same</td>
</tr>
<tr class="even">
<td>sh</td>
<td>“sh”</td>
<td>h</td>
<td>longest suffix is “h”</td>
</tr>
<tr class="odd">
<td>she</td>
<td>“she”</td>
<td>he</td>
<td>“he” is suffix and prefix</td>
</tr>
<tr class="even">
<td>hers</td>
<td>“hers”</td>
<td>s</td>
<td>suffix “s” is prefix</td>
</tr>
</tbody>
</table>
<p>Now each node knows where to continue when a mismatch occurs.</p>
</section>
<section id="tiny-code-easy-version-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-version-1">Tiny Code (Easy Version)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_failure_links(trie, fail, output):</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque()</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize: root's children fail to root</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch, nxt <span class="kw">in</span> trie[<span class="dv">0</span>].items():</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        fail[nxt] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        q.append(nxt)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> q.popleft()</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, s <span class="kw">in</span> trie[r].items():</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>            q.append(s)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>            f <span class="op">=</span> fail[r]</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> trie[f]:</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> fail[f]</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>            fail[s] <span class="op">=</span> trie[f].get(ch, <span class="dv">0</span>)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>            output[s] <span class="op">|=</span> output[fail[s]]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage context (inside Aho–Corasick build phase):</p>
<ul>
<li><code>trie</code>: list of dicts <code>{char: next_state}</code></li>
<li><code>fail</code>: list of failure links</li>
<li><code>output</code>: list of sets for pattern endpoints</li>
</ul>
<p>After running this, every node has a valid <code>fail</code> pointer and merged outputs.</p>
</section>
<section id="why-it-matters-12" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-12">Why It Matters</h4>
<ul>
<li>Prevents backtracking → linear-time scanning</li>
<li>Shares partial matches across patterns</li>
<li>Enables overlapping match detection</li>
<li>Generalizes KMP’s prefix fallback to multiple patterns</li>
</ul>
<p>Without failure links, the automaton would degrade into multiple independent searches.</p>
</section>
<section id="complexity-12" class="level4">
<h4 class="anchored" data-anchor-id="complexity-12">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 19%">
<col style="width: 21%">
<col style="width: 18%">
<col style="width: 9%">
<col style="width: 3%">
<col style="width: 2%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build Failure Links</td>
<td><span class="math inline">\(O(\sum         | p_i              | \cdot \sigma)\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Merge Outputs</td>
<td><span class="math inline">\(O(\sum         | p_i              | )\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(\sigma\)</span> is alphabet size.</p>
<p>Each edge and node is processed exactly once.</p>
</section>
<section id="try-it-yourself-12" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-12">Try It Yourself</h4>
<ol type="1">
<li>Build the trie for <span class="math display">\[
P = {\texttt{"a"}, \texttt{"ab"}, \texttt{"bab"}}
\]</span></li>
<li>Compute failure links step by step using BFS.</li>
<li>Visualize merged outputs at each node.</li>
<li>Compare with KMP’s prefix table for <code>"abab"</code>.</li>
<li>Trace text <code>"ababbab"</code> through automaton transitions.</li>
</ol>
<p>Failure links are the nervous system of the Aho–Corasick automaton, always pointing to the next best match, ensuring no time is wasted retracing steps.</p>
</section>
</section>
<section id="output-link-management" class="level3">
<h3 class="anchored" data-anchor-id="output-link-management">614 Output Link Management</h3>
<p>In the Aho–Corasick automaton, output links (or output sets) record which patterns end at each state. These links ensure that all matches, including overlapping and nested ones, are reported correctly during text scanning. Without them, some patterns would go unnoticed when one pattern is a suffix of another.</p>
<section id="what-problem-are-we-solving-13" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-13">What Problem Are We Solving?</h4>
<p>When multiple patterns share suffixes, a single node in the trie may represent the end of multiple words.</p>
<p>For example, consider <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"hers"}}
\]</span></p>
<p>When the automaton reaches the node for <code>"hers"</code>, it should also output <code>"he"</code> and <code>"she"</code> because those are suffixes recognized earlier.</p>
<p>We need a mechanism to:</p>
<ul>
<li>Record which patterns end at each node</li>
<li>Follow failure links to include matches that end earlier in the chain</li>
</ul>
<p>This is the role of output links, each node’s output set accumulates all patterns recognized at that state.</p>
</section>
<section id="how-does-it-work-plain-language-13" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-13">How Does It Work (Plain Language)</h4>
<p>Each node in the automaton has:</p>
<ul>
<li>A set of patterns that end exactly there</li>
<li>A failure link that points to the next fallback state</li>
</ul>
<p>When constructing the automaton, after setting a node’s failure link:</p>
<ol type="1">
<li>Merge outputs from its failure node: <span class="math display">\[
\text{output}[u] \gets \text{output}[u] \cup \text{output}[\text{fail}[u]]
\]</span></li>
<li>This ensures if a suffix of the current path is also a pattern, it is recognized.</li>
</ol>
<p>During search, whenever we visit a node:</p>
<ul>
<li>Emit all patterns in <span class="math inline">\(\text{output}[u]\)</span></li>
<li>Each represents a pattern ending at the current text position</li>
</ul>
</section>
<section id="example-9" class="level4">
<h4 class="anchored" data-anchor-id="example-9">Example</h4>
<p>Patterns: <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"hers"}}
\]</span> Text: <code>"ushers"</code></p>
<p>Trie (simplified):</p>
<pre><code>(root)
 ├── h ── e* ── r ── s*
 └── s ── h ── e*</code></pre>
<p>(* = pattern end)</p>
<p>Failure links:</p>
<ul>
<li><code>"he"</code> → root</li>
<li><code>"she"</code> → <code>"he"</code></li>
<li><code>"hers"</code> → <code>"s"</code></li>
</ul>
<p>Output links (after merging):</p>
<ul>
<li><span class="math inline">\(\text{output}["he"] = {\texttt{"he"}}\)</span></li>
<li><span class="math inline">\(\text{output}["she"] = {\texttt{"she"}, \texttt{"he"}}\)</span></li>
<li><span class="math inline">\(\text{output}["hers"] = {\texttt{"hers"}, \texttt{"he"}}\)</span></li>
</ul>
<p>So, when reaching <code>"she"</code>, both <code>"she"</code> and <code>"he"</code> are reported. When reaching <code>"hers"</code>, <code>"hers"</code> and <code>"he"</code> are reported.</p>
</section>
<section id="tiny-code-python-snippet" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-snippet">Tiny Code (Python Snippet)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_output_links(trie, fail, output):</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    q <span class="op">=</span> deque()</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch, nxt <span class="kw">in</span> trie[<span class="dv">0</span>].items():</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        fail[nxt] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        q.append(nxt)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> q:</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> q.popleft()</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, s <span class="kw">in</span> trie[r].items():</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>            q.append(s)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>            f <span class="op">=</span> fail[r]</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> trie[f]:</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> fail[f]</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>            fail[s] <span class="op">=</span> trie[f].get(ch, <span class="dv">0</span>)</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Merge outputs from failure link</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>            output[s] <span class="op">|=</span> output[fail[s]]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Explanation</p>
<ul>
<li><code>trie</code>: list of dicts (edges)</li>
<li><code>fail</code>: list of failure pointers</li>
<li><code>output</code>: list of sets (patterns ending at node)</li>
</ul>
<p>Each node inherits its failure node’s outputs. Thus, when a node is visited, printing <code>output[node]</code> gives all matches.</p>
</section>
<section id="why-it-matters-13" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-13">Why It Matters</h4>
<ul>
<li>Enables complete match reporting</li>
<li>Captures overlapping matches, e.g.&nbsp;<code>"he"</code> inside <code>"she"</code></li>
<li>Essential for correctness, without output merging, only longest matches would appear</li>
<li>Used in search tools, intrusion detection systems, NLP tokenizers, and compilers</li>
</ul>
</section>
<section id="complexity-13" class="level4">
<h4 class="anchored" data-anchor-id="complexity-13">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 50%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Merge outputs</td>
<td><span class="math inline">\(O\!\left(\sum |p_i|\right)\)</span></td>
<td><span class="math inline">\(O\!\left(\sum |p_i|\right)\)</span></td>
</tr>
<tr class="even">
<td>Search phase</td>
<td><span class="math inline">\(O(n + \text{output\_count})\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Each node merges its outputs once during automaton construction.</p>
</section>
<section id="try-it-yourself-13" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-13">Try It Yourself</h4>
<ol type="1">
<li>Build the trie for <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"hers"}}
\]</span></li>
<li>Compute failure links and merge outputs.</li>
<li>Trace the text <code>"ushers"</code> character by character.</li>
<li>Print <span class="math inline">\(\text{output}[u]\)</span> at each visited state.</li>
<li>Verify all suffix patterns are reported.</li>
</ol>
<p>Output link management ensures no pattern is left behind. Every suffix, every overlap, every embedded word is captured, a complete record of recognition at every step.</p>
</section>
</section>
<section id="multi-pattern-search" class="level3">
<h3 class="anchored" data-anchor-id="multi-pattern-search">615 Multi-Pattern Search</h3>
<p>The multi-pattern search problem asks us to find all occurrences of multiple keywords within a single text. Instead of running separate searches for each pattern, we combine them into a single traversal, powered by the Aho–Corasick automaton. This approach is foundational for text analytics, spam filtering, and network intrusion detection.</p>
<section id="what-problem-are-we-solving-14" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-14">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A set of patterns <span class="math display">\[
P = {p_1, p_2, \ldots, p_k}
\]</span></li>
<li>A text <span class="math display">\[
T = t_1 t_2 \ldots t_n
\]</span></li>
</ul>
<p>We need to find every occurrence of every pattern in ( P ) inside ( T ), including overlapping matches.</p>
<p>Naively, we could run KMP or Z-algorithm for each ( p_i ): <span class="math display">\[
O\Big(n \times \sum_{i=1}^k |p_i|\Big)
\]</span></p>
<p>But Aho–Corasick solves it in: <span class="math display">\[
O(n + \sum_{i=1}^k |p_i| + \text{output\_count})
\]</span></p>
<p>That is, one pass through the text, all matches reported.</p>
</section>
<section id="how-does-it-work-plain-language-14" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-14">How Does It Work (Plain Language)</h4>
<p>The solution proceeds in three stages:</p>
<ol type="1">
<li><p>Build a Trie Combine all patterns into one prefix tree.</p></li>
<li><p>Compute Failure and Output Links</p>
<ul>
<li>Failure links redirect the search after mismatches.</li>
<li>Output links collect all matched patterns at each state.</li>
</ul></li>
<li><p>Scan the Text Move through the automaton using characters from ( T ).</p>
<ul>
<li>If a transition exists, follow it.</li>
<li>If not, follow failure links until one does.</li>
<li>Every time a state is reached, output all patterns in <code>output[state]</code>.</li>
</ul></li>
</ol>
<p>In essence, we simulate k searches in parallel, sharing common prefixes and reusing progress across patterns.</p>
</section>
<section id="example-10" class="level4">
<h4 class="anchored" data-anchor-id="example-10">Example</h4>
<p>Let <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"his"}, \texttt{"hers"}}
\]</span> and <span class="math display">\[
T = \texttt{"ushers"}
\]</span></p>
<p>During scanning:</p>
<ul>
<li><code>u</code> → root</li>
<li><code>s</code> → <code>"s"</code></li>
<li><code>h</code> → <code>"sh"</code></li>
<li><code>e</code> → <code>"she"</code> → report <code>"she"</code>, <code>"he"</code></li>
<li><code>r</code> → <code>"her"</code></li>
<li><code>s</code> → <code>"hers"</code> → report <code>"hers"</code>, <code>"he"</code></li>
</ul>
<p>Output:</p>
<pre><code>she @ 1
he  @ 2
hers @ 2</code></pre>
<p>All patterns are found in a single pass.</p>
</section>
<section id="tiny-code-python-implementation" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AhoCorasick:</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, patterns):</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trie <span class="op">=</span> [{}]</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fail <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output <span class="op">=</span> [<span class="bu">set</span>()]</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pat <span class="kw">in</span> patterns:</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._insert(pat)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._build()</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _insert(<span class="va">self</span>, pat):</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> pat:</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie[node][ch] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.trie)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie.append({})</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail.append(<span class="dv">0</span>)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output.append(<span class="bu">set</span>())</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node][ch]</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output[node].add(pat)</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _build(<span class="va">self</span>):</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> deque()</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, nxt <span class="kw">in</span> <span class="va">self</span>.trie[<span class="dv">0</span>].items():</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>            q.append(nxt)</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> q:</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> q.popleft()</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ch, s <span class="kw">in</span> <span class="va">self</span>.trie[r].items():</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>                q.append(s)</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> <span class="va">self</span>.fail[r]</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[f]:</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>                    f <span class="op">=</span> <span class="va">self</span>.fail[f]</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail[s] <span class="op">=</span> <span class="va">self</span>.trie[f].get(ch, <span class="dv">0</span>)</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output[s] <span class="op">|=</span> <span class="va">self</span>.output[<span class="va">self</span>.fail[s]]</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, text):</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> []</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="va">self</span>.fail[node]</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node].get(ch, <span class="dv">0</span>)</span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pat <span class="kw">in</span> <span class="va">self</span>.output[node]:</span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>                results.append((i <span class="op">-</span> <span class="bu">len</span>(pat) <span class="op">+</span> <span class="dv">1</span>, pat))</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> results</span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>patterns <span class="op">=</span> [<span class="st">"he"</span>, <span class="st">"she"</span>, <span class="st">"his"</span>, <span class="st">"hers"</span>]</span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> AhoCorasick(patterns)</span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ac.search(<span class="st">"ushers"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$(1, 'she'), (2, 'he'), (2, 'hers')]</code></pre>
</section>
<section id="why-it-matters-14" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-14">Why It Matters</h4>
<ul>
<li><p>Handles multiple keywords simultaneously</p></li>
<li><p>Reports overlapping and nested matches</p></li>
<li><p>Widely used in:</p>
<ul>
<li>Spam filters</li>
<li>Intrusion detection systems</li>
<li>Search engines</li>
<li>Plagiarism detectors</li>
<li>DNA sequence analysis</li>
</ul></li>
</ul>
<p>It’s the gold standard for searching many patterns in one pass.</p>
</section>
<section id="complexity-14" class="level4">
<h4 class="anchored" data-anchor-id="complexity-14">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 31%">
<col style="width: 17%">
<col style="width: 15%">
<col style="width: 7%">
<col style="width: 3%">
<col style="width: 2%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build trie</td>
<td><span class="math inline">\(O(\sum                      | p_i              | )\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Build failure links</td>
<td><span class="math inline">\(O(\sum                      | p_i              | \cdot \sigma)\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Search</td>
<td><span class="math inline">\(O(n + \text{output\_count})\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(\sigma\)</span> is the alphabet size.</p>
<p>Total time: <span class="math display">\[
O(n + \sum |p_i| + \text{output\_count})
\]</span></p>
</section>
<section id="try-it-yourself-14" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-14">Try It Yourself</h4>
<ol type="1">
<li>Build a multi-pattern automaton for <span class="math display">\[
P = {\texttt{"ab"}, \texttt{"bc"}, \texttt{"abc"}}
\]</span> and trace it on <code>"zabcbcabc"</code>.</li>
<li>Compare with running KMP three times.</li>
<li>Count total transitions vs naive scanning.</li>
<li>Modify code to count number of matches only.</li>
<li>Extend it to case-insensitive search.</li>
</ol>
<p>Multi-pattern search transforms a list of keywords into a single machine. Each step reads one character and reveals every pattern hiding in that text, one scan, complete coverage.</p>
</section>
</section>
<section id="dictionary-matching" class="level3">
<h3 class="anchored" data-anchor-id="dictionary-matching">616 Dictionary Matching</h3>
<p>Dictionary matching is a specialized form of multi-pattern search where the goal is to locate all occurrences of words from a fixed dictionary within a given text. Unlike single-pattern search (like KMP or Boyer–Moore), dictionary matching solves the problem for an entire vocabulary, all at once, using shared structure and efficient transitions.</p>
<section id="what-problem-are-we-solving-15" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-15">What Problem Are We Solving?</h4>
<p>We want to find every word from a dictionary inside a large body of text.</p>
<p>Given:</p>
<ul>
<li>A dictionary <span class="math display">\[
D = {w_1, w_2, \ldots, w_k}
\]</span></li>
<li>A text <span class="math display">\[
T = t_1 t_2 \ldots t_n
\]</span></li>
</ul>
<p>We must report all substrings of <span class="math inline">\(T\)</span> that match any <span class="math inline">\(w_i \in D\)</span>.</p>
<p>Naive solution:</p>
<ul>
<li>Run KMP or Z-algorithm for each word: <span class="math inline">\(O(n \times \sum |w_i|)\)</span></li>
</ul>
<p>Efficient solution (Aho–Corasick):</p>
<ul>
<li>Build automaton once: <span class="math inline">\(O(\sum |w_i|)\)</span></li>
<li>Search in one pass: <span class="math inline">\(O(n + \text{output\_count})\)</span></li>
</ul>
<p>So total: <span class="math display">\[
O(n + \sum |w_i| + \text{output\_count})
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-15" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-15">How Does It Work (Plain Language)</h4>
<p>The key insight is shared prefixes and failure links.</p>
<ol type="1">
<li><p>Trie Construction Combine all words from the dictionary into a single prefix tree.</p></li>
<li><p>Failure Links When a mismatch occurs, follow a failure pointer to the longest suffix that is still a valid prefix.</p></li>
<li><p>Output Sets Each node stores all dictionary words that end at that state.</p></li>
<li><p>Search Phase Scan <span class="math inline">\(T\)</span> one character at a time.</p>
<ul>
<li>Follow existing edges if possible</li>
<li>Otherwise, follow failure links until a valid transition exists</li>
<li>Report all words in the current node’s output set</li>
</ul></li>
</ol>
<p>Each position in <span class="math inline">\(T\)</span> is processed exactly once.</p>
</section>
<section id="example-11" class="level4">
<h4 class="anchored" data-anchor-id="example-11">Example</h4>
<p>Dictionary: <span class="math display">\[
D = {\texttt{"he"}, \texttt{"she"}, \texttt{"his"}, \texttt{"hers"}}
\]</span> Text: <span class="math display">\[
T = \texttt{"ushers"}
\]</span></p>
<p>Scanning:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Char</th>
<th>State</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>u</td>
<td>root</td>
<td>∅</td>
</tr>
<tr class="even">
<td>2</td>
<td>s</td>
<td>s</td>
<td>∅</td>
</tr>
<tr class="odd">
<td>3</td>
<td>h</td>
<td>sh</td>
<td>∅</td>
</tr>
<tr class="even">
<td>4</td>
<td>e</td>
<td>she</td>
<td>{“she”, “he”}</td>
</tr>
<tr class="odd">
<td>5</td>
<td>r</td>
<td>her</td>
<td>∅</td>
</tr>
<tr class="even">
<td>6</td>
<td>s</td>
<td>hers</td>
<td>{“hers”, “he”}</td>
</tr>
</tbody>
</table>
<p>Matches:</p>
<ul>
<li><code>"she"</code> at index 1</li>
<li><code>"he"</code> at index 2</li>
<li><code>"hers"</code> at index 2</li>
</ul>
<p>All found in one traversal.</p>
</section>
<section id="tiny-code-python-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-version">Tiny Code (Python Version)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DictionaryMatcher:</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, words):</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trie <span class="op">=</span> [{}]</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fail <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output <span class="op">=</span> [<span class="bu">set</span>()]</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> word <span class="kw">in</span> words:</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._insert(word)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._build()</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _insert(<span class="va">self</span>, word):</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie[node][ch] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.trie)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie.append({})</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail.append(<span class="dv">0</span>)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output.append(<span class="bu">set</span>())</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node][ch]</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output[node].add(word)</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _build(<span class="va">self</span>):</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> deque()</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, nxt <span class="kw">in</span> <span class="va">self</span>.trie[<span class="dv">0</span>].items():</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>            q.append(nxt)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> q:</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> q.popleft()</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ch, s <span class="kw">in</span> <span class="va">self</span>.trie[r].items():</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>                q.append(s)</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> <span class="va">self</span>.fail[r]</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[f]:</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>                    f <span class="op">=</span> <span class="va">self</span>.fail[f]</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail[s] <span class="op">=</span> <span class="va">self</span>.trie[f].get(ch, <span class="dv">0</span>)</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output[s] <span class="op">|=</span> <span class="va">self</span>.output[<span class="va">self</span>.fail[s]]</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, text):</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> []</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="va">self</span>.fail[node]</span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node].get(ch, <span class="dv">0</span>)</span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> word <span class="kw">in</span> <span class="va">self</span>.output[node]:</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a>                results.append((i <span class="op">-</span> <span class="bu">len</span>(word) <span class="op">+</span> <span class="dv">1</span>, word))</span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> results</span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a>dictionary <span class="op">=</span> [<span class="st">"he"</span>, <span class="st">"she"</span>, <span class="st">"his"</span>, <span class="st">"hers"</span>]</span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a>dm <span class="op">=</span> DictionaryMatcher(dictionary)</span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dm.search(<span class="st">"ushers"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$(1, 'she'), (2, 'he'), (2, 'hers')]</code></pre>
</section>
<section id="why-it-matters-15" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-15">Why It Matters</h4>
<ul>
<li><p>Solves dictionary word search efficiently</p></li>
<li><p>Core technique in:</p>
<ul>
<li>Text indexing and keyword filtering</li>
<li>Intrusion detection systems (IDS)</li>
<li>Linguistic analysis</li>
<li>Plagiarism and content matching</li>
<li>DNA or protein motif discovery</li>
</ul></li>
</ul>
<p>It scales beautifully, a single automaton handles hundreds of thousands of dictionary words.</p>
</section>
<section id="complexity-15" class="level4">
<h4 class="anchored" data-anchor-id="complexity-15">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 32%">
<col style="width: 18%">
<col style="width: 16%">
<col style="width: 8%">
<col style="width: 3%">
<col style="width: 2%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build automaton</td>
<td><span class="math inline">\(O(\sum                      | w_i              | \cdot \sigma)\)</span></td>
<td><span class="math inline">\(O(\sum | w_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Search</td>
<td><span class="math inline">\(O(n + \text{output\_count})\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(\sigma\)</span> = alphabet size (e.g., 26 for lowercase letters).</p>
</section>
<section id="try-it-yourself-15" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-15">Try It Yourself</h4>
<ol type="1">
<li>Use <span class="math display">\[
D = {\texttt{"cat"}, \texttt{"car"}, \texttt{"cart"}, \texttt{"art"}}
\]</span> and <span class="math inline">\(T = \texttt{"cartographer"}\)</span>.</li>
<li>Trace the automaton step by step.</li>
<li>Compare against running 4 separate KMP searches.</li>
<li>Modify the automaton to return positions and words.</li>
<li>Extend to case-insensitive dictionary matching.</li>
</ol>
<p>Dictionary matching transforms a word list into a search automaton, every character of text advances all searches together, ensuring complete detection with no redundancy.</p>
</section>
</section>
<section id="dynamic-ahocorasick" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-ahocorasick">617 Dynamic Aho–Corasick</h3>
<p>The Dynamic Aho–Corasick automaton extends the classical Aho–Corasick algorithm to handle insertions and deletions of patterns at runtime. It allows us to maintain a live dictionary, updating the automaton as new keywords arrive or old ones are removed, without rebuilding from scratch.</p>
<section id="what-problem-are-we-solving-16" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-16">What Problem Are We Solving?</h4>
<p>Standard Aho–Corasick assumes a static dictionary. But in many real-world systems, the set of patterns changes over time:</p>
<ul>
<li>Spam filters receive new rules</li>
<li>Network intrusion systems add new signatures</li>
<li>Search engines update keyword lists</li>
</ul>
<p>We need a way to insert or delete words dynamically while still searching in <span class="math display">\[
O(n + \text{output\_count})
\]</span> per query, without reconstructing the automaton each time.</p>
<p>So, our goal is an incrementally updatable pattern matcher.</p>
</section>
<section id="how-does-it-work-plain-language-16" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-16">How Does It Work (Plain Language)</h4>
<p>We maintain the automaton incrementally:</p>
<ol type="1">
<li><p>Trie Insertion Add a new pattern by walking down existing nodes, creating new ones when needed.</p></li>
<li><p>Failure Link Update For each new node, compute its failure link:</p>
<ul>
<li>Follow parent’s failure link until a node with the same edge exists</li>
<li>Set new node’s failure link to that target</li>
<li>Merge output sets: <span class="math display">\[
\text{output}[v] \gets \text{output}[v] \cup \text{output}[\text{fail}[v]]
\]</span></li>
</ul></li>
<li><p>Deletion (Optional)</p>
<ul>
<li>Mark pattern as inactive (logical deletion)</li>
<li>Optionally perform lazy cleanup when needed</li>
</ul></li>
<li><p>Query Search proceeds as usual, following transitions and failure links.</p></li>
</ol>
<p>This incremental construction is like Aho–Corasick in motion, adding one word at a time while preserving correctness.</p>
</section>
<section id="example-12" class="level4">
<h4 class="anchored" data-anchor-id="example-12">Example</h4>
<p>Start with <span class="math display">\[
P_0 = {\texttt{"he"}, \texttt{"she"}}
\]</span> Build automaton.</p>
<p>Now insert <code>"hers"</code>:</p>
<ul>
<li><p>Walk: <code>h → e → r → s</code></p></li>
<li><p>Create nodes as needed</p></li>
<li><p>Update failure links:</p>
<ul>
<li><code>fail("hers") = "s"</code></li>
<li>Merge output from <code>"s"</code> (if any)</li>
</ul></li>
</ul>
<p>Next insert <code>"his"</code>:</p>
<ul>
<li><code>h → i → s</code></li>
<li>Compute <code>fail("his") = "s"</code></li>
<li>Merge outputs</li>
</ul>
<p>Now automaton recognizes all words in <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"hers"}, \texttt{"his"}}
\]</span> without full rebuild.</p>
</section>
<section id="tiny-code-python-sketch" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DynamicAC:</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trie <span class="op">=</span> [{}]</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fail <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output <span class="op">=</span> [<span class="bu">set</span>()]</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, word):</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie[node][ch] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.trie)</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie.append({})</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail.append(<span class="dv">0</span>)</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output.append(<span class="bu">set</span>())</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node][ch]</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output[node].add(word)</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._update_failures(word)</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _update_failures(<span class="va">self</span>, word):</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>            nxt <span class="op">=</span> <span class="va">self</span>.trie[node][ch]</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nxt <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail[nxt] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> <span class="va">self</span>.fail[node]</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[f]:</span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>                    f <span class="op">=</span> <span class="va">self</span>.fail[f]</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail[nxt] <span class="op">=</span> <span class="va">self</span>.trie[f].get(ch, <span class="dv">0</span>)</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output[nxt] <span class="op">|=</span> <span class="va">self</span>.output[<span class="va">self</span>.fail[nxt]]</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> nxt</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, text):</span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>        matches <span class="op">=</span> []</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="va">self</span>.fail[node]</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node].get(ch, <span class="dv">0</span>)</span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> w <span class="kw">in</span> <span class="va">self</span>.output[node]:</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>                matches.append((i <span class="op">-</span> <span class="bu">len</span>(w) <span class="op">+</span> <span class="dv">1</span>, w))</span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> matches</span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage</span></span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> DynamicAC()</span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a>ac.insert(<span class="st">"he"</span>)</span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a>ac.insert(<span class="st">"she"</span>)</span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a>ac.insert(<span class="st">"hers"</span>)</span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ac.search(<span class="st">"ushers"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$(1, 'she'), (2, 'he'), (2, 'hers')]</code></pre>
</section>
<section id="why-it-matters-16" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-16">Why It Matters</h4>
<ul>
<li><p>Supports real-time pattern updates</p></li>
<li><p>Crucial for:</p>
<ul>
<li>Live spam filters</li>
<li>Intrusion detection systems (IDS)</li>
<li>Adaptive search systems</li>
<li>Dynamic word lists in NLP pipelines</li>
</ul></li>
</ul>
<p>Unlike static Aho–Corasick, this version adapts as the dictionary evolves.</p>
</section>
<section id="complexity-16" class="level4">
<h4 class="anchored" data-anchor-id="complexity-16">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 40%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert word of length <span class="math inline">\(m\)</span></td>
<td><span class="math inline">\(O(m \cdot \sigma)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Delete word</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span> (lazy)</td>
</tr>
<tr class="odd">
<td>Search text</td>
<td><span class="math inline">\(O(n + \text{output\_count})\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Each insertion updates only affected nodes.</p>
</section>
<section id="try-it-yourself-16" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-16">Try It Yourself</h4>
<ol type="1">
<li>Start with <span class="math display">\[
P = {\texttt{"a"}, \texttt{"ab"}}
\]</span> then add <code>"abc"</code> dynamically.</li>
<li>Print <code>fail</code> array after each insertion.</li>
<li>Try deleting <code>"ab"</code> (mark inactive).</li>
<li>Search text <code>"zabca"</code> after each change.</li>
<li>Compare rebuild vs incremental time.</li>
</ol>
<p>Dynamic Aho–Corasick turns a static automaton into a living dictionary, always learning new words, forgetting old ones, and scanning the world in real time.</p>
</section>
</section>
<section id="parallel-ahocorasick-search" class="level3">
<h3 class="anchored" data-anchor-id="parallel-ahocorasick-search">618 Parallel Aho–Corasick Search</h3>
<p>The Parallel Aho–Corasick algorithm adapts the classical Aho–Corasick automaton for multi-threaded or distributed environments. It divides the input text or workload into independent chunks so that multiple processors can simultaneously search for patterns, enabling high-throughput keyword detection on massive data streams.</p>
<section id="what-problem-are-we-solving-17" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-17">What Problem Are We Solving?</h4>
<p>The classical Aho–Corasick algorithm scans the text sequentially. For large-scale tasks, like scanning logs, DNA sequences, or network packets, this becomes a bottleneck.</p>
<p>We want to:</p>
<ul>
<li>Maintain linear-time matching</li>
<li>Leverage multiple cores or machines</li>
<li>Preserve correctness across chunk boundaries</li>
</ul>
<p>So our goal is to search <span class="math display">\[
T = t_1 t_2 \ldots t_n
\]</span> against <span class="math display">\[
P = {p_1, p_2, \ldots, p_k}
\]</span> using parallel execution.</p>
</section>
<section id="how-does-it-work-plain-language-17" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-17">How Does It Work (Plain Language)</h4>
<p>There are two major strategies for parallelizing Aho–Corasick:</p>
<section id="text-partitioning-input-split-model" class="level5">
<h5 class="anchored" data-anchor-id="text-partitioning-input-split-model">1. Text Partitioning (Input-Split Model)</h5>
<ul>
<li>Split text <span class="math inline">\(T\)</span> into <span class="math inline">\(m\)</span> chunks: <span class="math display">\[
T = T_1 , T_2 , \ldots , T_m
\]</span></li>
<li>Assign each chunk to a worker thread.</li>
<li>Each thread runs Aho–Corasick independently.</li>
<li>Handle boundary cases (patterns overlapping chunk edges) by overlapping buffers of length equal to the longest pattern.</li>
</ul>
<p>Pros: Simple, efficient for long texts Cons: Requires overlap for correctness</p>
</section>
<section id="automaton-partitioning-state-split-model" class="level5">
<h5 class="anchored" data-anchor-id="automaton-partitioning-state-split-model">2. Automaton Partitioning (State-Split Model)</h5>
<ul>
<li>Partition the state machine across threads or nodes.</li>
<li>Each processor is responsible for a subset of patterns or states.</li>
<li>Transitions are communicated via message passing (e.g., MPI).</li>
</ul>
<p>Pros: Good for static, small pattern sets Cons: Synchronization cost, complex state handoff</p>
<p>In both approaches:</p>
<ul>
<li>Each thread scans text in <span class="math inline">\(O(|T_i| + \text{output\_count}_i)\)</span></li>
<li>Results are merged at the end.</li>
</ul>
</section>
</section>
<section id="example-text-partitioning" class="level4">
<h4 class="anchored" data-anchor-id="example-text-partitioning">Example (Text Partitioning)</h4>
<p>Let <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"his"}, \texttt{"hers"}}
\]</span> and <span class="math display">\[
T = \texttt{"ushershehis"}
\]</span></p>
<p>Split <span class="math inline">\(T\)</span> into two parts with overlap of length 4 (max pattern length):</p>
<ul>
<li>Thread 1: <code>"ushersh"</code></li>
<li>Thread 2: <code>"shehis"</code></li>
</ul>
<p>Both threads run the same automaton. At merge time, deduplicate matches in overlapping region.</p>
<p>Each finds:</p>
<ul>
<li>Thread 1 → <code>she@1</code>, <code>he@2</code>, <code>hers@2</code></li>
<li>Thread 2 → <code>she@6</code>, <code>he@7</code>, <code>his@8</code></li>
</ul>
<p>Final result = union of both sets.</p>
</section>
<section id="tiny-code-parallel-example-python-threads" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-parallel-example-python-threads">Tiny Code (Parallel Example, Python Threads)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> concurrent.futures <span class="im">import</span> ThreadPoolExecutor</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search_chunk(ac, text, offset<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    matches <span class="op">=</span> []</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> ac.trie[node]:</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> ac.fail[node]</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> ac.trie[node].get(ch, <span class="dv">0</span>)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pat <span class="kw">in</span> ac.output[node]:</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>            matches.append((offset <span class="op">+</span> i <span class="op">-</span> <span class="bu">len</span>(pat) <span class="op">+</span> <span class="dv">1</span>, pat))</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matches</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parallel_search(ac, text, chunk_size, overlap):</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    tasks <span class="op">=</span> []</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> ThreadPoolExecutor() <span class="im">as</span> executor:</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(text), chunk_size):</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>            chunk <span class="op">=</span> text[i : i <span class="op">+</span> chunk_size <span class="op">+</span> overlap]</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>            tasks.append(executor.submit(search_chunk, ac, chunk, i))</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> tasks:</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>            results.extend(t.result())</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optionally deduplicate overlapping matches</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(<span class="bu">set</span>(results))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>patterns <span class="op">=</span> [<span class="st">"he"</span>, <span class="st">"she"</span>, <span class="st">"his"</span>, <span class="st">"hers"</span>]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> AhoCorasick(patterns)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(parallel_search(ac, <span class="st">"ushershehis"</span>, chunk_size<span class="op">=</span><span class="dv">6</span>, overlap<span class="op">=</span><span class="dv">4</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$(1, 'she'), (2, 'he'), (2, 'hers'), (6, 'she'), (7, 'he'), (8, 'his')]</code></pre>
</section>
<section id="why-it-matters-17" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-17">Why It Matters</h4>
<ul>
<li><p>Enables real-time matching on large-scale data</p></li>
<li><p>Used in:</p>
<ul>
<li>Intrusion detection systems (IDS)</li>
<li>Big data text analytics</li>
<li>Log scanning and threat detection</li>
<li>Genome sequence analysis</li>
<li>Network packet inspection</li>
</ul></li>
</ul>
<p>Parallelism brings Aho–Corasick to gigabyte-per-second throughput.</p>
</section>
<section id="complexity-17" class="level4">
<h4 class="anchored" data-anchor-id="complexity-17">Complexity</h4>
<p>For <span class="math inline">\(m\)</span> threads:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 54%">
<col style="width: 15%">
<col style="width: 1%">
<col style="width: 6%">
<col style="width: 2%">
<col style="width: 1%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build automaton</td>
<td><span class="math inline">\(O(\sum                                                 | p_i              | )\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Search</td>
<td><span class="math inline">\(O\left(\frac{n}{m} + \text{overlap}\right)\)</span> per thread</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Merge results</td>
<td><span class="math inline">\(O(k)\)</span></td>
<td><span class="math inline">\(O(k)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Total time approximates <span class="math display">\[
O\left(\frac{n}{m} + \text{overlap} \cdot m\right)
\]</span></p>
</section>
<section id="try-it-yourself-17" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-17">Try It Yourself</h4>
<ol type="1">
<li>Split <span class="math display">\[
T = \texttt{"bananabanabanana"}
\]</span> and <span class="math display">\[
P = {\texttt{"ana"}, \texttt{"banana"}}
\]</span> into chunks with overlap = 6.</li>
<li>Verify all matches found.</li>
<li>Experiment with different chunk sizes and overlaps.</li>
<li>Compare single-thread vs multi-thread performance.</li>
<li>Extend to multiprocessing or GPU streams.</li>
</ol>
<p>Parallel Aho–Corasick turns a sequential automaton into a scalable search engine, distributing the rhythm of matching across threads, yet producing a single, synchronized melody of results.</p>
</section>
</section>
<section id="parallel-ahocorasick-search-1" class="level3">
<h3 class="anchored" data-anchor-id="parallel-ahocorasick-search-1">618 Parallel Aho–Corasick Search</h3>
<p>The Parallel Aho–Corasick algorithm adapts the classical Aho–Corasick automaton for multi-threaded or distributed environments. It divides the input text or workload into independent chunks so that multiple processors can simultaneously search for patterns, enabling high-throughput keyword detection on massive data streams.</p>
<section id="what-problem-are-we-solving-18" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-18">What Problem Are We Solving?</h4>
<p>The classical Aho–Corasick algorithm scans the text sequentially. For large-scale tasks, like scanning logs, DNA sequences, or network packets, this becomes a bottleneck.</p>
<p>We want to:</p>
<ul>
<li>Maintain linear-time matching</li>
<li>Leverage multiple cores or machines</li>
<li>Preserve correctness across chunk boundaries</li>
</ul>
<p>So our goal is to search <span class="math display">\[
T = t_1 t_2 \ldots t_n
\]</span> against <span class="math display">\[
P = {p_1, p_2, \ldots, p_k}
\]</span> using parallel execution.</p>
</section>
<section id="how-does-it-work-plain-language-18" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-18">How Does It Work (Plain Language)</h4>
<p>There are two major strategies for parallelizing Aho–Corasick:</p>
<section id="text-partitioning-input-split-model-1" class="level5">
<h5 class="anchored" data-anchor-id="text-partitioning-input-split-model-1">1. Text Partitioning (Input-Split Model)</h5>
<ul>
<li>Split text <span class="math inline">\(T\)</span> into <span class="math inline">\(m\)</span> chunks: <span class="math display">\[
T = T_1 , T_2 , \ldots , T_m
\]</span></li>
<li>Assign each chunk to a worker thread.</li>
<li>Each thread runs Aho–Corasick independently.</li>
<li>Handle boundary cases (patterns overlapping chunk edges) by overlapping buffers of length equal to the longest pattern.</li>
</ul>
<p>Pros: Simple, efficient for long texts Cons: Requires overlap for correctness</p>
</section>
<section id="automaton-partitioning-state-split-model-1" class="level5">
<h5 class="anchored" data-anchor-id="automaton-partitioning-state-split-model-1">2. Automaton Partitioning (State-Split Model)</h5>
<ul>
<li>Partition the state machine across threads or nodes.</li>
<li>Each processor is responsible for a subset of patterns or states.</li>
<li>Transitions are communicated via message passing (e.g., MPI).</li>
</ul>
<p>Pros: Good for static, small pattern sets Cons: Synchronization cost, complex state handoff</p>
<p>In both approaches:</p>
<ul>
<li>Each thread scans text in <span class="math inline">\(O(|T_i| + \text{output\_count}_i)\)</span></li>
<li>Results are merged at the end.</li>
</ul>
</section>
</section>
<section id="example-text-partitioning-1" class="level4">
<h4 class="anchored" data-anchor-id="example-text-partitioning-1">Example (Text Partitioning)</h4>
<p>Let <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"his"}, \texttt{"hers"}}
\]</span> and <span class="math display">\[
T = \texttt{"ushershehis"}
\]</span></p>
<p>Split <span class="math inline">\(T\)</span> into two parts with overlap of length 4 (max pattern length):</p>
<ul>
<li>Thread 1: <code>"ushersh"</code></li>
<li>Thread 2: <code>"shehis"</code></li>
</ul>
<p>Both threads run the same automaton. At merge time, deduplicate matches in overlapping region.</p>
<p>Each finds:</p>
<ul>
<li>Thread 1 → <code>she@1</code>, <code>he@2</code>, <code>hers@2</code></li>
<li>Thread 2 → <code>she@6</code>, <code>he@7</code>, <code>his@8</code></li>
</ul>
<p>Final result = union of both sets.</p>
</section>
<section id="tiny-code-parallel-example-python-threads-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-parallel-example-python-threads-1">Tiny Code (Parallel Example, Python Threads)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> concurrent.futures <span class="im">import</span> ThreadPoolExecutor</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search_chunk(ac, text, offset<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    matches <span class="op">=</span> []</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> ac.trie[node]:</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> ac.fail[node]</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> ac.trie[node].get(ch, <span class="dv">0</span>)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pat <span class="kw">in</span> ac.output[node]:</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>            matches.append((offset <span class="op">+</span> i <span class="op">-</span> <span class="bu">len</span>(pat) <span class="op">+</span> <span class="dv">1</span>, pat))</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matches</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parallel_search(ac, text, chunk_size, overlap):</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    tasks <span class="op">=</span> []</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> ThreadPoolExecutor() <span class="im">as</span> executor:</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(text), chunk_size):</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>            chunk <span class="op">=</span> text[i : i <span class="op">+</span> chunk_size <span class="op">+</span> overlap]</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>            tasks.append(executor.submit(search_chunk, ac, chunk, i))</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> tasks:</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>            results.extend(t.result())</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optionally deduplicate overlapping matches</span></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(<span class="bu">set</span>(results))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>patterns <span class="op">=</span> [<span class="st">"he"</span>, <span class="st">"she"</span>, <span class="st">"his"</span>, <span class="st">"hers"</span>]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> AhoCorasick(patterns)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(parallel_search(ac, <span class="st">"ushershehis"</span>, chunk_size<span class="op">=</span><span class="dv">6</span>, overlap<span class="op">=</span><span class="dv">4</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$(1, 'she'), (2, 'he'), (2, 'hers'), (6, 'she'), (7, 'he'), (8, 'his')]</code></pre>
</section>
<section id="why-it-matters-18" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-18">Why It Matters</h4>
<ul>
<li><p>Enables real-time matching on large-scale data</p></li>
<li><p>Used in:</p>
<ul>
<li>Intrusion detection systems (IDS)</li>
<li>Big data text analytics</li>
<li>Log scanning and threat detection</li>
<li>Genome sequence analysis</li>
<li>Network packet inspection</li>
</ul></li>
</ul>
<p>Parallelism brings Aho–Corasick to gigabyte-per-second throughput.</p>
</section>
<section id="complexity-18" class="level4">
<h4 class="anchored" data-anchor-id="complexity-18">Complexity</h4>
<p>For <span class="math inline">\(m\)</span> threads:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 54%">
<col style="width: 15%">
<col style="width: 1%">
<col style="width: 6%">
<col style="width: 2%">
<col style="width: 1%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build automaton</td>
<td><span class="math inline">\(O(\sum                                                 | p_i              | )\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Search</td>
<td><span class="math inline">\(O\left(\frac{n}{m} + \text{overlap}\right)\)</span> per thread</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Merge results</td>
<td><span class="math inline">\(O(k)\)</span></td>
<td><span class="math inline">\(O(k)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Total time approximates <span class="math display">\[
O\left(\frac{n}{m} + \text{overlap} \cdot m\right)
\]</span></p>
</section>
<section id="try-it-yourself-18" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-18">Try It Yourself</h4>
<ol type="1">
<li>Split <span class="math display">\[
T = \texttt{"bananabanabanana"}
\]</span> and <span class="math display">\[
P = {\texttt{"ana"}, \texttt{"banana"}}
\]</span> into chunks with overlap = 6.</li>
<li>Verify all matches found.</li>
<li>Experiment with different chunk sizes and overlaps.</li>
<li>Compare single-thread vs multi-thread performance.</li>
<li>Extend to multiprocessing or GPU streams.</li>
</ol>
<p>Parallel Aho–Corasick turns a sequential automaton into a scalable search engine, distributing the rhythm of matching across threads, yet producing a single, synchronized melody of results.</p>
</section>
</section>
<section id="compressed-ahocorasick-automaton" class="level3">
<h3 class="anchored" data-anchor-id="compressed-ahocorasick-automaton">619 Compressed Aho–Corasick Automaton</h3>
<p>The Compressed Aho–Corasick automaton is a space-optimized version of the classical Aho–Corasick structure. It preserves linear-time matching while reducing memory footprint through compact representations of states, transitions, and failure links, ideal for massive dictionaries or embedded systems.</p>
<section id="what-problem-are-we-solving-19" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-19">What Problem Are We Solving?</h4>
<p>The standard Aho–Corasick automaton stores:</p>
<ul>
<li>States: one per prefix of every pattern</li>
<li>Transitions: explicit dictionary of outgoing edges per state</li>
<li>Failure links and output sets</li>
</ul>
<p>For large pattern sets (millions of words), this becomes memory-heavy:</p>
<p><span class="math display">\[
O(\sum |p_i| \cdot \sigma)
\]</span></p>
<p>We need a space-efficient structure that fits into limited memory while maintaining:</p>
<ul>
<li>Deterministic transitions</li>
<li>Fast lookup (preferably <span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(\log \sigma)\)</span>)</li>
<li>Exact same matching behavior</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-19" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-19">How Does It Work (Plain Language)</h4>
<p>Compression focuses on representation, not algorithmic change. The matching logic is identical, but stored compactly.</p>
<p>There are several key strategies:</p>
<section id="sparse-transition-encoding" class="level5">
<h5 class="anchored" data-anchor-id="sparse-transition-encoding">1. Sparse Transition Encoding</h5>
<p>Instead of storing all <span class="math inline">\(\sigma\)</span> transitions per node, store only existing ones:</p>
<ul>
<li>Use hash tables or sorted arrays for edges</li>
<li>Binary search per character lookup</li>
<li>Reduces space from <span class="math inline">\(O(\sum |p_i| \cdot \sigma)\)</span> to <span class="math inline">\(O(\sum |p_i|)\)</span></li>
</ul>
</section>
<section id="double-array-trie" class="level5">
<h5 class="anchored" data-anchor-id="double-array-trie">2. Double-Array Trie</h5>
<p>Represent trie using two parallel arrays <code>base[]</code> and <code>check[]</code>:</p>
<ul>
<li><code>base[s] + c</code> gives next state</li>
<li><code>check[next] = s</code> confirms parent</li>
<li>Extremely compact and cache-friendly</li>
<li>Used in tools like Darts and MARP</li>
</ul>
<p>Transition: <span class="math display">\[
\text{next} = \text{base}[s] + \text{code}(c)
\]</span></p>
</section>
<section id="bit-packed-links" class="level5">
<h5 class="anchored" data-anchor-id="bit-packed-links">3. Bit-Packed Links</h5>
<p>Store failure links and outputs in integer arrays or bitsets:</p>
<ul>
<li>Each node’s fail pointer is a 32-bit integer</li>
<li>Output sets replaced with compressed indices or flags</li>
</ul>
<p>If a pattern ends at a node, mark it with a bitmask instead of a set.</p>
</section>
<section id="succinct-representation" class="level5">
<h5 class="anchored" data-anchor-id="succinct-representation">4. Succinct Representation</h5>
<p>Use wavelet trees or succinct tries to store edges:</p>
<ul>
<li>Space near theoretical lower bound</li>
<li>Transition queries in <span class="math inline">\(O(\log \sigma)\)</span></li>
<li>Ideal for very large alphabets (e.g., Unicode, DNA)</li>
</ul>
</section>
</section>
<section id="example-13" class="level4">
<h4 class="anchored" data-anchor-id="example-13">Example</h4>
<p>Consider patterns: <span class="math display">\[
P = {\texttt{"he"}, \texttt{"she"}, \texttt{"hers"}}
\]</span></p>
<p>Naive trie representation:</p>
<ul>
<li>Nodes: 8</li>
<li>Transitions: stored as dicts <code>{char: next_state}</code></li>
</ul>
<p>Compressed double-array representation:</p>
<ul>
<li><code>base = [0, 5, 9, ...]</code></li>
<li><code>check = [-1, 0, 1, 1, 2, ...]</code></li>
<li>Transition: <code>next = base[state] + code(char)</code></li>
</ul>
<p>Failure links and output sets stored as arrays:</p>
<pre><code>fail = [0, 0, 0, 1, 2, 3, ...]
output_flag = [0, 1, 1, 0, 1, ...]</code></pre>
<p>This reduces overhead drastically.</p>
</section>
<section id="tiny-code-python-example-using-sparse-dicts" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-example-using-sparse-dicts">Tiny Code (Python Example Using Sparse Dicts)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CompressedAC:</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trie <span class="op">=</span> [{}]</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fail <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output <span class="op">=</span> [<span class="dv">0</span>]  <span class="co"># bitmask flag</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, word, idx):</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie[node][ch] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.trie)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie.append({})</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail.append(<span class="dv">0</span>)</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output.append(<span class="dv">0</span>)</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node][ch]</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output[node] <span class="op">|=</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> idx)  <span class="co"># mark pattern end</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build(<span class="va">self</span>):</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> deque()</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, nxt <span class="kw">in</span> <span class="va">self</span>.trie[<span class="dv">0</span>].items():</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>            q.append(nxt)</span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> q:</span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> q.popleft()</span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ch, s <span class="kw">in</span> <span class="va">self</span>.trie[r].items():</span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>                q.append(s)</span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> <span class="va">self</span>.fail[r]</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[f]:</span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>                    f <span class="op">=</span> <span class="va">self</span>.fail[f]</span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail[s] <span class="op">=</span> <span class="va">self</span>.trie[f].get(ch, <span class="dv">0</span>)</span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output[s] <span class="op">|=</span> <span class="va">self</span>.output[<span class="va">self</span>.fail[s]]</span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, text):</span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="va">self</span>.fail[node]</span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node].get(ch, <span class="dv">0</span>)</span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.output[node]:</span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Match bitmask </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>output[node]<span class="sc">:b}</span><span class="ss"> at index </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Bitmasks replace sets, shrinking memory and enabling fast OR-merges.</p>
</section>
<section id="why-it-matters-19" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-19">Why It Matters</h4>
<ul>
<li><p>Memory-efficient: fits large dictionaries in RAM</p></li>
<li><p>Cache-friendly: improves real-world performance</p></li>
<li><p>Used in:</p>
<ul>
<li>Spam filters with large rule sets</li>
<li>Embedded systems (firewalls, IoT)</li>
<li>Search appliances and anti-virus engines</li>
</ul></li>
</ul>
<p>Compressed tries are foundational in systems that trade small overhead for massive throughput.</p>
</section>
<section id="complexity-19" class="level4">
<h4 class="anchored" data-anchor-id="complexity-19">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 27%">
<col style="width: 15%">
<col style="width: 18%">
<col style="width: 6%">
<col style="width: 2%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert patterns</td>
<td><span class="math inline">\(O(\sum                      | p_i              | )\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span> (compressed)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Build links</td>
<td><span class="math inline">\(O(\sum                      | p_i              | \cdot \log \sigma)\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Search text</td>
<td><span class="math inline">\(O(n + \text{output\_count})\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Compared to classical Aho–Corasick:</p>
<ul>
<li>Same asymptotic time</li>
<li>Reduced constants and memory usage</li>
</ul>
</section>
<section id="try-it-yourself-19" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-19">Try It Yourself</h4>
<ol type="1">
<li>Build both standard and compressed Aho–Corasick automata for <span class="math display">\[
P = {\texttt{"abc"}, \texttt{"abd"}, \texttt{"bcd"}, \texttt{"cd"}}
\]</span></li>
<li>Measure number of nodes and memory size.</li>
<li>Compare performance on a 1 MB random text.</li>
<li>Experiment with bitmasks for output merging.</li>
<li>Visualize the <code>base[]</code> and <code>check[]</code> arrays.</li>
</ol>
<p>A compressed Aho–Corasick automaton is lean yet powerful, every bit counts, every transition packed tight, delivering full pattern detection with a fraction of the space.</p>
</section>
</section>
<section id="extended-ahocorasick-with-wildcards" class="level3">
<h3 class="anchored" data-anchor-id="extended-ahocorasick-with-wildcards">620 Extended Aho–Corasick with Wildcards</h3>
<p>The Extended Aho–Corasick automaton generalizes the classic algorithm to handle wildcards, special symbols that can match any character. This version is essential for pattern sets containing flexible templates, such as <code>"he*o"</code>, <code>"a?b"</code>, or <code>"c*t"</code>. It allows robust multi-pattern matching in noisy or semi-structured data.</p>
<section id="what-problem-are-we-solving-20" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-20">What Problem Are We Solving?</h4>
<p>Traditional Aho–Corasick matches only exact patterns. But many real-world queries require wildcard tolerance, for example:</p>
<ul>
<li><code>"a?b"</code> → matches <code>"acb"</code>, <code>"adb"</code>, <code>"aeb"</code></li>
<li><code>"he*o"</code> → matches <code>"hello"</code>, <code>"hero"</code>, <code>"heyo"</code></li>
</ul>
<p>Given: <span class="math display">\[
P = {p_1, p_2, \ldots, p_k}
\]</span> and wildcard symbol(s) such as <code>?</code> (single) or <code>*</code> (multi), we need to find all substrings of text <span class="math inline">\(T\)</span> that match any pattern under wildcard semantics.</p>
</section>
<section id="how-does-it-work-plain-language-20" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-20">How Does It Work (Plain Language)</h4>
<p>We extend the trie and failure mechanism to handle wildcard transitions.</p>
<p>There are two main wildcard models:</p>
<section id="single-character-wildcard" class="level5">
<h5 class="anchored" data-anchor-id="single-character-wildcard">1. Single-Character Wildcard (<code>?</code>)</h5>
<ul>
<li>Represents exactly one arbitrary character</li>
<li>At construction time, each <code>?</code> creates a universal edge from the current state</li>
<li>During search, the automaton transitions to this state for any character</li>
</ul>
<p>Formally: <span class="math display">\[
\delta(u, c) = v \quad \text{if } c \in \Sigma \text{ and edge labeled '?' exists from } u
\]</span></p>
</section>
<section id="multi-character-wildcard" class="level5">
<h5 class="anchored" data-anchor-id="multi-character-wildcard">2. Multi-Character Wildcard (<code>*</code>)</h5>
<ul>
<li><p>Matches zero or more arbitrary characters</p></li>
<li><p>Creates a self-loop plus a skip edge to next state</p></li>
<li><p>Requires additional transitions:</p>
<ul>
<li><span class="math inline">\(\text{stay}(u, c) = u\)</span> for any <span class="math inline">\(c\)</span></li>
<li><span class="math inline">\(\text{skip}(u) = v\)</span> (next literal after <code>*</code>)</li>
</ul></li>
</ul>
<p>This effectively blends regular expression semantics into the Aho–Corasick structure.</p>
</section>
</section>
<section id="example-14" class="level4">
<h4 class="anchored" data-anchor-id="example-14">Example</h4>
<p>Patterns: <span class="math display">\[
P = {\texttt{"he?o"}, \texttt{"a*c"}}
\]</span> Text: <span class="math display">\[
T = \texttt{"hero and abc and aac"}
\]</span></p>
<ol type="1">
<li><code>"he?o"</code> matches <code>"hero"</code></li>
<li><code>"a*c"</code> matches <code>"abc"</code>, <code>"aac"</code></li>
</ol>
<p>Trie edges include:</p>
<pre><code>(root)
 ├── h ─ e ─ ? ─ o*
 └── a ─ * ─ c*</code></pre>
<p>Wildcard nodes expand transitions for all characters dynamically or by default edge handling.</p>
</section>
<section id="tiny-code-python-sketch-wildcard" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-wildcard">Tiny Code (Python Sketch, <code>?</code> Wildcard)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> WildcardAC:</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.trie <span class="op">=</span> [{}]</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fail <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output <span class="op">=</span> [<span class="bu">set</span>()]</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, word):</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie[node][ch] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.trie)</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.trie.append({})</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail.append(<span class="dv">0</span>)</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output.append(<span class="bu">set</span>())</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node][ch]</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.output[node].add(word)</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build(<span class="va">self</span>):</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> deque()</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, nxt <span class="kw">in</span> <span class="va">self</span>.trie[<span class="dv">0</span>].items():</span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>            q.append(nxt)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> q:</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> q.popleft()</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ch, s <span class="kw">in</span> <span class="va">self</span>.trie[r].items():</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>                q.append(s)</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>                f <span class="op">=</span> <span class="va">self</span>.fail[r]</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> f <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[f] <span class="kw">and</span> <span class="st">'?'</span> <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[f]:</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>                    f <span class="op">=</span> <span class="va">self</span>.fail[f]</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.fail[s] <span class="op">=</span> <span class="va">self</span>.trie[f].get(ch, <span class="va">self</span>.trie[f].get(<span class="st">'?'</span>, <span class="dv">0</span>))</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.output[s] <span class="op">|=</span> <span class="va">self</span>.output[<span class="va">self</span>.fail[s]]</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, text):</span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> []</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> node <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node] <span class="kw">and</span> <span class="st">'?'</span> <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.trie[node]:</span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="va">self</span>.fail[node]</span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>.trie[node].get(ch, <span class="va">self</span>.trie[node].get(<span class="st">'?'</span>, <span class="dv">0</span>))</span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pat <span class="kw">in</span> <span class="va">self</span>.output[node]:</span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a>                results.append((i <span class="op">-</span> <span class="bu">len</span>(pat) <span class="op">+</span> <span class="dv">1</span>, pat))</span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> results</span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a>patterns <span class="op">=</span> [<span class="st">"he?o"</span>, <span class="st">"a?c"</span>]</span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a>ac <span class="op">=</span> WildcardAC()</span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> patterns:</span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>    ac.insert(p)</span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>ac.build()</span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ac.search(<span class="st">"hero abc aac"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$(0, 'he?o'), (5, 'a?c'), (9, 'a?c')]</code></pre>
</section>
<section id="why-it-matters-20" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-20">Why It Matters</h4>
<ul>
<li><p>Supports pattern flexibility in structured data</p></li>
<li><p>Useful in:</p>
<ul>
<li>Log scanning with variable fields</li>
<li>Keyword search with templates</li>
<li>Malware and rule-based filtering</li>
<li>DNA sequence motif matching</li>
</ul></li>
<li><p>Extends beyond fixed strings toward regex-like matching, while remaining efficient</p></li>
</ul>
</section>
<section id="complexity-20" class="level4">
<h4 class="anchored" data-anchor-id="complexity-20">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 22%">
<col style="width: 19%">
<col style="width: 9%">
<col style="width: 4%">
<col style="width: 2%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build automaton</td>
<td><span class="math inline">\(O(\sum         | p_i              | \cdot \sigma)\)</span></td>
<td><span class="math inline">\(O(\sum | p_i | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Search text</td>
<td><span class="math inline">\(O(n \cdot d)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(d\)</span> is the branching factor from wildcard transitions (usually small). The automaton remains linear if wildcard edges are bounded.</p>
</section>
<section id="try-it-yourself-20" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-20">Try It Yourself</h4>
<ol type="1">
<li>Build an automaton for <span class="math display">\[
P = {\texttt{"c?t"}, \texttt{"b*g"}}
\]</span> and test on <code>"cat bag big cog bug"</code>.</li>
<li>Add overlapping wildcard patterns like <code>"a*a"</code> and <code>"aa*"</code>.</li>
<li>Visualize wildcard transitions in the trie.</li>
<li>Measure runtime with vs without wildcards.</li>
<li>Extend to both <code>?</code> and <code>*</code> handling.</li>
</ol>
<p>The Extended Aho–Corasick with Wildcards brings together deterministic automata and pattern generalization, matching both the exact and the uncertain, all in one unified scan.</p>
</section>
</section>
</section>
<section id="section-63.-suffix-structure" class="level1">
<h1>Section 63. Suffix Structure</h1>
<section id="suffix-array-naive" class="level3">
<h3 class="anchored" data-anchor-id="suffix-array-naive">621 Suffix Array (Naive)</h3>
<p>The suffix array is a fundamental data structure in string algorithms, a sorted list of all suffixes of a string. It provides a compact and efficient way to perform substring search, pattern matching, and text indexing, forming the backbone of structures like the FM-index and Burrows–Wheeler Transform.</p>
<p>The naive algorithm constructs the suffix array by generating all suffixes, sorting them lexicographically, and recording their starting positions.</p>
<section id="what-problem-are-we-solving-21" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-21">What Problem Are We Solving?</h4>
<p>Given a string <span class="math display">\[
S = s_0 s_1 \ldots s_{n-1}
\]</span> we want to build an array <span class="math display">\[
SA[0 \ldots n-1]
\]</span> such that <span class="math display">\[
S[SA[0] \ldots n-1] &lt; S[SA[1] \ldots n-1] &lt; \cdots &lt; S[SA[n-1] \ldots n-1]
\]</span> in lexicographic order.</p>
<p>Each entry in the suffix array points to the starting index of a suffix in sorted order.</p>
<p>Example: Let <span class="math display">\[
S = \texttt{"banana"}
\]</span></p>
<p>All suffixes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Index</th>
<th>Suffix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>banana</td>
</tr>
<tr class="even">
<td>1</td>
<td>anana</td>
</tr>
<tr class="odd">
<td>2</td>
<td>nana</td>
</tr>
<tr class="even">
<td>3</td>
<td>ana</td>
</tr>
<tr class="odd">
<td>4</td>
<td>na</td>
</tr>
<tr class="even">
<td>5</td>
<td>a</td>
</tr>
</tbody>
</table>
<p>Sorted lexicographically:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Rank</th>
<th>Suffix</th>
<th>Index</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>a</td>
<td>5</td>
</tr>
<tr class="even">
<td>1</td>
<td>ana</td>
<td>3</td>
</tr>
<tr class="odd">
<td>2</td>
<td>anana</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>banana</td>
<td>0</td>
</tr>
<tr class="odd">
<td>4</td>
<td>na</td>
<td>4</td>
</tr>
<tr class="even">
<td>5</td>
<td>nana</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Thus: <span class="math display">\[
SA = [5, 3, 1, 0, 4, 2]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-21" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-21">How Does It Work (Plain Language)</h4>
<p>The naive algorithm proceeds as follows:</p>
<ol type="1">
<li><p>Generate all suffixes Create <span class="math inline">\(n\)</span> substrings starting at each index <span class="math inline">\(i\)</span>.</p></li>
<li><p>Sort suffixes Compare strings lexicographically (like dictionary order).</p></li>
<li><p>Store indices Collect starting indices of sorted suffixes into array <code>SA</code>.</p></li>
</ol>
<p>This is straightforward but inefficient, every suffix comparison may take <span class="math inline">\(O(n)\)</span> time, and there are <span class="math inline">\(O(n \log n)\)</span> comparisons.</p>
</section>
<section id="algorithm-step-by-step" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-step-by-step">Algorithm (Step by Step)</h4>
<ol type="1">
<li><p>Initialize list of pairs: <span class="math display">\[
L = [(i, S[i:])] \quad \text{for } i = 0, 1, \ldots, n-1
\]</span></p></li>
<li><p>Sort <span class="math inline">\(L\)</span> by the string component.</p></li>
<li><p>Output array: <span class="math display">\[
SA[j] = L[j].i
\]</span></p></li>
</ol>
</section>
<section id="tiny-code-easy-versions-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-easy-versions-9">Tiny Code (Easy Versions)</h4>
<p>Python</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> suffix_array_naive(s):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    suffixes <span class="op">=</span> [(i, s[i:]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    suffixes.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [idx <span class="cf">for</span> idx, _ <span class="kw">in</span> suffixes]</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"banana"</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(suffix_array_naive(s))  <span class="co"># [5, 3, 1, 0, 4, 2]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>C</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> index<span class="op">;</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>suffix<span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Suffix<span class="op">;</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cmp<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    Suffix <span class="op">*</span>sa <span class="op">=</span> <span class="op">(</span>Suffix <span class="op">*)</span>a<span class="op">;</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    Suffix <span class="op">*</span>sb <span class="op">=</span> <span class="op">(</span>Suffix <span class="op">*)</span>b<span class="op">;</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> strcmp<span class="op">(</span>sa<span class="op">-&gt;</span>suffix<span class="op">,</span> sb<span class="op">-&gt;</span>suffix<span class="op">);</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> build_suffix_array<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> sa<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>    Suffix arr<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">].</span>index <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">].</span>suffix <span class="op">=</span> s <span class="op">+</span> i<span class="op">;</span></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>arr<span class="op">,</span> n<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Suffix<span class="op">),</span> cmp<span class="op">);</span></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>        sa<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>i<span class="op">].</span>index<span class="op">;</span></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">"banana"</span><span class="op">;</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sa<span class="op">[</span><span class="dv">6</span><span class="op">];</span></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>    build_suffix_array<span class="op">(</span>s<span class="op">,</span> sa<span class="op">);</span></span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">6</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> sa<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-21" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-21">Why It Matters</h4>
<ul>
<li>Enables fast substring search via binary search</li>
<li>Foundation for LCP (Longest Common Prefix) and suffix tree construction</li>
<li>Core in compressed text indexes like FM-index and BWT</li>
<li>Simple, educational introduction to more advanced <span class="math inline">\(O(n \log n)\)</span> and <span class="math inline">\(O(n)\)</span> methods</li>
</ul>
</section>
<section id="complexity-21" class="level4">
<h4 class="anchored" data-anchor-id="complexity-21">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 60%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Generate suffixes</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="even">
<td>Sort</td>
<td><span class="math inline">\(O(n \log n)\)</span> comparisons × <span class="math inline">\(O(n)\)</span> each</td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(n^2 \log n)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
</tbody>
</table>
<p>Slow, but conceptually clear and easy to implement.</p>
</section>
<section id="try-it-yourself-21" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-21">Try It Yourself</h4>
<ol type="1">
<li>Compute suffix array for <code>"abracadabra"</code>.</li>
<li>Verify lexicographic order of suffixes.</li>
<li>Use binary search on <code>SA</code> to find substring <code>"bra"</code>.</li>
<li>Compare with suffix array built by doubling algorithm.</li>
<li>Optimize storage to avoid storing full substrings.</li>
</ol>
<p>The naive suffix array is a pure, clear view of text indexing, every suffix, every order, one by one, simple to build, and a perfect first step toward the elegant <span class="math inline">\(O(n \log n)\)</span> and <span class="math inline">\(O(n)\)</span> algorithms that follow.</p>
</section>
</section>
<section id="suffix-array-doubling-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="suffix-array-doubling-algorithm">622 Suffix Array (Doubling Algorithm)</h3>
<p>The doubling algorithm builds a suffix array in <span class="math display">\[
O(n \log n)
\]</span> time, a major improvement over the naive <span class="math inline">\(O(n^2 \log n)\)</span> approach. It works by ranking prefixes of length <span class="math inline">\(2^k\)</span>, doubling that length each iteration, until the whole string is sorted.</p>
<p>This elegant idea, sorting by progressively longer prefixes, makes it both fast and conceptually clear.</p>
<section id="what-problem-are-we-solving-22" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-22">What Problem Are We Solving?</h4>
<p>Given a string <span class="math display">\[
S = s_0 s_1 \ldots s_{n-1}
\]</span> we want to compute its suffix array <span class="math display">\[
SA[0 \ldots n-1]
\]</span> such that <span class="math display">\[
S[SA[0]:] &lt; S[SA[1]:] &lt; \ldots &lt; S[SA[n-1]:]
\]</span></p>
<p>Instead of comparing entire suffixes, we compare prefixes of length <span class="math inline">\(2^k\)</span>, using integer ranks from the previous iteration, just like radix sort.</p>
</section>
<section id="how-does-it-work-plain-language-22" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-22">How Does It Work (Plain Language)</h4>
<p>We’ll sort suffixes by first 1 character, then 2, then 4, then 8, and so on. At each stage, we assign each suffix a pair of ranks:</p>
<p><span class="math display">\[
\text{rank}*k[i] = (\text{rank}*{k-1}[i], \text{rank}_{k-1}[i + 2^{k-1}])
\]</span></p>
<p>We sort suffixes by this pair and assign new ranks. After <span class="math inline">\(\log_2 n\)</span> rounds, all suffixes are fully sorted.</p>
</section>
<section id="example-15" class="level4">
<h4 class="anchored" data-anchor-id="example-15">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"banana"}
\]</span></p>
<ol type="1">
<li>Initial ranks (by single character):</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Index</th>
<th>Char</th>
<th>Rank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>b</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>a</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>n</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>a</td>
<td>0</td>
</tr>
<tr class="odd">
<td>4</td>
<td>n</td>
<td>2</td>
</tr>
<tr class="even">
<td>5</td>
<td>a</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>Sort by pairs (rank, next rank):</li>
</ol>
<p>For <span class="math inline">\(k = 1\)</span> (prefix length <span class="math inline">\(2\)</span>):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>pair</th>
<th>suffix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>(1, 0)</td>
<td>banana</td>
</tr>
<tr class="even">
<td>1</td>
<td>(0, 2)</td>
<td>anana</td>
</tr>
<tr class="odd">
<td>2</td>
<td>(2, 0)</td>
<td>nana</td>
</tr>
<tr class="even">
<td>3</td>
<td>(0, 2)</td>
<td>ana</td>
</tr>
<tr class="odd">
<td>4</td>
<td>(2, 0)</td>
<td>na</td>
</tr>
<tr class="even">
<td>5</td>
<td>(0,-1)</td>
<td>a</td>
</tr>
</tbody>
</table>
<p>Sort lexicographically by pair, assign new ranks.</p>
<p>Repeat doubling until ranks are unique.</p>
<p>Final <span class="math display">\[
SA = [5, 3, 1, 0, 4, 2]
\]</span></p>
</section>
<section id="algorithm-step-by-step-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-step-by-step-1">Algorithm (Step by Step)</h4>
<ol type="1">
<li><p>Initialize ranks Sort suffixes by first character.</p></li>
<li><p>Iteratively sort by 2ᵏ prefixes For <span class="math inline">\(k = 1, 2, \ldots\)</span></p>
<ul>
<li>Form tuples <span class="math display">\[
(rank[i], rank[i + 2^{k-1}])
\]</span></li>
<li>Sort suffixes by these tuples</li>
<li>Assign new ranks</li>
</ul></li>
<li><p>Stop when all ranks are distinct or <span class="math inline">\(2^k \ge n\)</span></p></li>
</ol>
</section>
<section id="tiny-code-python-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-1">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> suffix_array_doubling(s):</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> [<span class="bu">ord</span>(c) <span class="cf">for</span> c <span class="kw">in</span> s]</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    sa <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(n))</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>        sa.sort(key<span class="op">=</span><span class="kw">lambda</span> i: (rank[i], rank[i <span class="op">+</span> k] <span class="cf">if</span> i <span class="op">+</span> k <span class="op">&lt;</span> n <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        tmp[sa[<span class="dv">0</span>]] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> (rank[sa[i<span class="op">-</span><span class="dv">1</span>]], rank[sa[i<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span>k] <span class="cf">if</span> sa[i<span class="op">-</span><span class="dv">1</span>]<span class="op">+</span>k <span class="op">&lt;</span> n <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>            curr <span class="op">=</span> (rank[sa[i]], rank[sa[i]<span class="op">+</span>k] <span class="cf">if</span> sa[i]<span class="op">+</span>k <span class="op">&lt;</span> n <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>            tmp[sa[i]] <span class="op">=</span> tmp[sa[i<span class="op">-</span><span class="dv">1</span>]] <span class="op">+</span> (curr <span class="op">!=</span> prev)</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>        rank[:] <span class="op">=</span> tmp[:]</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        k <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">max</span>(rank) <span class="op">==</span> n<span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sa</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"banana"</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(suffix_array_doubling(s))  <span class="co"># [5, 3, 1, 0, 4, 2]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-22" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-22">Why It Matters</h4>
<ul>
<li>Reduces naive <span class="math inline">\(O(n^2 \log n)\)</span> to <span class="math inline">\(O(n \log n)\)</span></li>
<li>Foundation for Kasai’s LCP computation</li>
<li>Simple yet fast, widely used in practical suffix array builders</li>
<li>Extensible to cyclic rotations and minimal string rotation</li>
</ul>
</section>
<section id="complexity-22" class="level4">
<h4 class="anchored" data-anchor-id="complexity-22">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sorting (per round)</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Rounds</td>
<td><span class="math inline">\(\log n\)</span></td>
<td>,</td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-22" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-22">Try It Yourself</h4>
<ol type="1">
<li>Build suffix array for <code>"mississippi"</code>.</li>
<li>Trace first 3 rounds of ranking.</li>
<li>Verify sorted suffixes manually.</li>
<li>Compare runtime with naive method.</li>
<li>Use resulting ranks for LCP computation (Kasai’s algorithm).</li>
</ol>
<p>The doubling algorithm is the bridge from clarity to performance, iterative refinement, powers of two, and lex order, simple ranks revealing the full order of the string.</p>
</section>
</section>
<section id="kasais-lcp-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="kasais-lcp-algorithm">623 Kasai’s LCP Algorithm</h3>
<p>The Kasai algorithm computes the Longest Common Prefix (LCP) array from a suffix array in linear time. It tells you, for every adjacent pair of suffixes in sorted order, how many characters they share at the beginning, revealing the structure of repetitions and overlaps inside the string.</p>
<section id="what-problem-are-we-solving-23" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-23">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(S\)</span> and its suffix array <span class="math inline">\(SA\)</span>, we want to compute the LCP array, where:</p>
<p><span class="math display">\[
LCP[i] = \text{length of common prefix between } S[SA[i]] \text{ and } S[SA[i-1]]
\]</span></p>
<p>This allows us to answer questions like:</p>
<ul>
<li>How many repeated substrings exist?</li>
<li>What’s the longest repeated substring?</li>
<li>What’s the similarity between adjacent suffixes?</li>
</ul>
<p>Example:</p>
<p>Let <span class="math display">\[
S = \texttt{"banana"}
\]</span> and <span class="math display">\[
SA = [5, 3, 1, 0, 4, 2]
\]</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>SA[i]</th>
<th>Suffix</th>
<th>LCP[i]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>5</td>
<td>a</td>
<td>,</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>ana</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>anana</td>
<td>3</td>
</tr>
<tr class="even">
<td>3</td>
<td>0</td>
<td>banana</td>
<td>0</td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
<td>na</td>
<td>0</td>
</tr>
<tr class="even">
<td>5</td>
<td>2</td>
<td>nana</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>So: <span class="math display">\[
LCP = [0, 1, 3, 0, 0, 2]
\]</span></p>
</section>
<section id="how-does-it-work-plain-language-23" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-23">How Does It Work (Plain Language)</h4>
<p>Naively comparing each adjacent pair of suffixes costs <span class="math inline">\(O(n^2)\)</span>. Kasai’s trick: reuse previous LCP computation.</p>
<p>If <span class="math inline">\(h\)</span> is the LCP of <span class="math inline">\(S[i:]\)</span> and <span class="math inline">\(S[j:]\)</span>, then the LCP of <span class="math inline">\(S[i+1:]\)</span> and <span class="math inline">\(S[j+1:]\)</span> is at least <span class="math inline">\(h-1\)</span>. So we slide down one character at a time, reusing previous overlap.</p>
</section>
<section id="step-by-step-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-algorithm">Step-by-Step Algorithm</h4>
<ol type="1">
<li><p>Build inverse suffix array <code>rank[]</code> such that <span class="math display">\[
\text{rank}[SA[i]] = i
\]</span></p></li>
<li><p>Initialize <span class="math inline">\(h = 0\)</span></p></li>
<li><p>For each position <span class="math inline">\(i\)</span> in <span class="math inline">\(S\)</span>:</p>
<ul>
<li><p>If <span class="math inline">\(rank[i] &gt; 0\)</span>:</p>
<ul>
<li>Let <span class="math inline">\(j = SA[rank[i] - 1]\)</span></li>
<li>Compare <span class="math inline">\(S[i+h]\)</span> and <span class="math inline">\(S[j+h]\)</span></li>
<li>Increase <span class="math inline">\(h\)</span> while they match</li>
<li>Set <span class="math inline">\(LCP[rank[i]] = h\)</span></li>
<li>Decrease <span class="math inline">\(h\)</span> by 1 (for next iteration)</li>
</ul></li>
</ul></li>
</ol>
<p>This makes sure each character is compared at most twice.</p>
</section>
<section id="example-walkthrough" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough">Example Walkthrough</h4>
<p>For <code>"banana"</code>:</p>
<p>Suffix array: <span class="math display">\[
SA = [5, 3, 1, 0, 4, 2]
\]</span> Inverse rank: <span class="math display">\[
rank = [3, 2, 5, 1, 4, 0]
\]</span></p>
<p>Now iterate <span class="math inline">\(i\)</span> from 0 to 5:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>rank[i]</th>
<th>j = SA[rank[i]-1]</th>
<th>Compare</th>
<th>h</th>
<th>LCP[rank[i]]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>3</td>
<td>1</td>
<td>banana vs anana</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>2</td>
<td>3</td>
<td>anana vs ana</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>2</td>
<td>5</td>
<td>4</td>
<td>nana vs na</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>5</td>
<td>ana vs a</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>4</td>
<td>0</td>
<td>na vs banana</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>5</td>
<td>0</td>
<td>,</td>
<td>skip</td>
<td>,</td>
<td>,</td>
</tr>
</tbody>
</table>
<p>So <span class="math display">\[
LCP = [0, 1, 3, 0, 0, 2]
\]</span></p>
</section>
<section id="tiny-code-python-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-2">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kasai(s, sa):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        rank[sa[i]] <span class="op">=</span> i</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    lcp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> rank[i] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> sa[rank[i] <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> i <span class="op">+</span> h <span class="op">&lt;</span> n <span class="kw">and</span> j <span class="op">+</span> h <span class="op">&lt;</span> n <span class="kw">and</span> s[i <span class="op">+</span> h] <span class="op">==</span> s[j <span class="op">+</span> h]:</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>                h <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>            lcp[rank[i]] <span class="op">=</span> h</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> h <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>                h <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lcp</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"banana"</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>sa <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">2</span>]</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(kasai(s, sa))  <span class="co"># [0, 1, 3, 0, 0, 2]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-23" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-23">Why It Matters</h4>
<ul>
<li><p>Fundamental for string processing:</p>
<ul>
<li>Longest repeated substring</li>
<li>Number of distinct substrings</li>
<li>Common substring queries</li>
</ul></li>
<li><p>Linear time, easy to integrate with suffix array</p></li>
<li><p>Core component in bioinformatics, indexing, and data compression</p></li>
</ul>
</section>
<section id="complexity-23" class="level4">
<h4 class="anchored" data-anchor-id="complexity-23">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build rank array</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>LCP computation</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Total</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-23" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-23">Try It Yourself</h4>
<ol type="1">
<li>Compute <code>LCP</code> for <code>"mississippi"</code>.</li>
<li>Draw suffix array and adjacent suffixes.</li>
<li>Find longest repeated substring using max LCP.</li>
<li>Count number of distinct substrings via <span class="math display">\[
\frac{n(n+1)}{2} - \sum_i LCP[i]
\]</span></li>
<li>Compare with naive pairwise approach.</li>
</ol>
<p>Kasai’s algorithm is a masterpiece of reuse, slide, reuse, and reduce. Every character compared once forward, once backward, and the entire structure of overlap unfolds in linear time.</p>
</section>
</section>
<section id="suffix-tree-ukkonens-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="suffix-tree-ukkonens-algorithm">624 Suffix Tree (Ukkonen’s Algorithm)</h3>
<p>The suffix tree is a powerful data structure that compactly represents all suffixes of a string. With Ukkonen’s algorithm, we can build it in linear time — <span class="math display">\[
O(n)
\]</span>, a landmark achievement in string processing.</p>
<p>A suffix tree unlocks a world of efficient solutions: substring search, longest repeated substring, pattern frequency, and much more, all in <span class="math inline">\(O(m)\)</span> query time for a pattern of length <span class="math inline">\(m\)</span>.</p>
<section id="what-problem-are-we-solving-24" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-24">What Problem Are We Solving?</h4>
<p>Given a string <span class="math display">\[
S = s_0 s_1 \ldots s_{n-1}
\]</span> we want a tree where:</p>
<ul>
<li>Each path from root corresponds to a prefix of a suffix of <span class="math inline">\(S\)</span>.</li>
<li>Each leaf corresponds to a suffix.</li>
<li>Edge labels are substrings of <span class="math inline">\(S\)</span> (not single chars).</li>
<li>The tree is compressed: no redundant nodes with single child.</li>
</ul>
<p>The structure should support:</p>
<ul>
<li>Substring search: <span class="math inline">\(O(m)\)</span></li>
<li>Count distinct substrings: <span class="math inline">\(O(n)\)</span></li>
<li>Longest repeated substring: via deepest internal node</li>
</ul>
</section>
<section id="example-16" class="level4">
<h4 class="anchored" data-anchor-id="example-16">Example</h4>
<p>For<br>
<span class="math display">\[
S = \texttt{"banana\textdollar"}
\]</span></p>
<p>All suffixes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>Suffix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>banana$</td>
</tr>
<tr class="even">
<td>1</td>
<td>anana$</td>
</tr>
<tr class="odd">
<td>2</td>
<td>nana$</td>
</tr>
<tr class="even">
<td>3</td>
<td>ana$</td>
</tr>
<tr class="odd">
<td>4</td>
<td>na$</td>
</tr>
<tr class="even">
<td>5</td>
<td>a$</td>
</tr>
<tr class="odd">
<td>6</td>
<td>$</td>
</tr>
</tbody>
</table>
<p>The suffix tree compresses these suffixes into shared paths.</p>
<p>The root branches into: - <code>$</code> → terminal leaf<br>
- <code>a</code> → covering suffixes starting at positions 1, 3, and 5 (<code>anana$</code>, <code>ana$</code>, <code>a$</code>)<br>
- <code>b</code> → covering suffix starting at position 0 (<code>banana$</code>)<br>
- <code>n</code> → covering suffixes starting at positions 2 and 4 (<code>nana$</code>, <code>na$</code>)</p>
<pre><code>(root)
├── a → na → na$
├── b → anana$
├── n → a → na$
└── $</code></pre>
<p>Every suffix appears exactly once as a path.</p>
</section>
<section id="why-naive-construction-is-slow" class="level4">
<h4 class="anchored" data-anchor-id="why-naive-construction-is-slow">Why Naive Construction Is Slow</h4>
<p>Naively inserting all <span class="math inline">\(n\)</span> suffixes into a trie takes <span class="math display">\[
O(n^2)
\]</span> since each suffix is <span class="math inline">\(O(n)\)</span> long.</p>
<p>Ukkonen’s algorithm incrementally builds online, maintaining suffix links and implicit suffix trees, achieving <span class="math display">\[
O(n)
\]</span> time and space.</p>
</section>
<section id="how-it-works-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language">How It Works (Plain Language)</h4>
<p>Ukkonen’s algorithm builds the tree one character at a time.</p>
<p>We maintain:</p>
<ul>
<li>Active Point: current node + edge + offset</li>
<li>Suffix Links: shortcuts between internal nodes</li>
<li>Implicit Tree: built so far (without ending every suffix)</li>
</ul>
<p>At step <span class="math inline">\(i\)</span> (after reading <span class="math inline">\(S[0..i]\)</span>):</p>
<ul>
<li>Add new suffixes ending at <span class="math inline">\(i\)</span></li>
<li>Reuse previous structure with suffix links</li>
<li>Split edges only when necessary</li>
</ul>
<p>After final character (often <code>$</code>), tree becomes explicit, containing all suffixes.</p>
</section>
<section id="step-by-step-sketch" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-sketch">Step-by-Step Sketch</h4>
<ol type="1">
<li><p>Initialize empty root</p></li>
<li><p>For each position <span class="math inline">\(i\)</span> in <span class="math inline">\(S\)</span>:</p>
<ul>
<li>Extend all suffixes ending at <span class="math inline">\(i\)</span></li>
<li>Use active point to track insertion position</li>
<li>Create internal nodes and suffix links as needed</li>
</ul></li>
<li><p>Repeat until full tree is built</p></li>
</ol>
<p>Suffix links skip redundant traversal, turning quadratic work into linear.</p>
</section>
<section id="example-sketch" class="level4">
<h4 class="anchored" data-anchor-id="example-sketch">Example (Sketch)</h4>
<p>Build for <code>abcab$</code>:</p>
<ul>
<li>Add <code>a</code>: path <code>a</code></li>
<li>Add <code>b</code>: paths <code>a</code>, <code>b</code></li>
<li>Add <code>c</code>: paths <code>a</code>, <code>b</code>, <code>c</code></li>
<li>Add <code>a</code>: paths reuse existing prefix</li>
<li>Add <code>b</code>: creates internal node for <code>ab</code></li>
<li>Add <code>$</code>: closes all suffixes</li>
</ul>
<p>Result: compressed tree with 6 leaves, one per suffix.</p>
</section>
<section id="tiny-code-simplified-python" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-python">Tiny Code (Simplified, Python)</h4>
<p><em>(Simplified pseudo-implementation, for educational clarity)</em></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node:</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> {}</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.link <span class="op">=</span> <span class="va">None</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_suffix_tree(s):</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="st">"$"</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> Node()</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> root</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, n):</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>            ch <span class="op">=</span> s[j]</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> current.edges:</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>                current.edges[ch] <span class="op">=</span> Node()</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> current.edges[ch]</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> root</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Naive O(n^2) version for intuition</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> build_suffix_tree(<span class="st">"banana"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Ukkonen’s true implementation uses edge spans <code>[l, r]</code> to avoid copying substrings, and active point management to ensure <span class="math inline">\(O(n)\)</span> time.</p>
</section>
<section id="why-it-matters-24" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-24">Why It Matters</h4>
<ul>
<li><p>Fast substring search: <span class="math inline">\(O(m)\)</span></p></li>
<li><p>Count distinct substrings: number of paths</p></li>
<li><p>Longest repeated substring: deepest internal node</p></li>
<li><p>Longest common substring (of two strings): via generalized suffix tree</p></li>
<li><p>Basis for:</p>
<ul>
<li>LCP array (via DFS)</li>
<li>Suffix automaton</li>
<li>FM-index</li>
</ul></li>
</ul>
</section>
<section id="complexity-24" class="level4">
<h4 class="anchored" data-anchor-id="complexity-24">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Query</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Count substrings</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-24" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-24">Try It Yourself</h4>
<ol type="1">
<li>Build suffix tree for <code>"abaaba$"</code>.</li>
<li>Mark leaf nodes with starting index.</li>
<li>Count number of distinct substrings.</li>
<li>Trace active point movement in Ukkonen’s algorithm.</li>
<li>Compare with suffix array + LCP construction.</li>
</ol>
<p>The suffix tree is the cathedral of string structures, every suffix a path, every branch a shared history, and Ukkonen’s algorithm lays each stone in perfect linear time.</p>
</section>
</section>
<section id="suffix-automaton" class="level3">
<h3 class="anchored" data-anchor-id="suffix-automaton">625 Suffix Automaton</h3>
<p>The suffix automaton is the smallest deterministic finite automaton (DFA) that recognizes all substrings of a given string. It captures every substring implicitly, in a compact, linear-size structure, perfect for substring queries, repetition analysis, and pattern counting.</p>
<p>Built in <span class="math inline">\(O(n)\)</span> time, it’s often called the “Swiss Army knife” of string algorithms, flexible, elegant, and deeply powerful.</p>
<section id="what-problem-are-we-solving-25" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-25">What Problem Are We Solving?</h4>
<p>Given a string <span class="math display">\[
S = s_0 s_1 \ldots s_{n-1}
\]</span> we want an automaton that:</p>
<ul>
<li><p>Accepts exactly the set of all substrings of <span class="math inline">\(S\)</span></p></li>
<li><p>Supports queries like:</p>
<ul>
<li>“Is <span class="math inline">\(T\)</span> a substring of <span class="math inline">\(S\)</span>?”</li>
<li>“How many distinct substrings does <span class="math inline">\(S\)</span> have?”</li>
<li>“Longest common substring with another string”</li>
</ul></li>
<li><p>Is minimal: no equivalent states, deterministic transitions</p></li>
</ul>
<p>The suffix automaton (SAM) does exactly this — constructed incrementally, state by state, edge by edge.</p>
</section>
<section id="key-idea" class="level4">
<h4 class="anchored" data-anchor-id="key-idea">Key Idea</h4>
<p>Each state represents a set of substrings that share the same end positions in <span class="math inline">\(S\)</span>. Each transition represents appending one character. Suffix links connect states that represent “next smaller” substring sets.</p>
<p>So the SAM is essentially the DFA of all substrings, built online, in linear time.</p>
</section>
<section id="how-does-it-work-plain-language-24" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-24">How Does It Work (Plain Language)</h4>
<p>We build the automaton as we read <span class="math inline">\(S\)</span>, extending it character by character:</p>
<ol type="1">
<li><p>Start with initial state (empty string)</p></li>
<li><p>For each new character <span class="math inline">\(c\)</span>:</p>
<ul>
<li>Create a new state for substrings ending with <span class="math inline">\(c\)</span></li>
<li>Follow suffix links to extend old paths</li>
<li>Maintain minimality by cloning states when necessary</li>
</ul></li>
<li><p>Update suffix links to ensure every substring’s end position is represented</p></li>
</ol>
<p>Each extension adds at most two states, so total states ≤ <span class="math inline">\(2n - 1\)</span>.</p>
</section>
<section id="example-17" class="level4">
<h4 class="anchored" data-anchor-id="example-17">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"aba"}
\]</span></p>
<p>Step 1: Start with initial state (id 0)</p>
<p>Step 2: Add <code>'a'</code></p>
<pre><code>0 --a--&gt; 1</code></pre>
<p>link(1) = 0</p>
<p>Step 3: Add <code>'b'</code></p>
<pre><code>1 --b--&gt; 2
0 --b--&gt; 2</code></pre>
<p>link(2) = 0</p>
<p>Step 4: Add <code>'a'</code></p>
<ul>
<li>Extend from state 2 by <code>'a'</code></li>
<li>Need clone state since overlap</li>
</ul>
<pre><code>2 --a--&gt; 3
link(3) = 1</code></pre>
<p>Now automaton accepts: <code>"a"</code>, <code>"b"</code>, <code>"ab"</code>, <code>"ba"</code>, <code>"aba"</code> All substrings represented!</p>
</section>
<section id="tiny-code-python-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-3">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> State:</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="bu">next</span> <span class="op">=</span> {}</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.link <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="bu">len</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_suffix_automaton(s):</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    sa <span class="op">=</span> [State()]</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    last <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch <span class="kw">in</span> s:</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        cur <span class="op">=</span> <span class="bu">len</span>(sa)</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>        sa.append(State())</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>        sa[cur].<span class="bu">len</span> <span class="op">=</span> sa[last].<span class="bu">len</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> last</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> p <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> sa[p].<span class="bu">next</span>:</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>            sa[p].<span class="bu">next</span>[ch] <span class="op">=</span> cur</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> sa[p].link</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>            sa[cur].link <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>            q <span class="op">=</span> sa[p].<span class="bu">next</span>[ch]</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> sa[p].<span class="bu">len</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> sa[q].<span class="bu">len</span>:</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>                sa[cur].link <span class="op">=</span> q</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>                clone <span class="op">=</span> <span class="bu">len</span>(sa)</span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>                sa.append(State())</span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>                sa[clone].<span class="bu">len</span> <span class="op">=</span> sa[p].<span class="bu">len</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>                sa[clone].<span class="bu">next</span> <span class="op">=</span> sa[q].<span class="bu">next</span>.copy()</span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>                sa[clone].link <span class="op">=</span> sa[q].link</span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> p <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> sa[p].<span class="bu">next</span>[ch] <span class="op">==</span> q:</span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>                    sa[p].<span class="bu">next</span>[ch] <span class="op">=</span> clone</span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>                    p <span class="op">=</span> sa[p].link</span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>                sa[q].link <span class="op">=</span> sa[cur].link <span class="op">=</span> clone</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> cur</span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sa</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>sam <span class="op">=</span> build_suffix_automaton(<span class="st">"aba"</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(sam))  <span class="co"># number of states (≤ 2n - 1)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-25" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-25">Why It Matters</h4>
<ul>
<li>Linear construction Build in <span class="math inline">\(O(n)\)</span></li>
<li>Substring queries Check if <span class="math inline">\(T\)</span> in <span class="math inline">\(S\)</span> in <span class="math inline">\(O(|T|)\)</span></li>
<li>Counting distinct substrings <span class="math display">\[
\sum_{v} (\text{len}[v] - \text{len}[\text{link}[v]])
\]</span></li>
<li>Longest common substring Run second string through automaton</li>
<li>Frequency analysis Count occurrences via end positions</li>
</ul>
</section>
<section id="complexity-25" class="level4">
<h4 class="anchored" data-anchor-id="complexity-25">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Substring query</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Distinct substrings</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-25" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-25">Try It Yourself</h4>
<ol type="1">
<li>Build SAM for <code>"banana"</code> Count distinct substrings.</li>
<li>Verify total = <span class="math inline">\(n(n+1)/2 - \sum LCP[i]\)</span></li>
<li>Add code to compute occurrences per substring.</li>
<li>Test substring search for <code>"nan"</code>, <code>"ana"</code>, <code>"nana"</code>.</li>
<li>Build SAM for reversed string and find palindromes.</li>
</ol>
<p>The suffix automaton is minimal yet complete — each state a horizon of possible endings, each link a bridge to a shorter shadow. A perfect mirror of all substrings, built step by step, in linear time.</p>
</section>
</section>
<section id="sa-is-algorithm-linear-time-suffix-array-construction" class="level3">
<h3 class="anchored" data-anchor-id="sa-is-algorithm-linear-time-suffix-array-construction">626 SA-IS Algorithm (Linear-Time Suffix Array Construction)</h3>
<p>The SA-IS algorithm is a modern, elegant method for building suffix arrays in true linear time <span class="math display">\[
O(n)
\]</span> It uses induced sorting, classifying suffixes by type (S or L), sorting a small subset first, and then <em>inducing</em> the rest from that ordering.</p>
<p>It’s the foundation of state-of-the-art suffix array builders and is used in tools like DivSufSort, libdivsufsort, and BWT-based compressors.</p>
<section id="what-problem-are-we-solving-26" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-26">What Problem Are We Solving?</h4>
<p>We want to build the suffix array of a string <span class="math display">\[
S = s_0 s_1 \ldots s_{n-1}
\]</span> that lists all starting indices of suffixes in lexicographic order, but we want to do it in linear time, not <span class="math display">\[
O(n \log n)
\]</span></p>
<p>The SA-IS algorithm achieves this by:</p>
<ol type="1">
<li>Classifying suffixes into S-type and L-type</li>
<li>Identifying LMS (Leftmost S-type) substrings</li>
<li>Sorting these LMS substrings</li>
<li>Inducing the full suffix order from the LMS order</li>
</ol>
</section>
<section id="key-concepts" class="level4">
<h4 class="anchored" data-anchor-id="key-concepts">Key Concepts</h4>
<p>Let $S[n] = $ $ be a sentinel smaller than all characters.</p>
<ol type="1">
<li><p>S-type suffix: <span class="math inline">\(S[i:] &lt; S[i+1:]\)</span></p></li>
<li><p>L-type suffix: <span class="math inline">\(S[i:] &gt; S[i+1:]\)</span></p></li>
<li><p>LMS position: An index <span class="math inline">\(i\)</span> such that <span class="math inline">\(S[i]\)</span> is S-type and <span class="math inline">\(S[i-1]\)</span> is L-type.</p></li>
</ol>
<p>These LMS positions act as <em>anchors</em>, if we can sort them, we can “induce” the full suffix order.</p>
</section>
<section id="how-it-works-plain-language-1" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-1">How It Works (Plain Language)</h4>
<p>Step 1. Classify S/L types Walk backward:</p>
<ul>
<li>Last char <code>$</code> is S-type</li>
<li><span class="math inline">\(S[i]\)</span> is S-type if <span class="math inline">\(S[i] &lt; S[i+1]\)</span> or (<span class="math inline">\(S[i] = S[i+1]\)</span> and <span class="math inline">\(S[i+1]\)</span> is S-type)</li>
</ul>
<p>Step 2. Identify LMS positions Mark every transition from L → S</p>
<p>Step 3. Sort LMS substrings Each substring between LMS positions (inclusive) is unique. We sort them (recursively, if needed) to get LMS order.</p>
<p>Step 4. Induce L-suffixes From left to right, fill buckets using LMS order.</p>
<p>Step 5. Induce S-suffixes From right to left, fill remaining buckets.</p>
<p>Result: full suffix array.</p>
</section>
<section id="example-18" class="level4">
<h4 class="anchored" data-anchor-id="example-18">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"banana\$"}
\]</span></p>
<ol type="1">
<li>Classify types</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>Char</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6</td>
<td>$</td>
<td>S</td>
</tr>
<tr class="even">
<td>5</td>
<td>a</td>
<td>L</td>
</tr>
<tr class="odd">
<td>4</td>
<td>n</td>
<td>S</td>
</tr>
<tr class="even">
<td>3</td>
<td>a</td>
<td>L</td>
</tr>
<tr class="odd">
<td>2</td>
<td>n</td>
<td>S</td>
</tr>
<tr class="even">
<td>1</td>
<td>a</td>
<td>L</td>
</tr>
<tr class="odd">
<td>0</td>
<td>b</td>
<td>L</td>
</tr>
</tbody>
</table>
<p>LMS positions: 2, 4, 6</p>
<ol start="2" type="1">
<li><p>LMS substrings: <code>"na$"</code>, <code>"nana$"</code>, <code>"$"</code></p></li>
<li><p>Sort LMS substrings lexicographically.</p></li>
<li><p>Induce L and S suffixes using bucket boundaries.</p></li>
</ol>
<p>Final <span class="math display">\[
SA = [6, 5, 3, 1, 0, 4, 2]
\]</span></p>
</section>
<section id="tiny-code-python-sketch-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-1">Tiny Code (Python Sketch)</h4>
<p><em>(Illustrative, not optimized)</em></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sa_is(s):</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> [<span class="bu">ord</span>(c) <span class="cf">for</span> c <span class="kw">in</span> s] <span class="op">+</span> [<span class="dv">0</span>]  <span class="co"># append sentinel</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    SA <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: classify</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    t[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">&lt;</span> s[i<span class="op">+</span><span class="dv">1</span>] <span class="kw">or</span> (s[i] <span class="op">==</span> s[i<span class="op">+</span><span class="dv">1</span>] <span class="kw">and</span> t[i<span class="op">+</span><span class="dv">1</span>]):</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>            t[i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Identify LMS</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>    LMS <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n) <span class="cf">if</span> <span class="kw">not</span> t[i<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> t[i]]</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simplified: use Python sort for LMS order (concept only)</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    LMS.sort(key<span class="op">=</span><span class="kw">lambda</span> i: s[i:])</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Induce-sort sketch omitted</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (Full SA-IS would fill SA using bucket boundaries)</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> LMS  <span class="co"># placeholder for educational illustration</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sa_is(<span class="st">"banana"</span>))  <span class="co"># [2, 4, 6]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>A real implementation uses bucket arrays and induced sorting, still linear.</p>
</section>
<section id="why-it-matters-26" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-26">Why It Matters</h4>
<ul>
<li><p>True linear time construction</p></li>
<li><p>Memory-efficient, no recursion unless necessary</p></li>
<li><p>Backbone for:</p>
<ul>
<li>Burrows–Wheeler Transform (BWT)</li>
<li>FM-index</li>
<li>Compressed suffix arrays</li>
</ul></li>
<li><p>Practical and fast even on large datasets</p></li>
</ul>
</section>
<section id="complexity-26" class="level4">
<h4 class="anchored" data-anchor-id="complexity-26">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Classify + LMS</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Sort LMS substrings</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>Induce sort</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Total</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-26" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-26">Try It Yourself</h4>
<ol type="1">
<li>Classify types for <code>"mississippi$"</code>.</li>
<li>Mark LMS positions and substrings.</li>
<li>Sort LMS substrings by lexicographic order.</li>
<li>Perform induction step by step.</li>
<li>Compare output with doubling algorithm.</li>
</ol>
<p>The SA-IS algorithm is a masterclass in economy — sort a few, infer the rest, and let the structure unfold. From sparse anchors, the full order of the text emerges, perfectly, in linear time.</p>
</section>
</section>
<section id="lcp-rmq-query-range-minimum-query-on-lcp-array" class="level3">
<h3 class="anchored" data-anchor-id="lcp-rmq-query-range-minimum-query-on-lcp-array">627 LCP RMQ Query (Range Minimum Query on LCP Array)</h3>
<p>The LCP RMQ structure allows constant-time retrieval of the Longest Common Prefix length between <em>any two suffixes</em> of a string, using the LCP array and a Range Minimum Query (RMQ) data structure.</p>
<p>In combination with the suffix array, it becomes a powerful text indexing tool, enabling substring comparisons, lexicographic ranking, and efficient pattern matching in <span class="math display">\[
O(1)
\]</span> after linear preprocessing.</p>
<section id="what-problem-are-we-solving-27" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-27">What Problem Are We Solving?</h4>
<p>Given:</p>
<ul>
<li>A string <span class="math inline">\(S\)</span></li>
<li>Its suffix array <span class="math inline">\(SA\)</span></li>
<li>Its LCP array, where <span class="math display">\[
LCP[i] = \text{lcp}(S[SA[i-1]:], S[SA[i]:])
\]</span></li>
</ul>
<p>We want to answer queries of the form:</p>
<blockquote class="blockquote">
<p>“What is the LCP length of suffixes starting at positions <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> in <span class="math inline">\(S\)</span>?”</p>
</blockquote>
<p>That is: <span class="math display">\[
\text{LCP}(i, j) = \text{length of longest common prefix of } S[i:] \text{ and } S[j:]
\]</span></p>
<p>This is fundamental for:</p>
<ul>
<li>Fast substring comparison</li>
<li>Longest common substring (LCS) queries</li>
<li>String periodicity detection</li>
<li>Lexicographic interval analysis</li>
</ul>
</section>
<section id="key-observation" class="level4">
<h4 class="anchored" data-anchor-id="key-observation">Key Observation</h4>
<p>Let <span class="math inline">\(pos[i]\)</span> and <span class="math inline">\(pos[j]\)</span> be the positions of suffixes <span class="math inline">\(S[i:]\)</span> and <span class="math inline">\(S[j:]\)</span> in the suffix array.</p>
<p>Then: <span class="math display">\[
\text{LCP}(i, j) = \min \big( LCP[k] \big), \quad k \in [\min(pos[i], pos[j]) + 1, \max(pos[i], pos[j])]
\]</span></p>
<p>So the problem reduces to a Range Minimum Query on the LCP array.</p>
</section>
<section id="example-19" class="level4">
<h4 class="anchored" data-anchor-id="example-19">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"banana"}
\]</span> <span class="math display">\[
SA = [5, 3, 1, 0, 4, 2]
\]</span> <span class="math display">\[
LCP = [0, 1, 3, 0, 0, 2]
\]</span></p>
<p>Goal: <span class="math inline">\(\text{LCP}(1, 3)\)</span>, common prefix of <code>"anana"</code> and <code>"ana"</code></p>
<ol type="1">
<li><span class="math inline">\(pos[1] = 2\)</span>, <span class="math inline">\(pos[3] = 1\)</span></li>
<li>Range = <span class="math inline">\((1, 2]\)</span></li>
<li><span class="math inline">\(\min(LCP[2]) = 1\)</span></li>
</ol>
<p>So <span class="math display">\[
\text{LCP}(1, 3) = 1
\]</span> (both start with <code>"a"</code>)</p>
</section>
<section id="how-does-it-work-plain-language-25" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-25">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Preprocess LCP using an RMQ structure (like Sparse Table or Segment Tree)</p></li>
<li><p>For query <span class="math inline">\((i, j)\)</span>:</p>
<ul>
<li>Get <span class="math inline">\(p = pos[i]\)</span>, <span class="math inline">\(q = pos[j]\)</span></li>
<li>Swap if <span class="math inline">\(p &gt; q\)</span></li>
<li>Answer = RMQ on <span class="math inline">\(LCP[p+1..q]\)</span></li>
</ul></li>
</ol>
<p>Each query becomes <span class="math inline">\(O(1)\)</span> with <span class="math inline">\(O(n \log n)\)</span> or <span class="math inline">\(O(n)\)</span> preprocessing.</p>
</section>
<section id="tiny-code-python-sparse-table-rmq" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sparse-table-rmq">Tiny Code (Python – Sparse Table RMQ)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_rmq(lcp):</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(lcp)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    log <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        log[i] <span class="op">=</span> log[i <span class="op">//</span> <span class="dv">2</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> log[n]</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    st <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        st[i][<span class="dv">0</span>] <span class="op">=</span> lcp[i]</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>            st[i][j] <span class="op">=</span> <span class="bu">min</span>(st[i][j<span class="op">-</span><span class="dv">1</span>], st[i <span class="op">+</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (j<span class="op">-</span><span class="dv">1</span>))][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> st, log</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> query_rmq(st, log, L, R):</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> log[R <span class="op">-</span> L <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(st[L][j], st[R <span class="op">-</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j) <span class="op">+</span> <span class="dv">1</span>][j])</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>LCP <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>]</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>st, log <span class="op">=</span> build_rmq(LCP)</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(query_rmq(st, log, <span class="dv">1</span>, <span class="dv">2</span>))  <span class="co"># 1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Query flow:</p>
<ul>
<li><span class="math inline">\(O(n \log n)\)</span> preprocessing</li>
<li><span class="math inline">\(O(1)\)</span> per query</li>
</ul>
</section>
<section id="why-it-matters-27" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-27">Why It Matters</h4>
<ul>
<li><p>Enables fast substring comparison:</p>
<ul>
<li>Compare suffixes in <span class="math inline">\(O(1)\)</span></li>
<li>Lexicographic rank / order check</li>
</ul></li>
<li><p>Core in:</p>
<ul>
<li>LCP Interval Trees</li>
<li>Suffix Tree Emulation via array</li>
<li>LCS Queries across multiple strings</li>
<li>Distinct substring counting</li>
</ul></li>
</ul>
<p>With RMQ, a suffix array becomes a full-featured string index.</p>
</section>
<section id="complexity-27" class="level4">
<h4 class="anchored" data-anchor-id="complexity-27">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Preprocess</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
</tr>
<tr class="even">
<td>Query (LCP)</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Advanced RMQs (like Cartesian Tree + Euler Tour + Sparse Table) achieve <span class="math inline">\(O(n)\)</span> space with <span class="math inline">\(O(1)\)</span> queries.</p>
</section>
<section id="try-it-yourself-27" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-27">Try It Yourself</h4>
<ol type="1">
<li><p>Build <span class="math inline">\(SA\)</span>, <span class="math inline">\(LCP\)</span>, and <span class="math inline">\(pos\)</span> for <code>"banana"</code>.</p></li>
<li><p>Answer queries:</p>
<ul>
<li><span class="math inline">\(\text{LCP}(1, 2)\)</span></li>
<li><span class="math inline">\(\text{LCP}(0, 4)\)</span></li>
<li><span class="math inline">\(\text{LCP}(3, 5)\)</span></li>
</ul></li>
<li><p>Compare results with direct prefix comparison.</p></li>
<li><p>Replace Sparse Table with Segment Tree implementation.</p></li>
<li><p>Build <span class="math inline">\(O(n)\)</span> RMQ using Euler Tour + RMQ over Cartesian Tree.</p></li>
</ol>
<p>The LCP RMQ bridges suffix arrays and suffix trees — a quiet connection through minimums, where each interval tells the shared length of two paths in the lexicographic landscape.</p>
</section>
</section>
<section id="generalized-suffix-array-multiple-strings" class="level3">
<h3 class="anchored" data-anchor-id="generalized-suffix-array-multiple-strings">628 Generalized Suffix Array (Multiple Strings)</h3>
<p>The Generalized Suffix Array (GSA) extends the classical suffix array to handle multiple strings simultaneously. It provides a unified structure for cross-string comparisons, allowing us to compute longest common substrings, shared motifs, and cross-document search efficiently.</p>
<section id="what-problem-are-we-solving-28" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-28">What Problem Are We Solving?</h4>
<p>Given multiple strings: <span class="math display">\[
S_1, S_2, \ldots, S_k
\]</span> we want to index all suffixes of all strings in a single sorted array.</p>
<p>Each suffix in the array remembers:</p>
<ul>
<li>Which string it belongs to</li>
<li>Its starting position</li>
</ul>
<p>With this, we can:</p>
<ul>
<li>Find substrings shared between two or more strings</li>
<li>Compute Longest Common Substring (LCS) across strings</li>
<li>Perform multi-document search or text comparison</li>
</ul>
</section>
<section id="example-20" class="level4">
<h4 class="anchored" data-anchor-id="example-20">Example</h4>
<p>Let: <span class="math display">\[
S_1 = \texttt{"banana\$1"}
\]</span> <span class="math display">\[
S_2 = \texttt{"bandana\$2"}
\]</span></p>
<p>All suffixes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>ID</th>
<th>Index</th>
<th>Suffix</th>
<th>String</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>banana$1</td>
<td>S₁</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>anana$1</td>
<td>S₁</td>
</tr>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>nana$1</td>
<td>S₁</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>ana$1</td>
<td>S₁</td>
</tr>
<tr class="odd">
<td>1</td>
<td>4</td>
<td>na$1</td>
<td>S₁</td>
</tr>
<tr class="even">
<td>1</td>
<td>5</td>
<td>a$1</td>
<td>S₁</td>
</tr>
<tr class="odd">
<td>1</td>
<td>6</td>
<td>$1</td>
<td>S₁</td>
</tr>
<tr class="even">
<td>2</td>
<td>0</td>
<td>bandana$2</td>
<td>S₂</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>andana$2</td>
<td>S₂</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>ndana$2</td>
<td>S₂</td>
</tr>
<tr class="odd">
<td>2</td>
<td>3</td>
<td>dana$2</td>
<td>S₂</td>
</tr>
<tr class="even">
<td>2</td>
<td>4</td>
<td>ana$2</td>
<td>S₂</td>
</tr>
<tr class="odd">
<td>2</td>
<td>5</td>
<td>na$2</td>
<td>S₂</td>
</tr>
<tr class="even">
<td>2</td>
<td>6</td>
<td>a$2</td>
<td>S₂</td>
</tr>
<tr class="odd">
<td>2</td>
<td>7</td>
<td>$2</td>
<td>S₂</td>
</tr>
</tbody>
</table>
<p>Now sort all suffixes lexicographically. Each entry in GSA records <code>(suffix_start, string_id)</code>.</p>
</section>
<section id="data-structures" class="level4">
<h4 class="anchored" data-anchor-id="data-structures">Data Structures</h4>
<p>We maintain:</p>
<ol type="1">
<li>SA, all suffixes across all strings, sorted lexicographically</li>
<li>LCP, longest common prefix between consecutive suffixes</li>
<li>Owner array, owner of each suffix (which string)</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>SA[i]</th>
<th>Owner[i]</th>
<th>LCP[i]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>…</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>…</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>2</td>
<td>…</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="even">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>From this, we can compute LCS by checking intervals where <code>Owner</code> differs.</p>
</section>
<section id="how-does-it-work-plain-language-26" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-26">How Does It Work (Plain Language)</h4>
<ol type="1">
<li><p>Concatenate all strings with unique sentinels <span class="math display">\[
S = S_1 + \text{\$1} + S_2 + \text{\$2} + \cdots + S_k + \text{\$k}
\]</span></p></li>
<li><p>Build suffix array over combined string (using SA-IS or doubling)</p></li>
<li><p>Record ownership: for each position, mark which string it belongs to</p></li>
<li><p>Build LCP array (Kasai)</p></li>
<li><p>Query shared substrings:</p>
<ul>
<li>A common substring exists where consecutive suffixes belong to different strings</li>
<li>The minimum LCP over that range gives shared length</li>
</ul></li>
</ol>
</section>
<section id="example-query-longest-common-substring" class="level4">
<h4 class="anchored" data-anchor-id="example-query-longest-common-substring">Example Query: Longest Common Substring</h4>
<p>For <code>"banana"</code> and <code>"bandana"</code>:</p>
<p>Suffixes from different strings overlap with <span class="math display">\[
\text{LCP} = 3 \text{ ("ban") }
\]</span> and <span class="math display">\[
\text{LCP} = 2 \text{ ("na") }
\]</span></p>
<p>So <span class="math display">\[
\text{LCS} = \texttt{"ban"} \quad \text{length } 3
\]</span></p>
</section>
<section id="tiny-code-python-sketch-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-2">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generalized_suffix_array(strings):</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    text <span class="op">=</span> <span class="st">""</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    owners <span class="op">=</span> []</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    sep <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> strings:</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        text <span class="op">+=</span> s <span class="op">+</span> <span class="bu">chr</span>(sep)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>        owners <span class="op">+=</span> [<span class="bu">len</span>(owners)] <span class="op">*</span> (<span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>        sep <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    sa <span class="op">=</span> suffix_array_doubling(text)</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>    lcp <span class="op">=</span> kasai(text, sa)</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>    owner_map <span class="op">=</span> [owners[i] <span class="cf">for</span> i <span class="kw">in</span> sa]</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sa, lcp, owner_map</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>(Assumes you have <code>suffix_array_doubling</code> and <code>kasai</code> from earlier sections.)</em></p>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>S1 <span class="op">=</span> <span class="st">"banana"</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>S2 <span class="op">=</span> <span class="st">"bandana"</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>sa, lcp, owner <span class="op">=</span> generalized_suffix_array([S1, S2])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Now scan <code>lcp</code> where <code>owner[i] != owner[i-1]</code> to find cross-string overlaps.</p>
</section>
<section id="why-it-matters-28" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-28">Why It Matters</h4>
<ul>
<li><p>Core structure for:</p>
<ul>
<li>Longest Common Substring across files</li>
<li>Multi-document indexing</li>
<li>Bioinformatics motif finding</li>
<li>Plagiarism detection</li>
</ul></li>
<li><p>Compact alternative to Generalized Suffix Tree</p></li>
<li><p>Easy to implement from existing SA + LCP pipeline</p></li>
</ul>
</section>
<section id="complexity-28" class="level4">
<h4 class="anchored" data-anchor-id="complexity-28">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Concatenate</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>SA build</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="odd">
<td>LCP build</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>LCS query</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span> per query</td>
</tr>
</tbody>
</table>
<p>Total: <span class="math display">\[
O(n)
\]</span> where <span class="math inline">\(n\)</span> = total length of all strings.</p>
</section>
<section id="try-it-yourself-28" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-28">Try It Yourself</h4>
<ol type="1">
<li>Build GSA for <code>["banana", "bandana"]</code>.</li>
<li>Find all substrings common to both.</li>
<li>Use <code>LCP</code> + <code>Owner</code> to extract longest shared substring.</li>
<li>Extend to 3 strings, e.g.&nbsp;<code>["banana", "bandana", "canada"]</code>.</li>
<li>Verify LCS correctness by brute-force comparison.</li>
</ol>
<p>The Generalized Suffix Array is a chorus of strings — each suffix a voice, each overlap a harmony. From many songs, one lexicographic score — and within it, every shared melody.</p>
</section>
</section>
<section id="enhanced-suffix-array-sa-lcp-rmq" class="level3">
<h3 class="anchored" data-anchor-id="enhanced-suffix-array-sa-lcp-rmq">629 Enhanced Suffix Array (SA + LCP + RMQ)</h3>
<p>The Enhanced Suffix Array (ESA) is a fully functional alternative to a suffix tree, built from a suffix array, LCP array, and range minimum query (RMQ) structure. It supports the same powerful operations, substring search, LCP queries, longest repeated substring, and pattern matching, all with linear space and fast queries.</p>
<p>Think of it as a <em>compressed suffix tree</em>, implemented over arrays.</p>
<section id="what-problem-are-we-solving-29" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-29">What Problem Are We Solving?</h4>
<p>Suffix arrays alone can locate suffixes efficiently, but without structural information (like branching or overlap) that suffix trees provide. The Enhanced Suffix Array enriches SA with auxiliary arrays to recover tree-like navigation:</p>
<ol type="1">
<li>SA, sorted suffixes</li>
<li>LCP, longest common prefix between adjacent suffixes</li>
<li>RMQ / Cartesian Tree, to simulate tree structure</li>
</ol>
<p>With these, we can:</p>
<ul>
<li>Perform substring search</li>
<li>Traverse suffix intervals</li>
<li>Compute LCP of any two suffixes</li>
<li>Enumerate distinct substrings, repeated substrings, and patterns</li>
</ul>
<p>All without explicit tree nodes.</p>
</section>
<section id="key-idea-1" class="level4">
<h4 class="anchored" data-anchor-id="key-idea-1">Key Idea</h4>
<p>A suffix tree can be represented implicitly by the SA + LCP arrays:</p>
<ul>
<li>SA defines lexicographic order (in-order traversal)</li>
<li>LCP defines edge lengths (branch depths)</li>
<li>RMQ on LCP gives Lowest Common Ancestor (LCA) in tree view</li>
</ul>
<p>So the ESA is a <em>view of the suffix tree</em>, not a reconstruction.</p>
</section>
<section id="example-21" class="level4">
<h4 class="anchored" data-anchor-id="example-21">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"banana\$"}
\]</span></p>
<p>Suffix array: <span class="math display">\[
SA = [6, 5, 3, 1, 0, 4, 2]
\]</span></p>
<p>LCP array: <span class="math display">\[
LCP = [0, 1, 3, 0, 0, 2, 0]
\]</span></p>
<p>These arrays already describe a tree-like structure:</p>
<ul>
<li>Branch depths = <code>LCP</code> values</li>
<li>Subtrees = SA intervals sharing prefix length ≥ <span class="math inline">\(k\)</span></li>
</ul>
<p>Example:</p>
<ul>
<li>Repeated substring <code>"ana"</code> corresponds to interval <code>[2, 4]</code> where <code>LCP ≥ 3</code></li>
</ul>
</section>
<section id="how-does-it-work-plain-language-27" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-27">How Does It Work (Plain Language)</h4>
<p>The ESA answers queries via intervals and RMQs:</p>
<ol type="1">
<li><p>Substring Search (Pattern Matching) Binary search over <code>SA</code> for pattern prefix. Once found, <code>SA[l..r]</code> is the match interval.</p></li>
<li><p>LCP Query (Two Suffixes) Using RMQ: <span class="math display">\[
\text{LCP}(i, j) = \min(LCP[k]) \text{ over } k \in [\min(pos[i], pos[j])+1, \max(pos[i], pos[j])]
\]</span></p></li>
<li><p>Longest Repeated Substring <span class="math inline">\(\max(LCP)\)</span> gives length, position via SA index.</p></li>
<li><p>Longest Common Prefix of Intervals RMQ over <code>LCP[l+1..r]</code> yields branch depth.</p></li>
</ol>
</section>
<section id="esa-components" class="level4">
<h4 class="anchored" data-anchor-id="esa-components">ESA Components</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Component</th>
<th>Description</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SA</td>
<td>Sorted suffix indices</td>
<td>Lexicographic traversal</td>
</tr>
<tr class="even">
<td>LCP</td>
<td>LCP between adjacent suffixes</td>
<td>Branch depths</td>
</tr>
<tr class="odd">
<td>INVSA</td>
<td>Inverse of SA</td>
<td>Fast suffix lookup</td>
</tr>
<tr class="even">
<td>RMQ</td>
<td>Range min over LCP</td>
<td>LCA / interval query</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-4">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_esa(s):</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    sa <span class="op">=</span> suffix_array_doubling(s)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    lcp <span class="op">=</span> kasai(s, sa)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    inv <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(s)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, idx <span class="kw">in</span> <span class="bu">enumerate</span>(sa):</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>        inv[idx] <span class="op">=</span> i</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    st, log <span class="op">=</span> build_rmq(lcp)</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sa, lcp, inv, st, log</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lcp_query(inv, st, log, i, j):</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> j:</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(s) <span class="op">-</span> i</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>    pi, pj <span class="op">=</span> inv[i], inv[j]</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pi <span class="op">&gt;</span> pj:</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>        pi, pj <span class="op">=</span> pj, pi</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> query_rmq(st, log, pi <span class="op">+</span> <span class="dv">1</span>, pj)</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"banana"</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>sa, lcp, inv, st, log <span class="op">=</span> build_esa(s)</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lcp_query(inv, st, log, <span class="dv">1</span>, <span class="dv">3</span>))  <span class="co"># "anana" vs "ana" → 3</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>(Uses previous <code>suffix_array_doubling</code>, <code>kasai</code>, <code>build_rmq</code>, <code>query_rmq</code>.)</em></p>
</section>
<section id="why-it-matters-29" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-29">Why It Matters</h4>
<p>The ESA matches suffix tree functionality with:</p>
<ul>
<li>Linear space (<span class="math inline">\(O(n)\)</span>)</li>
<li>Simpler implementation</li>
<li>Cache-friendly array access</li>
<li>Easy integration with compressed indexes (FM-index)</li>
</ul>
<p>Used in:</p>
<ul>
<li>Bioinformatics (sequence alignment)</li>
<li>Search engines</li>
<li>Document similarity</li>
<li>Compression tools (BWT, LCP intervals)</li>
</ul>
</section>
<section id="complexity-29" class="level4">
<h4 class="anchored" data-anchor-id="complexity-29">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build SA + LCP</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Build RMQ</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
</tr>
<tr class="odd">
<td>Query LCP</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Substring search</td>
<td><span class="math inline">\(O(m \log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-29" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-29">Try It Yourself</h4>
<ol type="1">
<li><p>Build ESA for <code>"mississippi"</code>.</p></li>
<li><p>Find:</p>
<ul>
<li>Longest repeated substring</li>
<li>Count distinct substrings</li>
<li>LCP of suffixes at 1 and 4</li>
</ul></li>
<li><p>Extract substring intervals from <code>LCP ≥ 2</code></p></li>
<li><p>Compare ESA output with suffix tree visualization</p></li>
</ol>
<p>The Enhanced Suffix Array is the suffix tree reborn as arrays — no nodes, no pointers, only order, overlap, and structure woven into the lexicographic tapestry.</p>
</section>
</section>
<section id="sparse-suffix-tree-space-efficient-variant" class="level3">
<h3 class="anchored" data-anchor-id="sparse-suffix-tree-space-efficient-variant">630 Sparse Suffix Tree (Space-Efficient Variant)</h3>
<p>The Sparse Suffix Tree (SST) is a space-efficient variant of the classical suffix tree. Instead of storing <em>all</em> suffixes of a string, it indexes only a selected subset, typically every <span class="math inline">\(k\)</span>-th suffix, reducing space from <span class="math inline">\(O(n)\)</span> nodes to <span class="math inline">\(O(n / k)\)</span> while preserving many of the same query capabilities.</p>
<p>This makes it ideal for large texts where memory is tight and approximate indexing is acceptable.</p>
<section id="what-problem-are-we-solving-30" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-30">What Problem Are We Solving?</h4>
<p>A full suffix tree gives incredible power, substring queries in <span class="math inline">\(O(m)\)</span> time, but at a steep memory cost, often 10–20× the size of the original text.</p>
<p>We want a data structure that:</p>
<ul>
<li>Supports fast substring search</li>
<li>Is lightweight and cache-friendly</li>
<li>Scales to large corpora (e.g., genomes, logs)</li>
</ul>
<p>The Sparse Suffix Tree solves this by sampling suffixes, only building the tree on a subset.</p>
</section>
<section id="core-idea" class="level4">
<h4 class="anchored" data-anchor-id="core-idea">Core Idea</h4>
<p>Instead of inserting <em>every</em> suffix <span class="math inline">\(S[i:]\)</span>, we insert only those where <span class="math display">\[
i \bmod k = 0
\]</span></p>
<p>or from a sample set <span class="math inline">\(P = {p_1, p_2, \ldots, p_t}\)</span>.</p>
<p>We then augment with verification steps (like binary search over text) to confirm full matches.</p>
<p>This reduces the structure size proportionally to the sample rate <span class="math inline">\(k\)</span>.</p>
</section>
<section id="how-it-works-plain-language-2" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-2">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Sampling step Choose sampling interval <span class="math inline">\(k\)</span> (e.g.&nbsp;every 4th suffix).</p></li>
<li><p>Build suffix tree Insert only sampled suffixes: <span class="math display">\[
{ S[0:], S[k:], S[2k:], \ldots }
\]</span></p></li>
<li><p>Search</p>
<ul>
<li>To match a pattern <span class="math inline">\(P\)</span>, find closest sampled suffix that shares prefix with <span class="math inline">\(P\)</span></li>
<li>Extend search in text for verification (O(<span class="math inline">\(k\)</span>) overhead at most)</li>
</ul></li>
</ol>
<p>This yields approximate O(m) query time with smaller constants.</p>
</section>
<section id="example-22" class="level4">
<h4 class="anchored" data-anchor-id="example-22">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"banana\$"}
\]</span> and choose <span class="math inline">\(k = 2\)</span>.</p>
<p>Sampled suffixes:</p>
<ul>
<li>$S[0:] = $ <code>"banana$"</code></li>
<li>$S[2:] = $ <code>"nana$"</code></li>
<li>$S[4:] = $ <code>"na$"</code></li>
<li>$S[6:] = $ <code>"$"</code></li>
</ul>
<p>Build suffix tree only over these 4 suffixes.</p>
<p>When searching <code>"ana"</code>,</p>
<ul>
<li>Match found at node covering <code>"ana"</code> from <code>"banana$"</code> and <code>"nana$"</code></li>
<li>Verify remaining characters directly in <span class="math inline">\(S\)</span></li>
</ul>
</section>
<section id="tiny-code-python-sketch-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-sketch-3">Tiny Code (Python Sketch)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SparseSuffixTree:</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, s, k):</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.s <span class="op">=</span> s <span class="op">+</span> <span class="st">"$"</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k <span class="op">=</span> k</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.suffixes <span class="op">=</span> [<span class="va">self</span>.s[i:] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(s), k)]</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.suffixes.sort()  <span class="co"># naive for illustration</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, pattern):</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># binary search over sampled suffixes</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>        lo, hi <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(<span class="va">self</span>.suffixes)</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> lo <span class="op">&lt;</span> hi:</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>            mid <span class="op">=</span> (lo <span class="op">+</span> hi) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.suffixes[mid].startswith(pattern):</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.suffixes[mid] <span class="op">&lt;</span> pattern:</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>                lo <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>                hi <span class="op">=</span> mid</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>sst <span class="op">=</span> SparseSuffixTree(<span class="st">"banana"</span>, <span class="dv">2</span>)</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sst.search(<span class="st">"ana"</span>))  <span class="co"># True (verified from sampled suffix)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>For actual suffix tree structure, one can use Ukkonen’s algorithm restricted to sampled suffixes.</em></p>
</section>
<section id="why-it-matters-30" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-30">Why It Matters</h4>
<ul>
<li><p>Space reduction: <span class="math inline">\(O(n / k)\)</span> nodes</p></li>
<li><p>Scalable indexing for massive strings</p></li>
<li><p>Fast enough for most substring queries</p></li>
<li><p>Used in:</p>
<ul>
<li>Genomic indexing</li>
<li>Log pattern search</li>
<li>Approximate data compression</li>
<li>Text analytics at scale</li>
</ul></li>
</ul>
<p>A practical balance between speed and size.</p>
</section>
<section id="complexity-30" class="level4">
<h4 class="anchored" data-anchor-id="complexity-30">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build (sampled)</td>
<td><span class="math inline">\(O((n/k) \cdot k)\)</span> = <span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n/k)\)</span></td>
</tr>
<tr class="even">
<td>Search</td>
<td><span class="math inline">\(O(m + k)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Verify match</td>
<td><span class="math inline">\(O(k)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Tuning <span class="math inline">\(k\)</span> trades memory for search precision.</p>
</section>
<section id="try-it-yourself-30" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-30">Try It Yourself</h4>
<ol type="1">
<li>Build SST for <code>"mississippi"</code> with <span class="math inline">\(k = 3\)</span></li>
<li>Compare memory vs full suffix tree</li>
<li>Search <code>"issi"</code>, measure verification steps</li>
<li>Experiment with different <span class="math inline">\(k\)</span> values</li>
<li>Plot build size vs query latency</li>
</ol>
<p>The Sparse Suffix Tree is a memory-wise compromise — a forest of sampled branches, holding just enough of the text’s structure to navigate the space of substrings swiftly, without carrying every leaf.</p>
</section>
</section>
</section>
<section id="section-64.-palindromes-and-periodicity" class="level1">
<h1>Section 64. Palindromes and Periodicity</h1>
<section id="naive-palindrome-check" class="level3">
<h3 class="anchored" data-anchor-id="naive-palindrome-check">631 Naive Palindrome Check</h3>
<p>The Naive Palindrome Check is the simplest way to detect palindromes, strings that read the same forward and backward. It’s a direct, easy-to-understand algorithm: expand around each possible center, compare characters symmetrically, and count or report all palindromic substrings.</p>
<p>This method is conceptually clear and perfect as a starting point before introducing optimized methods like Manacher’s algorithm.</p>
<section id="what-problem-are-we-solving-31" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-31">What Problem Are We Solving?</h4>
<p>We want to find whether a string (or any substring) is a palindrome, i.e.</p>
<p><span class="math display">\[
S[l \ldots r] \text{ is a palindrome if } S[l + i] = S[r - i], \ \forall i
\]</span></p>
<p>We can use this to:</p>
<ul>
<li>Check if a given substring is palindromic</li>
<li>Count the total number of palindromic substrings</li>
<li>Find the longest palindrome (brute force)</li>
</ul>
</section>
<section id="definition" class="level4">
<h4 class="anchored" data-anchor-id="definition">Definition</h4>
<p>A palindrome satisfies: <span class="math display">\[
S = \text{reverse}(S)
\]</span></p>
<p>Examples:</p>
<ul>
<li><code>"aba"</code> → palindrome</li>
<li><code>"abba"</code> → palindrome</li>
<li><code>"abc"</code> → not palindrome</li>
</ul>
</section>
<section id="how-does-it-work-plain-language-28" class="level4">
<h4 class="anchored" data-anchor-id="how-does-it-work-plain-language-28">How Does It Work (Plain Language)</h4>
<p>We can use center expansion or brute-force checking.</p>
<section id="brute-force-check" class="level5">
<h5 class="anchored" data-anchor-id="brute-force-check">1. Brute-Force Check</h5>
<p>Compare characters from both ends:</p>
<ol type="1">
<li>Start at left and right</li>
<li>Move inward while matching</li>
<li>Stop on mismatch or middle</li>
</ol>
<p>Time complexity: <span class="math inline">\(O(n)\)</span> for a single substring.</p>
</section>
<section id="expand-around-center" class="level5">
<h5 class="anchored" data-anchor-id="expand-around-center">2. Expand Around Center</h5>
<p>Every palindrome has a center:</p>
<ul>
<li>Odd-length: single character</li>
<li>Even-length: gap between two characters</li>
</ul>
<p>We expand around each center and count palindromes.</p>
<p>There are <span class="math inline">\(2n - 1\)</span> centers total.</p>
</section>
</section>
<section id="example-23" class="level4">
<h4 class="anchored" data-anchor-id="example-23">Example</h4>
<p>String: <span class="math display">\[
S = \texttt{"abba"}
\]</span></p>
<p>Centers and expansions:</p>
<ul>
<li>Center at <code>'a'</code>: <code>"a"</code> Ok</li>
<li>Center between <code>'a'</code> and <code>'b'</code>: no palindrome</li>
<li>Center at <code>'b'</code>: <code>"b"</code>, <code>"bb"</code>, <code>"abba"</code> Ok</li>
<li>Center at <code>'a'</code>: <code>"a"</code> Ok</li>
</ul>
<p>Total palindromic substrings: <code>6</code></p>
</section>
<section id="tiny-code-python-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-5">Tiny Code (Python)</h4>
<ol type="a">
<li>Brute Force Check)</li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_palindrome(s):</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s <span class="op">==</span> s[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(is_palindrome(<span class="st">"abba"</span>))  <span class="co"># True</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(is_palindrome(<span class="st">"abc"</span>))   <span class="co"># False</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol start="2" type="a">
<li>Expand Around Center (Count All)</li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_palindromes(s):</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> center <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> center <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> l <span class="op">+</span> (center <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> r <span class="op">&lt;</span> n <span class="kw">and</span> s[l] <span class="op">==</span> s[r]:</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>            l <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>            r <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_palindromes(<span class="st">"abba"</span>))  <span class="co"># 6</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol start="3" type="a">
<li>Expand Around Center (Longest Palindrome)</li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_palindrome(s):</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    best <span class="op">=</span> <span class="st">""</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> center <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> center <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> l <span class="op">+</span> (center <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> r <span class="op">&lt;</span> n <span class="kw">and</span> s[l] <span class="op">==</span> s[r]:</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> r <span class="op">-</span> l <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> <span class="bu">len</span>(best):</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> s[l:r<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>            l <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>            r <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_palindrome(<span class="st">"babad"</span>))  <span class="co"># "bab" or "aba"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-31" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-31">Why It Matters</h4>
<ul>
<li>Foundation for more advanced algorithms (Manacher, DP)</li>
<li>Works well for small or educational examples</li>
<li>Simple way to verify correctness of optimized versions</li>
<li>Useful for palindrome-related pattern discovery (DNA, text symmetry)</li>
</ul>
</section>
<section id="complexity-31" class="level4">
<h4 class="anchored" data-anchor-id="complexity-31">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Check if palindrome</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Count all palindromes</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Find longest palindrome</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-31" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-31">Try It Yourself</h4>
<ol type="1">
<li>Count all palindromes in <code>"level"</code>.</li>
<li>Find longest palindrome in <code>"civicracecar"</code>.</li>
<li>Compare brute-force vs expand-around-center runtime for length 1000.</li>
<li>Modify to ignore non-alphanumeric characters.</li>
<li>Extend to find palindromic substrings within specific range <span class="math inline">\([l, r]\)</span>.</li>
</ol>
<p>The Naive Palindrome Check is the mirror’s first glance — each center a reflection, each expansion a journey inward — simple, direct, and a perfect foundation for the symmetries ahead.</p>
</section>
</section>
<section id="manachers-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="manachers-algorithm">632 Manacher’s Algorithm</h3>
<p>Manacher’s Algorithm is the elegant, linear-time method to find the longest palindromic substring in a given string. Unlike the naive <span class="math inline">\(O(n^2)\)</span> center-expansion, it leverages symmetry, every palindrome mirrors across its center, to reuse computations and skip redundant checks.</p>
<p>It’s a classic example of how a clever insight turns a quadratic process into a linear one.</p>
<section id="what-problem-are-we-solving-32" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-32">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>, find the longest substring that reads the same forward and backward.</p>
<p>Example:</p>
<p><span class="math display">\[
S = \texttt{"babad"}
\]</span></p>
<p>Longest palindromic substrings: <span class="math display">\[
\texttt{"bab"} \text{ or } \texttt{"aba"}
\]</span></p>
<p>We want to compute this in <span class="math inline">\(O(n)\)</span> time, not <span class="math inline">\(O(n^2)\)</span>.</p>
</section>
<section id="the-core-idea" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea">The Core Idea</h4>
<p>Manacher’s key insight: Each palindrome has a mirror about the current center.</p>
<p>If we know the palindrome radius at a position <span class="math inline">\(i\)</span>, we can deduce information about its mirror position <span class="math inline">\(j\)</span> (using previously computed values), without rechecking all characters.</p>
</section>
<section id="step-by-step-plain-language" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-plain-language">Step-by-Step (Plain Language)</h4>
<ol type="1">
<li><p>Preprocess the string to handle even-length palindromes<br>
Insert <code>#</code> between all characters and at boundaries: <span class="math display">\[
S=\texttt{"abba"}\ \Rightarrow\ T=\texttt{"\#a\#b\#b\#a\#"}
\]</span> This way, all palindromes become odd-length in <span class="math inline">\(T\)</span>.</p></li>
<li><p>Iterate through <span class="math inline">\(T\)</span> Maintain:</p>
<ul>
<li><span class="math inline">\(C\)</span>: center of the rightmost palindrome</li>
<li><span class="math inline">\(R\)</span>: right boundary</li>
<li><span class="math inline">\(P[i]\)</span>: palindrome radius at <span class="math inline">\(i\)</span></li>
</ul></li>
<li><p>For each position <span class="math inline">\(i\)</span>:</p>
<ul>
<li>Mirror index: <span class="math inline">\(i' = 2C - i\)</span></li>
<li>Initialize <span class="math inline">\(P[i] = \min(R - i, P[i'])\)</span></li>
<li>Expand around <span class="math inline">\(i\)</span> while boundaries match</li>
</ul></li>
<li><p>Update center and boundary if the palindrome expands beyond <span class="math inline">\(R\)</span>.</p></li>
<li><p>After the loop, the maximum radius in <span class="math inline">\(P\)</span> gives the longest palindrome.</p></li>
</ol>
</section>
<section id="example-walkthrough-1" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-1">Example Walkthrough</h4>
<p>String: <span class="math display">\[
S = \texttt{"abaaba"}
\]</span></p>
<p>Preprocessed: <span class="math display">\[
T = \texttt{"\#a\#b\#a\#a\#b\#a\#"}
\]</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>T[i]</th>
<th>Mirror</th>
<th>P[i]</th>
<th>Center</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>#</td>
<td>,</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>a</td>
<td>,</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="odd">
<td>2</td>
<td>#</td>
<td>,</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>b</td>
<td></td>
<td>3</td>
<td>3</td>
<td>6</td>
</tr>
<tr class="odd">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Result: <span class="math display">\[
\text{Longest palindrome length } = 5
\]</span> <span class="math display">\[
\text{Substring } = \texttt{"abaaba"}
\]</span></p>
</section>
<section id="tiny-code-python-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-6">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> manacher(s):</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Preprocess</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="st">"#"</span> <span class="op">+</span> <span class="st">"#"</span>.join(s) <span class="op">+</span> <span class="st">"#"</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(t)</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> r <span class="op">=</span> <span class="dv">0</span>  <span class="co"># center, right boundary</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>        mirror <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> c <span class="op">-</span> i</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> r:</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>            p[i] <span class="op">=</span> <span class="bu">min</span>(r <span class="op">-</span> i, p[mirror])</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Expand around center i</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> p[i] <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> p[i] <span class="op">&lt;</span> n <span class="kw">and</span> t[i <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> p[i]] <span class="op">==</span> t[i <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> p[i]]:</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>            p[i] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update center if expanded past right boundary</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">+</span> p[i] <span class="op">&gt;</span> r:</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>            c, r <span class="op">=</span> i, i <span class="op">+</span> p[i]</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find max palindrome</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>    max_len <span class="op">=</span> <span class="bu">max</span>(p)</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>    center_index <span class="op">=</span> p.index(max_len)</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> (center_index <span class="op">-</span> max_len) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s[start:start <span class="op">+</span> max_len]</span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(manacher(<span class="st">"babad"</span>))  <span class="co"># "bab" or "aba"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-32" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-32">Why It Matters</h4>
<ul>
<li><p>Linear time, the fastest known for longest palindrome problem</p></li>
<li><p>Foundation for:</p>
<ul>
<li>Palindromic substring enumeration</li>
<li>Palindromic tree construction</li>
<li>DNA symmetry search</li>
</ul></li>
</ul>
<p>It’s a gem of algorithmic ingenuity, turning reflection into speed.</p>
</section>
<section id="complexity-32" class="level4">
<h4 class="anchored" data-anchor-id="complexity-32">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build (with preprocess)</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Query longest palindrome</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-32" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-32">Try It Yourself</h4>
<ol type="1">
<li>Run Manacher on <code>"banana"</code> → <code>"anana"</code></li>
<li>Compare with center-expansion time for <span class="math inline">\(n = 10^5\)</span></li>
<li>Modify to count all palindromic substrings</li>
<li>Track left and right boundaries visually</li>
<li>Apply to DNA sequence to detect symmetry motifs</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works">A Gentle Proof (Why It Works)</h4>
<p>Each position <span class="math inline">\(i\)</span> inside the current palindrome <span class="math inline">\((C, R)\)</span> has a mirror <span class="math inline">\(i' = 2C - i\)</span>. If <span class="math inline">\(i + P[i'] &lt; R\)</span>, palindrome is fully inside → reuse <span class="math inline">\(P[i']\)</span>. Else, expand beyond <span class="math inline">\(R\)</span> and update center.</p>
<p>No position is expanded twice → total <span class="math inline">\(O(n)\)</span>.</p>
<p>Manacher’s Algorithm is symmetry embodied — every center a mirror, every reflection a shortcut. What once took quadratic effort now glides in linear grace.</p>
</section>
</section>
<section id="longest-palindromic-substring-center-expansion" class="level3">
<h3 class="anchored" data-anchor-id="longest-palindromic-substring-center-expansion">633 Longest Palindromic Substring (Center Expansion)</h3>
<p>The Longest Palindromic Substring problem asks:</p>
<blockquote class="blockquote">
<p><em>What is the longest contiguous substring of a given string that reads the same forward and backward?</em></p>
</blockquote>
<p>The center expansion method is the intuitive and elegant <span class="math inline">\(O(n^2)\)</span> solution, simple to code, easy to reason about, and surprisingly efficient in practice. It sits between the naive brute force (<span class="math inline">\(O(n^3)\)</span>) and Manacher’s algorithm (<span class="math inline">\(O(n)\)</span>).</p>
<section id="what-problem-are-we-solving-33" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-33">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>, find the substring <span class="math inline">\(S[l \ldots r]\)</span> such that:</p>
<p><span class="math display">\[
S[l \ldots r] = \text{reverse}(S[l \ldots r])
\]</span></p>
<p>and <span class="math inline">\((r - l + 1)\)</span> is maximal.</p>
<p>Examples:</p>
<ul>
<li><code>"babad"</code> → <code>"bab"</code> or <code>"aba"</code></li>
<li><code>"cbbd"</code> → <code>"bb"</code></li>
<li><code>"a"</code> → <code>"a"</code></li>
</ul>
<p>We want to find this substring efficiently and clearly.</p>
</section>
<section id="core-idea-1" class="level4">
<h4 class="anchored" data-anchor-id="core-idea-1">Core Idea</h4>
<p>Every palindrome is defined by its center:</p>
<ul>
<li>Odd-length palindromes: one center (e.g.&nbsp;<code>"aba"</code>)</li>
<li>Even-length palindromes: two-character center (e.g.&nbsp;<code>"abba"</code>)</li>
</ul>
<p>If we expand from every possible center, we can detect all palindromic substrings and track the longest one.</p>
</section>
<section id="how-it-works-plain-language-3" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-3">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>For each index <span class="math inline">\(i\)</span> in <span class="math inline">\(S\)</span>:</p>
<ul>
<li>Expand around <span class="math inline">\(i\)</span> (odd palindrome)</li>
<li>Expand around <span class="math inline">\((i, i+1)\)</span> (even palindrome)</li>
</ul></li>
<li><p>Stop expanding when characters don’t match.</p></li>
<li><p>Track the maximum length and start index.</p></li>
</ol>
<p>Each expansion costs <span class="math inline">\(O(n)\)</span>, across <span class="math inline">\(n\)</span> centers → <span class="math inline">\(O(n^2)\)</span> total.</p>
</section>
<section id="example-24" class="level4">
<h4 class="anchored" data-anchor-id="example-24">Example</h4>
<p>String: <span class="math display">\[
S = \texttt{"babad"}
\]</span></p>
<p>Centers and expansions:</p>
<ul>
<li>Center at <code>b</code>: <code>"b"</code>, expand <code>"bab"</code></li>
<li>Center at <code>a</code>: <code>"a"</code>, expand <code>"aba"</code></li>
<li>Center at <code>ba</code>: mismatch, no expansion</li>
</ul>
<p>Longest found: <code>"bab"</code> or <code>"aba"</code></p>
</section>
<section id="tiny-code-python-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-7">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_palindrome_expand(s):</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> s:</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">""</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> end <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expand(l, r):</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> r <span class="op">&lt;</span> <span class="bu">len</span>(s) <span class="kw">and</span> s[l] <span class="op">==</span> s[r]:</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>            l <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>            r <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> l <span class="op">+</span> <span class="dv">1</span>, r <span class="op">-</span> <span class="dv">1</span>  <span class="co"># bounds of palindrome</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>        l1, r1 <span class="op">=</span> expand(i, i)       <span class="co"># odd length</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>        l2, r2 <span class="op">=</span> expand(i, i <span class="op">+</span> <span class="dv">1</span>)   <span class="co"># even length</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r1 <span class="op">-</span> l1 <span class="op">&gt;</span> end <span class="op">-</span> start:</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>            start, end <span class="op">=</span> l1, r1</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r2 <span class="op">-</span> l2 <span class="op">&gt;</span> end <span class="op">-</span> start:</span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>            start, end <span class="op">=</span> l2, r2</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s[start:end<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_palindrome_expand(<span class="st">"babad"</span>))  <span class="co"># "bab" or "aba"</span></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_palindrome_expand(<span class="st">"cbbd"</span>))   <span class="co"># "bb"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-33" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-33">Why It Matters</h4>
<ul>
<li><p>Straightforward and robust</p></li>
<li><p>Useful for:</p>
<ul>
<li>Substring symmetry checks</li>
<li>Bioinformatics (palindromic DNA segments)</li>
<li>Natural language analysis</li>
</ul></li>
<li><p>Easier to implement than Manacher’s, yet performant for most <span class="math inline">\(n \le 10^4\)</span></p></li>
</ul>
</section>
<section id="complexity-33" class="level4">
<h4 class="anchored" data-anchor-id="complexity-33">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expand from all centers</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Find longest palindrome</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-33" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-33">Try It Yourself</h4>
<ol type="1">
<li>Find the longest palindrome in <code>"racecarxyz"</code>.</li>
<li>Modify to count all palindromic substrings.</li>
<li>Return start and end indices of longest palindrome.</li>
<li>Test on <code>"aaaabaaa"</code> → <code>"aaabaaa"</code>.</li>
<li>Compare with Manacher’s Algorithm output.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-1" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-1">A Gentle Proof (Why It Works)</h4>
<p>Each palindrome is uniquely centered at either:</p>
<ul>
<li>a single character (odd case), or</li>
<li>between two characters (even case)</li>
</ul>
<p>Since we try all <span class="math inline">\(2n - 1\)</span> centers, every palindrome is discovered once, and we take the longest among them.</p>
<p>Thus correctness and completeness follow directly.</p>
<p>The center expansion method is a mirror dance — each position a pivot, each match a reflection — building symmetry outward, one step at a time.</p>
</section>
</section>
<section id="palindrome-dp-table-dynamic-programming-approach" class="level3">
<h3 class="anchored" data-anchor-id="palindrome-dp-table-dynamic-programming-approach">634 Palindrome DP Table (Dynamic Programming Approach)</h3>
<p>The Palindrome DP Table method uses dynamic programming to find and count palindromic substrings. It’s a bottom-up strategy that builds a 2D table marking whether each substring <span class="math inline">\(S[i \ldots j]\)</span> is a palindrome, and from there, we can easily answer questions like:</p>
<ul>
<li>Is substring <span class="math inline">\(S[i \ldots j]\)</span> palindromic?</li>
<li>What is the longest palindromic substring?</li>
<li>How many palindromic substrings exist?</li>
</ul>
<p>It’s systematic and easy to extend, though it costs more memory than center expansion.</p>
<section id="what-problem-are-we-solving-34" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-34">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>, we want to precompute palindromic substrings efficiently.</p>
<p>We define a DP table <span class="math inline">\(P[i][j]\)</span> such that:</p>
<p><span class="math display">\[
P[i][j] =
\begin{cases}
\text{True}, &amp; \text{if } S[i \ldots j] \text{ is a palindrome},\\
\text{False}, &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>Then we can query or count all palindromes using this table.</p>
</section>
<section id="recurrence-relation" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relation">Recurrence Relation</h4>
<p>A substring <span class="math inline">\(S[i \ldots j]\)</span> is a palindrome if:</p>
<ol type="1">
<li>The boundary characters match: <span class="math display">\[
S[i] = S[j]
\]</span></li>
<li>The inner substring is also a palindrome (or small enough): <span class="math display">\[
P[i+1][j-1] = \text{True} \quad \text{or} \quad (j - i \le 2)
\]</span></li>
</ol>
<p>So the recurrence is:</p>
<p><span class="math display">\[
P[i][j] = (S[i] = S[j]) \ \text{and} \ (j - i \le 2 \ \text{or} \ P[i+1][j-1])
\]</span></p>
</section>
<section id="initialization" class="level4">
<h4 class="anchored" data-anchor-id="initialization">Initialization</h4>
<ul>
<li>All single characters are palindromes: <span class="math display">\[
P[i][i] = \text{True}
\]</span></li>
<li>Two-character substrings are palindromic if both match: <span class="math display">\[
P[i][i+1] = (S[i] = S[i+1])
\]</span></li>
</ul>
<p>We fill the table from shorter substrings to longer ones.</p>
</section>
<section id="example-25" class="level4">
<h4 class="anchored" data-anchor-id="example-25">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"abba"}
\]</span></p>
<p>We build <span class="math inline">\(P\)</span> bottom-up:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>0:a</th>
<th>1:b</th>
<th>2:b</th>
<th>3:a</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0:a</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
</tr>
<tr class="even">
<td>1:b</td>
<td></td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
<tr class="odd">
<td>2:b</td>
<td></td>
<td></td>
<td>T</td>
<td>F</td>
</tr>
<tr class="even">
<td>3:a</td>
<td></td>
<td></td>
<td></td>
<td>T</td>
</tr>
</tbody>
</table>
<p>Palindromic substrings: <code>"a"</code>, <code>"b"</code>, <code>"bb"</code>, <code>"abba"</code></p>
</section>
<section id="tiny-code-python-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-8">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_palindrome_dp(s):</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">""</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    start, max_len <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># length 1</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># length 2</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[i<span class="op">+</span><span class="dv">1</span>]:</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>            dp[i][i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>            start, max_len <span class="op">=</span> i, <span class="dv">2</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># length &gt;= 3</span></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j] <span class="kw">and</span> dp[i<span class="op">+</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>                start, max_len <span class="op">=</span> i, length</span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s[start:start<span class="op">+</span>max_len]</span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_palindrome_dp(<span class="st">"babad"</span>))  <span class="co"># "bab" or "aba"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-34" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-34">Why It Matters</h4>
<ul>
<li><p>Clear logic, easy to adapt</p></li>
<li><p>Useful for:</p>
<ul>
<li>Counting all palindromic substrings</li>
<li>Finding all palindromic indices</li>
<li>Teaching DP recurrence building</li>
</ul></li>
</ul>
<p>It’s the pedagogical bridge from brute force to linear-time solutions.</p>
</section>
<section id="complexity-34" class="level4">
<h4 class="anchored" data-anchor-id="complexity-34">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build DP table</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="even">
<td>Query palindrome <span class="math inline">\(S[i \ldots j]\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Longest palindrome extraction</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-34" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-34">Try It Yourself</h4>
<ol type="1">
<li>Count all palindromic substrings by summing <code>dp[i][j]</code>.</li>
<li>Return all indices <span class="math inline">\((i, j)\)</span> where <code>dp[i][j] == True</code>.</li>
<li>Compare runtime vs center-expansion for <span class="math inline">\(n = 2000\)</span>.</li>
<li>Optimize space by using 1D rolling arrays.</li>
<li>Adapt for “near-palindromes” (allow 1 mismatch).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-2" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-2">A Gentle Proof (Why It Works)</h4>
<p>We expand palindrome definitions incrementally:</p>
<ul>
<li>Base case: length 1 or 2</li>
<li>Recursive case: match outer chars + inner palindrome</li>
</ul>
<p>Every palindrome has a smaller palindrome inside, so the bottom-up order ensures correctness.</p>
<p>The Palindrome DP Table turns reflection into recurrence — each cell a mirror, each step a layer — revealing every symmetry hidden in the string.</p>
</section>
</section>
<section id="palindromic-tree-eertree" class="level3">
<h3 class="anchored" data-anchor-id="palindromic-tree-eertree">635 Palindromic Tree (Eertree)</h3>
<p>A palindromic tree (often called Eertree) is a dynamic structure that stores all distinct palindromic substrings of a string while you scan it from left to right. It maintains one node per palindrome and supports insertion of the next character in amortized constant time, yielding linear total time.</p>
<p>It is the most direct way to enumerate palindromes: you get their counts, lengths, end positions, and suffix links for free.</p>
<section id="what-problem-are-we-solving-35" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-35">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(S\)</span>, we want to maintain after each prefix <span class="math inline">\(S[0..i]\)</span>:</p>
<ul>
<li>All distinct palindromic substrings present so far</li>
<li>For each palindrome, its length, suffix link to the longest proper palindromic suffix, and optionally its occurrence count</li>
</ul>
<p>With an Eertree we can build this online in <span class="math inline">\(O(n)\)</span> time and <span class="math inline">\(O(n)\)</span> space, since a string of length <span class="math inline">\(n\)</span> has at most <span class="math inline">\(n\)</span> distinct palindromic substrings.</p>
</section>
<section id="core-idea-2" class="level4">
<h4 class="anchored" data-anchor-id="core-idea-2">Core Idea</h4>
<p>Nodes correspond to distinct palindromes. There are two special roots:</p>
<ul>
<li>Node <span class="math inline">\(-1\)</span> representing a virtual palindrome of length <span class="math inline">\(-1\)</span></li>
<li>Node <span class="math inline">\(0\)</span> representing the empty palindrome of length <span class="math inline">\(0\)</span></li>
</ul>
<p>Each node keeps:</p>
<ul>
<li><code>len[v]</code>: palindrome length</li>
<li><code>link[v]</code>: suffix link to the longest proper palindromic suffix</li>
<li><code>next[v][c]</code>: transition by adding character <span class="math inline">\(c\)</span> to both ends</li>
<li>optionally <code>occ[v]</code>: number of occurrences ending at processed positions</li>
<li><code>first_end[v]</code> or a last end index to recover positions</li>
</ul>
<p>To insert a new character <span class="math inline">\(S[i]\)</span>:</p>
<ol type="1">
<li>Walk suffix links from the current longest suffix-palindrome until you find a node <span class="math inline">\(v\)</span> such that <span class="math inline">\(S[i - len[v] - 1] = S[i]\)</span>. This is the largest palindromic suffix of <span class="math inline">\(S[0..i]\)</span> that can be extended by <span class="math inline">\(S[i]\)</span>.</li>
<li>If edge by <span class="math inline">\(S[i]\)</span> does not exist from <span class="math inline">\(v\)</span>, create a new node for the new palindrome. Set its <code>len</code>, compute its <code>link</code> by continuing suffix-link jumps from <code>link[v]</code>, and set transitions.</li>
<li>Update occurrence counters and set the new current node to this node.</li>
</ol>
<p>Each insertion creates at most one new node, so total nodes are at most <span class="math inline">\(n + 2\)</span>.</p>
</section>
<section id="example-26" class="level4">
<h4 class="anchored" data-anchor-id="example-26">Example</h4>
<p>Let <span class="math inline">\(S = \texttt{"ababa"}\)</span>.</p>
<p>Processed prefixes and newly created palindromes:</p>
<ul>
<li><span class="math inline">\(i=0\)</span>: add <code>a</code> → <code>"a"</code></li>
<li><span class="math inline">\(i=1\)</span>: add <code>b</code> → <code>"b"</code></li>
<li><span class="math inline">\(i=2\)</span>: add <code>a</code> → <code>"aba"</code></li>
<li><span class="math inline">\(i=3\)</span>: add <code>b</code> → <code>"bab"</code></li>
<li><span class="math inline">\(i=4\)</span>: add <code>a</code> → <code>"ababa"</code></li>
</ul>
<p>Distinct palindromes: <code>a</code>, <code>b</code>, <code>aba</code>, <code>bab</code>, <code>ababa</code>. Two special roots always exist: length <span class="math inline">\(-1\)</span> and <span class="math inline">\(0\)</span>.</p>
</section>
<section id="tiny-code-python-educational" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-educational">Tiny Code (Python, educational)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Eertree:</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># node 0: empty palindrome, len = 0</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># node 1: imaginary root, len = -1</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="bu">len</span> <span class="op">=</span> [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.link <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.<span class="bu">next</span> <span class="op">=</span> [<span class="bu">dict</span>(), <span class="bu">dict</span>()]</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.occ <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.s <span class="op">=</span> []</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.last <span class="op">=</span> <span class="dv">0</span>  <span class="co"># node of the longest suffix palindrome of current string</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _get_suflink(<span class="va">self</span>, v, i):</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> <span class="va">self</span>.<span class="bu">len</span>[v]</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">-</span> l <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> <span class="va">self</span>.s[i <span class="op">-</span> l <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="va">self</span>.s[i]:</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> v</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> <span class="va">self</span>.link[v]</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_char(<span class="va">self</span>, ch):</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.s.append(ch)</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="va">self</span>.n</span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="va">self</span>._get_suflink(<span class="va">self</span>.last, i)</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.<span class="bu">next</span>[v]:</span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.<span class="bu">next</span>[v][ch] <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.<span class="bu">len</span>)</span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.<span class="bu">len</span>.append(<span class="va">self</span>.<span class="bu">len</span>[v] <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.<span class="bu">next</span>.append(<span class="bu">dict</span>())</span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.occ.append(<span class="dv">0</span>)</span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># compute suffix link of the new node</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.<span class="bu">len</span>[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.link.append(<span class="dv">0</span>)  <span class="co"># single char palindromes link to empty</span></span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>                u <span class="op">=</span> <span class="va">self</span>._get_suflink(<span class="va">self</span>.link[v], i)</span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.link.append(<span class="va">self</span>.<span class="bu">next</span>[u][ch])</span>
<span id="cb72-37"><a href="#cb72-37" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> <span class="va">self</span>.<span class="bu">next</span>[v][ch]</span>
<span id="cb72-38"><a href="#cb72-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.last <span class="op">=</span> w</span>
<span id="cb72-39"><a href="#cb72-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.occ[w] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb72-40"><a href="#cb72-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> w  <span class="co"># returns node index for the longest suffix palindrome</span></span>
<span id="cb72-41"><a href="#cb72-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-42"><a href="#cb72-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> finalize_counts(<span class="va">self</span>):</span>
<span id="cb72-43"><a href="#cb72-43" aria-hidden="true" tabindex="-1"></a>        <span class="co"># propagate occurrences along suffix links so occ[v] counts all ends</span></span>
<span id="cb72-44"><a href="#cb72-44" aria-hidden="true" tabindex="-1"></a>        order <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(<span class="va">self</span>.<span class="bu">len</span>)), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="va">self</span>.<span class="bu">len</span>[x], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb72-45"><a href="#cb72-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> order:</span>
<span id="cb72-46"><a href="#cb72-46" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.occ[<span class="va">self</span>.link[v]] <span class="op">+=</span> <span class="va">self</span>.occ[v]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> Eertree()</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> <span class="st">"ababa"</span>:</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    T.add_char(c)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>T.finalize_counts()</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Distinct palindromes count (excluding two roots):</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(T.<span class="bu">len</span>) <span class="op">-</span> <span class="dv">2</span>)  <span class="co"># 5</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>What you get:</p>
<ul>
<li>Number of distinct palindromes: <code>len(nodes) - 2</code></li>
<li>Occurrences of each palindrome after <code>finalize_counts</code></li>
<li>Lengths, suffix links, and transitions for traversal</li>
</ul>
</section>
<section id="why-it-matters-35" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-35">Why It Matters</h4>
<ul>
<li><p>Lists all distinct palindromic substrings in linear time</p></li>
<li><p>Supports online updates: add one character and update in amortized <span class="math inline">\(O(1)\)</span></p></li>
<li><p>Gives counts and boundaries for palindromes</p></li>
<li><p>Natural fit for:</p>
<ul>
<li>Counting palindromic substrings</li>
<li>Longest palindromic substring while streaming</li>
<li>Palindromic factorization and periodicity analysis</li>
<li>Biosequence symmetry mining</li>
</ul></li>
</ul>
</section>
<section id="complexity-35" class="level4">
<h4 class="anchored" data-anchor-id="complexity-35">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert one character</td>
<td>amortized <span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span> extra</td>
</tr>
<tr class="even">
<td>Build on length <span class="math inline">\(n\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span> nodes</td>
</tr>
<tr class="odd">
<td>Occurrence aggregation</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>At most one new palindrome per position, hence linear bounds.</p>
</section>
<section id="try-it-yourself-35" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-35">Try It Yourself</h4>
<ol type="1">
<li>Build the eertree for <code>"aaaabaaa"</code>. Verify the distinct palindromes and their counts.</li>
<li>Track the longest palindrome after each insertion.</li>
<li>Record first and last end positions per node to list all occurrences.</li>
<li>Modify the structure to also maintain even and odd longest suffix palindromes separately.</li>
<li>Compare memory and speed with DP and Manacher for <span class="math inline">\(n \approx 10^5\)</span>.</li>
</ol>
<p>The palindromic tree models the universe of palindromes succinctly: every node is a mirror, every link a shorter reflection, and with one sweep over the string you discover them all.</p>
</section>
</section>
<section id="prefix-function-periodicity" class="level3">
<h3 class="anchored" data-anchor-id="prefix-function-periodicity">636 Prefix Function Periodicity</h3>
<p>The prefix function is a core tool in string algorithms, it tells you, for each position, the length of the longest proper prefix that is also a suffix. When studied through the lens of periodicity, it becomes a sharp instrument for detecting repetition patterns, string borders, and minimal periods, foundational in pattern matching, compression, and combinatorics on words.</p>
<section id="what-problem-are-we-solving-36" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-36">What Problem Are We Solving?</h4>
<p>We want to find periodic structure in a string, specifically, the shortest repeating unit.</p>
<p>A string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span> is periodic if there exists a <span class="math inline">\(p &lt; n\)</span> such that:</p>
<p><span class="math display">\[
S[i] = S[i + p] \quad \forall i = 0, 1, \ldots, n - p - 1
\]</span></p>
<p>We call <span class="math inline">\(p\)</span> the period of <span class="math inline">\(S\)</span>.</p>
<p>The prefix function gives us exactly the border lengths we need to compute <span class="math inline">\(p\)</span> in <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="the-prefix-function" class="level4">
<h4 class="anchored" data-anchor-id="the-prefix-function">The Prefix Function</h4>
<p>For string <span class="math inline">\(S[0 \ldots n-1]\)</span>, define:</p>
<p><span class="math display">\[
\pi[i] = \text{length of the longest proper prefix of } S[0..i] \text{ that is also a suffix}
\]</span></p>
<p>This is the same array used in Knuth–Morris–Pratt (KMP).</p>
</section>
<section id="periodicity-formula" class="level4">
<h4 class="anchored" data-anchor-id="periodicity-formula">Periodicity Formula</h4>
<p>The minimal period of the prefix <span class="math inline">\(S[0..i]\)</span> is:</p>
<p><span class="math display">\[
p = (i + 1) - \pi[i]
\]</span></p>
<p>If <span class="math inline">\((i + 1) \bmod p = 0\)</span>, then the prefix <span class="math inline">\(S[0..i]\)</span> is fully periodic with period <span class="math inline">\(p\)</span>.</p>
</section>
<section id="example-27" class="level4">
<h4 class="anchored" data-anchor-id="example-27">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"abcabcabc"}
\]</span></p>
<p>Compute prefix function:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>S[i]</th>
<th>π[i]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>a</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>b</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>c</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>a</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>b</td>
<td>2</td>
</tr>
<tr class="even">
<td>5</td>
<td>c</td>
<td>3</td>
</tr>
<tr class="odd">
<td>6</td>
<td>a</td>
<td>4</td>
</tr>
<tr class="even">
<td>7</td>
<td>b</td>
<td>5</td>
</tr>
<tr class="odd">
<td>8</td>
<td>c</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>Now minimal period for <span class="math inline">\(i=8\)</span>:</p>
<p><span class="math display">\[
p = 9 - \pi[8] = 9 - 6 = 3
\]</span></p>
<p>And since <span class="math inline">\(9 \bmod 3 = 0\)</span>, period = 3, repeating unit <code>"abc"</code>.</p>
</section>
<section id="how-it-works-plain-language-4" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-4">How It Works (Plain Language)</h4>
<p>Each <span class="math inline">\(\pi[i]\)</span> measures how much of the string “wraps around” itself. If a prefix and suffix align, they hint at repetition. The difference between length <span class="math inline">\((i + 1)\)</span> and border <span class="math inline">\(\pi[i]\)</span> gives the repeating block length.</p>
<p>When the total length divides evenly by this block, the entire prefix is made of repeated copies.</p>
</section>
<section id="tiny-code-python-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-9">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prefix_function(s):</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> pi[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> s[i] <span class="op">!=</span> s[j]:</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> pi[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>        pi[i] <span class="op">=</span> j</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pi</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimal_period(s):</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> prefix_function(s)</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> n <span class="op">-</span> pi[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">%</span> p <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n  <span class="co"># no smaller period</span></span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"abcabcabc"</span></span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(minimal_period(s))  <span class="co"># 3</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-36" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-36">Why It Matters</h4>
<ul>
<li><p>Detects repetition in strings in linear time</p></li>
<li><p>Used in:</p>
<ul>
<li>Pattern compression</li>
<li>DNA repeat detection</li>
<li>Music rhythm analysis</li>
<li>Periodic task scheduling</li>
</ul></li>
<li><p>Core concept behind KMP, Z-algorithm, and border arrays</p></li>
</ul>
</section>
<section id="complexity-36" class="level4">
<h4 class="anchored" data-anchor-id="complexity-36">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build prefix function</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Find minimal period</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Check periodic prefix</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-36" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-36">Try It Yourself</h4>
<ol type="1">
<li>Compute period of <code>"ababab"</code> → <code>2</code>.</li>
<li>Compute period of <code>"aaaaa"</code> → <code>1</code>.</li>
<li>Compute period of <code>"abcd"</code> → <code>4</code> (no repetition).</li>
<li>For each prefix, print <code>(i + 1) - π[i]</code> and test divisibility.</li>
<li>Compare with Z-function periodicity (section 637).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-3" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-3">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(\pi[i] = k\)</span>, then <span class="math inline">\(S[0..k-1] = S[i-k+1..i]\)</span>.</p>
<p>Hence, the prefix has a border of length <span class="math inline">\(k\)</span>, and repeating block size <span class="math inline">\((i + 1) - k\)</span>. If <span class="math inline">\((i + 1)\)</span> divides evenly by that, the entire prefix is copies of one unit.</p>
<p>Prefix Function Periodicity reveals rhythm in repetition — each border a rhyme, each overlap a hidden beat — turning pattern detection into simple modular music.</p>
</section>
</section>
<section id="z-function-periodicity" class="level3">
<h3 class="anchored" data-anchor-id="z-function-periodicity">637 Z-Function Periodicity</h3>
<p>The Z-Function offers another elegant path to uncovering repetition and periodicity in strings. While the prefix function looks backward (prefix–suffix overlaps), the Z-function looks forward, it measures how far each position matches the beginning of the string. This makes it a natural fit for analyzing repeating prefixes and finding periods in linear time.</p>
<section id="what-problem-are-we-solving-37" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-37">What Problem Are We Solving?</h4>
<p>We want to detect if a string <span class="math inline">\(S\)</span> has a period <span class="math inline">\(p\)</span> — that is, if it consists of one or more repetitions of a smaller block.</p>
<p>Formally, <span class="math inline">\(S\)</span> has period <span class="math inline">\(p\)</span> if:</p>
<p><span class="math display">\[
S[i] = S[i + p], \quad \forall i \in [0, n - p - 1]
\]</span></p>
<p>Equivalently, if:</p>
<p><span class="math display">\[
S = T^k \quad \text{for some } T, k \ge 2
\]</span></p>
<p>The Z-function reveals this structure by measuring prefix matches at every shift.</p>
</section>
<section id="definition-1" class="level4">
<h4 class="anchored" data-anchor-id="definition-1">Definition</h4>
<p>For string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>:</p>
<p><span class="math display">\[
Z[i] = \text{length of the longest prefix of } S \text{ starting at } i
\]</span></p>
<p>Formally:</p>
<p><span class="math display">\[
Z[i] = \max { k \ | \ S[0..k-1] = S[i..i+k-1] }
\]</span></p>
<p>By definition, <span class="math inline">\(Z[0] = 0\)</span> or <span class="math inline">\(n\)</span> (often set to 0 for simplicity).</p>
</section>
<section id="periodicity-criterion" class="level4">
<h4 class="anchored" data-anchor-id="periodicity-criterion">Periodicity Criterion</h4>
<p>A string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span> has period <span class="math inline">\(p\)</span> if:</p>
<p><span class="math display">\[
Z[p] = n - p
\]</span></p>
<p>and <span class="math inline">\(p\)</span> divides <span class="math inline">\(n\)</span>, i.e.&nbsp;<span class="math inline">\(n \bmod p = 0\)</span>.</p>
<p>This means the prefix of length <span class="math inline">\(n - p\)</span> repeats perfectly from position <span class="math inline">\(p\)</span>.</p>
<p>More generally, any <span class="math inline">\(p\)</span> satisfying <span class="math inline">\(Z[p] = n - p\)</span> is a border length, and minimal period = smallest such <span class="math inline">\(p\)</span>.</p>
</section>
<section id="example-28" class="level4">
<h4 class="anchored" data-anchor-id="example-28">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"abcabcabc"}
\]</span> <span class="math inline">\(n = 9\)</span></p>
<p>Compute <span class="math inline">\(Z\)</span> array:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>S[i:]</th>
<th>Z[i]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>abcabcabc</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>bcabcabc</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>cabcabc</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>abcabc</td>
<td>6</td>
</tr>
<tr class="odd">
<td>4</td>
<td>bcabc</td>
<td>0</td>
</tr>
<tr class="even">
<td>5</td>
<td>cabc</td>
<td>0</td>
</tr>
<tr class="odd">
<td>6</td>
<td>abc</td>
<td>3</td>
</tr>
<tr class="even">
<td>7</td>
<td>bc</td>
<td>0</td>
</tr>
<tr class="odd">
<td>8</td>
<td>c</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Check <span class="math inline">\(p = 3\)</span>:</p>
<p><span class="math display">\[
Z[3] = 6 = n - 3, \quad 9 \bmod 3 = 0
\]</span></p>
<p>Ok So <span class="math inline">\(p = 3\)</span> is the minimal period.</p>
</section>
<section id="how-it-works-plain-language-5" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-5">How It Works (Plain Language)</h4>
<p>Imagine sliding the string against itself:</p>
<ul>
<li>At shift <span class="math inline">\(p\)</span>, <span class="math inline">\(Z[p]\)</span> tells how many leading characters still match.</li>
<li>If the overlap spans the rest of the string (<span class="math inline">\(Z[p] = n - p\)</span>), then the pattern before and after aligns perfectly.</li>
</ul>
<p>This alignment implies repetition.</p>
</section>
<section id="tiny-code-python-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-10">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> z_function(s):</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> r <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;=</span> r:</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>            Z[i] <span class="op">=</span> <span class="bu">min</span>(r <span class="op">-</span> i <span class="op">+</span> <span class="dv">1</span>, Z[i <span class="op">-</span> l])</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">+</span> Z[i] <span class="op">&lt;</span> n <span class="kw">and</span> s[Z[i]] <span class="op">==</span> s[i <span class="op">+</span> Z[i]]:</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>            Z[i] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">+</span> Z[i] <span class="op">-</span> <span class="dv">1</span> <span class="op">&gt;</span> r:</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>            l, r <span class="op">=</span> i, i <span class="op">+</span> Z[i] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Z</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimal_period_z(s):</span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>    Z <span class="op">=</span> z_function(s)</span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Z[p] <span class="op">==</span> n <span class="op">-</span> p <span class="kw">and</span> n <span class="op">%</span> p <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> p</span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n</span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"abcabcabc"</span></span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(minimal_period_z(s))  <span class="co"># 3</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-37" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-37">Why It Matters</h4>
<ul>
<li><p>A simple way to test repetition and pattern structure</p></li>
<li><p>Linear-time (<span class="math inline">\(O(n)\)</span>) algorithm</p></li>
<li><p>Useful in:</p>
<ul>
<li>String periodicity detection</li>
<li>Prefix-based hashing</li>
<li>Pattern discovery</li>
<li>Suffix comparisons</li>
</ul></li>
</ul>
<p>The Z-function complements the prefix function:</p>
<ul>
<li>Prefix function → borders (prefix = suffix)</li>
<li>Z-function → prefix matches at every offset</li>
</ul>
</section>
<section id="complexity-37" class="level4">
<h4 class="anchored" data-anchor-id="complexity-37">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compute Z-array</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Check periodicity</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Find minimal period</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-37" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-37">Try It Yourself</h4>
<ol type="1">
<li>Compute <span class="math inline">\(Z\)</span> for <code>"aaaaaa"</code> → minimal period = 1</li>
<li>For <code>"ababab"</code> → <span class="math inline">\(Z[2] = 4\)</span>, period = 2</li>
<li>For <code>"abcd"</code> → no valid <span class="math inline">\(p\)</span>, period = 4</li>
<li>Verify <span class="math inline">\(Z[p] = n - p\)</span> corresponds to repeating prefix</li>
<li>Compare results with prefix function periodicity</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-4" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-4">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(Z[p] = n - p\)</span>, then <span class="math inline">\(S[0..n-p-1] = S[p..n-1]\)</span>. Thus <span class="math inline">\(S\)</span> can be partitioned into blocks of size <span class="math inline">\(p\)</span>. If <span class="math inline">\(n \bmod p = 0\)</span>, then <span class="math inline">\(S = T^{n/p}\)</span> with <span class="math inline">\(T = S[0..p-1]\)</span>.</p>
<p>Therefore, the smallest <span class="math inline">\(p\)</span> with that property is the minimal period.</p>
<p>The Z-Function turns overlap into insight — each shift a mirror, each match a rhyme — revealing the string’s hidden beat through forward reflection.</p>
</section>
</section>
<section id="kmp-prefix-period-check-shortest-repeating-unit" class="level3">
<h3 class="anchored" data-anchor-id="kmp-prefix-period-check-shortest-repeating-unit">638 KMP Prefix Period Check (Shortest Repeating Unit)</h3>
<p>The KMP prefix function not only powers fast pattern matching but also quietly encodes the repetitive structure of a string. By analyzing the final value of the prefix function, we can reveal whether a string is built from repeated copies of a smaller block, and if so, find that shortest repeating unit, the <em>fundamental period</em>.</p>
<section id="what-problem-are-we-solving-38" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-38">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>, we want to determine:</p>
<ol type="1">
<li>Is <span class="math inline">\(S\)</span> composed of repeated copies of a smaller substring?</li>
<li>If yes, what is the shortest repeating unit <span class="math inline">\(T\)</span> and its length <span class="math inline">\(p\)</span>?</li>
</ol>
<p>Formally, <span class="math display">\[
S = T^k, \quad \text{where } |T| = p, \ k = n / p
\]</span> and <span class="math inline">\(n \bmod p = 0\)</span>.</p>
</section>
<section id="core-insight" class="level4">
<h4 class="anchored" data-anchor-id="core-insight">Core Insight</h4>
<p>The prefix function <span class="math inline">\(\pi[i]\)</span> captures the longest border of each prefix — a border is a substring that is both a proper prefix and proper suffix.</p>
<p>At the end (<span class="math inline">\(i = n - 1\)</span>), <span class="math inline">\(\pi[n-1]\)</span> gives the length of the longest border of the full string.</p>
<p>Let: <span class="math display">\[
b = \pi[n-1]
\]</span> Then the candidate period is: <span class="math display">\[
p = n - b
\]</span></p>
<p>If <span class="math inline">\(n \bmod p = 0\)</span>, the string is periodic with shortest repeating unit of length <span class="math inline">\(p\)</span>.</p>
<p>Otherwise, it’s aperiodic, and <span class="math inline">\(p = n\)</span>.</p>
</section>
<section id="example-1-1" class="level4">
<h4 class="anchored" data-anchor-id="example-1-1">Example 1</h4>
<p><span class="math display">\[
S = \texttt{"abcabcabc"}
\]</span></p>
<p><span class="math inline">\(n = 9\)</span></p>
<p>Compute prefix function:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>S[i]</th>
<th>π[i]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>a</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>b</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>c</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>a</td>
<td>1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>b</td>
<td>2</td>
</tr>
<tr class="even">
<td>5</td>
<td>c</td>
<td>3</td>
</tr>
<tr class="odd">
<td>6</td>
<td>a</td>
<td>4</td>
</tr>
<tr class="even">
<td>7</td>
<td>b</td>
<td>5</td>
</tr>
<tr class="odd">
<td>8</td>
<td>c</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>So <span class="math inline">\(\pi[8] = 6\)</span></p>
<p><span class="math display">\[
p = 9 - 6 = 3
\]</span></p>
<p>Check: <span class="math inline">\(9 \bmod 3 = 0\)</span> Ok Hence, shortest repeating unit = <code>"abc"</code>.</p>
</section>
<section id="example-2-1" class="level4">
<h4 class="anchored" data-anchor-id="example-2-1">Example 2</h4>
<p><span class="math display">\[
S = \texttt{"aaaa"} \implies n=4
\]</span> <span class="math inline">\(\pi = [0, 1, 2, 3]\)</span>, so <span class="math inline">\(\pi[3] = 3\)</span> <span class="math display">\[
p = 4 - 3 = 1, \quad 4 \bmod 1 = 0
\]</span> Ok Repeating unit = <code>"a"</code></p>
</section>
<section id="example-3-1" class="level4">
<h4 class="anchored" data-anchor-id="example-3-1">Example 3</h4>
<p><span class="math display">\[
S = \texttt{"abcd"} \implies n=4
\]</span> <span class="math inline">\(\pi = [0, 0, 0, 0]\)</span> <span class="math display">\[
p = 4 - 0 = 4, \quad 4 \bmod 4 = 0
\]</span> Only repeats once → no smaller period.</p>
</section>
<section id="how-it-works-plain-language-6" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-6">How It Works (Plain Language)</h4>
<p>The prefix function shows how much of the string overlaps with itself. If the border length is <span class="math inline">\(b\)</span>, then the last <span class="math inline">\(b\)</span> characters match the first <span class="math inline">\(b\)</span>. That means every <span class="math inline">\(p = n - b\)</span> characters, the pattern repeats. If the string length divides evenly by <span class="math inline">\(p\)</span>, it’s made up of repeated blocks.</p>
</section>
<section id="tiny-code-python-11" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-11">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prefix_function(s):</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> pi[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> s[i] <span class="op">!=</span> s[j]:</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> pi[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>        pi[i] <span class="op">=</span> j</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pi</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shortest_repeating_unit(s):</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> prefix_function(s)</span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> pi[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> n <span class="op">-</span> b</span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">%</span> p <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> s[:p]</span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s  <span class="co"># no repetition</span></span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(shortest_repeating_unit(<span class="st">"abcabcabc"</span>))  <span class="co"># "abc"</span></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(shortest_repeating_unit(<span class="st">"aaaa"</span>))       <span class="co"># "a"</span></span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(shortest_repeating_unit(<span class="st">"abcd"</span>))       <span class="co"># "abcd"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-38" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-38">Why It Matters</h4>
<ul>
<li><p>Finds string periodicity in <span class="math inline">\(O(n)\)</span> time</p></li>
<li><p>Crucial for:</p>
<ul>
<li>Pattern detection and compression</li>
<li>Border analysis and combinatorics</li>
<li>Minimal automata construction</li>
<li>Rhythm detection in music or DNA repeats</li>
</ul></li>
</ul>
<p>Elegant and efficient, all from a single <span class="math inline">\(\pi\)</span> array.</p>
</section>
<section id="complexity-38" class="level4">
<h4 class="anchored" data-anchor-id="complexity-38">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compute prefix function</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Extract period</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-38" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-38">Try It Yourself</h4>
<ol type="1">
<li><code>"abababab"</code> → π = [0,0,1,2,3,4,5,6], <span class="math inline">\(b=6\)</span>, <span class="math inline">\(p=2\)</span>, unit = <code>"ab"</code></li>
<li><code>"xyzxyzx"</code> → <span class="math inline">\(n=7\)</span>, <span class="math inline">\(\pi[6]=3\)</span>, <span class="math inline">\(p=4\)</span>, <span class="math inline">\(7 \bmod 4 \neq 0\)</span> → aperiodic</li>
<li><code>"aaaaa"</code> → <span class="math inline">\(p=1\)</span>, unit = <code>"a"</code></li>
<li><code>"abaaba"</code> → <span class="math inline">\(n=6\)</span>, <span class="math inline">\(\pi[5]=3\)</span>, <span class="math inline">\(p=3\)</span>, <span class="math inline">\(6 \bmod 3 = 0\)</span> → <code>"aba"</code></li>
<li>Try combining with prefix-function periodicity table (Sec. 636).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-5" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-5">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(\pi[n-1] = b\)</span>, then prefix of length <span class="math inline">\(b\)</span> = suffix of length <span class="math inline">\(b\)</span>. Hence, block length <span class="math inline">\(p = n - b\)</span>. If <span class="math inline">\(p\)</span> divides <span class="math inline">\(n\)</span>, then <span class="math inline">\(S\)</span> is made of <span class="math inline">\(n / p\)</span> copies of <span class="math inline">\(S[0..p-1]\)</span>.</p>
<p>Otherwise, it only has partial repetition at the end.</p>
<p>KMP Prefix Period Check is the heartbeat of repetition — each border a callback, each overlap a rhythm — revealing the smallest phrase that composes the song.</p>
</section>
</section>
<section id="lyndon-factorization-chenfoxlyndon-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="lyndon-factorization-chenfoxlyndon-decomposition">639 Lyndon Factorization (Chen–Fox–Lyndon Decomposition)</h3>
<p>The Lyndon Factorization, also known as the Chen–Fox–Lyndon decomposition, is a remarkable string theorem that breaks any string into a unique sequence of Lyndon words, substrings that are strictly smaller (lexicographically) than any of their nontrivial suffixes.</p>
<p>This factorization is deeply connected to lexicographic order, suffix arrays, suffix automata, and string combinatorics, and is the foundation of algorithms like the Duval algorithm.</p>
<section id="what-problem-are-we-solving-39" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-39">What Problem Are We Solving?</h4>
<p>We want to decompose a string <span class="math inline">\(S\)</span> into a sequence of factors:</p>
<p><span class="math display">\[
S = w_1 w_2 w_3 \dots w_k
\]</span></p>
<p>such that:</p>
<ol type="1">
<li>Each <span class="math inline">\(w_i\)</span> is a Lyndon word (i.e.&nbsp;strictly smaller than any of its proper suffixes)</li>
<li>The sequence is nonincreasing in lexicographic order: <span class="math display">\[
w_1 \ge w_2 \ge w_3 \ge \dots \ge w_k
\]</span></li>
</ol>
<p>This decomposition is unique for every string.</p>
</section>
<section id="what-is-a-lyndon-word" class="level4">
<h4 class="anchored" data-anchor-id="what-is-a-lyndon-word">What Is a Lyndon Word?</h4>
<p>A Lyndon word is a nonempty string that is strictly lexicographically smaller than all its rotations.</p>
<p>Formally, <span class="math inline">\(w\)</span> is Lyndon if: <span class="math display">\[
\forall u, v \text{ such that } w = uv, v \ne \varepsilon: \quad w &lt; v u
\]</span></p>
<p>Examples:</p>
<ul>
<li><code>"a"</code>, <code>"ab"</code>, <code>"aab"</code>, <code>"abc"</code> are Lyndon</li>
<li><code>"aa"</code>, <code>"aba"</code>, <code>"ba"</code> are not</li>
</ul>
</section>
<section id="example-29" class="level4">
<h4 class="anchored" data-anchor-id="example-29">Example</h4>
<p>Let: <span class="math display">\[
S = \texttt{"banana"}
\]</span></p>
<p>Factorization:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Remaining</th>
<th>Factor</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>banana</td>
<td>b</td>
<td><code>"b"</code> &lt; <code>"anana"</code></td>
</tr>
<tr class="even">
<td>2</td>
<td>anana</td>
<td>a</td>
<td><code>"a"</code> &lt; <code>"nana"</code></td>
</tr>
<tr class="odd">
<td>3</td>
<td>nana</td>
<td>n</td>
<td><code>"n"</code> &lt; <code>"ana"</code></td>
</tr>
<tr class="even">
<td>4</td>
<td>ana</td>
<td>a</td>
<td><code>"a"</code> &lt; <code>"na"</code></td>
</tr>
<tr class="odd">
<td>5</td>
<td>na</td>
<td>n</td>
<td><code>"n"</code> &lt; <code>"a"</code></td>
</tr>
<tr class="even">
<td>6</td>
<td>a</td>
<td>a</td>
<td>end</td>
</tr>
<tr class="odd">
<td></td>
<td>Result</td>
<td>b a n a n a</td>
<td>nonincreasing sequence</td>
</tr>
</tbody>
</table>
<p>Each factor is a Lyndon word.</p>
</section>
<section id="how-it-works-plain-language-7" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-7">How It Works (Plain Language)</h4>
<p>The Duval algorithm constructs this factorization efficiently:</p>
<ol type="1">
<li>Start from the beginning of <span class="math inline">\(S\)</span> Let <code>i = 0</code></li>
<li>Find the smallest Lyndon word prefix starting at <code>i</code></li>
<li>Output that word as a factor Move <code>i</code> to the next position after the factor</li>
<li>Repeat until end of string</li>
</ol>
<p>This runs in linear time, <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="tiny-code-python-duval-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-duval-algorithm">Tiny Code (Python – Duval Algorithm)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lyndon_factorization(s):</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> n:</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> i</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&lt;</span> n <span class="kw">and</span> s[k] <span class="op">&lt;=</span> s[j]:</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[k] <span class="op">&lt;</span> s[j]:</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>                k <span class="op">=</span> i</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>                k <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&lt;=</span> k:</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>            result.append(s[i:i <span class="op">+</span> j <span class="op">-</span> k])</span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> j <span class="op">-</span> k</span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lyndon_factorization(<span class="st">"banana"</span>))  <span class="co"># ['b', 'a', 'n', 'a', 'n', 'a']</span></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lyndon_factorization(<span class="st">"aababc"</span>))  <span class="co"># ['a', 'ab', 'abc']</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-39" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-39">Why It Matters</h4>
<ul>
<li><p>Produces canonical decomposition of a string</p></li>
<li><p>Used in:</p>
<ul>
<li>Suffix array construction (via BWT)</li>
<li>Lexicographically minimal rotations</li>
<li>Combinatorial string analysis</li>
<li>Free Lie algebra basis generation</li>
<li>Cryptography and DNA periodicity</li>
</ul></li>
<li><p>Linear time and space efficiency make it practical in text indexing.</p></li>
</ul>
</section>
<section id="complexity-39" class="level4">
<h4 class="anchored" data-anchor-id="complexity-39">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Factorization (Duval)</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Verify Lyndon property</td>
<td><span class="math inline">\(O(    | w      | )\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-39" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-39">Try It Yourself</h4>
<ol type="1">
<li>Factorize <code>"aababc"</code> and verify each factor is Lyndon.</li>
<li>Find the smallest rotation of <code>"cabab"</code> using Lyndon properties.</li>
<li>Apply to <code>"zzzzyzzzzz"</code> and analyze pattern.</li>
<li>Generate all Lyndon words up to length 3 over <code>{a, b}</code>.</li>
<li>Compare Duval’s output with suffix array order.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-6" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-6">A Gentle Proof (Why It Works)</h4>
<p>Every string <span class="math inline">\(S\)</span> can be expressed as a nonincreasing sequence of Lyndon words — and this factorization is unique.</p>
<p>The proof uses:</p>
<ul>
<li>Lexicographic minimality (each factor is the smallest prefix possible)</li>
<li>Concatenation monotonicity (ensures order)</li>
<li>Induction on length <span class="math inline">\(n\)</span></li>
</ul>
<p>The Lyndon Factorization is the melody line of a string — every factor a self-contained phrase, each smaller echoing the rhythm of the one before.</p>
</section>
</section>
<section id="minimal-rotation-booths-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="minimal-rotation-booths-algorithm">640 Minimal Rotation (Booth’s Algorithm)</h3>
<p>The Minimal Rotation problem asks for the lexicographically smallest rotation of a string, the rotation that would come first in dictionary order. Booth’s Algorithm solves this in linear time, <span class="math inline">\(O(n)\)</span>, using clever modular comparisons without generating all rotations.</p>
<p>This problem ties together ideas from Lyndon words, suffix arrays, and cyclic string order, and is foundational in string normalization, hashing, and pattern equivalence.</p>
<section id="what-problem-are-we-solving-40" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-40">What Problem Are We Solving?</h4>
<p>Given a string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>, consider all its rotations:</p>
<p><span class="math display">\[
R_i = S[i..n-1] + S[0..i-1], \quad i = 0, 1, \ldots, n-1
\]</span></p>
<p>We want to find the index <span class="math inline">\(k\)</span> such that <span class="math inline">\(R_k\)</span> is lexicographically smallest.</p>
</section>
<section id="example-30" class="level4">
<h4 class="anchored" data-anchor-id="example-30">Example</h4>
<p>Let <span class="math display">\[
S = \texttt{"bbaaccaadd"}
\]</span></p>
<p>All rotations:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Shift</th>
<th style="text-align: left;">Rotation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: left;">bbaaccaadd</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: left;">baaccaaddb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: left;">aaccaaddbb</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: left;">accaaddbba</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: left;">ccaaddbb aa</td>
</tr>
<tr class="even">
<td style="text-align: center;">…</td>
<td style="text-align: left;">…</td>
</tr>
</tbody>
</table>
<p>The smallest rotation is <span class="math display">\[
R_2 = \texttt{"aaccaaddbb"}
\]</span></p>
<p>So rotation index = 2.</p>
</section>
<section id="the-naive-way" class="level4">
<h4 class="anchored" data-anchor-id="the-naive-way">The Naive Way</h4>
<p>Generate all rotations, then sort, <span class="math inline">\(O(n^2 \log n)\)</span> time and <span class="math inline">\(O(n^2)\)</span> space. Booth’s Algorithm achieves <span class="math inline">\(O(n)\)</span> time and <span class="math inline">\(O(1)\)</span> extra space by comparing characters cyclically with modular arithmetic.</p>
</section>
<section id="booths-algorithm-core-idea" class="level4">
<h4 class="anchored" data-anchor-id="booths-algorithm-core-idea">Booth’s Algorithm (Core Idea)</h4>
<ol type="1">
<li><p>Concatenate the string with itself: <span class="math display">\[
T = S + S
\]</span> Now every rotation of <span class="math inline">\(S\)</span> is a substring of <span class="math inline">\(T\)</span> of length <span class="math inline">\(n\)</span>.</p></li>
<li><p>Maintain a candidate index <code>k</code> for minimal rotation. For each position <code>i</code>, compare <code>T[k + j]</code> and <code>T[i + j]</code> character by character.</p></li>
<li><p>When a mismatch is found:</p>
<ul>
<li>If <code>T[k + j] &gt; T[i + j]</code>, the rotation at <code>i</code> is lexicographically smaller → update <code>k = i</code>.</li>
<li>Otherwise, skip ahead past the compared region.</li>
</ul></li>
<li><p>Continue until all rotations are checked.</p></li>
</ol>
<p>The algorithm cleverly ensures no redundant comparisons using arithmetic progressions.</p>
</section>
<section id="example-walkthrough-2" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-2">Example Walkthrough</h4>
<p>Let <span class="math display">\[
S = \texttt{"abab"} \quad (n = 4)
\]</span> <span class="math display">\[
T = \texttt{"abababab"}
\]</span></p>
<p>Start <code>k = 0</code>, compare rotations starting at 0 and 1:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Compare</th>
<th>Result</th>
<th>New k</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0 vs 1</td>
<td><code>a</code> vs <code>b</code></td>
<td><code>a &lt; b</code></td>
<td>keep 0</td>
</tr>
<tr class="even">
<td>0 vs 2</td>
<td>same prefix, next chars equal</td>
<td>skip</td>
<td></td>
</tr>
<tr class="odd">
<td>0 vs 3</td>
<td><code>a</code> vs <code>b</code></td>
<td>keep 0</td>
<td></td>
</tr>
</tbody>
</table>
<p>Smallest rotation starts at index 0 → <code>"abab"</code>.</p>
</section>
<section id="tiny-code-python-booths-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-booths-algorithm">Tiny Code (Python – Booth’s Algorithm)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimal_rotation(s):</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> s</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n  <span class="co"># failure function</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> f[j <span class="op">-</span> k <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">and</span> s[j] <span class="op">!=</span> s[k <span class="op">+</span> i <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[j] <span class="op">&lt;</span> s[k <span class="op">+</span> i <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>                k <span class="op">=</span> j <span class="op">-</span> i <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> f[i]</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[j] <span class="op">!=</span> s[k <span class="op">+</span> i <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[j] <span class="op">&lt;</span> s[k]:</span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>                k <span class="op">=</span> j</span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>            f[j <span class="op">-</span> k] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>            f[j <span class="op">-</span> k] <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> k <span class="op">%</span> (n <span class="op">//</span> <span class="dv">2</span>)</span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"bbaaccaadd"</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> minimal_rotation(s)</span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(idx, s[idx:] <span class="op">+</span> s[:idx])  <span class="co"># 2 aaccaaddbb</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-40" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-40">Why It Matters</h4>
<ul>
<li><p>Computes canonical form of cyclic strings</p></li>
<li><p>Detects rotational equivalence</p></li>
<li><p>Used in:</p>
<ul>
<li>String hashing</li>
<li>DNA cyclic pattern recognition</li>
<li>Lexicographic normalization</li>
<li>Circular suffix array construction</li>
</ul></li>
</ul>
<p>It’s a beautiful marriage of KMP’s prefix logic and Lyndon’s word theory.</p>
</section>
<section id="complexity-40" class="level4">
<h4 class="anchored" data-anchor-id="complexity-40">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Minimal rotation (Booth)</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verify rotation</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-40" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-40">Try It Yourself</h4>
<ol type="1">
<li><code>"bbaaccaadd"</code> → index 2, rotation <code>"aaccaaddbb"</code></li>
<li><code>"cabbage"</code> → index 1, rotation <code>"abbagec"</code></li>
<li><code>"aaaa"</code> → any rotation works</li>
<li><code>"dcba"</code> → index 3, rotation <code>"adcb"</code></li>
<li>Compare with brute-force rotation sorting to verify results.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-7" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-7">A Gentle Proof (Why It Works)</h4>
<p>Booth’s algorithm maintains a candidate <span class="math inline">\(k\)</span> such that no rotation before <span class="math inline">\(k\)</span> can be smaller. At each mismatch, skipping ensures we never reconsider rotations that share the same prefix pattern, similar to KMP’s prefix-function logic.</p>
<p>Thus, total comparisons <span class="math inline">\(\le 2n\)</span>, ensuring linear time.</p>
<p>The Minimal Rotation reveals the string’s lexicographic core — the rotation of purest order, found not by brute force, but by rhythm and reflection within the string itself.</p>
</section>
</section>
</section>
<section id="section-65.-edit-distance-and-alignment" class="level1">
<h1>Section 65. Edit Distance and Alignment</h1>
<section id="levenshtein-distance" class="level3">
<h3 class="anchored" data-anchor-id="levenshtein-distance">641 Levenshtein Distance</h3>
<p>The Levenshtein distance measures the <em>minimum number of edits</em> required to transform one string into another, where edits include insertions, deletions, and substitutions. It’s the foundational metric for string similarity, powering spell checkers, fuzzy search, DNA alignment, and chat autocorrect systems.</p>
<section id="what-problem-are-we-solving-41" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-41">What Problem Are We Solving?</h4>
<p>Given two strings:</p>
<p><span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_m
\]</span></p>
<p>we want the smallest number of single-character operations to make <span class="math inline">\(A\)</span> equal to <span class="math inline">\(B\)</span>:</p>
<ul>
<li>Insert one character</li>
<li>Delete one character</li>
<li>Replace one character</li>
</ul>
<p>The result is the edit distance <span class="math inline">\(D(n, m)\)</span>.</p>
</section>
<section id="example-31" class="level4">
<h4 class="anchored" data-anchor-id="example-31">Example</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>String A</th>
<th>String B</th>
<th>Edits</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"kitten"</code></td>
<td><code>"sitting"</code></td>
<td>k→s, +i, +g</td>
<td>3</td>
</tr>
<tr class="even">
<td><code>"flaw"</code></td>
<td><code>"lawn"</code></td>
<td>-f, +n</td>
<td>2</td>
</tr>
<tr class="odd">
<td><code>"intention"</code></td>
<td><code>"execution"</code></td>
<td>i→e, n→x, +u</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Each edit transforms <span class="math inline">\(A\)</span> step by step into <span class="math inline">\(B\)</span>.</p>
</section>
<section id="recurrence-relation-1" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relation-1">Recurrence Relation</h4>
<p>Let <span class="math inline">\(D[i][j]\)</span> = minimal edits to transform <span class="math inline">\(A[0..i-1]\)</span> → <span class="math inline">\(B[0..j-1]\)</span></p>
<p>Then:</p>
<p><span class="math display">\[
D[i][j] =
\begin{cases}
0, &amp; \text{if } i = 0,\, j = 0,\\
j, &amp; \text{if } i = 0,\\
i, &amp; \text{if } j = 0,\\[6pt]
\min
\begin{cases}
D[i-1][j] + 1, &amp; \text{(deletion)}\\
D[i][j-1] + 1, &amp; \text{(insertion)}\\
D[i-1][j-1] + (a_i \ne b_j), &amp; \text{(substitution)}
\end{cases}, &amp; \text{otherwise.}
\end{cases}
\]</span></p>
</section>
<section id="how-it-works-plain-language-8" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-8">How It Works (Plain Language)</h4>
<p>You build a grid comparing every prefix of <code>A</code> to every prefix of <code>B</code>. Each cell <span class="math inline">\(D[i][j]\)</span> represents the minimal edits so far. By choosing the minimum among insertion, deletion, or substitution, you “grow” the solution from the simplest cases.</p>
</section>
<section id="example-table" class="level4">
<h4 class="anchored" data-anchor-id="example-table">Example Table</h4>
<p>Compute <code>D("kitten", "sitting")</code>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>“”</th>
<th>s</th>
<th>i</th>
<th>t</th>
<th>t</th>
<th>i</th>
<th>n</th>
<th>g</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“”</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr class="even">
<td>k</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr class="odd">
<td>i</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr class="even">
<td>t</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="odd">
<td>t</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="even">
<td>e</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="odd">
<td>n</td>
<td>6</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Ok Levenshtein distance = 3</p>
</section>
<section id="tiny-code-python-12" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-12">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> levenshtein(a, b):</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># deletion</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>                dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># insertion</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> cost  <span class="co"># substitution</span></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][m]</span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(levenshtein(<span class="st">"kitten"</span>, <span class="st">"sitting"</span>))  <span class="co"># 3</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="space-optimized-version" class="level4">
<h4 class="anchored" data-anchor-id="space-optimized-version">Space-Optimized Version</h4>
<p>We only need the previous row:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> levenshtein_optimized(a, b):</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(b) <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ca <span class="kw">in</span> <span class="bu">enumerate</span>(a, <span class="dv">1</span>):</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>        curr <span class="op">=</span> [i]</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j, cb <span class="kw">in</span> <span class="bu">enumerate</span>(b, <span class="dv">1</span>):</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> ca <span class="op">==</span> cb <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>            curr.append(<span class="bu">min</span>(</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>                prev[j] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>                curr[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>                prev[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> cost</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>            ))</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> curr</span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-41" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-41">Why It Matters</h4>
<ul>
<li><p>Fundamental similarity metric in text processing</p></li>
<li><p>Used in:</p>
<ul>
<li>Spell correction (<code>levenstein("color", "colour")</code>)</li>
<li>DNA sequence alignment</li>
<li>Approximate search</li>
<li>Chat autocorrect / fuzzy matching</li>
</ul></li>
<li><p>Provides interpretable results: every edit has meaning</p></li>
</ul>
</section>
<section id="complexity-41" class="level4">
<h4 class="anchored" data-anchor-id="complexity-41">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DP (full table)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
</tr>
<tr class="even">
<td>DP (optimized)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(\min(n, m))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-41" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-41">Try It Yourself</h4>
<ol type="1">
<li><code>"flaw"</code> vs <code>"lawn"</code> → distance = 2</li>
<li><code>"intention"</code> vs <code>"execution"</code> → 5</li>
<li><code>"abc"</code> vs <code>"yabd"</code> → 2</li>
<li>Compute edit path by backtracking the DP table.</li>
<li>Compare runtime between full DP and optimized version.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-8" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-8">A Gentle Proof (Why It Works)</h4>
<p>The recurrence ensures optimal substructure:</p>
<ul>
<li>The minimal edit for prefixes extends naturally to longer prefixes. Each step considers all possible last operations, taking the smallest. Dynamic programming guarantees global optimality.</li>
</ul>
<p>The Levenshtein distance is the true language of transformation — each insertion a birth, each deletion a loss, and each substitution a change of meaning that measures how far two words drift apart.</p>
</section>
</section>
<section id="dameraulevenshtein-distance" class="level3">
<h3 class="anchored" data-anchor-id="dameraulevenshtein-distance">642 Damerau–Levenshtein Distance</h3>
<p>The Damerau–Levenshtein distance extends the classic Levenshtein metric by recognizing that humans (and computers) often make a common fourth kind of typo, transposition, swapping two adjacent characters. This extension captures a more realistic notion of “edit distance” in natural text, such as typing “hte” instead of “the”.</p>
<section id="what-problem-are-we-solving-42" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-42">What Problem Are We Solving?</h4>
<p>We want the minimum number of operations to transform one string <span class="math inline">\(A\)</span> into another string <span class="math inline">\(B\)</span>, using:</p>
<ol type="1">
<li>Insertion – add a character</li>
<li>Deletion – remove a character</li>
<li>Substitution – replace a character</li>
<li>Transposition – swap two adjacent characters</li>
</ol>
<p>Formally, find <span class="math inline">\(D(n, m)\)</span>, the minimal edit distance with these four operations.</p>
</section>
<section id="example-32" class="level4">
<h4 class="anchored" data-anchor-id="example-32">Example</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>String A</th>
<th>String B</th>
<th>Edits</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"ca"</code></td>
<td><code>"ac"</code></td>
<td>transpose c↔︎a</td>
<td>1</td>
</tr>
<tr class="even">
<td><code>"abcd"</code></td>
<td><code>"acbd"</code></td>
<td>transpose b↔︎c</td>
<td>1</td>
</tr>
<tr class="odd">
<td><code>"abcf"</code></td>
<td><code>"acfb"</code></td>
<td>substitution c→f, transpose f↔︎b</td>
<td>2</td>
</tr>
<tr class="even">
<td><code>"hte"</code></td>
<td><code>"the"</code></td>
<td>transpose h↔︎t</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>This distance better models real-world typos and biological swaps.</p>
</section>
<section id="recurrence-relation-2" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relation-2">Recurrence Relation</h4>
<p>Let <span class="math inline">\(D[i][j]\)</span> be the Damerau–Levenshtein distance between <span class="math inline">\(A[0..i-1]\)</span> and <span class="math inline">\(B[0..j-1]\)</span>.</p>
<p><span class="math display">\[
D[i][j] =
\begin{cases}
\max(i, j), &amp; \text{if } \min(i, j) = 0,\\[6pt]
\min
\begin{cases}
D[i-1][j] + 1, &amp; \text{(deletion)}\\
D[i][j-1] + 1, &amp; \text{(insertion)}\\
D[i-1][j-1] + (a_i \ne b_j), &amp; \text{(substitution)}\\
D[i-2][j-2] + 1, &amp; \text{if } i,j &gt; 1,\, a_i=b_{j-1},\, a_{i-1}=b_j \text{ (transposition)}
\end{cases}
\end{cases}
\]</span></p>
</section>
<section id="how-it-works-plain-language-9" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-9">How It Works (Plain Language)</h4>
<p>We fill a dynamic programming table just like Levenshtein distance, but we add an extra check for the transposition case — when two characters are swapped, e.g.&nbsp;<code>a_i == b_{j-1}</code> and <code>a_{i-1} == b_j</code>. In that case, we can “jump diagonally two steps” with a cost of one.</p>
</section>
<section id="example-33" class="level4">
<h4 class="anchored" data-anchor-id="example-33">Example</h4>
<p>Compute distance between <code>"ca"</code> and <code>"ac"</code>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>“”</th>
<th>a</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“”</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>c</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>a</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>The transposition (<code>c↔︎a</code>) allows <code>D[2][2] = 1</code>. Ok Damerau–Levenshtein distance = 1.</p>
</section>
<section id="tiny-code-python-13" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-13">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> damerau_levenshtein(a, b):</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># deletion</span></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>                dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># insertion</span></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> cost  <span class="co"># substitution</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>            <span class="co"># transposition</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">1</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">1</span> <span class="kw">and</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">2</span>] <span class="kw">and</span> a[i <span class="op">-</span> <span class="dv">2</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i][j], dp[i <span class="op">-</span> <span class="dv">2</span>][j <span class="op">-</span> <span class="dv">2</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][m]</span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(damerau_levenshtein(<span class="st">"ca"</span>, <span class="st">"ac"</span>))  <span class="co"># 1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-42" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-42">Why It Matters</h4>
<ul>
<li><p>Models human typing errors (swapped letters, e.g.&nbsp;“teh”, “hte”)</p></li>
<li><p>Used in:</p>
<ul>
<li>Spell checkers</li>
<li>Fuzzy search engines</li>
<li>Optical character recognition (OCR)</li>
<li>Speech-to-text correction</li>
<li>Genetic sequence analysis (for local transpositions)</li>
</ul></li>
</ul>
<p>Adding the transposition operation brings the model closer to natural data noise.</p>
</section>
<section id="complexity-42" class="level4">
<h4 class="anchored" data-anchor-id="complexity-42">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DP (full table)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
</tr>
<tr class="even">
<td>Optimized (rolling rows)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(\min(n, m))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-42" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-42">Try It Yourself</h4>
<ol type="1">
<li><code>"ab"</code> → <code>"ba"</code> → 1 (swap)</li>
<li><code>"abcdef"</code> → <code>"abdcef"</code> → 1 (transpose d↔︎c)</li>
<li><code>"sponge"</code> → <code>"spnoge"</code> → 1</li>
<li>Compare <code>"hte"</code> vs <code>"the"</code> → 1</li>
<li>Compare with Levenshtein distance to see when transpositions matter.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-9" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-9">A Gentle Proof (Why It Works)</h4>
<p>The transposition case extends the dynamic program by considering a 2-step diagonal, ensuring optimal substructure still holds. Each path through the DP grid corresponds to a sequence of edits; adding transpositions does not break optimality because we still choose the minimal-cost local transition.</p>
<p>The Damerau–Levenshtein distance refines our sense of textual closeness — it doesn’t just see missing or wrong letters, it <em>understands when your fingers danced out of order.</em></p>
</section>
</section>
<section id="hamming-distance" class="level3">
<h3 class="anchored" data-anchor-id="hamming-distance">643 Hamming Distance</h3>
<p>The Hamming distance measures how many positions differ between two strings of equal length. It’s the simplest and most direct measure of dissimilarity between binary codes, DNA sequences, or fixed-length text fragments, a perfect tool for detecting errors, mutations, or noise in transmission.</p>
<section id="what-problem-are-we-solving-43" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-43">What Problem Are We Solving?</h4>
<p>Given two strings <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> of equal length <span class="math inline">\(n\)</span>:</p>
<p><span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_n
\]</span></p>
<p>the Hamming distance is the number of positions <span class="math inline">\(i\)</span> where <span class="math inline">\(a_i \ne b_i\)</span>:</p>
<p><span class="math display">\[
H(A, B) = \sum_{i=1}^{n} [a_i \ne b_i]
\]</span></p>
<p>It tells us <em>how many substitutions</em> would be needed to make them identical (no insertions or deletions allowed).</p>
</section>
<section id="example-34" class="level4">
<h4 class="anchored" data-anchor-id="example-34">Example</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>Differences</th>
<th>Hamming Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1011101</td>
<td>1001001</td>
<td>2 bits differ</td>
<td>2</td>
</tr>
<tr class="even">
<td>karolin</td>
<td>kathrin</td>
<td>3 letters differ</td>
<td>3</td>
</tr>
<tr class="odd">
<td>2173896</td>
<td>2233796</td>
<td>3 digits differ</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Only substitutions are counted, so both strings must be the same length.</p>
</section>
<section id="how-it-works-plain-language-10" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-10">How It Works (Plain Language)</h4>
<p>Just walk through both strings together, character by character, and count how many positions don’t match. That’s the Hamming distance, nothing more, nothing less.</p>
</section>
<section id="tiny-code-python-14" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-14">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hamming_distance(a, b):</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(a) <span class="op">!=</span> <span class="bu">len</span>(b):</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Strings must be of equal length"</span>)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(c1 <span class="op">!=</span> c2 <span class="cf">for</span> c1, c2 <span class="kw">in</span> <span class="bu">zip</span>(a, b))</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(hamming_distance(<span class="st">"karolin"</span>, <span class="st">"kathrin"</span>))  <span class="co"># 3</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(hamming_distance(<span class="st">"1011101"</span>, <span class="st">"1001001"</span>))  <span class="co"># 2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="bitwise-version-for-binary-strings" class="level4">
<h4 class="anchored" data-anchor-id="bitwise-version-for-binary-strings">Bitwise Version (for Binary Strings)</h4>
<p>If <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are integers, use XOR to find differing bits:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hamming_bits(x, y):</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">bin</span>(x <span class="op">^</span> y).count(<span class="st">"1"</span>)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(hamming_bits(<span class="bn">0b1011101</span>, <span class="bn">0b1001001</span>))  <span class="co"># 2</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Because XOR highlights exactly the differing bits.</p>
</section>
<section id="why-it-matters-43" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-43">Why It Matters</h4>
<ul>
<li>Error detection – measures how many bits flipped in transmission</li>
<li>Genetics – counts nucleotide mutations</li>
<li>Hashing &amp; ML – quantifies similarity between binary fingerprints</li>
<li>Cryptography – evaluates diffusion (bit changes under encryption)</li>
</ul>
<p>It’s one of the cornerstones of information theory, introduced by Richard Hamming in 1950.</p>
</section>
<section id="complexity-43" class="level4">
<h4 class="anchored" data-anchor-id="complexity-43">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Direct comparison</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Bitwise XOR</td>
<td><span class="math inline">\(O(1)\)</span> per machine word</td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-43" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-43">Try It Yourself</h4>
<ol type="1">
<li>Compare <code>"1010101"</code> vs <code>"1110001"</code> → 4</li>
<li>Compute <span class="math inline">\(H(0b1111, 0b1001)\)</span> → 2</li>
<li>Count mutations between <code>"AACCGGTT"</code> and <code>"AAACGGTA"</code> → 2</li>
<li>Implement Hamming similarity = <span class="math inline">\(1 - \frac{H(A,B)}{n}\)</span></li>
<li>Use it in a binary nearest-neighbor search.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-10" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-10">A Gentle Proof (Why It Works)</h4>
<p>Each mismatch contributes +1 to the total count, and since the operation is independent per position, the sum directly measures substitution count — a simple metric that satisfies all distance axioms: non-negativity, symmetry, and triangle inequality.</p>
<p>The Hamming distance is minimalism in motion — a ruler that measures difference one symbol at a time, from codewords to chromosomes.</p>
</section>
</section>
<section id="needlemanwunsch-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="needlemanwunsch-algorithm">644 Needleman–Wunsch Algorithm</h3>
<p>The Needleman–Wunsch algorithm is the classic dynamic programming method for global sequence alignment. It finds the <em>optimal way</em> to align two full sequences, character by character, by allowing insertions, deletions, and substitutions with given scores.</p>
<p>This algorithm forms the backbone of computational biology, comparing genes, proteins, or any sequences where <em>every part matters</em>.</p>
<section id="what-problem-are-we-solving-44" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-44">What Problem Are We Solving?</h4>
<p>Given two sequences:</p>
<p><span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_m
\]</span></p>
<p>we want to find the best alignment (possibly with gaps) that maximizes a similarity score.</p>
<p>We define scoring parameters:</p>
<ul>
<li>match reward = <span class="math inline">\(+M\)</span></li>
<li>mismatch penalty = <span class="math inline">\(-S\)</span></li>
<li>gap penalty = <span class="math inline">\(-G\)</span></li>
</ul>
<p>The goal is to find an alignment with maximum total score.</p>
</section>
<section id="example-35" class="level4">
<h4 class="anchored" data-anchor-id="example-35">Example</h4>
<p>Align <code>"GATTACA"</code> and <code>"GCATGCU"</code>:</p>
<p>One possible alignment:</p>
<pre><code>G A T T A C A
| |   |   | |
G C A T G C U</code></pre>
<p>The algorithm will explore all possibilities and return the <em>best</em> alignment by total score.</p>
</section>
<section id="recurrence-relation-3" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relation-3">Recurrence Relation</h4>
<p>Let <span class="math inline">\(D[i][j]\)</span> = best score for aligning <span class="math inline">\(A[0..i-1]\)</span> with <span class="math inline">\(B[0..j-1]\)</span>.</p>
<p>Base cases:</p>
<p><span class="math display">\[
D[0][0] = 0, \quad
D[i][0] = -iG, \quad
D[0][j] = -jG
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
D[i][j] = \max
\begin{cases}
D[i-1][j-1] + \text{score}(a_i, b_j), &amp; \text{(match/mismatch)}\\
D[i-1][j] - G, &amp; \text{(gap in B)}\\
D[i][j-1] - G, &amp; \text{(gap in A)}
\end{cases}
\]</span></p>
<p>where:</p>
<p><span class="math display">\[
\text{score}(a_i, b_j) =
\begin{cases}
+M, &amp; \text{if } a_i = b_j,\\
-S, &amp; \text{if } a_i \ne b_j.
\end{cases}
\]</span></p>
</section>
<section id="how-it-works-plain-language-11" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-11">How It Works (Plain Language)</h4>
<ol type="1">
<li>Build a scoring matrix of size <span class="math inline">\((n+1) \times (m+1)\)</span>.</li>
<li>Initialize first row and column with cumulative gap penalties.</li>
<li>Fill each cell using the recurrence rule, each step considers match, delete, or insert.</li>
<li>Backtrack from bottom-right to recover the best alignment path.</li>
</ol>
</section>
<section id="example-table-1" class="level4">
<h4 class="anchored" data-anchor-id="example-table-1">Example Table</h4>
<p>For small sequences:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>“”</th>
<th>G</th>
<th>C</th>
<th>A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“”</td>
<td>0</td>
<td>-2</td>
<td>-4</td>
<td>-6</td>
</tr>
<tr class="even">
<td>G</td>
<td>-2</td>
<td>1</td>
<td>-1</td>
<td>-3</td>
</tr>
<tr class="odd">
<td>A</td>
<td>-4</td>
<td>-1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>C</td>
<td>-6</td>
<td>-3</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Final score = 1 → best global alignment found by backtracking.</p>
</section>
<section id="tiny-code-python-15" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-15">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> needleman_wunsch(a, b, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># initialize</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i <span class="op">*</span> gap</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j <span class="op">*</span> gap</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fill matrix</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> match <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> score,</span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>                dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][m]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-44" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-44">Why It Matters</h4>
<ul>
<li><p>Foundational in bioinformatics for DNA/protein alignment</p></li>
<li><p>Used in:</p>
<ul>
<li>Comparing genetic sequences</li>
<li>Plagiarism and text similarity detection</li>
<li>Speech and time-series matching</li>
</ul></li>
</ul>
<p>Needleman–Wunsch guarantees the optimal global alignment, unlike Smith–Waterman, which is local.</p>
</section>
<section id="complexity-44" class="level4">
<h4 class="anchored" data-anchor-id="complexity-44">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Fill DP table</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
</tr>
<tr class="even">
<td>Backtracking</td>
<td><span class="math inline">\(O(n+m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Memory can be optimized to <span class="math inline">\(O(\min(n,m))\)</span> if only the score is needed.</p>
</section>
<section id="try-it-yourself-44" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-44">Try It Yourself</h4>
<ol type="1">
<li>Align <code>"GATTACA"</code> and <code>"GCATGCU"</code>.</li>
<li>Change gap penalty and observe how alignments shift.</li>
<li>Modify scoring for mismatches → softer penalties give longer alignments.</li>
<li>Compare with Smith–Waterman to see the local-global difference.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-11" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-11">A Gentle Proof (Why It Works)</h4>
<p>The DP structure ensures optimal substructure — the best alignment of prefixes builds from smaller optimal alignments. By evaluating match, insert, and delete at each step, the algorithm always retains the globally best alignment path.</p>
<p>The Needleman–Wunsch algorithm is the archetype of alignment — balancing matches and gaps, it teaches sequences how to meet halfway.</p>
</section>
</section>
<section id="smithwaterman-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="smithwaterman-algorithm">645 Smith–Waterman Algorithm</h3>
<p>The Smith–Waterman algorithm is the dynamic programming method for local sequence alignment, finding the <em>most similar subsequences</em> between two sequences. Unlike Needleman–Wunsch, which aligns the <em>entire</em> sequences, Smith–Waterman focuses only on the best matching region, where true biological or textual similarity lies.</p>
<section id="what-problem-are-we-solving-45" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-45">What Problem Are We Solving?</h4>
<p>Given two sequences:</p>
<p><span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_m
\]</span></p>
<p>find the pair of substrings <span class="math inline">\((A[i_1..i_2], B[j_1..j_2])\)</span> that maximizes the local alignment score, allowing gaps and mismatches.</p>
</section>
<section id="scoring-scheme" class="level4">
<h4 class="anchored" data-anchor-id="scoring-scheme">Scoring Scheme</h4>
<p>Define scoring parameters:</p>
<ul>
<li>match reward = <span class="math inline">\(+M\)</span></li>
<li>mismatch penalty = <span class="math inline">\(-S\)</span></li>
<li>gap penalty = <span class="math inline">\(-G\)</span></li>
</ul>
<p>The goal is to find:</p>
<p><span class="math display">\[
\max_{i,j} D[i][j]
\]</span></p>
<p>where <span class="math inline">\(D[i][j]\)</span> represents the best local alignment ending at <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_j\)</span>.</p>
</section>
<section id="recurrence-relation-4" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relation-4">Recurrence Relation</h4>
<p>Base cases:</p>
<p><span class="math display">\[
D[0][j] = D[i][0] = 0
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
D[i][j] = \max
\begin{cases}
0, &amp; \text{(start new alignment)}\\
D[i-1][j-1] + \text{score}(a_i, b_j), &amp; \text{(match/mismatch)}\\
D[i-1][j] - G, &amp; \text{(gap in B)}\\
D[i][j-1] - G, &amp; \text{(gap in A)}
\end{cases}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\text{score}(a_i, b_j) =
\begin{cases}
+M, &amp; \text{if } a_i = b_j,\\
-S, &amp; \text{if } a_i \ne b_j.
\end{cases}
\]</span></p>
<p>The 0 resets alignment when the score drops below zero — ensuring we only keep high-similarity regions.</p>
</section>
<section id="example-36" class="level4">
<h4 class="anchored" data-anchor-id="example-36">Example</h4>
<p>Align <code>"ACACACTA"</code> and <code>"AGCACACA"</code>.</p>
<p>Smith–Waterman detects the strongest overlap:</p>
<pre><code>A C A C A C T A
| | | | |
A G C A C A C A</code></pre>
<p>Best local alignment: <code>"ACACA"</code> Ok Local alignment score = 10 (for match = +2, mismatch = -1, gap = -2)</p>
</section>
<section id="how-it-works-plain-language-12" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-12">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Build a DP matrix, starting with zeros.</p></li>
<li><p>For each pair of positions <span class="math inline">\((i, j)\)</span>:</p>
<ul>
<li>Compute best local score ending at <span class="math inline">\((i, j)\)</span>.</li>
<li>Reset to zero if alignment becomes negative.</li>
</ul></li>
<li><p>Track the maximum score in the matrix.</p></li>
<li><p>Backtrack from that cell to reconstruct the highest-scoring local subsequence.</p></li>
</ol>
</section>
<section id="tiny-code-python-16" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-16">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> smith_waterman(a, b, match<span class="op">=</span><span class="dv">2</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    max_score <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> match <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> score,</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>                dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>            max_score <span class="op">=</span> <span class="bu">max</span>(max_score, dp[i][j])</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_score</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-45" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-45">Why It Matters</h4>
<ul>
<li><p>Models biological similarity, detects conserved regions, not entire genome alignment</p></li>
<li><p>Used in:</p>
<ul>
<li>Bioinformatics (protein/DNA local alignment)</li>
<li>Text similarity and plagiarism detection</li>
<li>Pattern matching with noise</li>
<li>Fuzzy substring matching</li>
</ul></li>
</ul>
<p>Smith–Waterman ensures that only the <em>best-matching portion</em> contributes to the score, avoiding penalties from unrelated prefixes/suffixes.</p>
</section>
<section id="complexity-45" class="level4">
<h4 class="anchored" data-anchor-id="complexity-45">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DP (full table)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
</tr>
<tr class="even">
<td>Space optimized</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(\min(n,m))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-45" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-45">Try It Yourself</h4>
<ol type="1">
<li><code>"GATTACA"</code> vs <code>"GCATGCU"</code> → local alignment <code>"ATG"</code></li>
<li><code>"ACACACTA"</code> vs <code>"AGCACACA"</code> → <code>"ACACA"</code></li>
<li>Change gap penalty from 2 to 5 → how does alignment shrink?</li>
<li>Compare global vs local alignment outputs (Needleman–Wunsch vs Smith–Waterman).</li>
<li>Apply to <code>"hello"</code> vs <code>"yellow"</code> → find shared region.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-12" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-12">A Gentle Proof (Why It Works)</h4>
<p>The inclusion of 0 in the recurrence ensures optimal local behavior: whenever the running score becomes negative, we restart alignment. Dynamic programming guarantees that all possible substrings are considered, and the global maximum corresponds to the strongest local match.</p>
<p>The Smith–Waterman algorithm listens for echoes in the noise — finding the brightest overlap between two long melodies, and telling you where they truly harmonize.</p>
</section>
</section>
<section id="hirschbergs-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="hirschbergs-algorithm">646 Hirschberg’s Algorithm</h3>
<p>The Hirschberg algorithm is a clever optimization of the Needleman–Wunsch alignment. It produces the same global alignment, but using only linear space, <span class="math inline">\(O(n + m)\)</span>, instead of <span class="math inline">\(O(nm)\)</span>. This makes it ideal for aligning long DNA or text sequences where memory is tight.</p>
<section id="what-problem-are-we-solving-46" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-46">What Problem Are We Solving?</h4>
<p>We want to compute a global sequence alignment (like Needleman–Wunsch) between:</p>
<p><span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_m
\]</span></p>
<p>but we want to do so using linear space, not quadratic. The trick is to compute only the scores needed to reconstruct the optimal path, not the full DP table.</p>
</section>
<section id="the-key-insight" class="level4">
<h4 class="anchored" data-anchor-id="the-key-insight">The Key Insight</h4>
<p>The classic Needleman–Wunsch algorithm fills an <span class="math inline">\(n \times m\)</span> DP matrix to find an optimal alignment path.</p>
<p>But:</p>
<ul>
<li>We only need half of the table at any time to compute scores.</li>
<li>The middle column of the DP table divides the problem into two independent halves.</li>
</ul>
<p>By combining these two facts, Hirschberg finds the split point of the alignment recursively.</p>
</section>
<section id="algorithm-outline" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-outline">Algorithm Outline</h4>
<ol type="1">
<li><p>Base case:</p>
<ul>
<li>If either string is empty → return a sequence of gaps.</li>
<li>If either string has length 1 → do a simple alignment directly.</li>
</ul></li>
<li><p>Divide:</p>
<ul>
<li>Split <span class="math inline">\(A\)</span> in half: <span class="math inline">\(A = A_{\text{left}} + A_{\text{right}}\)</span>.</li>
<li>Compute forward alignment scores of <span class="math inline">\(A_{\text{left}}\)</span> with <span class="math inline">\(B\)</span>.</li>
<li>Compute backward alignment scores of <span class="math inline">\(A_{\text{right}}\)</span> with <span class="math inline">\(B\)</span> (reversed).</li>
<li>Add corresponding scores to find the best split point in <span class="math inline">\(B\)</span>.</li>
</ul></li>
<li><p>Recurse:</p>
<ul>
<li>Align the two halves <span class="math inline">\((A_{\text{left}}, B_{\text{left}})\)</span> and <span class="math inline">\((A_{\text{right}}, B_{\text{right}})\)</span> recursively.</li>
</ul></li>
<li><p>Combine:</p>
<ul>
<li>Merge the two sub-alignments into a full global alignment.</li>
</ul></li>
</ol>
</section>
<section id="recurrence-relation-5" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relation-5">Recurrence Relation</h4>
<p>We use the Needleman–Wunsch scoring recurrence:</p>
<p><span class="math display">\[
D[i][j] = \max
\begin{cases}
D[i-1][j-1] + s(a_i, b_j), &amp; \text{match/mismatch},\\
D[i-1][j] - G, &amp; \text{gap in B},\\
D[i][j-1] - G, &amp; \text{gap in A}.
\end{cases}
\]</span></p>
<p>But only the <em>previous row</em> is kept in memory for each half, and we find the optimal middle column split by combining forward and backward scores.</p>
</section>
<section id="example-37" class="level4">
<h4 class="anchored" data-anchor-id="example-37">Example</h4>
<p>Align <code>"AGTACGCA"</code> and <code>"TATGC"</code>.</p>
<ul>
<li>Split <code>"AGTACGCA"</code> into <code>"AGTA"</code> and <code>"CGCA"</code>.</li>
<li>Compute forward DP for <code>"AGTA"</code> vs <code>"TATGC"</code>.</li>
<li>Compute backward DP for <code>"CGCA"</code> vs <code>"TATGC"</code>.</li>
<li>Combine scores to find the best split in <code>"TATGC"</code>.</li>
<li>Recurse on two smaller alignments, merge results.</li>
</ul>
<p>Final alignment matches the same as Needleman–Wunsch, but with dramatically lower space cost.</p>
</section>
<section id="tiny-code-python-simplified" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-simplified">Tiny Code (Python – simplified)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hirschberg(a, b, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(a) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="st">"-"</span> <span class="op">*</span> <span class="bu">len</span>(b), b)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(b) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (a, <span class="st">"-"</span> <span class="op">*</span> <span class="bu">len</span>(a))</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(a) <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> <span class="bu">len</span>(b) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># base case: simple Needleman-Wunsch</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> needleman_wunsch_align(a, b, match, mismatch, gap)</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(a) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>    scoreL <span class="op">=</span> nw_score(a[:mid], b, match, mismatch, gap)</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>    scoreR <span class="op">=</span> nw_score(a[mid:][::<span class="op">-</span><span class="dv">1</span>], b[::<span class="op">-</span><span class="dv">1</span>], match, mismatch, gap)</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    j_split <span class="op">=</span> <span class="bu">max</span>(<span class="bu">range</span>(<span class="bu">len</span>(b) <span class="op">+</span> <span class="dv">1</span>), key<span class="op">=</span><span class="kw">lambda</span> j: scoreL[j] <span class="op">+</span> scoreR[<span class="bu">len</span>(b) <span class="op">-</span> j])</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> hirschberg(a[:mid], b[:j_split], match, mismatch, gap)</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> hirschberg(a[mid:], b[j_split:], match, mismatch, gap)</span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (left[<span class="dv">0</span>] <span class="op">+</span> right[<span class="dv">0</span>], left[<span class="dv">1</span>] <span class="op">+</span> right[<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>(Helper <code>nw_score</code> computes Needleman–Wunsch row scores for one direction.)</em></p>
</section>
<section id="why-it-matters-46" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-46">Why It Matters</h4>
<ul>
<li><p>Uses linear memory with optimal alignment quality.</p></li>
<li><p>Ideal for:</p>
<ul>
<li>Genome sequence alignment</li>
<li>Massive document comparisons</li>
<li>Low-memory environments</li>
</ul></li>
<li><p>Preserves Needleman–Wunsch correctness, improving practicality for big data.</p></li>
</ul>
</section>
<section id="complexity-46" class="level4">
<h4 class="anchored" data-anchor-id="complexity-46">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alignment</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(n + m)\)</span></td>
</tr>
</tbody>
</table>
<p>The recursive splitting introduces small overhead but no asymptotic penalty.</p>
</section>
<section id="try-it-yourself-46" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-46">Try It Yourself</h4>
<ol type="1">
<li>Align <code>"GATTACA"</code> with <code>"GCATGCU"</code> using both Needleman–Wunsch and Hirschberg, confirm identical output.</li>
<li>Test with sequences of 10,000+ length, watch the memory savings.</li>
<li>Experiment with different gap penalties to see how the split point changes.</li>
<li>Visualize the recursion tree, it divides neatly down the middle.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-13" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-13">A Gentle Proof (Why It Works)</h4>
<p>Each middle column score pair <span class="math inline">\((L[j], R[m - j])\)</span> represents the best possible alignment that passes through cell <span class="math inline">\((\text{mid}, j)\)</span>. By choosing the <span class="math inline">\(j\)</span> that maximizes <span class="math inline">\(L[j] + R[m - j]\)</span>, we ensure the globally optimal alignment crosses that point. This preserves optimal substructure, guaranteeing correctness.</p>
<p>The Hirschberg algorithm is elegance by reduction — it remembers only what’s essential, aligning vast sequences with the grace of a minimalist mathematician.</p>
</section>
</section>
<section id="edit-script-reconstruction" class="level3">
<h3 class="anchored" data-anchor-id="edit-script-reconstruction">647 Edit Script Reconstruction</h3>
<p>Once we compute the edit distance between two strings, we often want more than just the number, we want to know <em>how</em> to transform one into the other. That transformation plan is called an edit script: the ordered sequence of operations (insert, delete, substitute) that converts string A into string B optimally.</p>
<section id="what-problem-are-we-solving-47" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-47">What Problem Are We Solving?</h4>
<p>Given two strings:</p>
<p><span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_m
\]</span></p>
<p>and their minimal edit distance <span class="math inline">\(D[n][m]\)</span>, we want to reconstruct the series of edit operations that achieves that minimal cost.</p>
<p>Operations:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: left;">Operation</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>M</code></td>
<td style="text-align: left;">Match</td>
<td style="text-align: left;"><span class="math inline">\(a_i = b_j\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>S</code></td>
<td style="text-align: left;">Substitute</td>
<td style="text-align: left;">replace <span class="math inline">\(a_i\)</span> with <span class="math inline">\(b_j\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>I</code></td>
<td style="text-align: left;">Insert</td>
<td style="text-align: left;">add <span class="math inline">\(b_j\)</span> into <span class="math inline">\(A\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>D</code></td>
<td style="text-align: left;">Delete</td>
<td style="text-align: left;">remove <span class="math inline">\(a_i\)</span> from <span class="math inline">\(A\)</span></td>
</tr>
</tbody>
</table>
<p>The output is a human-readable edit trace like:</p>
<pre><code>M M S I M D</code></pre>
</section>
<section id="example-38" class="level4">
<h4 class="anchored" data-anchor-id="example-38">Example</h4>
<p>Transform <code>"kitten"</code> → <code>"sitting"</code>.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Step</th>
<th style="text-align: left;">Operation</th>
<th style="text-align: left;">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: left;">Substitute <code>k → s</code></td>
<td style="text-align: left;">“sitten”</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: left;">Insert <code>i</code></td>
<td style="text-align: left;">“sittien”</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: left;">Insert <code>g</code></td>
<td style="text-align: left;">“sitting”</td>
</tr>
</tbody>
</table>
<p>Ok Edit distance = 3 Ok Edit script = <code>S, I, I</code></p>
</section>
<section id="how-it-works-plain-language-13" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-13">How It Works (Plain Language)</h4>
<ol type="1">
<li><p>Compute the full Levenshtein DP table <span class="math inline">\(D[i][j]\)</span>.</p></li>
<li><p>Start from bottom-right <span class="math inline">\((n, m)\)</span>.</p></li>
<li><p>Move backward:</p>
<ul>
<li>If characters match → <code>M</code> (diagonal move)</li>
<li>Else if <span class="math inline">\(D[i][j] = D[i-1][j-1] + 1\)</span> → <code>S</code></li>
<li>Else if <span class="math inline">\(D[i][j] = D[i-1][j] + 1\)</span> → <code>D</code></li>
<li>Else if <span class="math inline">\(D[i][j] = D[i][j-1] + 1\)</span> → <code>I</code></li>
</ul></li>
<li><p>Record the operation and move accordingly.</p></li>
<li><p>Reverse the list at the end.</p></li>
</ol>
</section>
<section id="example-table-simplified" class="level4">
<h4 class="anchored" data-anchor-id="example-table-simplified">Example Table (Simplified)</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>“”</th>
<th>s</th>
<th>i</th>
<th>t</th>
<th>t</th>
<th>i</th>
<th>n</th>
<th>g</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“”</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr class="even">
<td>k</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr class="odd">
<td>i</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr class="even">
<td>t</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="odd">
<td>t</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="even">
<td>e</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="odd">
<td>n</td>
<td>6</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>Backtrack path: diagonal (S), right (I), right (I). Reconstructed edit script = <code>[Substitute, Insert, Insert]</code>.</p>
</section>
<section id="tiny-code-python-17" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-17">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edit_script(a, b):</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># deletion</span></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>                dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># insertion</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> cost  <span class="co"># substitution or match</span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># backtrack</span></span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a>    ops <span class="op">=</span> []</span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> n, m</span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="st">"M"</span>)</span>
<span id="cb90-25"><a href="#cb90-25" aria-hidden="true" tabindex="-1"></a>            i, j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span>, j <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb90-26"><a href="#cb90-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[i][j] <span class="op">==</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb90-27"><a href="#cb90-27" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="ss">f"S:</span><span class="sc">{</span>a[i <span class="op">-</span> <span class="dv">1</span>]<span class="sc">}</span><span class="ss">-&gt;</span><span class="sc">{</span>b[j <span class="op">-</span> <span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb90-28"><a href="#cb90-28" aria-hidden="true" tabindex="-1"></a>            i, j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span>, j <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb90-29"><a href="#cb90-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> dp[i][j] <span class="op">==</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb90-30"><a href="#cb90-30" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="ss">f"D:</span><span class="sc">{</span>a[i <span class="op">-</span> <span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb90-31"><a href="#cb90-31" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb90-32"><a href="#cb90-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb90-33"><a href="#cb90-33" aria-hidden="true" tabindex="-1"></a>            ops.append(<span class="ss">f"I:</span><span class="sc">{</span>b[j <span class="op">-</span> <span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb90-34"><a href="#cb90-34" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb90-35"><a href="#cb90-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-36"><a href="#cb90-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ops[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb90-37"><a href="#cb90-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-38"><a href="#cb90-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(edit_script(<span class="st">"kitten"</span>, <span class="st">"sitting"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$'S:k-&gt;s', 'M', 'M', 'M', 'I:i', 'M', 'I:g']</code></pre>
</section>
<section id="why-it-matters-47" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-47">Why It Matters</h4>
<ul>
<li><p>Converts distance metrics into explainable transformations</p></li>
<li><p>Used in:</p>
<ul>
<li>Diff tools (e.g.&nbsp;<code>git diff</code>, Myers diff)</li>
<li>Spelling correction</li>
<li>DNA edit tracing</li>
<li>Version control systems</li>
<li>Document merge tools</li>
</ul></li>
</ul>
<p>Without edit reconstruction, we know <em>how far</em> two strings are — with it, we know <em>how to get there</em>.</p>
</section>
<section id="complexity-47" class="level4">
<h4 class="anchored" data-anchor-id="complexity-47">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DP table construction</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
</tr>
<tr class="even">
<td>Backtracking</td>
<td><span class="math inline">\(O(n+m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Space can be reduced with Hirschberg’s divide-and-conquer backtrace.</p>
</section>
<section id="try-it-yourself-47" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-47">Try It Yourself</h4>
<ol type="1">
<li><code>"flaw"</code> → <code>"lawn"</code> → <code>D:f, M, M, I:n</code></li>
<li><code>"sunday"</code> → <code>"saturday"</code> → multiple insertions</li>
<li>Reverse the script to get inverse transformation.</li>
<li>Modify cost function: make substitution more expensive.</li>
<li>Visualize path on the DP grid, it traces your script.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-14" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-14">A Gentle Proof (Why It Works)</h4>
<p>The DP table encodes minimal edit costs for all prefixes. By walking backward from <span class="math inline">\((n, m)\)</span>, each local choice (diagonal, up, left) represents the exact operation that achieved optimal cost. Thus, the backtrace reconstructs the minimal transformation path.</p>
<p>The edit script is the diary of transformation — a record of what changed, when, and how — turning raw distance into a story of difference.</p>
</section>
</section>
<section id="affine-gap-penalty-dynamic-programming" class="level3">
<h3 class="anchored" data-anchor-id="affine-gap-penalty-dynamic-programming">648 Affine Gap Penalty Dynamic Programming</h3>
<p>The Affine Gap Penalty model improves upon simple gap scoring in sequence alignment. Instead of charging a flat penalty per gap symbol, it distinguishes between gap opening and gap extension, reflecting biological or textual reality, it’s costly to <em>start</em> a gap, but cheaper to <em>extend</em> it.</p>
<section id="what-problem-are-we-solving-48" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-48">What Problem Are We Solving?</h4>
<p>In classical alignment (Needleman–Wunsch or Smith–Waterman), every gap is penalized linearly:</p>
<p><span class="math display">\[
\text{gap cost} = k \times g
\]</span></p>
<p>But in practice, a single long gap is <em>less bad</em> than many short ones. So we switch to an affine model:</p>
<p><span class="math display">\[
\text{gap cost} = g_o + (k - 1) \times g_e
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(g_o\)</span> = gap opening penalty</li>
<li><span class="math inline">\(g_e\)</span> = gap extension penalty and <span class="math inline">\(k\)</span> = length of the gap.</li>
</ul>
<p>This model gives smoother, more realistic alignments.</p>
</section>
<section id="example-39" class="level4">
<h4 class="anchored" data-anchor-id="example-39">Example</h4>
<p>Suppose <span class="math inline">\(g_o = 5\)</span>, <span class="math inline">\(g_e = 1\)</span>.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Gap</th>
<th>Linear Model</th>
<th>Affine Model</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1-symbol gap</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="even">
<td>3-symbol gap</td>
<td>15</td>
<td>7</td>
</tr>
<tr class="odd">
<td>5-symbol gap</td>
<td>25</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>Affine scoring <em>rewards longer continuous gaps</em> and avoids scattered gaps.</p>
</section>
<section id="how-it-works-plain-language-14" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-14">How It Works (Plain Language)</h4>
<p>We track three DP matrices instead of one:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Matrix</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(M[i][j]\)</span></td>
<td style="text-align: left;">best score ending in a match/mismatch</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(X[i][j]\)</span></td>
<td style="text-align: left;">best score ending with a gap in sequence A</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(Y[i][j]\)</span></td>
<td style="text-align: left;">best score ending with a gap in sequence B</td>
</tr>
</tbody>
</table>
<p>Each matrix uses different recurrence relations to model gap transitions properly.</p>
</section>
<section id="recurrence-relations" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relations">Recurrence Relations</h4>
<p>Let <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_j\)</span> be the current characters.</p>
<p><span class="math display">\[
\begin{aligned}
M[i][j] &amp;= \max \big(
M[i-1][j-1], X[i-1][j-1], Y[i-1][j-1]
\big) + s(a_i, b_j) [6pt]
X[i][j] &amp;= \max \big(
M[i-1][j] - g_o,; X[i-1][j] - g_e
\big) [6pt]
Y[i][j] &amp;= \max \big(
M[i][j-1] - g_o,; Y[i][j-1] - g_e
\big)
\end{aligned}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
s(a_i, b_j) =
\begin{cases}
+M, &amp; \text{if } a_i = b_j,\\
-S, &amp; \text{if } a_i \ne b_j.
\end{cases}
\]</span></p>
<p>The final alignment score:</p>
<p><span class="math display">\[
D[i][j] = \max(M[i][j], X[i][j], Y[i][j])
\]</span></p>
</section>
<section id="initialization-1" class="level4">
<h4 class="anchored" data-anchor-id="initialization-1">Initialization</h4>
<p><span class="math display">\[
M[0][0] = 0, \quad X[0][0] = Y[0][0] = -\infty
\]</span></p>
<p>For first row/column:</p>
<p><span class="math display">\[
X[i][0] = -g_o - (i - 1) g_e, \quad
Y[0][j] = -g_o - (j - 1) g_e
\]</span></p>
</section>
<section id="example-intuition" class="level4">
<h4 class="anchored" data-anchor-id="example-intuition">Example (Intuition)</h4>
<p>Let’s align:</p>
<pre><code>A:  G A T T A C A
B:  G C A T G C U</code></pre>
<p>With:</p>
<ul>
<li>match = +2</li>
<li>mismatch = -1</li>
<li>gap open = 5</li>
<li>gap extend = 1</li>
</ul>
<p>Small gaps will appear where needed, but long insertions will stay continuous instead of splitting, because continuing a gap is cheaper than opening a new one.</p>
</section>
<section id="tiny-code-python-18" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-18">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> affine_gap(a, b, match<span class="op">=</span><span class="dv">2</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap_open<span class="op">=</span><span class="dv">5</span>, gap_extend<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    neg_inf <span class="op">=</span> <span class="bu">float</span>(<span class="st">"-inf"</span>)</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> [[neg_inf] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> [[neg_inf] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>        M[i][<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>gap_open <span class="op">-</span> (i <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> gap_extend</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>        X[i][<span class="dv">0</span>] <span class="op">=</span> M[i][<span class="dv">0</span>]</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>        M[<span class="dv">0</span>][j] <span class="op">=</span> <span class="op">-</span>gap_open <span class="op">-</span> (j <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> gap_extend</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>        Y[<span class="dv">0</span>][j] <span class="op">=</span> M[<span class="dv">0</span>][j]</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> match <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a>            M[i][j] <span class="op">=</span> <span class="bu">max</span>(M[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>], X[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>], Y[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]) <span class="op">+</span> score</span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a>            X[i][j] <span class="op">=</span> <span class="bu">max</span>(M[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">-</span> gap_open, X[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">-</span> gap_extend)</span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a>            Y[i][j] <span class="op">=</span> <span class="bu">max</span>(M[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> gap_open, Y[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">-</span> gap_extend)</span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(M[n][m], X[n][m], Y[n][m])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-48" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-48">Why It Matters</h4>
<ul>
<li><p>Models biological gaps more realistically (e.g.&nbsp;insertions/deletions in DNA).</p></li>
<li><p>Produces cleaner alignments for text or speech.</p></li>
<li><p>Used in:</p>
<ul>
<li>Needleman–Wunsch and Smith–Waterman extensions</li>
<li>BLAST, FASTA, and bioinformatics pipelines</li>
<li>Dynamic time warping variants in ML and signal analysis</li>
</ul></li>
</ul>
<p>Affine penalties mirror the intuition that starting an error costs more than continuing one.</p>
</section>
<section id="complexity-48" class="level4">
<h4 class="anchored" data-anchor-id="complexity-48">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DP (3 matrices)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
</tr>
<tr class="even">
<td>Space optimized</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(\min(n, m))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-48" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-48">Try It Yourself</h4>
<ol type="1">
<li>Compare linear vs affine gaps for <code>"GATTACA"</code> vs <code>"GCATGCU"</code>.</li>
<li>Test long insertions, affine scoring will prefer one large gap.</li>
<li>Adjust gap penalties and see how alignment changes.</li>
<li>Combine affine scoring with local alignment (Smith–Waterman).</li>
<li>Visualize <span class="math inline">\(M\)</span>, <span class="math inline">\(X\)</span>, and <span class="math inline">\(Y\)</span> matrices separately.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-15" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-15">A Gentle Proof (Why It Works)</h4>
<p>Each of the three matrices represents a state machine:</p>
<ul>
<li><span class="math inline">\(M\)</span> → in a match state,</li>
<li><span class="math inline">\(X\)</span> → in a gap-in-A state,</li>
<li><span class="math inline">\(Y\)</span> → in a gap-in-B state.</li>
</ul>
<p>The affine recurrence ensures optimal substructure because transitions between states incur exactly the proper open/extend penalties. Thus, every path through the combined system yields an optimal total score under affine cost.</p>
<p>The Affine Gap Penalty model brings realism to alignment — understanding that beginnings are costly, but continuations are sometimes just persistence.</p>
</section>
</section>
<section id="myers-bit-vector-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="myers-bit-vector-algorithm">649 Myers Bit-Vector Algorithm</h3>
<p>The Myers Bit-Vector Algorithm is a brilliant optimization for computing edit distance (Levenshtein distance) between short strings or patterns, especially in search and matching tasks. It uses bitwise operations to simulate dynamic programming in parallel across multiple positions, achieving near-linear speed on modern CPUs.</p>
<section id="what-problem-are-we-solving-49" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-49">What Problem Are We Solving?</h4>
<p>Given two strings <span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_m
\]</span> we want to compute their edit distance (insertions, deletions, substitutions).</p>
<p>The classical dynamic programming solution takes <span class="math inline">\(O(nm)\)</span> time. Myers reduces this to <span class="math inline">\(O(n \cdot \lceil m / w \rceil)\)</span>, where <span class="math inline">\(w\)</span> is the machine word size (typically 32 or 64).</p>
<p>This makes it ideal for approximate string search — for example, finding all matches of <code>"pattern"</code> in a text within edit distance ≤ k.</p>
</section>
<section id="core-idea-3" class="level4">
<h4 class="anchored" data-anchor-id="core-idea-3">Core Idea</h4>
<p>The Levenshtein DP recurrence can be viewed as updating a band of cells that depend only on the previous row. If we represent each row as bit vectors, we can perform all cell updates at once using bitwise AND, OR, XOR, and shift operations.</p>
<p>For short patterns, all bits fit in a single word, so updates happen in constant time.</p>
</section>
<section id="representation" class="level4">
<h4 class="anchored" data-anchor-id="representation">Representation</h4>
<p>We define several bit masks of length <span class="math inline">\(m\)</span> (pattern length):</p>
<ul>
<li><p>Eq[c] – a bitmask marking where character <code>c</code> appears in the pattern. Example for pattern <code>"ACCA"</code>:</p>
<pre><code>Eq['A'] = 1001
Eq['C'] = 0110</code></pre></li>
</ul>
<p>During the algorithm, we maintain:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 90%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>Pv</code></td>
<td style="text-align: left;">bit vector of positions where there may be a positive difference</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>Mv</code></td>
<td style="text-align: left;">bit vector of positions where there may be a negative difference</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>Score</code></td>
<td style="text-align: left;">current edit distance</td>
</tr>
</tbody>
</table>
<p>These encode the running state of the edit DP.</p>
</section>
<section id="recurrence-bit-parallel-form" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-bit-parallel-form">Recurrence (Bit-Parallel Form)</h4>
<p>For each text character <code>t_j</code>:</p>
<p><span class="math display">\[
\begin{aligned}
Xv &amp;= \text{Eq}[t_j] ; \lor ; Mv \
Xh &amp;= (((Xv &amp; Pv) + Pv) \oplus Pv) ; \lor ; Xv \
Ph &amp;= Mv ; \lor ; \neg(Xh \lor Pv) \
Mh &amp;= Pv ; &amp; Xh
\end{aligned}
\]</span></p>
<p>Then shift and update the score:</p>
<p><span class="math display">\[
\begin{cases}
\text{if } (Ph \;\&amp;\; \text{bit}_m) \ne 0, &amp; \text{then Score++},\\
\text{if } (Mh \;\&amp;\; \text{bit}_m) \ne 0, &amp; \text{then Score--}.
\end{cases}
\]</span></p>
<p>Finally, set:</p>
<p><span class="math display">\[
\begin{aligned}
Pv &amp;= Mh \;\lor\; \neg(Xh \lor Ph),\\
Mv &amp;= Ph \;\&amp;\; Xh.
\end{aligned}
\]</span></p>
</section>
<section id="how-it-works-plain-language-15" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-15">How It Works (Plain Language)</h4>
<p>Think of each bit in <code>Pv</code> and <code>Mv</code> as representing a column in the DP table. Instead of updating each cell one by one, bit-operations update all columns in parallel, one CPU instruction updates 64 comparisons.</p>
<p>At each step:</p>
<ul>
<li>Eq[c] signals where matches occur.</li>
<li>Pv, Mv track cumulative mismatches.</li>
<li>The score adjusts as bits overflow at the top (edit cost propagation).</li>
</ul>
<p>The algorithm’s loop is extremely tight, just a handful of bitwise ops.</p>
</section>
<section id="example-conceptual" class="level4">
<h4 class="anchored" data-anchor-id="example-conceptual">Example (Conceptual)</h4>
<p>Pattern: <code>"ACGT"</code> Text: <code>"AGT"</code></p>
<p>We initialize:</p>
<pre><code>Eq['A'] = 1000
Eq['C'] = 0100
Eq['G'] = 0010
Eq['T'] = 0001</code></pre>
<p>Then process each character of text <code>"A"</code>, <code>"G"</code>, <code>"T"</code> in turn, updating bit vectors and keeping the current edit distance in a scalar <code>Score</code>.</p>
<p>Final Score = 1 Ok Edit distance = 1 (one deletion).</p>
</section>
<section id="tiny-code-python-19" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-19">Tiny Code (Python)</h4>
<p>Below is a simplified single-word implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> myers_distance(pattern, text):</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pattern)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    Peq <span class="op">=</span> {}</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">set</span>(pattern <span class="op">+</span> text):</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>        Peq[c] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ch <span class="kw">in</span> <span class="bu">enumerate</span>(pattern):</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>        Peq[ch] <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> i</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>    Pv <span class="op">=</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> m) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>    Mv <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> m</span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch <span class="kw">in</span> text:</span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a>        Eq <span class="op">=</span> Peq.get(ch, <span class="dv">0</span>)</span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a>        Xv <span class="op">=</span> Eq <span class="op">|</span> Mv</span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a>        Xh <span class="op">=</span> (((Eq <span class="op">&amp;</span> Pv) <span class="op">+</span> Pv) <span class="op">^</span> Pv) <span class="op">|</span> Eq</span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a>        Ph <span class="op">=</span> Mv <span class="op">|</span> <span class="op">~</span>(Xh <span class="op">|</span> Pv)</span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a>        Mh <span class="op">=</span> Pv <span class="op">&amp;</span> Xh</span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Ph <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (m <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true" tabindex="-1"></a>            score <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb96-22"><a href="#cb96-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> Mh <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (m <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb96-23"><a href="#cb96-23" aria-hidden="true" tabindex="-1"></a>            score <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb96-24"><a href="#cb96-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-25"><a href="#cb96-25" aria-hidden="true" tabindex="-1"></a>        Pv <span class="op">=</span> (Mh <span class="op">&lt;&lt;</span> <span class="dv">1</span>) <span class="op">|</span> <span class="op">~</span>(Xh <span class="op">|</span> (Ph <span class="op">&lt;&lt;</span> <span class="dv">1</span>))</span>
<span id="cb96-26"><a href="#cb96-26" aria-hidden="true" tabindex="-1"></a>        Mv <span class="op">=</span> (Ph <span class="op">&lt;&lt;</span> <span class="dv">1</span>) <span class="op">&amp;</span> Xh</span>
<span id="cb96-27"><a href="#cb96-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-28"><a href="#cb96-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> score</span>
<span id="cb96-29"><a href="#cb96-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-30"><a href="#cb96-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(myers_distance(<span class="st">"ACGT"</span>, <span class="st">"AGT"</span>))  <span class="co"># 1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-49" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-49">Why It Matters</h4>
<ul>
<li><p>Fast approximate matching in text and DNA sequences</p></li>
<li><p>Used in:</p>
<ul>
<li>grep-like fuzzy search</li>
<li>read alignment in genomics (e.g.&nbsp;BWA, Bowtie)</li>
<li>autocorrect / spell check</li>
<li>real-time text comparison</li>
</ul></li>
<li><p>Operates with just bitwise ops and integer arithmetic → extremely fast, branch-free inner loop.</p></li>
</ul>
</section>
<section id="complexity-49" class="level4">
<h4 class="anchored" data-anchor-id="complexity-49">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 46%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Main loop</td>
<td><span class="math inline">\(O(n \cdot \lceil m / w \rceil)\)</span></td>
<td><span class="math inline">\(O(\lceil m / w \rceil)\)</span></td>
</tr>
<tr class="even">
<td>For <span class="math inline">\(m \le w\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-49" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-49">Try It Yourself</h4>
<ol type="1">
<li>Compute edit distance between <code>"banana"</code> and <code>"bananas"</code>.</li>
<li>Compare runtime with classic DP for <span class="math inline">\(m=8, n=100000\)</span>.</li>
<li>Modify to early-stop when <code>Score ≤ k</code>.</li>
<li>Use multiple words (bit-blocks) for long patterns.</li>
<li>Visualize bit evolution per step.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-16" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-16">A Gentle Proof (Why It Works)</h4>
<p>The standard Levenshtein recurrence depends only on the previous row. Each bit in the word encodes whether the difference at that position increased or decreased. Bitwise arithmetic emulates the carry and borrow propagation in integer addition/subtraction — exactly reproducing the DP logic, but in parallel for every bit column.</p>
<p>The Myers Bit-Vector Algorithm turns edit distance into pure hardware logic — aligning strings not by loops, but by the rhythm of bits flipping in sync across a CPU register.</p>
</section>
</section>
<section id="longest-common-subsequence-lcs" class="level3">
<h3 class="anchored" data-anchor-id="longest-common-subsequence-lcs">650 Longest Common Subsequence (LCS)</h3>
<p>The Longest Common Subsequence (LCS) problem is one of the cornerstones of dynamic programming. It asks: <em>Given two sequences, what is the longest sequence that appears in both (in the same order, but not necessarily contiguous)?</em></p>
<p>It’s the foundation for tools like <code>diff</code>, DNA alignment, and text similarity systems, anywhere we care about order-preserving similarity.</p>
<section id="what-problem-are-we-solving-50" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-50">What Problem Are We Solving?</h4>
<p>Given two sequences:</p>
<p><span class="math display">\[
A = a_1 a_2 \ldots a_n, \quad B = b_1 b_2 \ldots b_m
\]</span></p>
<p>find the longest sequence <span class="math inline">\(C = c_1 c_2 \ldots c_k\)</span> such that <span class="math inline">\(C\)</span> is a subsequence of both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p>
<p>Formally: <span class="math display">\[
C \subseteq A, \quad C \subseteq B, \quad k = |C| \text{ is maximal.}
\]</span></p>
<p>We want both the length and optionally the subsequence itself.</p>
</section>
<section id="example-40" class="level4">
<h4 class="anchored" data-anchor-id="example-40">Example</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>LCS</th>
<th>Length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>"ABCBDAB"</code></td>
<td><code>"BDCABA"</code></td>
<td><code>"BCBA"</code></td>
<td>4</td>
</tr>
<tr class="even">
<td><code>"AGGTAB"</code></td>
<td><code>"GXTXAYB"</code></td>
<td><code>"GTAB"</code></td>
<td>4</td>
</tr>
<tr class="odd">
<td><code>"HELLO"</code></td>
<td><code>"YELLOW"</code></td>
<td><code>"ELLO"</code></td>
<td>4</td>
</tr>
</tbody>
</table>
</section>
<section id="recurrence-relation-6" class="level4">
<h4 class="anchored" data-anchor-id="recurrence-relation-6">Recurrence Relation</h4>
<p>Let <span class="math inline">\(L[i][j]\)</span> be the LCS length of prefixes <span class="math inline">\(A[0..i-1]\)</span> and <span class="math inline">\(B[0..j-1]\)</span>.</p>
<p>Then:</p>
<p><span class="math display">\[
L[i][j] =
\begin{cases}
0, &amp; \text{if } i = 0 \text{ or } j = 0,\\[4pt]
L[i-1][j-1] + 1, &amp; \text{if } a_i = b_j,\\[4pt]
\max(L[i-1][j],\, L[i][j-1]), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
</section>
<section id="how-it-works-plain-language-16" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-16">How It Works (Plain Language)</h4>
<p>You build a 2D grid comparing prefixes of both strings. Each cell <span class="math inline">\(L[i][j]\)</span> represents “how long is the LCS up to <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_j\)</span>”.</p>
<ul>
<li>If the characters match → extend the LCS by 1.</li>
<li>If not → take the best from skipping one character in either string.</li>
</ul>
<p>The value in the bottom-right corner is the final LCS length.</p>
</section>
<section id="example-table-2" class="level4">
<h4 class="anchored" data-anchor-id="example-table-2">Example Table</h4>
<p>For <code>"ABCBDAB"</code> vs <code>"BDCABA"</code>:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>“”</th>
<th>B</th>
<th>D</th>
<th>C</th>
<th>A</th>
<th>B</th>
<th>A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“”</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>A</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>B</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="even">
<td>C</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr class="odd">
<td>B</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="even">
<td>D</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>A</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="even">
<td>B</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Ok LCS length = 4 Ok One valid subsequence = <code>"BCBA"</code></p>
</section>
<section id="tiny-code-python-20" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-20">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lcs(a, b):</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][m]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>To reconstruct the subsequence:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lcs_traceback(a, b):</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># backtrack</span></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a>    i, j <span class="op">=</span> n, m</span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>    seq <span class="op">=</span> []</span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a>            seq.append(a[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">&gt;=</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb98-21"><a href="#cb98-21" aria-hidden="true" tabindex="-1"></a>            i <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb98-22"><a href="#cb98-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb98-23"><a href="#cb98-23" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb98-24"><a href="#cb98-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(<span class="bu">reversed</span>(seq))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lcs_traceback(<span class="st">"ABCBDAB"</span>, <span class="st">"BDCABA"</span>))  <span class="co"># BCBA</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-50" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-50">Why It Matters</h4>
<ul>
<li>Backbone of diff tools (<code>git diff</code>, text comparison, version control)</li>
<li>DNA/protein similarity (invariant subsequences)</li>
<li>Plagiarism detection</li>
<li>Machine translation evaluation (BLEU-like metrics)</li>
<li>Sequence compression and error correction</li>
</ul>
<p>The LCS gives structural similarity, not exact matches, but shared order.</p>
</section>
<section id="complexity-50" class="level4">
<h4 class="anchored" data-anchor-id="complexity-50">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DP (full table)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(nm)\)</span></td>
</tr>
<tr class="even">
<td>Optimized (length only)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(\min(n, m))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-50" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-50">Try It Yourself</h4>
<ol type="1">
<li><code>"HELLO"</code> vs <code>"YELLOW"</code> → <code>"ELLO"</code></li>
<li><code>"AGGTAB"</code> vs <code>"GXTXAYB"</code> → <code>"GTAB"</code></li>
<li>Compute LCS similarity ratio = <span class="math inline">\(2 \times LCS / (|A| + |B|)\)</span></li>
<li>Use LCS to align text versions and detect edits.</li>
<li>Try it on code diffs, it’s how <code>git</code> detects changed lines.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-17" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-17">A Gentle Proof (Why It Works)</h4>
<p>Each prefix of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> defines subproblems with optimal substructure:</p>
<ul>
<li>If <span class="math inline">\(a_i = b_j\)</span>, LCS extends previous prefix.</li>
<li>Else, best LCS must drop one element from either <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span>.</li>
</ul>
<p>Overlapping subproblems are solved once, stored in <span class="math inline">\(L[i][j]\)</span>. The recursion ensures all combinations are considered efficiently.</p>
<p>The Longest Common Subsequence is the quiet heart of comparison — it finds what survives between change and difference, the thread of sameness through time and transformation.</p>
</section>
</section>
</section>
<section id="section-66.-compression" class="level1">
<h1>Section 66. Compression</h1>
<section id="huffman-coding" class="level3">
<h3 class="anchored" data-anchor-id="huffman-coding">651 Huffman Coding</h3>
<p>Huffman Coding is a classic algorithm for lossless data compression. It builds an optimal prefix code, meaning no codeword is a prefix of another, ensuring unique decodability. By assigning shorter codes to frequent symbols and longer codes to rare ones, Huffman Coding minimizes total encoded length.</p>
<section id="problem-definition" class="level4">
<h4 class="anchored" data-anchor-id="problem-definition">Problem Definition</h4>
<p>Given an alphabet of symbols <span class="math display">\[
S = {s_1, s_2, \ldots, s_n}
\]</span> with corresponding frequencies <span class="math display">\[
f(s_i)
\]</span> we want to assign binary codes <span class="math inline">\(C(s_i)\)</span> such that:</p>
<ol type="1">
<li>The code is prefix-free (no code is a prefix of another).</li>
<li>The average code length <span class="math display">\[
L = \sum_i f(s_i) \cdot |C(s_i)|
\]</span> is minimal.</li>
</ol>
</section>
<section id="key-idea-2" class="level4">
<h4 class="anchored" data-anchor-id="key-idea-2">Key Idea</h4>
<ul>
<li>Combine the two least frequent symbols repeatedly into a new node.</li>
<li>Assign 0 and 1 to the two branches.</li>
<li>The tree you build defines the prefix codes.</li>
</ul>
<p>This process forms a binary tree where:</p>
<ul>
<li>Leaves represent original symbols.</li>
<li>Path from root to leaf gives the binary code.</li>
</ul>
</section>
<section id="algorithm-steps" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-steps">Algorithm Steps</h4>
<ol type="1">
<li><p>Initialize a priority queue (min-heap) with all symbols weighted by frequency.</p></li>
<li><p>While more than one node remains:</p>
<ul>
<li>Remove two nodes with smallest frequencies <span class="math inline">\(f_1, f_2\)</span>.</li>
<li>Create a new internal node with frequency <span class="math inline">\(f = f_1 + f_2\)</span>.</li>
<li>Insert it back into the queue.</li>
</ul></li>
<li><p>When only one node remains, it is the root.</p></li>
<li><p>Traverse the tree:</p>
<ul>
<li>Left branch = append <code>0</code></li>
<li>Right branch = append <code>1</code></li>
<li>Record codes for each leaf.</li>
</ul></li>
</ol>
</section>
<section id="example-41" class="level4">
<h4 class="anchored" data-anchor-id="example-41">Example</h4>
<p>Symbols and frequencies:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Frequency</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">45</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">13</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">12</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">16</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
<p>Step-by-step tree building:</p>
<ol type="1">
<li>Combine F (5) + E (9) → new node (14)</li>
<li>Combine C (12) + B (13) → new node (25)</li>
<li>Combine D (16) + (14) → new node (30)</li>
<li>Combine (25) + (30) → new node (55)</li>
<li>Combine A (45) + (55) → new root (100)</li>
</ol>
<p>Final codes (one valid solution):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">101</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">100</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">111</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">1101</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">1100</td>
</tr>
</tbody>
</table>
<p>Average code length: <span class="math display">\[
L = \frac{45(1) + 13(3) + 12(3) + 16(3) + 9(4) + 5(4)}{100} = 2.24 \text{ bits/symbol}
\]</span></p>
</section>
<section id="tiny-code-python-21" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-21">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> huffman(freqs):</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    heap <span class="op">=</span> [[w, [sym, <span class="st">""</span>]] <span class="cf">for</span> sym, w <span class="kw">in</span> freqs.items()]</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>    heapq.heapify(heap)</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(heap) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>        lo <span class="op">=</span> heapq.heappop(heap)</span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>        hi <span class="op">=</span> heapq.heappop(heap)</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pair <span class="kw">in</span> lo[<span class="dv">1</span>:]:</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>            pair[<span class="dv">1</span>] <span class="op">=</span> <span class="st">"0"</span> <span class="op">+</span> pair[<span class="dv">1</span>]</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pair <span class="kw">in</span> hi[<span class="dv">1</span>:]:</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a>            pair[<span class="dv">1</span>] <span class="op">=</span> <span class="st">"1"</span> <span class="op">+</span> pair[<span class="dv">1</span>]</span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a>        heapq.heappush(heap, [lo[<span class="dv">0</span>] <span class="op">+</span> hi[<span class="dv">0</span>]] <span class="op">+</span> lo[<span class="dv">1</span>:] <span class="op">+</span> hi[<span class="dv">1</span>:])</span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(heapq.heappop(heap)[<span class="dv">1</span>:], key<span class="op">=</span><span class="kw">lambda</span> p: (<span class="bu">len</span>(p[<span class="dv">1</span>]), p))</span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-18"><a href="#cb100-18" aria-hidden="true" tabindex="-1"></a>freqs <span class="op">=</span> {<span class="st">'A'</span>: <span class="dv">45</span>, <span class="st">'B'</span>: <span class="dv">13</span>, <span class="st">'C'</span>: <span class="dv">12</span>, <span class="st">'D'</span>: <span class="dv">16</span>, <span class="st">'E'</span>: <span class="dv">9</span>, <span class="st">'F'</span>: <span class="dv">5</span>}</span>
<span id="cb100-19"><a href="#cb100-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sym, code <span class="kw">in</span> huffman(freqs):</span>
<span id="cb100-20"><a href="#cb100-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(sym, code)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-51" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-51">Why It Matters</h4>
<ul>
<li><p>Forms the foundation of many real-world compression formats:</p>
<ul>
<li>DEFLATE (ZIP, PNG)</li>
<li>JPEG and MP3 (after quantization)</li>
</ul></li>
<li><p>Minimizes the expected bit-length for symbol encoding.</p></li>
<li><p>Demonstrates greedy optimality: combining smallest weights first yields the global minimum.</p></li>
</ul>
</section>
<section id="complexity-51" class="level4">
<h4 class="anchored" data-anchor-id="complexity-51">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Building tree</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Encoding/decoding</td>
<td><span class="math inline">\(O(k)\)</span> (per symbol)</td>
<td><span class="math inline">\(O(1)\)</span> (per lookup)</td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-51" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-51">Try It Yourself</h4>
<ol type="1">
<li>Use characters of <code>"HELLO WORLD"</code> with frequency counts.</li>
<li>Draw the Huffman tree manually.</li>
<li>Encode and decode a small string.</li>
<li>Compare average bit-length with fixed-length (ASCII = 8 bits).</li>
<li>Implement canonical Huffman codes for deterministic order.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-18" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-18">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> be the two least frequent symbols. In an optimal prefix code, these two must appear as siblings at the greatest depth. Replacing any other deeper pair with them would increase the average length. By repeatedly applying this property, Huffman’s greedy combination is always optimal.</p>
<p>Huffman Coding shows how greedy choice and tree structure work together to make compression elegant, turning frequency into efficiency.</p>
</section>
</section>
<section id="canonical-huffman-coding" class="level3">
<h3 class="anchored" data-anchor-id="canonical-huffman-coding">652 Canonical Huffman Coding</h3>
<p>Canonical Huffman Coding is a refined, deterministic version of Huffman Coding. It encodes symbols using the same code lengths as the original Huffman tree but arranges codes in lexicographic (canonical) order. This makes decoding much faster and compactly represents the code table, ideal for file formats and network protocols.</p>
<section id="what-problem-are-we-solving-51" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-51">What Problem Are We Solving?</h4>
<p>In standard Huffman coding, multiple trees can represent the same optimal code lengths. For example, codes <code>{A: 0, B: 10, C: 11}</code> and <code>{A: 1, B: 00, C: 01}</code> have the same total length. However, storing or transmitting the full tree is wasteful.</p>
<p>Canonical Huffman eliminates this ambiguity by assigning codes deterministically based only on symbol order and code lengths, not on tree structure.</p>
</section>
<section id="key-idea-3" class="level4">
<h4 class="anchored" data-anchor-id="key-idea-3">Key Idea</h4>
<p>Instead of storing the tree, we store code lengths for each symbol. Then, we generate all codes in a consistent way:</p>
<ol type="1">
<li>Sort symbols by code length (shortest first).</li>
<li>Assign the smallest possible binary code to the first symbol.</li>
<li>Each next symbol’s code = previous code + 1 (in binary).</li>
<li>When moving to a longer length, left-shift (append a zero).</li>
</ol>
<p>This guarantees lexicographic order and prefix-free structure.</p>
</section>
<section id="example-42" class="level4">
<h4 class="anchored" data-anchor-id="example-42">Example</h4>
<p>Suppose we have symbols and their Huffman code lengths:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<p>Step 1. Sort by (length, symbol):</p>
<p><code>A (1), B (3), C (3), D (3), E (4)</code></p>
<p>Step 2. Assign canonical codes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Length</th>
<th style="text-align: center;">Code (binary)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">100</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">101</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">110</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1110</td>
</tr>
</tbody>
</table>
<p>Step 3. Increment codes sequentially</p>
<p>Start with all zeros of length = 1 for the first symbol, then increment and shift as needed.</p>
</section>
<section id="pseudocode" class="level4">
<h4 class="anchored" data-anchor-id="pseudocode">Pseudocode</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> canonical_huffman(lengths):</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># lengths: dict {symbol: code_length}</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    sorted_syms <span class="op">=</span> <span class="bu">sorted</span>(lengths.items(), key<span class="op">=</span><span class="kw">lambda</span> x: (x[<span class="dv">1</span>], x[<span class="dv">0</span>]))</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    codes <span class="op">=</span> {}</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    code <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    prev_len <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> sym, length <span class="kw">in</span> sorted_syms:</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>        code <span class="op">&lt;&lt;=</span> (length <span class="op">-</span> prev_len)</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>        codes[sym] <span class="op">=</span> <span class="bu">format</span>(code, <span class="st">'0</span><span class="sc">{}</span><span class="st">b'</span>.<span class="bu">format</span>(length))</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>        code <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>        prev_len <span class="op">=</span> length</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> codes</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example run:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>lengths <span class="op">=</span> {<span class="st">'A'</span>: <span class="dv">1</span>, <span class="st">'B'</span>: <span class="dv">3</span>, <span class="st">'C'</span>: <span class="dv">3</span>, <span class="st">'D'</span>: <span class="dv">3</span>, <span class="st">'E'</span>: <span class="dv">4</span>}</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(canonical_huffman(lengths))</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="co"># {'A': '0', 'B': '100', 'C': '101', 'D': '110', 'E': '1110'}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-52" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-52">Why It Matters</h4>
<ul>
<li><p>Deterministic: every decoder reconstructs the same codes from code lengths.</p></li>
<li><p>Compact: storing code lengths (one byte each) is much smaller than storing full trees.</p></li>
<li><p>Fast decoding: tables can be generated using code-length ranges.</p></li>
<li><p>Used in:</p>
<ul>
<li>DEFLATE (ZIP, PNG, gzip)</li>
<li>JPEG</li>
<li>MPEG and MP3</li>
<li>Google’s Brotli and Zstandard</li>
</ul></li>
</ul>
</section>
<section id="decoding-process" class="level4">
<h4 class="anchored" data-anchor-id="decoding-process">Decoding Process</h4>
<p>Given the canonical table:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Length</th>
<th style="text-align: center;">Start Code</th>
<th style="text-align: center;">Count</th>
<th style="text-align: center;">Start Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">A</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">B, C, D</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">1110</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">E</td>
</tr>
</tbody>
</table>
<p>Decoding steps:</p>
<ol type="1">
<li>Read bits from input.</li>
<li>Track current code length.</li>
<li>If bits match a valid range → decode symbol.</li>
<li>Reset and continue.</li>
</ol>
<p>This process uses range tables instead of trees, yielding <span class="math inline">\(O(1)\)</span> lookups.</p>
</section>
<section id="comparison-with-standard-huffman" class="level4">
<h4 class="anchored" data-anchor-id="comparison-with-standard-huffman">Comparison with Standard Huffman</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Standard Huffman</th>
<th>Canonical Huffman</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Storage</td>
<td>Tree structure</td>
<td>Code lengths only</td>
</tr>
<tr class="even">
<td>Uniqueness</td>
<td>Non-deterministic</td>
<td>Deterministic</td>
</tr>
<tr class="odd">
<td>Decoding speed</td>
<td>Tree traversal</td>
<td>Table lookup</td>
</tr>
<tr class="even">
<td>Common use</td>
<td>Educational, conceptual</td>
<td>Real-world compressors</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-52" class="level4">
<h4 class="anchored" data-anchor-id="complexity-52">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build canonical table</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Encode/decode</td>
<td><span class="math inline">\(O(k)\)</span></td>
<td><span class="math inline">\(O(1)\)</span> per symbol</td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-52" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-52">Try It Yourself</h4>
<ol type="1">
<li>Take any Huffman code tree and extract code lengths.</li>
<li>Rebuild canonical codes from lengths.</li>
<li>Compare binary encodings, they decode identically.</li>
<li>Implement DEFLATE-style representation using <code>(symbol, bit length)</code> pairs.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-19" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-19">A Gentle Proof (Why It Works)</h4>
<p>The lexicographic ordering preserves prefix-freeness: if one code has length <span class="math inline">\(l_1\)</span> and the next has <span class="math inline">\(l_2 \ge l_1\)</span>, incrementing the code and shifting ensures that no code is a prefix of another. Thus, canonical codes produce the same compression ratio as the original Huffman tree.</p>
<p>Canonical Huffman Coding transforms optimal trees into simple arithmetic — the same compression, but with order, predictability, and elegance.</p>
</section>
</section>
<section id="arithmetic-coding" class="level3">
<h3 class="anchored" data-anchor-id="arithmetic-coding">653 Arithmetic Coding</h3>
<p>Arithmetic Coding is a powerful lossless compression method that encodes an entire message as a single number between 0 and 1. Unlike Huffman coding, which assigns discrete bit sequences to symbols, arithmetic coding represents the <em>whole message</em> as a fraction within an interval that shrinks as each symbol is processed.</p>
<p>It’s widely used in modern compression formats like JPEG, H.264, and BZIP2.</p>
<section id="what-problem-are-we-solving-52" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-52">What Problem Are We Solving?</h4>
<p>Huffman coding can only assign codewords of integer bit lengths. Arithmetic coding removes that restriction, it can assign fractional bits per symbol, achieving closer-to-optimal compression for any probability distribution.</p>
<p>The idea: Each symbol narrows the interval based on its probability. The final sub-interval uniquely identifies the message.</p>
</section>
<section id="how-it-works-plain-language-17" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-plain-language-17">How It Works (Plain Language)</h4>
<p>Start with the interval [0, 1). Each symbol refines the interval proportional to its probability.</p>
<p>Example with symbols and probabilities:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Probability</th>
<th style="text-align: center;">Range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">[0.0, 0.5)</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.3</td>
<td style="text-align: center;">[0.5, 0.8)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">[0.8, 1.0)</td>
</tr>
</tbody>
</table>
<p>For the message <code>"BAC"</code>:</p>
<ol type="1">
<li>Start: [0.0, 1.0)</li>
<li>Symbol B → [0.5, 0.8)</li>
<li>Symbol A → take 0.5 + (0.8 - 0.5) × [0.0, 0.5) = [0.5, 0.65)</li>
<li>Symbol C → take 0.5 + (0.65 - 0.5) × [0.8, 1.0) = [0.62, 0.65)</li>
</ol>
<p>Final range: [0.62, 0.65) Any number in this range (say 0.63) uniquely identifies the message.</p>
</section>
<section id="mathematical-formulation" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-formulation">Mathematical Formulation</h4>
<p>For a sequence of symbols <span class="math inline">\(s_1, s_2, \ldots, s_n\)</span> with cumulative probability ranges <span class="math inline">\([l_i, h_i)\)</span> per symbol, we iteratively compute:</p>
<p><span class="math display">\[
\begin{aligned}
\text{range} &amp;= h - l, \
h' &amp;= l + \text{range} \times \text{high}(s_i), \
l' &amp;= l + \text{range} \times \text{low}(s_i).
\end{aligned}
\]</span></p>
<p>After processing all symbols, pick any number <span class="math inline">\(x \in [l, h)\)</span> as the code.</p>
<p>Decoding reverses the process by seeing where <span class="math inline">\(x\)</span> falls within symbol ranges.</p>
</section>
<section id="example-step-table" class="level4">
<h4 class="anchored" data-anchor-id="example-step-table">Example Step Table</h4>
<p>Encoding <code>"BAC"</code> with same probabilities:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Symbol</th>
<th>Interval Before</th>
<th>Range</th>
<th>New Interval</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>B</td>
<td>[0.0, 1.0)</td>
<td>1.0</td>
<td>[0.5, 0.8)</td>
</tr>
<tr class="even">
<td>2</td>
<td>A</td>
<td>[0.5, 0.8)</td>
<td>0.3</td>
<td>[0.5, 0.65)</td>
</tr>
<tr class="odd">
<td>3</td>
<td>C</td>
<td>[0.5, 0.65)</td>
<td>0.15</td>
<td>[0.62, 0.65)</td>
</tr>
</tbody>
</table>
<p>Encoded number: 0.63</p>
</section>
<section id="tiny-code-python-22" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-22">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> arithmetic_encode(message, probs):</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    low, high <span class="op">=</span> <span class="fl">0.0</span>, <span class="fl">1.0</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> sym <span class="kw">in</span> message:</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>        range_ <span class="op">=</span> high <span class="op">-</span> low</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>        cum_low <span class="op">=</span> <span class="bu">sum</span>(v <span class="cf">for</span> k, v <span class="kw">in</span> probs.items() <span class="cf">if</span> k <span class="op">&lt;</span> sym)</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>        cum_high <span class="op">=</span> cum_low <span class="op">+</span> probs[sym]</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>        high <span class="op">=</span> low <span class="op">+</span> range_ <span class="op">*</span> cum_high</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>        low <span class="op">=</span> low <span class="op">+</span> range_ <span class="op">*</span> cum_low</span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (low <span class="op">+</span> high) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>probs <span class="op">=</span> {<span class="st">'A'</span>: <span class="fl">0.5</span>, <span class="st">'B'</span>: <span class="fl">0.3</span>, <span class="st">'C'</span>: <span class="fl">0.2</span>}</span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>code <span class="op">=</span> arithmetic_encode(<span class="st">"BAC"</span>, probs)</span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">round</span>(code, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-53" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-53">Why It Matters</h4>
<ul>
<li><p>Reaches near-entropy compression (fractional bits per symbol).</p></li>
<li><p>Handles non-integer probability models smoothly.</p></li>
<li><p>Adapts dynamically with context models, used in adaptive compressors.</p></li>
<li><p>Basis of:</p>
<ul>
<li>JPEG and H.264 (CABAC variant)</li>
<li>BZIP2 (arithmetic / range coder)</li>
<li>PPM compressors (Prediction by Partial Matching)</li>
</ul></li>
</ul>
</section>
<section id="complexity-53" class="level4">
<h4 class="anchored" data-anchor-id="complexity-53">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding/decoding</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>With adaptive probabilities</td>
<td><span class="math inline">\(O(n \log m)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-53" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-53">Try It Yourself</h4>
<ol type="1">
<li>Use symbols <code>{A:0.6, B:0.3, C:0.1}</code> and encode <code>"ABAC"</code>.</li>
<li>Change the order and see how the encoded number shifts.</li>
<li>Implement range coding, a scaled integer form of arithmetic coding.</li>
<li>Try adaptive frequency updates for real-time compression.</li>
<li>Decode by tracking which subinterval contains the encoded number.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-20" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-20">A Gentle Proof (Why It Works)</h4>
<p>Each symbol’s range subdivision corresponds to its probability mass. Thus, after encoding <span class="math inline">\(n\)</span> symbols, the interval width equals:</p>
<p><span class="math display">\[
\prod_{i=1}^{n} P(s_i)
\]</span></p>
<p>The number of bits required to represent this interval is approximately:</p>
<p><span class="math display">\[
-\log_2 \left( \prod_{i=1}^{n} P(s_i) \right)
= \sum_{i=1}^{n} -\log_2 P(s_i)
\]</span></p>
<p>which equals the Shannon information content — proving arithmetic coding achieves near-entropy optimality.</p>
<p>Arithmetic Coding replaces bits and trees with pure intervals — compressing not with steps, but with precision itself.</p>
</section>
</section>
<section id="shannonfano-coding" class="level3">
<h3 class="anchored" data-anchor-id="shannonfano-coding">654 Shannon–Fano Coding</h3>
<p>Shannon–Fano Coding is an early method of entropy-based lossless compression. It was developed independently by Claude Shannon and Robert Fano before Huffman’s algorithm. While not always optimal, it laid the foundation for modern prefix-free coding and influenced Huffman and arithmetic coding.</p>
<section id="what-problem-are-we-solving-53" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-53">What Problem Are We Solving?</h4>
<p>Given a set of symbols with known probabilities (or frequencies), we want to assign binary codes such that more frequent symbols get shorter codes — while ensuring the code remains prefix-free (no code is a prefix of another).</p>
<p>The goal: minimize the expected code length</p>
<p><span class="math display">\[
L = \sum_i p_i \cdot |C_i|
\]</span></p>
<p>close to the entropy bound <span class="math display">\[
H = -\sum_i p_i \log_2 p_i
\]</span></p>
</section>
<section id="the-idea" class="level4">
<h4 class="anchored" data-anchor-id="the-idea">The Idea</h4>
<p>Shannon–Fano coding works by dividing the probability table into two nearly equal halves and assigning 0s and 1s recursively.</p>
<ol type="1">
<li>Sort all symbols by decreasing probability.</li>
<li>Split the list into two parts with total probabilities as equal as possible.</li>
<li>Assign <code>0</code> to the first group, <code>1</code> to the second.</li>
<li>Recurse on each group until every symbol has a unique code.</li>
</ol>
<p>The result is a prefix code, though not always optimal.</p>
</section>
<section id="example-43" class="level4">
<h4 class="anchored" data-anchor-id="example-43">Example</h4>
<p>Symbols and probabilities:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.4</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.2</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">0.1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">0.1</td>
</tr>
</tbody>
</table>
<p>Step 1. Sort by probability:</p>
<p>A (0.4), B (0.2), C (0.2), D (0.1), E (0.1)</p>
<p>Step 2. Split into equal halves:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Group</th>
<th style="text-align: center;">Symbols</th>
<th style="text-align: center;">Sum</th>
<th style="text-align: center;">Bit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Left</td>
<td style="text-align: center;">A, B</td>
<td style="text-align: center;">0.6</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">Right</td>
<td style="text-align: center;">C, D, E</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>Step 3. Recurse:</p>
<ul>
<li>Left group (A, B): split → A (0.4) | B (0.2) → A = <code>00</code>, B = <code>01</code></li>
<li>Right group (C, D, E): split → C (0.2) | D, E (0.2) → C = <code>10</code>, D = <code>110</code>, E = <code>111</code></li>
</ul>
<p>Final codes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Probability</th>
<th style="text-align: center;">Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.4</td>
<td style="text-align: center;">00</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">01</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">10</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">110</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">111</td>
</tr>
</tbody>
</table>
<p>Average code length:</p>
<p><span class="math display">\[
L = 0.4(2) + 0.2(2) + 0.2(2) + 0.1(3) + 0.1(3) = 2.2 \text{ bits/symbol}
\]</span></p>
<p>Entropy:</p>
<p><span class="math display">\[
H = -\sum p_i \log_2 p_i \approx 2.12
\]</span></p>
<p>Efficiency:</p>
<p><span class="math display">\[
\frac{H}{L} = 0.96
\]</span></p>
</section>
<section id="tiny-code-python-23" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-23">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shannon_fano(symbols):</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    symbols <span class="op">=</span> <span class="bu">sorted</span>(symbols.items(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="op">-</span>x[<span class="dv">1</span>])</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    codes <span class="op">=</span> {}</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recurse(sub, prefix<span class="op">=</span><span class="st">""</span>):</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(sub) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>            codes[sub[<span class="dv">0</span>][<span class="dv">0</span>]] <span class="op">=</span> prefix</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="bu">sum</span>(p <span class="cf">for</span> _, p <span class="kw">in</span> sub)</span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>        acc, split <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, (_, p) <span class="kw">in</span> <span class="bu">enumerate</span>(sub):</span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a>            acc <span class="op">+=</span> p</span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> acc <span class="op">&gt;=</span> total <span class="op">/</span> <span class="dv">2</span>:</span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a>                split <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb104-15"><a href="#cb104-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb104-16"><a href="#cb104-16" aria-hidden="true" tabindex="-1"></a>        recurse(sub[:split], prefix <span class="op">+</span> <span class="st">"0"</span>)</span>
<span id="cb104-17"><a href="#cb104-17" aria-hidden="true" tabindex="-1"></a>        recurse(sub[split:], prefix <span class="op">+</span> <span class="st">"1"</span>)</span>
<span id="cb104-18"><a href="#cb104-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-19"><a href="#cb104-19" aria-hidden="true" tabindex="-1"></a>    recurse(symbols)</span>
<span id="cb104-20"><a href="#cb104-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> codes</span>
<span id="cb104-21"><a href="#cb104-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-22"><a href="#cb104-22" aria-hidden="true" tabindex="-1"></a>probs <span class="op">=</span> {<span class="st">'A'</span>: <span class="fl">0.4</span>, <span class="st">'B'</span>: <span class="fl">0.2</span>, <span class="st">'C'</span>: <span class="fl">0.2</span>, <span class="st">'D'</span>: <span class="fl">0.1</span>, <span class="st">'E'</span>: <span class="fl">0.1</span>}</span>
<span id="cb104-23"><a href="#cb104-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(shannon_fano(probs))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-54" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-54">Why It Matters</h4>
<ul>
<li>Historically important, first systematic prefix-coding method.</li>
<li>Basis for Huffman’s later improvement (which guarantees optimality).</li>
<li>Demonstrates divide-and-balance principle used in tree-based codes.</li>
<li>Simpler to understand and implement, suitable for educational use.</li>
</ul>
</section>
<section id="comparison-with-huffman-coding" class="level4">
<h4 class="anchored" data-anchor-id="comparison-with-huffman-coding">Comparison with Huffman Coding</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 33%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Shannon–Fano</th>
<th>Huffman</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Approach</td>
<td>Top-down splitting</td>
<td>Bottom-up merging</td>
</tr>
<tr class="even">
<td>Optimality</td>
<td>Not always optimal</td>
<td>Always optimal</td>
</tr>
<tr class="odd">
<td>Code order</td>
<td>Deterministic</td>
<td>Can vary with equal weights</td>
</tr>
<tr class="even">
<td>Usage</td>
<td>Historical, conceptual</td>
<td>Real-world compression (ZIP, JPEG)</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-54" class="level4">
<h4 class="anchored" data-anchor-id="complexity-54">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sorting</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Code generation</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-54" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-54">Try It Yourself</h4>
<ol type="1">
<li>Build a Shannon–Fano tree for <code>{A:7, B:5, C:2, D:1}</code>.</li>
<li>Compare average bit-length with Huffman’s result.</li>
<li>Verify prefix property (no code is prefix of another).</li>
<li>Implement decoding by reversing the code table.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-21" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-21">A Gentle Proof (Why It Works)</h4>
<p>At each recursive split, we ensure that total probability difference between groups is minimal. This keeps code lengths roughly proportional to symbol probabilities:</p>
<p><span class="math display">\[
|C_i| \approx \lceil -\log_2 p_i \rceil
\]</span></p>
<p>Thus, Shannon–Fano always produces a prefix-free code whose length is close (but not guaranteed equal) to the optimal entropy bound.</p>
<p>Shannon–Fano Coding was the first real step from probability to code — a balanced yet imperfect bridge between information theory and compression practice.</p>
</section>
</section>
<section id="run-length-encoding-rle" class="level3">
<h3 class="anchored" data-anchor-id="run-length-encoding-rle">655 Run-Length Encoding (RLE)</h3>
<p>Run-Length Encoding (RLE) is one of the simplest lossless compression techniques. It replaces consecutive repeating symbols, called <em>runs</em>, with a count and the symbol itself. RLE is ideal when data contains long sequences of the same value, such as in images, bitmaps, or text with whitespace.</p>
<section id="what-problem-are-we-solving-54" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-54">What Problem Are We Solving?</h4>
<p>Uncompressed data often has redundancy in the form of repeated symbols:</p>
<pre><code>AAAAABBBBCCCCCCDD</code></pre>
<p>Instead of storing each symbol, we can store <em>how many times</em> it repeats.</p>
<p>Encoded form:</p>
<pre><code>(5, A)(4, B)(6, C)(2, D)</code></pre>
<p>which saves space whenever runs are long relative to the alphabet size.</p>
</section>
<section id="core-idea-4" class="level4">
<h4 class="anchored" data-anchor-id="core-idea-4">Core Idea</h4>
<p>Compress data by representing runs of identical symbols as pairs:</p>
<p><span class="math display">\[
(\text{symbol}, \text{count})
\]</span></p>
<p>For example:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Input</th>
<th style="text-align: center;">Encoded</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>AAAAABBBCCDAA</code></td>
<td style="text-align: center;"><code>5A3B2C1D2A</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>0001111000</code></td>
<td style="text-align: center;"><code>(0,3)(1,4)(0,3)</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>AAAB</code></td>
<td style="text-align: center;"><code>3A1B</code></td>
</tr>
</tbody>
</table>
<p>Decoding simply reverses the process, expand each pair into repeated symbols.</p>
</section>
<section id="algorithm-steps-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-steps-1">Algorithm Steps</h4>
<ol type="1">
<li><p>Initialize <code>count = 1</code>.</p></li>
<li><p>Iterate through the sequence:</p>
<ul>
<li>If the next symbol is the same, increment <code>count</code>.</li>
<li>If it changes, output <code>(symbol, count)</code> and reset.</li>
</ul></li>
<li><p>After the loop, output the final run.</p></li>
</ol>
</section>
<section id="tiny-code-python-24" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-24">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rle_encode(s):</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> s:</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">""</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s)):</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>            result.append(<span class="ss">f"</span><span class="sc">{</span>count<span class="sc">}{</span>s[i<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>            count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>    result.append(<span class="ss">f"</span><span class="sc">{</span>count<span class="sc">}{</span>s[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">""</span>.join(result)</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rle_decode(encoded):</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> re</span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>    parts <span class="op">=</span> re.findall(<span class="vs">r'</span><span class="kw">(</span><span class="dv">\d</span><span class="op">+</span><span class="kw">)(</span><span class="dv">\D</span><span class="kw">)</span><span class="vs">'</span>, encoded)</span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">""</span>.join(sym <span class="op">*</span> <span class="bu">int</span>(cnt) <span class="cf">for</span> cnt, sym <span class="kw">in</span> parts)</span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"AAAAABBBCCDAA"</span></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a>encoded <span class="op">=</span> rle_encode(text)</span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>decoded <span class="op">=</span> rle_decode(encoded)</span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(encoded, decoded)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>5A3B2C1D2A AAAAABBBCCDAA</code></pre>
</section>
<section id="example-walkthrough-3" class="level4">
<h4 class="anchored" data-anchor-id="example-walkthrough-3">Example Walkthrough</h4>
<p>Input: <code>AAAABBCCCCD</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Current Symbol</th>
<th>Count</th>
<th>Encoded Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>4</td>
<td>→</td>
<td><code>4A</code></td>
</tr>
<tr class="even">
<td>B</td>
<td>2</td>
<td>→</td>
<td><code>2B</code></td>
</tr>
<tr class="odd">
<td>C</td>
<td>4</td>
<td>→</td>
<td><code>4C</code></td>
</tr>
<tr class="even">
<td>D</td>
<td>1</td>
<td>→</td>
<td><code>1D</code></td>
</tr>
</tbody>
</table>
<p>Final encoded string: <code>4A2B4C1D</code></p>
</section>
<section id="why-it-matters-55" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-55">Why It Matters</h4>
<ul>
<li><p>Simplicity: requires no statistical model or dictionary.</p></li>
<li><p>Efficiency: great for images, faxes, DNA sequences, or repeated characters.</p></li>
<li><p>Building block for more advanced compression schemes:</p>
<ul>
<li>TIFF, BMP, PCX image formats</li>
<li>DEFLATE preprocessing (in zlib, PNG)</li>
<li>Fax Group 3/4 standards</li>
</ul></li>
</ul>
</section>
<section id="when-it-works-well" class="level4">
<h4 class="anchored" data-anchor-id="when-it-works-well">When It Works Well</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 47%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Data Type</th>
<th>Example</th>
<th>Compression Benefit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Monochrome image</td>
<td>large white/black regions</td>
<td>High</td>
</tr>
<tr class="even">
<td>Plain text</td>
<td>spaces, tabs</td>
<td>Moderate</td>
</tr>
<tr class="odd">
<td>Binary data</td>
<td>many zeros (e.g.&nbsp;sparse bitmaps)</td>
<td>High</td>
</tr>
<tr class="even">
<td>Random data</td>
<td>no repetition</td>
<td>None or negative</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-55" class="level4">
<h4 class="anchored" data-anchor-id="complexity-55">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Decoding</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-55" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-55">Try It Yourself</h4>
<ol type="1">
<li>Encode and decode <code>"AAABBBAAACC"</code>.</li>
<li>Measure compression ratio = <span class="math inline">\(\text{compressed length} / \text{original length}\)</span>.</li>
<li>Try RLE on a text paragraph, does it help?</li>
<li>Modify code to use bytes <code>(count, symbol)</code> instead of text.</li>
<li>Combine RLE with Huffman coding, compress the RLE output.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-22" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-22">A Gentle Proof (Why It Works)</h4>
<p>If <span class="math inline">\(r\)</span> is the average run length, then RLE compresses from <span class="math inline">\(n\)</span> characters to approximately <span class="math inline">\(2n / r\)</span> symbols. Compression occurs when <span class="math inline">\(r &gt; 2\)</span> on average.</p>
<p>For highly repetitive data (<span class="math inline">\(r \gg 2\)</span>), the gain approaches:</p>
<p><span class="math display">\[
\text{compression ratio} \approx \frac{2}{r}
\]</span></p>
<p>Run-Length Encoding turns repetition into economy — it sees not each symbol, but the rhythm of their persistence.</p>
</section>
</section>
<section id="lz77-sliding-window-compression" class="level3">
<h3 class="anchored" data-anchor-id="lz77-sliding-window-compression">656 LZ77 (Sliding-Window Compression)</h3>
<p>LZ77 is a foundational compression algorithm invented by Abraham Lempel and Jacob Ziv in 1977. It introduced the idea of <em>sliding-window compression</em>, where repeated patterns are replaced by backward references. This concept underlies many modern compressors, including DEFLATE (ZIP, gzip), PNG, and Zstandard.</p>
<section id="what-problem-are-we-solving-55" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-55">What Problem Are We Solving?</h4>
<p>Redundancy in data often appears as repeated substrings rather than long identical runs. For example:</p>
<pre><code>ABABABA</code></pre>
<p>contains overlapping repetitions of <code>"ABA"</code>. RLE can’t handle this efficiently, but LZ77 can, by <em>referencing earlier occurrences</em> instead of repeating them.</p>
</section>
<section id="key-idea-4" class="level4">
<h4 class="anchored" data-anchor-id="key-idea-4">Key Idea</h4>
<p>Maintain a sliding window of recently seen data. When a new substring repeats part of that window, replace it with a (distance, length, next symbol) triple.</p>
<p>Each triple means:</p>
<blockquote class="blockquote">
<p>“Go back <code>distance</code> characters, copy <code>length</code> characters, then output <code>next</code>.”</p>
</blockquote>
</section>
<section id="example-44" class="level4">
<h4 class="anchored" data-anchor-id="example-44">Example</h4>
<p>Input:</p>
<pre><code>A B A B A B A</code></pre>
<p>Step-by-step compression (window shown progressively):</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 24%">
<col style="width: 19%">
<col style="width: 33%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Current Window</th>
<th>Next Symbol</th>
<th>Match Found</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>,</td>
<td>A</td>
<td>none</td>
<td>(0, 0, A)</td>
</tr>
<tr class="even">
<td>2</td>
<td>A</td>
<td>B</td>
<td>none</td>
<td>(0, 0, B)</td>
</tr>
<tr class="odd">
<td>3</td>
<td>AB</td>
<td>A</td>
<td>“A” at distance 2</td>
<td>(2, 1, B)</td>
</tr>
<tr class="even">
<td>4</td>
<td>ABA</td>
<td>B</td>
<td>“AB” at distance 2</td>
<td>(2, 2, A)</td>
</tr>
<tr class="odd">
<td>5</td>
<td>ABAB</td>
<td>A</td>
<td>“ABA” at distance 2</td>
<td>(2, 3, —)</td>
</tr>
</tbody>
</table>
<p>Final encoded sequence:</p>
<pre><code>(0,0,A) (0,0,B) (2,1,B) (2,2,A)</code></pre>
<p>Decoded output:</p>
<pre><code>ABABABA</code></pre>
</section>
<section id="how-it-works" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works">How It Works</h4>
<ol type="1">
<li><p>Initialize an empty search buffer (past) and a lookahead buffer (future).</p></li>
<li><p>For the next symbol(s) in the lookahead:</p>
<ul>
<li>Find the longest match in the search buffer.</li>
<li>Emit a triple <code>(distance, length, next_char)</code>.</li>
<li>Slide the window forward by <code>length + 1</code>.</li>
</ul></li>
<li><p>Continue until the end of input.</p></li>
</ol>
<p>The search buffer allows backward references, and the lookahead buffer limits how far ahead we match.</p>
</section>
<section id="tiny-code-python-simplified-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-simplified-1">Tiny Code (Python, Simplified)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lz77_compress(data, window_size<span class="op">=</span><span class="dv">16</span>):</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    i, output <span class="op">=</span> <span class="dv">0</span>, []</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(data):</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>        match <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>, data[i])</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dist <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">min</span>(i, window_size) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>            length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (i <span class="op">+</span> length <span class="op">&lt;</span> <span class="bu">len</span>(data) <span class="kw">and</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>                   data[i <span class="op">-</span> dist <span class="op">+</span> length] <span class="op">==</span> data[i <span class="op">+</span> length]):</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>                length <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> length <span class="op">&gt;</span> match[<span class="dv">1</span>]:</span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>                next_char <span class="op">=</span> data[i <span class="op">+</span> length] <span class="cf">if</span> i <span class="op">+</span> length <span class="op">&lt;</span> <span class="bu">len</span>(data) <span class="cf">else</span> <span class="st">''</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>                match <span class="op">=</span> (dist, length, next_char)</span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>        output.append(match)</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> match[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABABABA"</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lz77_compress(text))</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="co"># [(0,0,'A'), (0,0,'B'), (2,1,'B'), (2,2,'A')]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-56" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-56">Why It Matters</h4>
<ul>
<li>Foundation of DEFLATE (ZIP, gzip, PNG).</li>
<li>Enables powerful dictionary-based compression.</li>
<li>Self-referential: output can describe future data.</li>
<li>Works well on structured text, binaries, and repetitive data.</li>
</ul>
<p>Modern variants (LZSS, LZW, LZMA) extend or refine this model.</p>
</section>
<section id="compression-format" class="level4">
<h4 class="anchored" data-anchor-id="compression-format">Compression Format</h4>
<p>A typical LZ77 token:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Distance</td>
<td>How far back to look (bytes)</td>
</tr>
<tr class="even">
<td>Length</td>
<td>How many bytes to copy</td>
</tr>
<tr class="odd">
<td>Next Symbol</td>
<td>Literal following the match</td>
</tr>
</tbody>
</table>
<p>Example: <code>(distance=4, length=3, next='A')</code> → “copy 3 bytes from 4 positions back, then write A”.</p>
</section>
<section id="complexity-56" class="level4">
<h4 class="anchored" data-anchor-id="complexity-56">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding</td>
<td><span class="math inline">\(O(n w)\)</span> (window size <span class="math inline">\(w\)</span>)</td>
<td><span class="math inline">\(O(w)\)</span></td>
</tr>
<tr class="even">
<td>Decoding</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(w)\)</span></td>
</tr>
</tbody>
</table>
<p>Optimized implementations use hash tables or tries to reduce search cost.</p>
</section>
<section id="try-it-yourself-56" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-56">Try It Yourself</h4>
<ol type="1">
<li>Encode <code>"BANANA_BANDANA"</code>.</li>
<li>Experiment with different window sizes.</li>
<li>Visualize backward pointers as arrows between symbols.</li>
<li>Implement LZSS, skip storing <code>next_char</code> when unnecessary.</li>
<li>Combine with Huffman coding for DEFLATE-like compression.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-23" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-23">A Gentle Proof (Why It Works)</h4>
<p>Each emitted triple covers a non-overlapping substring of input. The reconstruction is unambiguous because each <code>(distance, length)</code> refers only to already-decoded data. Hence, LZ77 forms a self-consistent compression system with guaranteed lossless recovery.</p>
<p>Compression ratio improves with longer matching substrings: <span class="math display">\[
R \approx \frac{n}{n - \sum_i \text{length}_i}
\]</span></p>
<p>The more redundancy, the higher the compression.</p>
<p>LZ77 taught machines to <em>look back to move forward</em> — a model of memory and reuse that became the heartbeat of modern compression.</p>
</section>
</section>
<section id="lz78-dictionary-building" class="level3">
<h3 class="anchored" data-anchor-id="lz78-dictionary-building">657 LZ78 (Dictionary Building)</h3>
<p>LZ78, introduced by Abraham Lempel and Jacob Ziv in 1978, is the successor to LZ77. While LZ77 compresses using a <em>sliding window</em>, LZ78 instead builds an explicit dictionary of substrings encountered so far. Each new phrase is stored once, and later references point directly to dictionary entries.</p>
<p>This shift from window-based to dictionary-based compression paved the way for algorithms like LZW, GIF, and TIFF.</p>
<section id="what-problem-are-we-solving-56" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-56">What Problem Are We Solving?</h4>
<p>LZ77 reuses a <em>moving</em> window of previous text, which must be searched for every match. LZ78 improves efficiency by storing known substrings in a dictionary that grows dynamically. Instead of scanning backward, the encoder refers to dictionary entries directly by index.</p>
<p>This reduces search time and simplifies decoding, at the cost of managing a dictionary.</p>
</section>
<section id="the-core-idea-1" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-1">The Core Idea</h4>
<p>Each output token encodes:</p>
<p><span class="math display">\[
(\text{index}, \text{next symbol})
\]</span></p>
<p>where:</p>
<ul>
<li><code>index</code> points to the longest prefix already in the dictionary.</li>
<li><code>next symbol</code> is the new character that extends it.</li>
</ul>
<p>The pair defines a new entry added to the dictionary: <span class="math display">\[
\text{dict}[k] = \text{dict}[\text{index}] + \text{next symbol}
\]</span></p>
</section>
<section id="example-45" class="level4">
<h4 class="anchored" data-anchor-id="example-45">Example</h4>
<p>Let’s encode the string:</p>
<pre><code>ABAABABAABAB</code></pre>
<p>Step 1. Initialize an empty dictionary.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 25%">
<col style="width: 9%">
<col style="width: 20%">
<col style="width: 11%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Input</th>
<th>Longest Prefix</th>
<th>Index</th>
<th>Next Symbol</th>
<th>Output</th>
<th>New Entry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A</td>
<td>“”</td>
<td>0</td>
<td>A</td>
<td>(0, A)</td>
<td>1: A</td>
</tr>
<tr class="even">
<td>2</td>
<td>B</td>
<td>“”</td>
<td>0</td>
<td>B</td>
<td>(0, B)</td>
<td>2: B</td>
</tr>
<tr class="odd">
<td>3</td>
<td>A</td>
<td>A</td>
<td>1</td>
<td>B</td>
<td>(1, B)</td>
<td>3: AB</td>
</tr>
<tr class="even">
<td>4</td>
<td>A</td>
<td>A</td>
<td>1</td>
<td>A</td>
<td>(1, A)</td>
<td>4: AA</td>
</tr>
<tr class="odd">
<td>5</td>
<td>B</td>
<td>AB</td>
<td>3</td>
<td>A</td>
<td>(3, A)</td>
<td>5: ABA</td>
</tr>
<tr class="even">
<td>6</td>
<td>A</td>
<td>ABA</td>
<td>5</td>
<td>B</td>
<td>(5, B)</td>
<td>6: ABAB</td>
</tr>
</tbody>
</table>
<p>Final output:</p>
<pre><code>(0,A) (0,B) (1,B) (1,A) (3,A) (5,B)</code></pre>
<p>Dictionary at the end:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Index</th>
<th style="text-align: center;">Entry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">A</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">B</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">AB</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">AA</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">ABA</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">ABAB</td>
</tr>
</tbody>
</table>
<p>Decoded message is identical: <code>ABAABABAABAB</code>.</p>
</section>
<section id="tiny-code-python-25" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-25">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lz78_compress(s):</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    dictionary <span class="op">=</span> {}</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> []</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> <span class="st">""</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>    next_index <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> s:</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current <span class="op">+</span> c <span class="kw">in</span> dictionary:</span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>            current <span class="op">+=</span> c</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> dictionary.get(current, <span class="dv">0</span>)</span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>            output.append((idx, c))</span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>            dictionary[current <span class="op">+</span> c] <span class="op">=</span> next_index</span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>            next_index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> <span class="st">""</span></span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current:</span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a>        output.append((dictionary[current], <span class="st">""</span>))</span>
<span id="cb117-18"><a href="#cb117-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span>
<span id="cb117-19"><a href="#cb117-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-20"><a href="#cb117-20" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABAABABAABAB"</span></span>
<span id="cb117-21"><a href="#cb117-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lz78_compress(text))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$(0, 'A'), (0, 'B'), (1, 'B'), (1, 'A'), (3, 'A'), (5, 'B')]</code></pre>
</section>
<section id="decoding-process-1" class="level4">
<h4 class="anchored" data-anchor-id="decoding-process-1">Decoding Process</h4>
<p>Given encoded pairs <code>(index, symbol)</code>:</p>
<ol type="1">
<li><p>Initialize dictionary with <code>dict[0] = ""</code>.</p></li>
<li><p>For each pair:</p>
<ul>
<li>Output <code>dict[index] + symbol</code>.</li>
<li>Add it as a new dictionary entry.</li>
</ul></li>
</ol>
<p>Decoding reconstructs the text deterministically.</p>
</section>
<section id="why-it-matters-57" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-57">Why It Matters</h4>
<ul>
<li><p>Introduced explicit phrase dictionary, reusable across blocks.</p></li>
<li><p>No backward scanning, faster than LZ77 for large data.</p></li>
<li><p>Basis of LZW, which removes explicit symbol output and adds automatic dictionary management.</p></li>
<li><p>Used in:</p>
<ul>
<li>UNIX <code>compress</code></li>
<li>GIF and TIFF images</li>
<li>Old modem protocols (V.42bis)</li>
</ul></li>
</ul>
</section>
<section id="comparison" class="level4">
<h4 class="anchored" data-anchor-id="comparison">Comparison</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 35%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>LZ77</th>
<th>LZ78</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Model</td>
<td>Sliding window</td>
<td>Explicit dictionary</td>
</tr>
<tr class="even">
<td>Output</td>
<td>(distance, length, next)</td>
<td>(index, symbol)</td>
</tr>
<tr class="odd">
<td>Dictionary</td>
<td>Implicit (in stream)</td>
<td>Explicit (stored entries)</td>
</tr>
<tr class="even">
<td>Decoding</td>
<td>Immediate</td>
<td>Requires dictionary reconstruction</td>
</tr>
<tr class="odd">
<td>Successors</td>
<td>DEFLATE, LZMA</td>
<td>LZW, LZMW</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-57" class="level4">
<h4 class="anchored" data-anchor-id="complexity-57">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding</td>
<td><span class="math inline">\(O(n)\)</span> average</td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Decoding</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>Memory usage can grow with the number of unique substrings, so implementations often reset the dictionary when full.</p>
</section>
<section id="try-it-yourself-57" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-57">Try It Yourself</h4>
<ol type="1">
<li>Encode and decode <code>"TOBEORNOTTOBEORTOBEORNOT"</code>.</li>
<li>Print the dictionary evolution.</li>
<li>Compare output size with LZ77.</li>
<li>Implement dictionary reset at a fixed size (e.g.&nbsp;4096 entries).</li>
<li>Extend it to LZW by reusing indices without explicit characters.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-24" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-24">A Gentle Proof (Why It Works)</h4>
<p>Each emitted pair corresponds to a new phrase not seen before. Thus, every substring in the input can be expressed as a sequence of dictionary references. Because each new phrase extends a previous one by a single symbol, the dictionary is <em>prefix-closed</em>, ensuring unique reconstruction.</p>
<p>Compression efficiency improves with data redundancy:</p>
<p><span class="math display">\[
R \approx \frac{\text{\#pairs} \times (\log_2 N + \text{char bits})}{\text{input bits}}
\]</span></p>
<p>and approaches the entropy limit for large <span class="math inline">\(N\)</span>.</p>
<p>LZ78 taught compression to remember patterns as words, turning the sliding window of memory into a growing vocabulary of meaning.</p>
</section>
</section>
<section id="lzw-lempelzivwelch" class="level3">
<h3 class="anchored" data-anchor-id="lzw-lempelzivwelch">658 LZW (Lempel–Ziv–Welch)</h3>
<p>LZW, introduced by Terry Welch in 1984, is an optimized form of LZ78. It removes the need to transmit the <em>extra symbol</em> in each pair and instead relies on the dictionary itself to infer the next character. This small change made LZW faster, simpler, and perfect for real-world use, it powered GIF, TIFF, and UNIX compress.</p>
<section id="what-problem-are-we-solving-57" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-57">What Problem Are We Solving?</h4>
<p>LZ78 produces pairs of the form <code>(index, next_symbol)</code>, which adds extra data. LZW eliminates that redundancy: instead of sending the literal symbol, it transmits only dictionary indices, because the dictionary can predict the next symbol from previous context.</p>
<p>In short, LZW says:</p>
<blockquote class="blockquote">
<p>“If both encoder and decoder build the same dictionary in the same way, we only need to send the indices.”</p>
</blockquote>
</section>
<section id="core-idea-5" class="level4">
<h4 class="anchored" data-anchor-id="core-idea-5">Core Idea</h4>
<ol type="1">
<li><p>Initialize the dictionary with all single characters (e.g., ASCII 0–255).</p></li>
<li><p>Read the input symbol by symbol:</p>
<ul>
<li><p>Keep the longest string <code>w</code> found in the dictionary.</p></li>
<li><p>When <code>w + c</code> (current string + next character) is not found:</p>
<ul>
<li>Output the code for <code>w</code>.</li>
<li>Add <code>w + c</code> to the dictionary.</li>
<li>Set <code>w = c</code>.</li>
</ul></li>
</ul></li>
<li><p>When finished, output the code for the last <code>w</code>.</p></li>
</ol>
<p>Both encoder and decoder grow the dictionary identically, ensuring deterministic reconstruction.</p>
</section>
<section id="example-46" class="level4">
<h4 class="anchored" data-anchor-id="example-46">Example</h4>
<p>Let’s encode the string:</p>
<pre><code>TOBEORNOTTOBEORTOBEORNOT</code></pre>
<p>Step 1. Initialize the dictionary:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Code</th>
<th>Entry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–255</td>
<td>All ASCII characters</td>
</tr>
</tbody>
</table>
<p>Step 2. Encode step by step:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>w</th>
<th>c</th>
<th>Output</th>
<th>New Entry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>T</td>
<td>O</td>
<td>code(T) = 84</td>
<td>TO</td>
</tr>
<tr class="even">
<td>2</td>
<td>O</td>
<td>B</td>
<td>code(O) = 79</td>
<td>OB</td>
</tr>
<tr class="odd">
<td>3</td>
<td>B</td>
<td>E</td>
<td>code(B) = 66</td>
<td>BE</td>
</tr>
<tr class="even">
<td>4</td>
<td>E</td>
<td>O</td>
<td>code(E) = 69</td>
<td>EO</td>
</tr>
<tr class="odd">
<td>5</td>
<td>O</td>
<td>R</td>
<td>code(O) = 79</td>
<td>OR</td>
</tr>
<tr class="even">
<td>6</td>
<td>R</td>
<td>N</td>
<td>code(R) = 82</td>
<td>RN</td>
</tr>
<tr class="odd">
<td>7</td>
<td>N</td>
<td>O</td>
<td>code(N) = 78</td>
<td>NO</td>
</tr>
<tr class="even">
<td>8</td>
<td>O</td>
<td>T</td>
<td>code(O) = 79</td>
<td>OT</td>
</tr>
<tr class="odd">
<td>9</td>
<td>T</td>
<td>O</td>
<td>code(T) = 84</td>
<td>TO (already exists)</td>
</tr>
<tr class="even">
<td>10</td>
<td>TO</td>
<td>B</td>
<td>code(TO)</td>
<td>TOB</td>
</tr>
<tr class="odd">
<td>11</td>
<td>B</td>
<td>E</td>
<td>code(B) = 66</td>
<td>BE (already exists)</td>
</tr>
<tr class="even">
<td>12</td>
<td>E</td>
<td>O</td>
<td>code(E) = 69</td>
<td>EO (already exists)</td>
</tr>
</tbody>
</table>
<p>and so on…</p>
<p>Output sequence (partial):</p>
<pre><code>84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, ...</code></pre>
<p>Each number represents a code pointing to a dictionary entry.</p>
</section>
<section id="tiny-code-python-26" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-26">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lzw_compress(data):</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize dictionary with single characters</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    dict_size <span class="op">=</span> <span class="dv">256</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    dictionary <span class="op">=</span> {<span class="bu">chr</span>(i): i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(dict_size)}</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> <span class="st">""</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> data:</span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>        wc <span class="op">=</span> w <span class="op">+</span> c</span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> wc <span class="kw">in</span> dictionary:</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> wc</span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>            result.append(dictionary[w])</span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>            dictionary[wc] <span class="op">=</span> dict_size</span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>            dict_size <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> c</span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> w:</span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>        result.append(dictionary[w])</span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"TOBEORNOTTOBEORTOBEORNOT"</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>codes <span class="op">=</span> lzw_compress(text)</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(codes)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="decoding-process-2" class="level4">
<h4 class="anchored" data-anchor-id="decoding-process-2">Decoding Process</h4>
<p>Decoding reconstructs the text using the same logic in reverse:</p>
<ol type="1">
<li><p>Initialize dictionary with single characters.</p></li>
<li><p>Read the first code, output its character.</p></li>
<li><p>For each next code:</p>
<ul>
<li>If it exists in the dictionary → output it.</li>
<li>If not → output <code>w + first_char(w)</code> (special case for unseen code).</li>
<li>Add <code>w + first_char(current)</code> to the dictionary.</li>
<li>Update <code>w</code>.</li>
</ul></li>
</ol>
</section>
<section id="why-it-matters-58" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-58">Why It Matters</h4>
<ul>
<li><p>Dictionary-based efficiency: compact and fast.</p></li>
<li><p>No need to send dictionary or symbols.</p></li>
<li><p>Simple to implement in both hardware and software.</p></li>
<li><p>Used in real-world formats:</p>
<ul>
<li>GIF</li>
<li>TIFF</li>
<li>UNIX compress</li>
<li>PostScript / PDF</li>
</ul></li>
</ul>
</section>
<section id="comparison-with-lz78" class="level4">
<h4 class="anchored" data-anchor-id="comparison-with-lz78">Comparison with LZ78</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>LZ78</th>
<th>LZW</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Output</td>
<td>(index, symbol)</td>
<td>index only</td>
</tr>
<tr class="even">
<td>Dictionary</td>
<td>Explicit entries</td>
<td>Grows implicitly</td>
</tr>
<tr class="odd">
<td>Efficiency</td>
<td>Slightly less</td>
<td>Better on real data</td>
</tr>
<tr class="even">
<td>Used in</td>
<td>Research</td>
<td>Real-world standards</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-58" class="level4">
<h4 class="anchored" data-anchor-id="complexity-58">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding</td>
<td><span class="math inline">\(O(n)\)</span> average</td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Decoding</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
<p>Compression ratio improves with repetitive phrases and longer dictionaries.</p>
</section>
<section id="try-it-yourself-58" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-58">Try It Yourself</h4>
<ol type="1">
<li>Compress and decompress <code>"TOBEORNOTTOBEORTOBEORNOT"</code>.</li>
<li>Print dictionary growth step by step.</li>
<li>Try it on a text paragraph, notice the repeating words’ compression.</li>
<li>Modify for lowercase ASCII only (size 26).</li>
<li>Experiment with dictionary reset after 4096 entries (as in GIF).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-25" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-25">A Gentle Proof (Why It Works)</h4>
<p>Since both encoder and decoder start with identical dictionaries and add entries in the same sequence, the same index sequence leads to the same reconstruction. The dictionary grows by prefix extension, each new entry is a previous entry plus one symbol, ensuring deterministic decoding.</p>
<p>For long input of entropy <span class="math inline">\(H\)</span>, the average code length approaches <span class="math inline">\(H + 1\)</span> bits per symbol, making LZW asymptotically optimal for stationary sources.</p>
<p>LZW transformed compression into pure memory and inference — a dance of codes where meaning is built, shared, and never transmitted twice.</p>
</section>
</section>
<section id="burrowswheeler-transform-bwt" class="level3">
<h3 class="anchored" data-anchor-id="burrowswheeler-transform-bwt">659 Burrows–Wheeler Transform (BWT)</h3>
<p>The Burrows–Wheeler Transform (BWT), invented by Michael Burrows and David Wheeler in 1994, is a landmark in lossless compression. Unlike previous schemes that directly encode data, BWT rearranges it, transforming the input into a form that’s easier for compressors like RLE or Huffman to exploit.</p>
<p>The beauty of BWT is that it’s reversible and structure-preserving: it clusters similar characters together, amplifying patterns before actual encoding.</p>
<section id="what-problem-are-we-solving-58" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-58">What Problem Are We Solving?</h4>
<p>Traditional compressors operate locally, they detect patterns over small windows or dictionaries. However, when similar symbols are far apart, they fail to exploit global structure efficiently.</p>
<p>BWT solves this by sorting all rotations of a string, then extracting the last column, effectively grouping similar contexts together. This rearrangement doesn’t reduce entropy but makes it <em>easier</em> to compress with simple algorithms like RLE or Huffman.</p>
</section>
<section id="the-key-idea" class="level4">
<h4 class="anchored" data-anchor-id="the-key-idea">The Key Idea</h4>
<p>Given a string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>, append a special end marker <code>$</code> that is lexicographically smaller than any character. Form all cyclic rotations of <span class="math inline">\(S\)</span> and sort them lexicographically. The BWT output is the last column of this sorted matrix.</p>
<p>The transformation also records the index of the original string within the sorted list (needed for reversal).</p>
</section>
<section id="example-47" class="level4">
<h4 class="anchored" data-anchor-id="example-47">Example</h4>
<p>Input:</p>
<pre><code>BANANA$</code></pre>
<p>Step 1. Generate all rotations:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Rotation</th>
<th style="text-align: center;">String</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">BANANA$</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">ANANA<span class="math inline">\(B |
|     2    | NANA\)</span>BA</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">ANA<span class="math inline">\(BAN |
|     4    | NA\)</span>BANA</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">A$BANAN</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6</td>
<td style="text-align: center;">$BANANA</td>
</tr>
</tbody>
</table>
<p>Step 2. Sort all rotations lexicographically:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 35%">
<col style="width: 23%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Sorted Index</th>
<th style="text-align: center;">Rotation</th>
<th style="text-align: center;">Last Character</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(BANANA |        A       |
|       1      |  A\)</span>BANAN</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">ANA<span class="math inline">\(BAN |        N       |
|       3      |  ANANA\)</span>B</td>
<td style="text-align: center;">A</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">BANANA$</td>
<td style="text-align: center;">$</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">NA<span class="math inline">\(BANA |        A       |
|       6      |  NANA\)</span>BA</td>
<td style="text-align: center;">A</td>
</tr>
</tbody>
</table>
<p>Step 3. Extract last column (L):</p>
<pre><code>L = ANNA$AA</code></pre>
<p>and record the index of the original string (<code>BANANA$</code>) → row 4.</p>
<p>So, BWT output = (L = ANNA$AA, index = 4)</p>
</section>
<section id="decoding-inverse-bwt" class="level4">
<h4 class="anchored" data-anchor-id="decoding-inverse-bwt">Decoding (Inverse BWT)</h4>
<p>To reverse the transform, reconstruct the table column by column:</p>
<ol type="1">
<li>Start with the last column <code>L</code>.</li>
<li>Repeatedly prepend <code>L</code> to existing rows and sort after each iteration.</li>
<li>After <code>n</code> iterations, the row containing <code>$</code> at the end is the original string.</li>
</ol>
<p>For <code>L = ANNA$AA</code>, index = 4:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 74%">
</colgroup>
<thead>
<tr class="header">
<th>Iteration</th>
<th>Table (sorted each round)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A, N, N, A, <span class="math inline">\(, A, A        |
| 2         | A\)</span>, AN, AN, NA, N<span class="math inline">\(, AA, AA |
| 3         | ANA, NAN, NNA, A\)</span>B, etc.</td>
</tr>
</tbody>
</table>
<p>…eventually yields back <code>BANANA$</code>.</p>
<p>Efficient decoding skips building the full matrix using the LF-mapping relation: <span class="math display">\[
\text{next}(i) = C[L[i]] + \text{rank}(L, i, L[i])
\]</span> where <span class="math inline">\(C[c]\)</span> is the count of characters lexicographically smaller than <span class="math inline">\(c\)</span>.</p>
</section>
<section id="tiny-code-python-27" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-27">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bwt_transform(s):</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> s <span class="op">+</span> <span class="st">"$"</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    rotations <span class="op">=</span> [s[i:] <span class="op">+</span> s[:i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s))]</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    rotations.sort()</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>    last_column <span class="op">=</span> <span class="st">''</span>.join(row[<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> row <span class="kw">in</span> rotations)</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> rotations.index(s)</span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> last_column, index</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bwt_inverse(last_column, index):</span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(last_column)</span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>    table <span class="op">=</span> [<span class="st">""</span>] <span class="op">*</span> n</span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>        table <span class="op">=</span> <span class="bu">sorted</span>([last_column[i] <span class="op">+</span> table[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> table[index].rstrip(<span class="st">"$"</span>)</span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a>L, idx <span class="op">=</span> bwt_transform(<span class="st">"BANANA"</span>)</span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L, idx)</span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(bwt_inverse(L, idx))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>ANNA$AA 4
BANANA</code></pre>
</section>
<section id="why-it-matters-59" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-59">Why It Matters</h4>
<ul>
<li><p>Structure amplifier: Groups identical symbols by context, improving performance of:</p>
<ul>
<li>Run-Length Encoding (RLE)</li>
<li>Move-To-Front (MTF)</li>
<li>Huffman or Arithmetic Coding</li>
</ul></li>
<li><p>Foundation of modern compressors:</p>
<ul>
<li>bzip2</li>
<li>zstd’s preprocessing</li>
<li>FM-Index in bioinformatics</li>
</ul></li>
<li><p>Enables searchable compressed text via suffix arrays and ranks.</p></li>
</ul>
</section>
<section id="complexity-59" class="level4">
<h4 class="anchored" data-anchor-id="complexity-59">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Transform</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Inverse</td>
<td><span class="math inline">\(O(n)\)</span> (with LF mapping)</td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-59" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-59">Try It Yourself</h4>
<ol type="1">
<li>Apply BWT to <code>"MISSISSIPPI"</code>.</li>
<li>Combine with Run-Length Encoding.</li>
<li>Test compression ratio.</li>
<li>Compare result before and after applying BWT.</li>
<li>Visualize rotation matrix for small words.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-26" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-26">A Gentle Proof (Why It Works)</h4>
<p>BWT doesn’t compress; it permutes the data so that symbols with similar contexts appear near each other. Since most texts are locally predictable, this reduces entropy <em>after transformation</em>:</p>
<p><span class="math display">\[
H(\text{BWT}(S)) = H(S)
\]</span></p>
<p>but the transformed data exhibits longer runs and simpler local structure, which compressors like Huffman can exploit more effectively.</p>
<p>The Burrows–Wheeler Transform is compression’s quiet magician — it doesn’t shrink data itself but rearranges it into order, turning chaos into compressible calm.</p>
</section>
</section>
<section id="move-to-front-mtf-encoding" class="level3">
<h3 class="anchored" data-anchor-id="move-to-front-mtf-encoding">660 Move-to-Front (MTF) Encoding</h3>
<p>Move-to-Front (MTF) is a simple yet powerful transformation used in combination with the Burrows–Wheeler Transform (BWT). Its purpose is to turn localized symbol repetitions, produced by BWT, into sequences of small integers, which are highly compressible by Run-Length Encoding (RLE) or Huffman coding.</p>
<section id="what-problem-are-we-solving-59" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-59">What Problem Are We Solving?</h4>
<p>After applying BWT, the transformed string contains clusters of identical symbols. To take advantage of that, we want to represent symbols by how <em>recently</em> they appeared.</p>
<p>If we maintain a list of all possible symbols and move each accessed symbol to the front, then frequent symbols will have small indices, producing many zeros and ones, ideal for entropy coding.</p>
</section>
<section id="key-idea-5" class="level4">
<h4 class="anchored" data-anchor-id="key-idea-5">Key Idea</h4>
<p>Maintain an ordered list of all symbols (the “alphabet”). For each symbol in the input:</p>
<ol type="1">
<li>Output its position index in the current list.</li>
<li>Move that symbol to the front of the list.</li>
</ol>
<p>This captures locality, recently used symbols appear earlier and thus get smaller indices.</p>
</section>
<section id="example-48" class="level4">
<h4 class="anchored" data-anchor-id="example-48">Example</h4>
<p>Input sequence:</p>
<pre><code>banana</code></pre>
<p>Alphabet (initial): <code>[a, b, n]</code></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Symbol</th>
<th>List Before</th>
<th>Index</th>
<th>List After</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>b</td>
<td>[a, b, n]</td>
<td>1</td>
<td>[b, a, n]</td>
</tr>
<tr class="even">
<td>2</td>
<td>a</td>
<td>[b, a, n]</td>
<td>1</td>
<td>[a, b, n]</td>
</tr>
<tr class="odd">
<td>3</td>
<td>n</td>
<td>[a, b, n]</td>
<td>2</td>
<td>[n, a, b]</td>
</tr>
<tr class="even">
<td>4</td>
<td>a</td>
<td>[n, a, b]</td>
<td>1</td>
<td>[a, n, b]</td>
</tr>
<tr class="odd">
<td>5</td>
<td>n</td>
<td>[a, n, b]</td>
<td>1</td>
<td>[n, a, b]</td>
</tr>
<tr class="even">
<td>6</td>
<td>a</td>
<td>[n, a, b]</td>
<td>1</td>
<td>[a, n, b]</td>
</tr>
</tbody>
</table>
<p>Encoded output:</p>
<pre><code>$$1, 1, 2, 1, 1, 1]</code></pre>
<p>Notice how frequent letters (“a”, “n”) are represented with small numbers.</p>
</section>
<section id="decoding-process-3" class="level4">
<h4 class="anchored" data-anchor-id="decoding-process-3">Decoding Process</h4>
<p>Given the encoded indices and initial alphabet:</p>
<ol type="1">
<li>For each index, pick the symbol at that position.</li>
<li>Output it and move it to the front of the list.</li>
</ol>
<p>The process is perfectly reversible because both encoder and decoder perform identical list updates.</p>
</section>
<section id="tiny-code-python-28" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-28">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mtf_encode(data, alphabet):</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    symbols <span class="op">=</span> <span class="bu">list</span>(alphabet)</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> data:</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>        index <span class="op">=</span> symbols.index(c)</span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>        result.append(index)</span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>        symbols.insert(<span class="dv">0</span>, symbols.pop(index))</span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mtf_decode(indices, alphabet):</span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>    symbols <span class="op">=</span> <span class="bu">list</span>(alphabet)</span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> indices:</span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> symbols[i]</span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>        result.append(c)</span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a>        symbols.insert(<span class="dv">0</span>, symbols.pop(i))</span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(result)</span>
<span id="cb129-18"><a href="#cb129-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-19"><a href="#cb129-19" aria-hidden="true" tabindex="-1"></a>alphabet <span class="op">=</span> <span class="bu">list</span>(<span class="st">"abn"</span>)</span>
<span id="cb129-20"><a href="#cb129-20" aria-hidden="true" tabindex="-1"></a>encoded <span class="op">=</span> mtf_encode(<span class="st">"banana"</span>, alphabet)</span>
<span id="cb129-21"><a href="#cb129-21" aria-hidden="true" tabindex="-1"></a>decoded <span class="op">=</span> mtf_decode(encoded, <span class="bu">list</span>(<span class="st">"abn"</span>))</span>
<span id="cb129-22"><a href="#cb129-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(encoded, decoded)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$1, 1, 2, 1, 1, 1] banana</code></pre>
</section>
<section id="why-it-matters-60" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-60">Why It Matters</h4>
<ul>
<li><p>Pairs beautifully with BWT:</p>
<ul>
<li>BWT groups similar symbols together.</li>
<li>MTF converts those groups into small indices.</li>
<li>RLE or Huffman coding then compresses the small numbers efficiently.</li>
</ul></li>
<li><p>Used in:</p>
<ul>
<li>bzip2</li>
<li>block-sorting compressors</li>
<li>text indexing systems (FM-Index)</li>
</ul></li>
</ul>
<p>MTF itself does not compress, it transforms data into a shape that’s easier to compress.</p>
</section>
<section id="intuitive-example-after-bwt" class="level4">
<h4 class="anchored" data-anchor-id="intuitive-example-after-bwt">Intuitive Example (After BWT)</h4>
<p>Suppose BWT output is:</p>
<pre><code>AAAAABBBBCCCC</code></pre>
<p>MTF output becomes something like:</p>
<pre><code>0,0,0,0,1,1,1,1,2,2,2,2</code></pre>
<p>Now RLE or Huffman can compress these tiny integers extremely efficiently.</p>
</section>
<section id="complexity-60" class="level4">
<h4 class="anchored" data-anchor-id="complexity-60">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding</td>
<td><span class="math inline">\(O(n \cdot | \Sigma | )\)</span> (naive)</td>
<td><span class="math inline">\(O( | \Sigma | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Decoding</td>
<td><span class="math inline">\(O(n \cdot | \Sigma | )\)</span></td>
<td><span class="math inline">\(O( | \Sigma | )\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Optimized implementations use linked lists or direct-mapped arrays to reduce per-symbol cost to near <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="try-it-yourself-60" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-60">Try It Yourself</h4>
<ol type="1">
<li>Apply MTF to the BWT of <code>"BANANA$"</code> (→ <code>ANNA$AA</code>).</li>
<li>Encode result: you’ll get many low numbers.</li>
<li>Follow with RLE + Huffman to achieve full compression.</li>
<li>Compare compressed size before and after MTF.</li>
<li>Change the alphabet order, see how it changes results.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-27" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-27">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(f(c)\)</span> be the frequency of symbol <span class="math inline">\(c\)</span>. After BWT, identical symbols tend to appear consecutively, so their first appearance moves them to the front of the list, and subsequent appearances yield index <code>0</code>. Thus, the expected output index is proportional to the distance between identical symbols, making MTF effective for locality-rich data.</p>
<p>Entropy after MTF tends to be lower than before:</p>
<p><span class="math display">\[
H_\text{MTF}(X) \leq H(X)
\]</span></p>
<p>for structured inputs (not necessarily for random data).</p>
<p>Move-to-Front Encoding captures the <em>recency of symbols</em> — a minimalist memory that keeps what’s fresh right in front, ready to make compression beautifully simple.</p>
</section>
</section>
</section>
<section id="section-67.-cryptographic-hashes-and-checksum" class="level1">
<h1>Section 67. Cryptographic Hashes and Checksum</h1>
<section id="rolling-hash" class="level3">
<h3 class="anchored" data-anchor-id="rolling-hash">661 Rolling Hash</h3>
<p>The Rolling Hash is a clever hashing technique that allows you to compute hash values of overlapping substrings efficiently. It forms the backbone of algorithms like Rabin–Karp, Rabin fingerprinting, and string deduplication systems used in text search and data synchronization.</p>
<section id="what-problem-are-we-solving-60" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-60">What Problem Are We Solving?</h4>
<p>In many problems, you need to compare substrings or sliding windows efficiently. Naively recomputing the hash of every substring takes <span class="math inline">\(O(m)\)</span> per step, leading to <span class="math inline">\(O(nm)\)</span> overall, too slow for large inputs.</p>
<p>A rolling hash lets you update the hash in constant time when the window slides by one position, reducing total time to <span class="math inline">\(O(n)\)</span>.</p>
</section>
<section id="the-core-idea-2" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-2">The Core Idea</h4>
<p>Represent a string as a number in a chosen base and compute its value modulo a large prime:</p>
<p><span class="math display">\[
H(s_0 s_1 \dots s_{m-1}) = (s_0 b^{m-1} + s_1 b^{m-2} + \dots + s_{m-1}) \bmod M
\]</span></p>
<p>When the window moves by one character (drop <code>old</code> and add <code>new</code>), the hash can be updated efficiently:</p>
<p><span class="math display">\[
H_{\text{new}} = (b(H_{\text{old}} - s_0 b^{m-1}) + s_m) \bmod M
\]</span></p>
<p>This means we can slide across the text and compute new hashes in <span class="math inline">\(O(1)\)</span> time.</p>
</section>
<section id="example-49" class="level4">
<h4 class="anchored" data-anchor-id="example-49">Example</h4>
<p>Consider the string <code>ABCD</code> with base <span class="math inline">\(b = 256\)</span> and modulus <span class="math inline">\(M = 101\)</span>.</p>
<p>Compute:</p>
<p><span class="math display">\[
H("ABC") = (65 \times 256^2 + 66 \times 256 + 67) \bmod 101
\]</span></p>
<p>When the window slides from <code>"ABC"</code> to <code>"BCD"</code>:</p>
<p><span class="math display">\[
H("BCD") = (b(H("ABC") - 65 \times 256^2) + 68) \bmod 101
\]</span></p>
<p>This efficiently removes <code>'A'</code> and adds <code>'D'</code>.</p>
</section>
<section id="tiny-code-python-29" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-29">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rolling_hash(s, base<span class="op">=</span><span class="dv">256</span>, mod<span class="op">=</span><span class="dv">101</span>):</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> s:</span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> (h <span class="op">*</span> base <span class="op">+</span> <span class="bu">ord</span>(c)) <span class="op">%</span> mod</span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h</span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_hash(old_hash, left_char, right_char, power, base<span class="op">=</span><span class="dv">256</span>, mod<span class="op">=</span><span class="dv">101</span>):</span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># remove leftmost char, add rightmost char</span></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>    old_hash <span class="op">=</span> (old_hash <span class="op">-</span> <span class="bu">ord</span>(left_char) <span class="op">*</span> power) <span class="op">%</span> mod</span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    old_hash <span class="op">=</span> (old_hash <span class="op">*</span> base <span class="op">+</span> <span class="bu">ord</span>(right_char)) <span class="op">%</span> mod</span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> old_hash</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Usage:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"ABCD"</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>mod <span class="op">=</span> <span class="dv">101</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> <span class="dv">256</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>power <span class="op">=</span> <span class="bu">pow</span>(base, m<span class="op">-</span><span class="dv">1</span>, mod)</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> rolling_hash(text[:m], base, mod)</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(text) <span class="op">-</span> m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> update_hash(h, text[i<span class="op">-</span><span class="dv">1</span>], text[i<span class="op">+</span>m<span class="op">-</span><span class="dv">1</span>], power, base, mod)</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(h)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-61" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-61">Why It Matters</h4>
<ul>
<li>Constant-time sliding: hash updates in <span class="math inline">\(O(1)\)</span></li>
<li>Ideal for substring search: used in Rabin–Karp</li>
<li>Used in deduplication systems (rsync, git)</li>
<li>Foundation of polynomial hashing and rolling checksums (Adler-32, Rabin fingerprinting)</li>
</ul>
<p>Rolling hashes balance speed and accuracy, with large enough modulus and base, collisions are rare.</p>
</section>
<section id="collision-and-modulus" class="level4">
<h4 class="anchored" data-anchor-id="collision-and-modulus">Collision and Modulus</h4>
<p>Collisions happen when two different substrings share the same hash. We minimize them by:</p>
<ol type="1">
<li>Using a large prime modulus <span class="math inline">\(M\)</span>, often near <span class="math inline">\(2^{61} - 1\)</span>.</li>
<li>Using double hashing with two different <span class="math inline">\((b, M)\)</span> pairs.</li>
<li>Occasionally verifying matches by direct string comparison.</li>
</ol>
</section>
<section id="complexity-61" class="level4">
<h4 class="anchored" data-anchor-id="complexity-61">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compute first hash</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Slide update</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Total over text</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-61" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-61">Try It Yourself</h4>
<ol type="1">
<li>Compute rolling hashes for all substrings of <code>"BANANA"</code> of length 3.</li>
<li>Use modulus <span class="math inline">\(M = 101\)</span>, base <span class="math inline">\(b = 256\)</span>.</li>
<li>Compare collision rate for small vs large <span class="math inline">\(M\)</span>.</li>
<li>Modify the code to use two moduli for double hashing.</li>
<li>Implement Rabin–Karp substring search using this rolling hash.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-28" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-28">A Gentle Proof (Why It Works)</h4>
<p>When we slide from window <span class="math inline">\([i, i+m-1]\)</span> to <span class="math inline">\([i+1, i+m]\)</span>, the contribution of the dropped character is known in advance, so we can adjust the hash without recomputing everything.</p>
<p>Since modulo arithmetic is linear:</p>
<p><span class="math display">\[
H(s_1 \dots s_m) = (b(H(s_0 \dots s_{m-1}) - s_0 b^{m-1}) + s_m) \bmod M
\]</span></p>
<p>This property ensures correctness while preserving constant-time updates.</p>
<p>Rolling Hash is the quiet workhorse of modern text processing — it doesn’t look for patterns directly, it summarizes, slides, and lets arithmetic find the matches.</p>
</section>
</section>
<section id="crc32-cyclic-redundancy-check" class="level3">
<h3 class="anchored" data-anchor-id="crc32-cyclic-redundancy-check">662 CRC32 (Cyclic Redundancy Check)</h3>
<p>The Cyclic Redundancy Check (CRC) is a checksum algorithm that detects errors in digital data. It’s widely used in networks, storage, and file formats (like ZIP, PNG, Ethernet) to ensure that data was transmitted or stored correctly.</p>
<p>CRC32 is a common 32-bit variant, fast, simple, and highly reliable for detecting random errors.</p>
<section id="what-problem-are-we-solving-61" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-61">What Problem Are We Solving?</h4>
<p>When data is transmitted over a channel or written to disk, bits can flip due to noise or corruption. We need a way to detect whether received data is identical to what was sent.</p>
<p>A simple checksum (like summing bytes) can miss many errors. CRC treats data as a polynomial over GF(2) and performs division by a fixed generator polynomial, producing a remainder that acts as a strong integrity check.</p>
</section>
<section id="the-core-idea-3" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-3">The Core Idea</h4>
<p>Think of the data as a binary polynomial:</p>
<p><span class="math display">\[
M(x) = m_0x^{n-1} + m_1x^{n-2} + \dots + m_{n-1}
\]</span></p>
<p>Choose a generator polynomial <span class="math inline">\(G(x)\)</span> of degree <span class="math inline">\(r\)</span> (for CRC32, <span class="math inline">\(r=32\)</span>). We append <span class="math inline">\(r\)</span> zeros to the message and divide by <span class="math inline">\(G(x)\)</span> using modulo-2 arithmetic:</p>
<p><span class="math display">\[
R(x) = (M(x) \cdot x^r) \bmod G(x)
\]</span></p>
<p>Then, transmit:</p>
<p><span class="math display">\[
T(x) = M(x) \cdot x^r + R(x)
\]</span></p>
<p>At the receiver, the same division is performed. If the remainder is zero, the message is assumed valid.</p>
<p>All operations use XOR instead of subtraction since arithmetic is in GF(2).</p>
</section>
<section id="example-simple-crc" class="level4">
<h4 class="anchored" data-anchor-id="example-simple-crc">Example (Simple CRC)</h4>
<p>Let <span class="math inline">\(G(x) = x^3 + x + 1\)</span> (binary 1011). Message: <code>1101</code>.</p>
<ol type="1">
<li>Append three zeros → <code>1101000</code></li>
<li>Divide <code>1101000</code> by <code>1011</code> (mod-2).</li>
<li>The remainder is <code>010</code>.</li>
<li>Transmit <code>1101010</code>.</li>
</ol>
<p>At the receiver, dividing by the same polynomial gives remainder <code>0</code>, confirming integrity.</p>
</section>
<section id="crc32-polynomial" class="level4">
<h4 class="anchored" data-anchor-id="crc32-polynomial">CRC32 Polynomial</h4>
<p>CRC32 uses the polynomial:</p>
<p><span class="math display">\[
G(x) = x^{32} + x^{26} + x^{23} + x^{22} + x^{16} + x^{12} + x^{11} + x^{10} + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1
\]</span></p>
<p>In hexadecimal: <code>0x04C11DB7</code>.</p>
</section>
<section id="tiny-code-c" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb135"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="dt">uint32_t</span> crc32<span class="op">(</span><span class="dt">uint8_t</span> <span class="op">*</span>data<span class="op">,</span> <span class="dt">size_t</span> len<span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> crc <span class="op">=</span> <span class="bn">0xFFFFFFFF</span><span class="op">;</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>        crc <span class="op">^=</span> data<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>crc <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a>                crc <span class="op">=</span> <span class="op">(</span>crc <span class="op">&gt;&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">^</span> <span class="bn">0xEDB88320</span><span class="op">;</span></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a>                crc <span class="op">&gt;&gt;=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> crc <span class="op">^</span> <span class="bn">0xFFFFFFFF</span><span class="op">;</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> msg<span class="op">[]</span> <span class="op">=</span> <span class="st">"HELLO"</span><span class="op">;</span></span>
<span id="cb135-20"><a href="#cb135-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"CRC32: </span><span class="sc">%08X\n</span><span class="st">"</span><span class="op">,</span> crc32<span class="op">(</span>msg<span class="op">,</span> <span class="dv">5</span><span class="op">));</span></span>
<span id="cb135-21"><a href="#cb135-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>CRC32: 3610A686</code></pre>
</section>
<section id="tiny-code-python-30" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-30">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> crc32(data: <span class="bu">bytes</span>):</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    crc <span class="op">=</span> <span class="bn">0xFFFFFFFF</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> b <span class="kw">in</span> data:</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>        crc <span class="op">^=</span> b</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>):</span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> crc <span class="op">&amp;</span> <span class="dv">1</span>:</span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>                crc <span class="op">=</span> (crc <span class="op">&gt;&gt;</span> <span class="dv">1</span>) <span class="op">^</span> <span class="bn">0xEDB88320</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>                crc <span class="op">&gt;&gt;=</span> <span class="dv">1</span></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> crc <span class="op">^</span> <span class="bn">0xFFFFFFFF</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">hex</span>(crc32(<span class="st">b"HELLO"</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>0x3610a686</code></pre>
</section>
<section id="why-it-matters-62" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-62">Why It Matters</h4>
<ul>
<li><p>Error detection, not correction</p></li>
<li><p>Detects:</p>
<ul>
<li>All single-bit and double-bit errors</li>
<li>Odd numbers of bit errors</li>
<li>Burst errors shorter than 32 bits</li>
</ul></li>
<li><p>Used in:</p>
<ul>
<li>Ethernet, ZIP, PNG, gzip, TCP/IP checksums</li>
<li>Filesystems and data transmission protocols</li>
</ul></li>
</ul>
<p>CRC is fast, hardware-friendly, and mathematically grounded in polynomial division.</p>
</section>
<section id="complexity-62" class="level4">
<h4 class="anchored" data-anchor-id="complexity-62">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 53%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding</td>
<td><span class="math inline">\(O(nr)\)</span> (bitwise) or <span class="math inline">\(O(n)\)</span> (table-driven)</td>
<td><span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(256)\)</span> lookup</td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Table-based CRC implementations can compute checksums for megabytes of data per second.</p>
</section>
<section id="try-it-yourself-62" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-62">Try It Yourself</h4>
<ol type="1">
<li>Compute CRC3 for message <code>1101</code> using generator <code>1011</code>.</li>
<li>Compare remainders for small vs large polynomials.</li>
<li>Implement CRC16 and CRC32 in Python.</li>
<li>Flip one bit, verify CRC detects the error.</li>
<li>Visualize polynomial division with XOR operations.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-29" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-29">A Gentle Proof (Why It Works)</h4>
<p>Because CRC uses polynomial division over GF(2), each error pattern <span class="math inline">\(E(x)\)</span> has a unique remainder modulo <span class="math inline">\(G(x)\)</span>. If <span class="math inline">\(G(x)\)</span> is chosen so that no low-weight <span class="math inline">\(E(x)\)</span> divides it, then all small errors are guaranteed to change the remainder.</p>
<p>CRC32’s generator polynomial is carefully designed to catch the most likely error types in real communication systems.</p>
<p>CRC32 is the silent guardian of data integrity — fast enough for every packet, reliable enough for every disk, and simple enough to live in a few lines of C.</p>
</section>
</section>
<section id="adler-32-checksum" class="level3">
<h3 class="anchored" data-anchor-id="adler-32-checksum">663 Adler-32 Checksum</h3>
<p>Adler-32 is a simple and efficient checksum algorithm designed as a lightweight alternative to CRC32. It combines speed and reasonable error detection, making it popular in applications like zlib, PNG, and other data compression libraries.</p>
<section id="what-problem-are-we-solving-62" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-62">What Problem Are We Solving?</h4>
<p>CRC32 provides strong error detection but involves bitwise operations and polynomial arithmetic, which can be slower on some systems. For lightweight applications (like verifying compressed data), we need a faster, easy-to-implement checksum that still detects common transmission errors.</p>
<p>Adler-32 achieves this using modular arithmetic over integers rather than polynomials.</p>
</section>
<section id="the-core-idea-4" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-4">The Core Idea</h4>
<p>Adler-32 maintains two running sums, one for data bytes and one for the cumulative total.</p>
<p>Let the message be <span class="math inline">\(m_1, m_2, \dots, m_n\)</span>, each an unsigned byte.</p>
<p>Compute two values:</p>
<p><span class="math display">\[
A = 1 + \sum_{i=1}^{n} m_i \pmod{65521}
\]</span></p>
<p><span class="math display">\[
B = 0 + \sum_{i=1}^{n} A_i \pmod{65521}
\]</span></p>
<p>The final checksum is:</p>
<p><span class="math display">\[
\text{Adler-32}(M) = (B \ll 16) + A
\]</span></p>
<p>Here, 65521 is the largest prime smaller than <span class="math inline">\(2^{16}\)</span>, chosen for good modular behavior.</p>
</section>
<section id="example-50" class="level4">
<h4 class="anchored" data-anchor-id="example-50">Example</h4>
<p>Message: <code>"Hi"</code></p>
<p>Characters:</p>
<pre><code>'H' = 72
'i' = 105</code></pre>
<p>Compute:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>A (mod 65521)</th>
<th>B (mod 65521)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Init</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>+H (72)</td>
<td>73</td>
<td>73</td>
</tr>
<tr class="odd">
<td>+i (105)</td>
<td>178</td>
<td>251</td>
</tr>
</tbody>
</table>
<p>Then:</p>
<p><span class="math display">\[
\text{Checksum} = (251 \ll 16) + 178 = 16449842
\]</span></p>
<p>In hexadecimal:</p>
<pre><code>Adler-32 = 0x00FB00B2</code></pre>
</section>
<section id="tiny-code-c-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-1">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb141"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a><span class="dt">uint32_t</span> adler32<span class="op">(</span><span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>data<span class="op">,</span> <span class="dt">size_t</span> len<span class="op">)</span> <span class="op">{</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> A <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> B <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">uint32_t</span> MOD <span class="op">=</span> <span class="dv">65521</span><span class="op">;</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> <span class="op">(</span>A <span class="op">+</span> data<span class="op">[</span>i<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> <span class="op">(</span>B <span class="op">+</span> A<span class="op">)</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>B <span class="op">&lt;&lt;</span> <span class="dv">16</span><span class="op">)</span> <span class="op">|</span> A<span class="op">;</span></span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> msg<span class="op">[]</span> <span class="op">=</span> <span class="st">"Hello"</span><span class="op">;</span></span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Adler-32: </span><span class="sc">%08X\n</span><span class="st">"</span><span class="op">,</span> adler32<span class="op">(</span>msg<span class="op">,</span> <span class="dv">5</span><span class="op">));</span></span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Adler-32: 062C0215</code></pre>
</section>
<section id="tiny-code-python-31" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-31">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> adler32(data: <span class="bu">bytes</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>    MOD <span class="op">=</span> <span class="dv">65521</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    A, B <span class="op">=</span> <span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> b <span class="kw">in</span> data:</span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> (A <span class="op">+</span> b) <span class="op">%</span> MOD</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> (B <span class="op">+</span> A) <span class="op">%</span> MOD</span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (B <span class="op">&lt;&lt;</span> <span class="dv">16</span>) <span class="op">|</span> A</span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">hex</span>(adler32(<span class="st">b"Hello"</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>0x62c0215</code></pre>
</section>
<section id="why-it-matters-63" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-63">Why It Matters</h4>
<ul>
<li><p>Simpler than CRC32, just addition and modulo</p></li>
<li><p>Fast on small systems, especially in software</p></li>
<li><p>Good for short data and quick integrity checks</p></li>
<li><p>Used in:</p>
<ul>
<li>zlib</li>
<li>PNG image format</li>
<li>network protocols needing low-cost validation</li>
</ul></li>
</ul>
<p>However, Adler-32 is less robust than CRC32 for long or highly repetitive data.</p>
</section>
<section id="comparison-1" class="level4">
<h4 class="anchored" data-anchor-id="comparison-1">Comparison</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>CRC32</th>
<th>Adler-32</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arithmetic</td>
<td>Polynomial (GF(2))</td>
<td>Integer (mod prime)</td>
</tr>
<tr class="even">
<td>Bits</td>
<td>32</td>
<td>32</td>
</tr>
<tr class="odd">
<td>Speed</td>
<td>Moderate</td>
<td>Very fast</td>
</tr>
<tr class="even">
<td>Error detection</td>
<td>Strong</td>
<td>Weaker</td>
</tr>
<tr class="odd">
<td>Typical use</td>
<td>Networking, storage</td>
<td>Compression, local checks</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-63" class="level4">
<h4 class="anchored" data-anchor-id="complexity-63">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Encoding</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-63" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-63">Try It Yourself</h4>
<ol type="1">
<li>Compute Adler-32 of <code>"BANANA"</code>.</li>
<li>Flip one byte and recompute, observe checksum change.</li>
<li>Compare execution time vs CRC32 on large data.</li>
<li>Experiment with removing modulo to see integer overflow behavior.</li>
<li>Implement incremental checksum updates for streaming data.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-30" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-30">A Gentle Proof (Why It Works)</h4>
<p>Adler-32 treats the message as two-layered accumulation:</p>
<ul>
<li>The A sum ensures local sensitivity (each byte affects the total).</li>
<li>The B sum weights earlier bytes more heavily, amplifying positional effects.</li>
</ul>
<p>Because of the modulo prime arithmetic, small bit flips yield large changes in the checksum, enough to catch random noise with high probability.</p>
<p>Adler-32 is a study in simplicity — just two sums and a modulus, yet fast enough to guard every PNG and compressed stream.</p>
</section>
</section>
<section id="md5-message-digest-5" class="level3">
<h3 class="anchored" data-anchor-id="md5-message-digest-5">664 MD5 (Message Digest 5)</h3>
<p>MD5 is one of the most well-known cryptographic hash functions. It takes an arbitrary-length input and produces a 128-bit hash, a compact “fingerprint” of the data. Although once widely used, MD5 is now considered cryptographically broken, but it remains useful in non-security applications like data integrity checks.</p>
<section id="what-problem-are-we-solving-63" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-63">What Problem Are We Solving?</h4>
<p>We need a fixed-size “digest” that uniquely identifies data blocks, files, or messages. A good hash function should satisfy three key properties:</p>
<ol type="1">
<li>Preimage resistance, hard to find a message from its hash.</li>
<li>Second-preimage resistance, hard to find another message with the same hash.</li>
<li>Collision resistance, hard to find any two messages with the same hash.</li>
</ol>
<p>MD5 was designed to meet these goals efficiently, though only the first two hold up in limited use today.</p>
</section>
<section id="the-core-idea-5" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-5">The Core Idea</h4>
<p>MD5 processes data in 512-bit blocks, updating an internal state of four 32-bit words <span class="math inline">\((A, B, C, D)\)</span>.</p>
<p>At the end, these are concatenated to form the final 128-bit digest.</p>
<p>The algorithm consists of four main steps:</p>
<ol type="1">
<li><p>Padding the message to make its length congruent to 448 mod 512, then appending the original length (as a 64-bit value).</p></li>
<li><p>Initialization of the buffer:</p>
<p><span class="math display">\[
A = 0x67452301, \quad
B = 0xEFCDAB89, \quad
C = 0x98BADCFE, \quad
D = 0x10325476
\]</span></p></li>
<li><p>Processing each 512-bit block through four nonlinear rounds of operations using bitwise logic (AND, OR, XOR, NOT), additions, and rotations.</p></li>
<li><p>Output: concatenate <span class="math inline">\((A, B, C, D)\)</span> into a 128-bit digest.</p></li>
</ol>
</section>
<section id="main-transformation-simplified" class="level4">
<h4 class="anchored" data-anchor-id="main-transformation-simplified">Main Transformation (Simplified)</h4>
<p>For each 32-bit chunk:</p>
<p><span class="math display">\[
A = B + ((A + F(B, C, D) + X_k + T_i) \lll s)
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(F\)</span> is one of four nonlinear functions (changes per round),</li>
<li><span class="math inline">\(X_k\)</span> is a 32-bit block word,</li>
<li><span class="math inline">\(T_i\)</span> is a sine-based constant, and</li>
<li><span class="math inline">\(\lll s\)</span> is a left rotation.</li>
</ul>
<p>Each round modifies <span class="math inline">\((A, B, C, D)\)</span>, creating diffusion and nonlinearity.</p>
</section>
<section id="tiny-code-python-32" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-32">Tiny Code (Python)</h4>
<p>This example uses the standard <code>hashlib</code> library:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hashlib</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">b"Hello, world!"</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>digest <span class="op">=</span> hashlib.md5(data).hexdigest()</span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"MD5:"</span>, digest)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>MD5: 6cd3556deb0da54bca060b4c39479839</code></pre>
</section>
<section id="tiny-code-c-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-2">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb147"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;openssl/md5.h&gt;</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> digest<span class="op">[</span>MD5_DIGEST_LENGTH<span class="op">];</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>msg <span class="op">=</span> <span class="st">"Hello, world!"</span><span class="op">;</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>    MD5<span class="op">((</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*)</span>msg<span class="op">,</span> strlen<span class="op">(</span>msg<span class="op">),</span> digest<span class="op">);</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"MD5: "</span><span class="op">);</span></span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> MD5_DIGEST_LENGTH<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%02x</span><span class="st">"</span><span class="op">,</span> digest<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>MD5: 6cd3556deb0da54bca060b4c39479839</code></pre>
</section>
<section id="why-it-matters-64" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-64">Why It Matters</h4>
<ul>
<li><p>Fast: computes hashes very quickly</p></li>
<li><p>Compact: 128-bit output (32 hex characters)</p></li>
<li><p>Deterministic: same input → same hash</p></li>
<li><p>Used in:</p>
<ul>
<li>File integrity checks</li>
<li>Versioning systems (e.g., git object naming)</li>
<li>Deduplication tools</li>
<li>Legacy digital signatures</li>
</ul></li>
</ul>
<p>However, do not use MD5 for cryptographic security, it’s vulnerable to collision and chosen-prefix attacks.</p>
</section>
<section id="collisions-and-security" class="level4">
<h4 class="anchored" data-anchor-id="collisions-and-security">Collisions and Security</h4>
<p>Researchers have found that two different messages <span class="math inline">\(m_1 \neq m_2\)</span> can produce the same MD5 hash:</p>
<p><span class="math display">\[
\text{MD5}(m_1) = \text{MD5}(m_2)
\]</span></p>
<p>Modern attacks can generate such collisions in seconds on consumer hardware. For any security-sensitive purpose, use SHA-256 or higher.</p>
</section>
<section id="comparison-2" class="level4">
<h4 class="anchored" data-anchor-id="comparison-2">Comparison</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>MD5</th>
<th>SHA-1</th>
<th>SHA-256</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Output bits</td>
<td>128</td>
<td>160</td>
<td>256</td>
</tr>
<tr class="even">
<td>Speed</td>
<td>Fast</td>
<td>Moderate</td>
<td>Slower</td>
</tr>
<tr class="odd">
<td>Security</td>
<td>Broken</td>
<td>Weak</td>
<td>Strong</td>
</tr>
<tr class="even">
<td>Collisions found</td>
<td>Yes</td>
<td>Yes</td>
<td>None practical</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-64" class="level4">
<h4 class="anchored" data-anchor-id="complexity-64">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hashing</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-64" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-64">Try It Yourself</h4>
<ol type="1">
<li>Compute the MD5 of <code>"apple"</code> and <code>"APPLE"</code>.</li>
<li>Concatenate two files and hash again, does the hash change predictably?</li>
<li>Experiment with <code>md5sum</code> on your terminal.</li>
<li>Compare results with SHA-1 and SHA-256.</li>
<li>Search for known MD5 collision examples online and verify hashes yourself.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-31" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-31">A Gentle Proof (Why It Works)</h4>
<p>Each MD5 operation is a combination of modular addition and bit rotation, nonlinear over GF(2). These create avalanche effects, where flipping one bit of input changes about half of the bits in the output.</p>
<p>This ensures that small input changes yield drastically different hashes, though its collision resistance is mathematically compromised.</p>
<p>MD5 remains an elegant lesson in early cryptographic design — a fast, human-readable fingerprint, and a historical marker of how security evolves with computation.</p>
</section>
</section>
<section id="sha-1-secure-hash-algorithm-1" class="level3">
<h3 class="anchored" data-anchor-id="sha-1-secure-hash-algorithm-1">665 SHA-1 (Secure Hash Algorithm 1)</h3>
<p>SHA-1 is a 160-bit cryptographic hash function, once a cornerstone of digital signatures, SSL certificates, and version control systems. It improved upon MD5 with a longer digest and more rounds, but like MD5, it has since been broken, though still valuable for understanding the evolution of modern hashing.</p>
<section id="what-problem-are-we-solving-64" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-64">What Problem Are We Solving?</h4>
<p>Like MD5, SHA-1 compresses an arbitrary-length input into a fixed-size hash (160 bits). It was designed to provide stronger collision resistance and message integrity verification for use in authentication, encryption, and checksums.</p>
</section>
<section id="the-core-idea-6" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-6">The Core Idea</h4>
<p>SHA-1 works block by block, processing the message in 512-bit chunks. It maintains five 32-bit registers <span class="math inline">\((A, B, C, D, E)\)</span> that evolve through 80 rounds of bitwise operations, shifts, and additions.</p>
<p>At a high level:</p>
<ol type="1">
<li><p>Preprocessing</p>
<ul>
<li>Pad the message so its length is congruent to 448 mod 512.</li>
<li>Append the message length as a 64-bit integer.</li>
</ul></li>
<li><p>Initialization</p>
<ul>
<li>Set initial values: <span class="math display">\[
\begin{aligned}
H_0 &amp;= 0x67452301 \
H_1 &amp;= 0xEFCDAB89 \
H_2 &amp;= 0x98BADCFE \
H_3 &amp;= 0x10325476 \
H_4 &amp;= 0xC3D2E1F0
\end{aligned}
\]</span></li>
</ul></li>
<li><p>Processing Each Block</p>
<ul>
<li>Break each 512-bit block into 16 words <span class="math inline">\(W_0, W_1, \dots, W_{15}\)</span>.</li>
<li>Extend them to <span class="math inline">\(W_{16} \dots W_{79}\)</span> using: <span class="math display">\[
W_t = (W_{t-3} \oplus W_{t-8} \oplus W_{t-14} \oplus W_{t-16}) \lll 1
\]</span></li>
<li>Perform 80 rounds of updates: <span class="math display">\[
T = (A \lll 5) + f_t(B, C, D) + E + W_t + K_t
\]</span> Then shift registers: <span class="math inline">\(E = D, D = C, C = B \lll 30, B = A, A = T\)</span> (with round-dependent function <span class="math inline">\(f_t\)</span> and constant <span class="math inline">\(K_t\)</span>).</li>
</ul></li>
<li><p>Output</p>
<ul>
<li>Add <span class="math inline">\((A, B, C, D, E)\)</span> to <span class="math inline">\((H_0, \dots, H_4)\)</span>.</li>
<li>The final hash is the concatenation of <span class="math inline">\(H_0\)</span> through <span class="math inline">\(H_4\)</span>.</li>
</ul></li>
</ol>
</section>
<section id="round-functions" class="level4">
<h4 class="anchored" data-anchor-id="round-functions">Round Functions</h4>
<p>SHA-1 cycles through four different nonlinear Boolean functions:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 10%">
<col style="width: 64%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th>Rounds</th>
<th>Function</th>
<th>Formula</th>
<th>Constant <span class="math inline">\(K_t\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0–19</td>
<td>Choose</td>
<td><span class="math inline">\(f = (B \land C) \lor (\lnot B \land D)\)</span></td>
<td>0x5A827999</td>
</tr>
<tr class="even">
<td>20–39</td>
<td>Parity</td>
<td><span class="math inline">\(f = B \oplus C \oplus D\)</span></td>
<td>0x6ED9EBA1</td>
</tr>
<tr class="odd">
<td>40–59</td>
<td>Majority</td>
<td><span class="math inline">\(f = (B \land C) \lor (B \land D) \lor (C \land D)\)</span></td>
<td>0x8F1BBCDC</td>
</tr>
<tr class="even">
<td>60–79</td>
<td>Parity</td>
<td><span class="math inline">\(f = B \oplus C \oplus D\)</span></td>
<td>0xCA62C1D6</td>
</tr>
</tbody>
</table>
<p>These functions create nonlinear mixing and diffusion across bits.</p>
</section>
<section id="tiny-code-python-33" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-33">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hashlib</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>msg <span class="op">=</span> <span class="st">b"Hello, world!"</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>digest <span class="op">=</span> hashlib.sha1(msg).hexdigest()</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SHA-1:"</span>, digest)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SHA-1: d3486ae9136e7856bc42212385ea797094475802</code></pre>
</section>
<section id="tiny-code-c-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-3">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb151"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;openssl/sha.h&gt;</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> digest<span class="op">[</span>SHA_DIGEST_LENGTH<span class="op">];</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>msg <span class="op">=</span> <span class="st">"Hello, world!"</span><span class="op">;</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>    SHA1<span class="op">((</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*)</span>msg<span class="op">,</span> strlen<span class="op">(</span>msg<span class="op">),</span> digest<span class="op">);</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"SHA-1: "</span><span class="op">);</span></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> SHA_DIGEST_LENGTH<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%02x</span><span class="st">"</span><span class="op">,</span> digest<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb151-14"><a href="#cb151-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SHA-1: d3486ae9136e7856bc42212385ea797094475802</code></pre>
</section>
<section id="why-it-matters-65" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-65">Why It Matters</h4>
<ul>
<li>Extended output: 160 bits instead of MD5’s 128.</li>
<li>Wider adoption: used in SSL, Git, PGP, and digital signatures.</li>
<li>Still deterministic and fast, suitable for data fingerprinting.</li>
</ul>
<p>But it’s cryptographically deprecated, collisions can be found in hours using modern hardware.</p>
</section>
<section id="known-attacks" class="level4">
<h4 class="anchored" data-anchor-id="known-attacks">Known Attacks</h4>
<p>In 2017, Google and CWI Amsterdam demonstrated SHAttered, a practical collision attack:</p>
<p><span class="math display">\[
\text{SHA1}(m_1) = \text{SHA1}(m_2)
\]</span></p>
<p>where <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> were distinct PDF files.</p>
<p>The attack required about <span class="math inline">\(2^{63}\)</span> operations, feasible with cloud resources.</p>
<p>SHA-1 is now considered insecure for cryptography and should be replaced with SHA-256 or SHA-3.</p>
</section>
<section id="comparison-3" class="level4">
<h4 class="anchored" data-anchor-id="comparison-3">Comparison</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>MD5</th>
<th>SHA-1</th>
<th>SHA-256</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Output bits</td>
<td>128</td>
<td>160</td>
<td>256</td>
</tr>
<tr class="even">
<td>Rounds</td>
<td>64</td>
<td>80</td>
<td>64</td>
</tr>
<tr class="odd">
<td>Security</td>
<td>Broken</td>
<td>Broken</td>
<td>Strong</td>
</tr>
<tr class="even">
<td>Collision resistance</td>
<td><span class="math inline">\(2^{64}\)</span></td>
<td><span class="math inline">\(2^{80}\)</span></td>
<td><span class="math inline">\(2^{128}\)</span> (approx.)</td>
</tr>
<tr class="odd">
<td>Status</td>
<td>Deprecated</td>
<td>Deprecated</td>
<td>Recommended</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-65" class="level4">
<h4 class="anchored" data-anchor-id="complexity-65">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hashing</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>SHA-1 remains computationally efficient, around 300 MB/s in C implementations.</p>
</section>
<section id="try-it-yourself-65" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-65">Try It Yourself</h4>
<ol type="1">
<li>Compute SHA-1 of <code>"Hello"</code> and <code>"hello"</code>, notice the avalanche effect.</li>
<li>Concatenate two files and compare SHA-1 and SHA-256 digests.</li>
<li>Use <code>sha1sum</code> on Linux to verify file integrity.</li>
<li>Study the SHAttered PDFs online and verify their identical hashes.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-32" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-32">A Gentle Proof (Why It Works)</h4>
<p>Each bit of the input influences every bit of the output through a cascade of rotations and modular additions. The design ensures diffusion, small changes in input propagate widely, and confusion through nonlinear Boolean mixing.</p>
<p>Despite its elegance, mathematical weaknesses in its round structure allow attackers to manipulate internal states to produce collisions.</p>
<p>SHA-1 marked a turning point in cryptographic history — beautifully engineered, globally adopted, and a reminder that even strong math must evolve faster than computation.</p>
</section>
</section>
<section id="sha-256-secure-hash-algorithm-256-bit" class="level3">
<h3 class="anchored" data-anchor-id="sha-256-secure-hash-algorithm-256-bit">666 SHA-256 (Secure Hash Algorithm 256-bit)</h3>
<p>SHA-256 is one of the most widely used cryptographic hash functions today. It’s part of the SHA-2 family, standardized by NIST, and provides strong security for digital signatures, blockchain systems, and general data integrity. Unlike its predecessors MD5 and SHA-1, SHA-256 remains unbroken in practice.</p>
<section id="what-problem-are-we-solving-65" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-65">What Problem Are We Solving?</h4>
<p>We need a function that produces a unique, fixed-size digest for any input — but with strong resistance to collisions, preimages, and second preimages.</p>
<p>SHA-256 delivers that: it maps arbitrary-length data into a 256-bit digest, creating a nearly impossible-to-invert fingerprint used for secure verification and identification.</p>
</section>
<section id="the-core-idea-7" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-7">The Core Idea</h4>
<p>SHA-256 processes data in 512-bit blocks, updating eight 32-bit working registers through 64 rounds of modular arithmetic, logical operations, and message expansion.</p>
<p>Each round mixes bits in a nonlinear, irreversible way, achieving diffusion and confusion across the entire message.</p>
</section>
<section id="initialization-2" class="level4">
<h4 class="anchored" data-anchor-id="initialization-2">Initialization</h4>
<p>SHA-256 begins with eight fixed constants:</p>
<p><span class="math display">\[
\begin{aligned}
H_0 &amp;= 0x6a09e667, \quad H_1 = 0xbb67ae85, \
H_2 &amp;= 0x3c6ef372, \quad H_3 = 0xa54ff53a, \
H_4 &amp;= 0x510e527f, \quad H_5 = 0x9b05688c, \
H_6 &amp;= 0x1f83d9ab, \quad H_7 = 0x5be0cd19
\end{aligned}
\]</span></p>
</section>
<section id="message-expansion" class="level4">
<h4 class="anchored" data-anchor-id="message-expansion">Message Expansion</h4>
<p>Each 512-bit block is split into 16 words <span class="math inline">\(W_0 \dots W_{15}\)</span> and extended to 64 words:</p>
<p><span class="math display">\[
W_t = \sigma_1(W_{t-2}) + W_{t-7} + \sigma_0(W_{t-15}) + W_{t-16}
\]</span></p>
<p>with <span class="math display">\[
\sigma_0(x) = (x \mathbin{&gt;&gt;&gt;} 7) \oplus (x \mathbin{&gt;&gt;&gt;} 18) \oplus (x &gt;&gt; 3)
\]</span> <span class="math display">\[
\sigma_1(x) = (x \mathbin{&gt;&gt;&gt;} 17) \oplus (x \mathbin{&gt;&gt;&gt;} 19) \oplus (x &gt;&gt; 10)
\]</span></p>
</section>
<section id="round-function" class="level4">
<h4 class="anchored" data-anchor-id="round-function">Round Function</h4>
<p>For each of 64 rounds:</p>
<p><span class="math display">\[
\begin{aligned}
T_1 &amp;= H + \Sigma_1(E) + Ch(E, F, G) + K_t + W_t \
T_2 &amp;= \Sigma_0(A) + Maj(A, B, C) \
H &amp;= G \
G &amp;= F \
F &amp;= E \
E &amp;= D + T_1 \
D &amp;= C \
C &amp;= B \
B &amp;= A \
A &amp;= T_1 + T_2
\end{aligned}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\begin{aligned}
Ch(x,y,z) &amp;= (x \land y) \oplus (\lnot x \land z) \
Maj(x,y,z) &amp;= (x \land y) \oplus (x \land z) \oplus (y \land z) \
\Sigma_0(x) &amp;= (x \mathbin{&gt;&gt;&gt;} 2) \oplus (x \mathbin{&gt;&gt;&gt;} 13) \oplus (x \mathbin{&gt;&gt;&gt;} 22) \
\Sigma_1(x) &amp;= (x \mathbin{&gt;&gt;&gt;} 6) \oplus (x \mathbin{&gt;&gt;&gt;} 11) \oplus (x \mathbin{&gt;&gt;&gt;} 25)
\end{aligned}
\]</span></p>
<p>Constants <span class="math inline">\(K_t\)</span> are 64 predefined 32-bit values derived from cube roots of primes.</p>
</section>
<section id="finalization" class="level4">
<h4 class="anchored" data-anchor-id="finalization">Finalization</h4>
<p>After all rounds, the hash values are updated:</p>
<p><span class="math display">\[
H_i = H_i + \text{working\_register}_i \quad \text{for } i = 0 \dots 7
\]</span></p>
<p>The final digest is the concatenation of <span class="math inline">\((H_0, H_1, \dots, H_7)\)</span>, forming a 256-bit hash.</p>
</section>
<section id="tiny-code-python-34" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-34">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hashlib</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">b"Hello, world!"</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>digest <span class="op">=</span> hashlib.sha256(data).hexdigest()</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SHA-256:"</span>, digest)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SHA-256: c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a</code></pre>
</section>
<section id="tiny-code-c-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-4">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb155"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;openssl/sha.h&gt;</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> digest<span class="op">[</span>SHA256_DIGEST_LENGTH<span class="op">];</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>msg <span class="op">=</span> <span class="st">"Hello, world!"</span><span class="op">;</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a>    SHA256<span class="op">((</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*)</span>msg<span class="op">,</span> strlen<span class="op">(</span>msg<span class="op">),</span> digest<span class="op">);</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"SHA-256: "</span><span class="op">);</span></span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> SHA256_DIGEST_LENGTH<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%02x</span><span class="st">"</span><span class="op">,</span> digest<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SHA-256: c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a</code></pre>
</section>
<section id="why-it-matters-66" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-66">Why It Matters</h4>
<ul>
<li>Strong collision resistance (no practical attacks)</li>
<li>Used in cryptographic protocols: TLS, PGP, SSH, Bitcoin, Git</li>
<li>Efficient: processes large data quickly</li>
<li>Deterministic and irreversible</li>
</ul>
<p>SHA-256 underpins blockchain integrity, every Bitcoin block is linked by SHA-256 hashes.</p>
</section>
<section id="security-comparison" class="level4">
<h4 class="anchored" data-anchor-id="security-comparison">Security Comparison</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>MD5</th>
<th>SHA-1</th>
<th>SHA-256</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Output bits</td>
<td>128</td>
<td>160</td>
<td>256</td>
</tr>
<tr class="even">
<td>Collisions found</td>
<td>Yes</td>
<td>Yes</td>
<td>None practical</td>
</tr>
<tr class="odd">
<td>Security</td>
<td>Broken</td>
<td>Broken</td>
<td>Secure</td>
</tr>
<tr class="even">
<td>Typical use</td>
<td>Legacy</td>
<td>Legacy</td>
<td>Modern security</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-66" class="level4">
<h4 class="anchored" data-anchor-id="complexity-66">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hashing</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>SHA-256 is fast enough for real-time use but designed to resist hardware brute-force attacks.</p>
</section>
<section id="try-it-yourself-66" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-66">Try It Yourself</h4>
<ol type="1">
<li>Hash <code>"hello"</code> and <code>"Hello"</code>, see how much the output changes.</li>
<li>Compare SHA-256 vs SHA-512 speed.</li>
<li>Implement message padding by hand for small examples.</li>
<li>Experiment with Bitcoin block header hashing.</li>
<li>Compute double SHA-256 of a file and compare with <code>sha256sum</code>.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-33" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-33">A Gentle Proof (Why It Works)</h4>
<p>SHA-256’s strength lies in its nonlinear mixing, bit rotation, and modular addition, which spread every input bit’s influence across all output bits. Because every round scrambles data through independent functions and constants, the process is practically irreversible.</p>
<p>Mathematically, there’s no known way to invert or collide SHA-256 faster than brute force (<span class="math inline">\(2^{128}\)</span> effort).</p>
<p>SHA-256 is the cryptographic backbone of the digital age — trusted by blockchains, browsers, and systems everywhere — a balance of elegance, speed, and mathematical hardness.</p>
</section>
</section>
<section id="sha-3-keccak" class="level3">
<h3 class="anchored" data-anchor-id="sha-3-keccak">667 SHA-3 (Keccak)</h3>
<p>SHA-3, also known as Keccak, is the latest member of the Secure Hash Algorithm family, standardized by NIST in 2015. It represents a complete redesign, not a patch, introducing the sponge construction, which fundamentally changes how hashing works. SHA-3 is flexible, secure, and mathematically elegant.</p>
<section id="what-problem-are-we-solving-66" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-66">What Problem Are We Solving?</h4>
<p>SHA-2 (like SHA-256) is strong, but it shares internal structure with older hashes such as SHA-1 and MD5. If a major cryptanalytic breakthrough appeared against that structure, the entire family could be at risk.</p>
<p>SHA-3 was designed as a cryptographic fallback, a completely different approach, immune to the same types of attacks, yet compatible with existing use cases.</p>
</section>
<section id="the-core-idea-sponge-construction" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-sponge-construction">The Core Idea, Sponge Construction</h4>
<p>SHA-3 absorbs and squeezes data through a sponge function, based on a large internal state of 1600 bits.</p>
<ul>
<li><p>The sponge has two parameters:</p>
<ul>
<li>Rate (r), how many bits are processed per round.</li>
<li>Capacity (c), how many bits remain hidden (for security).</li>
</ul></li>
</ul>
<p>For SHA3-256, <span class="math inline">\(r = 1088\)</span> and <span class="math inline">\(c = 512\)</span>, since <span class="math inline">\(r + c = 1600\)</span>.</p>
<p>The process alternates between two phases:</p>
<ol type="1">
<li><p>Absorb phase The input is XORed into the state, block by block, then transformed by the Keccak permutation.</p></li>
<li><p>Squeeze phase The output bits are read from the state; more rounds are applied if more bits are needed.</p></li>
</ol>
</section>
<section id="keccak-state-and-transformation" class="level4">
<h4 class="anchored" data-anchor-id="keccak-state-and-transformation">Keccak State and Transformation</h4>
<p>The internal state is a 3D array of bits, visualized as <span class="math inline">\(5 \times 5\)</span> lanes of 64 bits each:</p>
<p><span class="math display">\[
A[x][y][z], \quad 0 \le x, y &lt; 5, ; 0 \le z &lt; 64
\]</span></p>
<p>Each round of Keccak applies five transformations:</p>
<ol type="1">
<li>θ (theta), column parity mixing</li>
<li>ρ (rho), bit rotation</li>
<li>π (pi), lane permutation</li>
<li>χ (chi), nonlinear mixing (bitwise logic)</li>
<li>ι (iota), round constant injection</li>
</ol>
<p>Each round scrambles bits across the state, achieving diffusion and confusion like a fluid stirring in 3D.</p>
</section>
<section id="padding-rule" class="level4">
<h4 class="anchored" data-anchor-id="padding-rule">Padding Rule</h4>
<p>Before processing, the message is padded using the multi-rate padding rule:</p>
<p><span class="math display">\[
\text{pad}(M) = M , || , 0x06 , || , 00...0 , || , 0x80
\]</span></p>
<p>This ensures that each message is unique, even with similar lengths.</p>
</section>
<section id="tiny-code-python-35" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-35">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb157"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hashlib</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">b"Hello, world!"</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>digest <span class="op">=</span> hashlib.sha3_256(data).hexdigest()</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SHA3-256:"</span>, digest)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SHA3-256: 644bcc7e564373040999aac89e7622f3ca71fba1d972fd94a31c3bfbf24e3938</code></pre>
</section>
<section id="tiny-code-c-openssl" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-openssl">Tiny Code (C, OpenSSL)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb159"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;openssl/evp.h&gt;</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> digest<span class="op">[</span><span class="dv">32</span><span class="op">];</span></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>msg <span class="op">=</span> <span class="st">"Hello, world!"</span><span class="op">;</span></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>    EVP_Digest<span class="op">(</span>msg<span class="op">,</span> strlen<span class="op">(</span>msg<span class="op">),</span> digest<span class="op">,</span> NULL<span class="op">,</span> EVP_sha3_256<span class="op">(),</span> NULL<span class="op">);</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"SHA3-256: "</span><span class="op">);</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">32</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%02x</span><span class="st">"</span><span class="op">,</span> digest<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SHA3-256: 644bcc7e564373040999aac89e7622f3ca71fba1d972fd94a31c3bfbf24e3938</code></pre>
</section>
<section id="why-it-matters-67" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-67">Why It Matters</h4>
<ul>
<li>Completely different design, not Merkle–Damgård like MD5/SHA-2</li>
<li>Mathematically clean and provable sponge model</li>
<li>Supports variable output lengths (SHAKE128, SHAKE256)</li>
<li>Resists all known cryptanalytic attacks</li>
</ul>
<p>Used in:</p>
<ul>
<li>Blockchain research (e.g., Ethereum uses Keccak-256)</li>
<li>Post-quantum cryptography frameworks</li>
<li>Digital forensics and verifiable ledgers</li>
</ul>
</section>
<section id="comparison-4" class="level4">
<h4 class="anchored" data-anchor-id="comparison-4">Comparison</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Structure</th>
<th>Output bits</th>
<th>Year</th>
<th>Security Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MD5</td>
<td>Merkle–Damgård</td>
<td>128</td>
<td>1992</td>
<td>Broken</td>
</tr>
<tr class="even">
<td>SHA-1</td>
<td>Merkle–Damgård</td>
<td>160</td>
<td>1995</td>
<td>Broken</td>
</tr>
<tr class="odd">
<td>SHA-256</td>
<td>Merkle–Damgård</td>
<td>256</td>
<td>2001</td>
<td>Secure</td>
</tr>
<tr class="even">
<td>SHA-3</td>
<td>Sponge (Keccak)</td>
<td>256</td>
<td>2015</td>
<td>Secure</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-67" class="level4">
<h4 class="anchored" data-anchor-id="complexity-67">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hashing</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Although SHA-3 is slower than SHA-256 in pure software, it scales better in hardware and parallel implementations.</p>
</section>
<section id="try-it-yourself-67" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-67">Try It Yourself</h4>
<ol type="1">
<li><p>Compute both <code>sha256()</code> and <code>sha3_256()</code> for the same file, compare outputs.</p></li>
<li><p>Experiment with variable-length digests using SHAKE256:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> hashlib <span class="im">import</span> shake_256</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(shake_256(<span class="st">b"hello"</span>).hexdigest(<span class="dv">64</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p>Visualize Keccak’s 5×5×64-bit state, draw how rounds mix the lanes.</p></li>
<li><p>Implement a toy sponge function with XOR and rotation to understand the design.</p></li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-34" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-34">A Gentle Proof (Why It Works)</h4>
<p>Unlike Merkle–Damgård constructions, which extend hashes block by block, the sponge absorbs input into a large nonlinear state, hiding correlations. Since only the “rate” bits are exposed, the “capacity” ensures that finding collisions or preimages would require <span class="math inline">\(2^{c/2}\)</span> work, for SHA3-256, about <span class="math inline">\(2^{256}\)</span> effort.</p>
<p>This design makes SHA-3 provably secure up to its capacity against generic attacks.</p>
<p>SHA-3 is the calm successor to SHA-2 — not born from crisis, but from mathematical renewal — a sponge that drinks data and squeezes out pure randomness.</p>
</section>
</section>
<section id="hmac-hash-based-message-authentication-code" class="level3">
<h3 class="anchored" data-anchor-id="hmac-hash-based-message-authentication-code">668 HMAC (Hash-Based Message Authentication Code)</h3>
<p>HMAC is a method for verifying both integrity and authenticity of messages. It combines any cryptographic hash function (like SHA-256 or SHA-3) with a secret key, ensuring that only someone who knows the key can produce or verify the correct hash.</p>
<p>HMAC is the foundation of many authentication protocols, including TLS, OAuth, JWT, and AWS API signing.</p>
<section id="what-problem-are-we-solving-67" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-67">What Problem Are We Solving?</h4>
<p>A regular hash like SHA-256 verifies data integrity, but not authenticity. Anyone can compute a hash of a file, so how can you tell who actually made it?</p>
<p>HMAC introduces a shared secret key to ensure that only authorized parties can generate or validate the correct hash.</p>
<p>If the hash doesn’t match, it means the data was either modified or produced without the correct key.</p>
</section>
<section id="the-core-idea-8" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-8">The Core Idea</h4>
<p>HMAC wraps a cryptographic hash function in two layers of keyed hashing:</p>
<ol type="1">
<li>Inner hash, hash of the message combined with an inner key pad.</li>
<li>Outer hash, hash of the inner digest combined with an outer key pad.</li>
</ol>
<p>Formally:</p>
<p><span class="math display">\[
\text{HMAC}(K, M) = H\left((K' \oplus opad) , || , H((K' \oplus ipad) , || , M)\right)
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(H\)</span> is a secure hash function (e.g., SHA-256)</li>
<li><span class="math inline">\(K'\)</span> is the key padded or hashed to match block size</li>
<li><span class="math inline">\(opad\)</span> is the “outer pad” (0x5C repeated)</li>
<li><span class="math inline">\(ipad\)</span> is the “inner pad” (0x36 repeated)</li>
<li><span class="math inline">\(||\)</span> means concatenation</li>
<li><span class="math inline">\(\oplus\)</span> means XOR</li>
</ul>
<p>This two-layer structure protects against attacks on hash function internals (like length-extension attacks).</p>
</section>
<section id="step-by-step-example-using-sha-256" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-example-using-sha-256">Step-by-Step Example (Using SHA-256)</h4>
<ol type="1">
<li><p>Pad the secret key <span class="math inline">\(K\)</span> to 64 bytes (block size of SHA-256).</p></li>
<li><p>Compute inner hash:</p>
<p><span class="math display">\[
\text{inner} = H((K' \oplus ipad) , || , M)
\]</span></p></li>
<li><p>Compute outer hash:</p>
<p><span class="math display">\[
\text{HMAC} = H((K' \oplus opad) , || , \text{inner})
\]</span></p></li>
<li><p>The result is a 256-bit digest authenticating both key and message.</p></li>
</ol>
</section>
<section id="tiny-code-python-36" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-36">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hmac, hashlib</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> <span class="st">b"secret-key"</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>message <span class="op">=</span> <span class="st">b"Attack at dawn"</span></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>digest <span class="op">=</span> hmac.new(key, message, hashlib.sha256).hexdigest()</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"HMAC-SHA256:"</span>, digest)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>HMAC-SHA256: 2cba05e5a7e03ffccf13e585c624cfa7cbf4b82534ef9ce454b0943e97ebc8aa</code></pre>
</section>
<section id="tiny-code-c-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-5">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb164"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;openssl/hmac.h&gt;</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> result<span class="op">[</span>EVP_MAX_MD_SIZE<span class="op">];</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>key <span class="op">=</span> <span class="st">"secret-key"</span><span class="op">;</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>msg <span class="op">=</span> <span class="st">"Attack at dawn"</span><span class="op">;</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>    HMAC<span class="op">(</span>EVP_sha256<span class="op">(),</span> key<span class="op">,</span> strlen<span class="op">(</span>key<span class="op">),</span></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>         <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*)</span>msg<span class="op">,</span> strlen<span class="op">(</span>msg<span class="op">),</span></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>         result<span class="op">,</span> <span class="op">&amp;</span>len<span class="op">);</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"HMAC-SHA256: "</span><span class="op">);</span></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">%02x</span><span class="st">"</span><span class="op">,</span> result<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb164-19"><a href="#cb164-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>HMAC-SHA256: 2cba05e5a7e03ffccf13e585c624cfa7cbf4b82534ef9ce454b0943e97ebc8aa</code></pre>
</section>
<section id="why-it-matters-68" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-68">Why It Matters</h4>
<ul>
<li>Protects authenticity, only someone with the key can compute a valid HMAC.</li>
<li>Protects integrity, any change in data or key changes the HMAC.</li>
<li>Resistant to length-extension and replay attacks.</li>
</ul>
<p>Used in:</p>
<ul>
<li>TLS, SSH, IPsec</li>
<li>AWS and Google Cloud API signing</li>
<li>JWT (HS256)</li>
<li>Webhooks, signed URLs, and secure tokens</li>
</ul>
</section>
<section id="comparison-of-hash-based-macs" class="level4">
<h4 class="anchored" data-anchor-id="comparison-of-hash-based-macs">Comparison of Hash-Based MACs</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Underlying Hash</th>
<th>Output (bits)</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HMAC-MD5</td>
<td>MD5</td>
<td>128</td>
<td>Insecure</td>
</tr>
<tr class="even">
<td>HMAC-SHA1</td>
<td>SHA-1</td>
<td>160</td>
<td>Weak (legacy)</td>
</tr>
<tr class="odd">
<td>HMAC-SHA256</td>
<td>SHA-256</td>
<td>256</td>
<td>Recommended</td>
</tr>
<tr class="even">
<td>HMAC-SHA3-256</td>
<td>SHA-3</td>
<td>256</td>
<td>Future-safe</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-68" class="level4">
<h4 class="anchored" data-anchor-id="complexity-68">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hashing</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>HMAC’s cost is roughly 2× the underlying hash function, since it performs two passes (inner + outer).</p>
</section>
<section id="try-it-yourself-68" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-68">Try It Yourself</h4>
<ol type="1">
<li>Compute HMAC-SHA256 of <code>"hello"</code> with key <code>"abc"</code>.</li>
<li>Modify one byte, notice how the digest changes completely.</li>
<li>Try verifying with a wrong key, verification fails.</li>
<li>Compare performance between SHA1 and SHA256 versions.</li>
<li>Implement a manual HMAC from scratch using the formula above.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-35" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-35">A Gentle Proof (Why It Works)</h4>
<p>The key insight: Even if an attacker knows <span class="math inline">\(H(K || M)\)</span>, they cannot compute <span class="math inline">\(H(K || M')\)</span> for another message <span class="math inline">\(M'\)</span>, because <span class="math inline">\(K\)</span> is mixed inside the hash in a non-reusable way.</p>
<p>Mathematically, the inner and outer pads break the linearity of the compression function, removing any exploitable structure.</p>
<p>Security depends entirely on the hash’s collision resistance and the secrecy of the key.</p>
<p>HMAC is the handshake between mathematics and trust — a compact cryptographic signature proving, “This message came from someone who truly knew the key.”</p>
</section>
</section>
<section id="merkle-tree-hash-tree" class="level3">
<h3 class="anchored" data-anchor-id="merkle-tree-hash-tree">669 Merkle Tree (Hash Tree)</h3>
<p>A Merkle Tree (or hash tree) is a hierarchical data structure that provides efficient and secure verification of large data sets. It’s the backbone of blockchains, distributed systems, and version control systems like Git, enabling integrity proofs with logarithmic verification time.</p>
<section id="what-problem-are-we-solving-68" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-68">What Problem Are We Solving?</h4>
<p>Suppose you have a massive dataset, gigabytes of files or blocks, and you want to verify whether a single piece is intact or altered. Hashing the entire dataset repeatedly would be expensive.</p>
<p>A Merkle Tree allows verification of any part of the data using only a small proof, without rehashing everything.</p>
</section>
<section id="the-core-idea-9" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-9">The Core Idea</h4>
<p>A Merkle Tree is built by recursively hashing pairs of child nodes until a single root hash is obtained.</p>
<ul>
<li>Leaf nodes: contain hashes of data blocks.</li>
<li>Internal nodes: contain hashes of their concatenated children.</li>
<li>Root hash: uniquely represents the entire dataset.</li>
</ul>
<p>If any block changes, the change propagates upward, altering the root hash, making tampering immediately detectable.</p>
</section>
<section id="construction" class="level4">
<h4 class="anchored" data-anchor-id="construction">Construction</h4>
<p>Given four data blocks <span class="math inline">\(D_1, D_2, D_3, D_4\)</span>:</p>
<ol type="1">
<li>Compute leaf hashes: <span class="math display">\[
H_1 = H(D_1), \quad H_2 = H(D_2), \quad H_3 = H(D_3), \quad H_4 = H(D_4)
\]</span></li>
<li>Compute intermediate hashes: <span class="math display">\[
H_{12} = H(H_1 || H_2), \quad H_{34} = H(H_3 || H_4)
\]</span></li>
<li>Compute root: <span class="math display">\[
H_{root} = H(H_{12} || H_{34})
\]</span></li>
</ol>
<p>The final <span class="math inline">\(H_{root}\)</span> acts as a fingerprint for all underlying data.</p>
</section>
<section id="example-visual" class="level4">
<h4 class="anchored" data-anchor-id="example-visual">Example (Visual)</h4>
<pre><code>              H_root
              /    \
         H_12       H_34
        /   \       /   \
     H1     H2   H3     H4
     |      |    |      |
    D1     D2   D3     D4</code></pre>
</section>
<section id="verification-proof-merkle-path" class="level4">
<h4 class="anchored" data-anchor-id="verification-proof-merkle-path">Verification Proof (Merkle Path)</h4>
<p>To prove that <span class="math inline">\(D_3\)</span> belongs to the tree:</p>
<ol type="1">
<li><p>Provide <span class="math inline">\(H_4\)</span>, <span class="math inline">\(H_{12}\)</span>, and the position of each (left/right).</p></li>
<li><p>Compute upward:</p>
<p><span class="math display">\[
H_3 = H(D_3)
\]</span></p>
<p><span class="math display">\[
H_{34} = H(H_3 || H_4)
\]</span></p>
<p><span class="math display">\[
H_{root}' = H(H_{12} || H_{34})
\]</span></p></li>
<li><p>If <span class="math inline">\(H_{root}' = H_{root}\)</span>, the data block is verified.</p></li>
</ol>
<p>Only log₂(n) hashes are needed for verification.</p>
</section>
<section id="tiny-code-python-37" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-37">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hashlib</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sha256(data):</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hashlib.sha256(data).digest()</span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merkle_tree(leaves):</span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(leaves) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> leaves[<span class="dv">0</span>]</span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(leaves) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>        leaves.append(leaves[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>    parents <span class="op">=</span> []</span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(leaves), <span class="dv">2</span>):</span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a>        parents.append(sha256(leaves[i] <span class="op">+</span> leaves[i<span class="op">+</span><span class="dv">1</span>]))</span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merkle_tree(parents)</span>
<span id="cb167-15"><a href="#cb167-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-16"><a href="#cb167-16" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [<span class="st">b"D1"</span>, <span class="st">b"D2"</span>, <span class="st">b"D3"</span>, <span class="st">b"D4"</span>]</span>
<span id="cb167-17"><a href="#cb167-17" aria-hidden="true" tabindex="-1"></a>leaves <span class="op">=</span> [sha256(d) <span class="cf">for</span> d <span class="kw">in</span> data]</span>
<span id="cb167-18"><a href="#cb167-18" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> merkle_tree(leaves)</span>
<span id="cb167-19"><a href="#cb167-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Merkle Root:"</span>, root.<span class="bu">hex</span>())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output (example):</p>
<pre><code>Merkle Root: 16d1c7a0cfb3b6e4151f3b24a884b78e0d1a826c45de2d0e0d0db1e4e44bff62</code></pre>
</section>
<section id="tiny-code-c-using-openssl" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-using-openssl">Tiny Code (C, using OpenSSL)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb169"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;openssl/sha.h&gt;</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sha256<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>data<span class="op">,</span> <span class="dt">size_t</span> len<span class="op">,</span> <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>    SHA256<span class="op">(</span>data<span class="op">,</span> len<span class="op">,</span> out<span class="op">);</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_hex<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>h<span class="op">,</span> <span class="dt">int</span> len<span class="op">)</span> <span class="op">{</span></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++)</span> printf<span class="op">(</span><span class="st">"</span><span class="sc">%02x</span><span class="st">"</span><span class="op">,</span> h<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb169-13"><a href="#cb169-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-14"><a href="#cb169-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb169-15"><a href="#cb169-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> d1<span class="op">[]</span> <span class="op">=</span> <span class="st">"D1"</span><span class="op">,</span> d2<span class="op">[]</span> <span class="op">=</span> <span class="st">"D2"</span><span class="op">,</span> d3<span class="op">[]</span> <span class="op">=</span> <span class="st">"D3"</span><span class="op">,</span> d4<span class="op">[]</span> <span class="op">=</span> <span class="st">"D4"</span><span class="op">;</span></span>
<span id="cb169-16"><a href="#cb169-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> h1<span class="op">[</span><span class="dv">32</span><span class="op">],</span> h2<span class="op">[</span><span class="dv">32</span><span class="op">],</span> h3<span class="op">[</span><span class="dv">32</span><span class="op">],</span> h4<span class="op">[</span><span class="dv">32</span><span class="op">],</span> h12<span class="op">[</span><span class="dv">32</span><span class="op">],</span> h34<span class="op">[</span><span class="dv">32</span><span class="op">],</span> root<span class="op">[</span><span class="dv">32</span><span class="op">];</span></span>
<span id="cb169-17"><a href="#cb169-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> tmp<span class="op">[</span><span class="dv">64</span><span class="op">];</span></span>
<span id="cb169-18"><a href="#cb169-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-19"><a href="#cb169-19" aria-hidden="true" tabindex="-1"></a>    sha256<span class="op">(</span>d1<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> h1<span class="op">);</span> sha256<span class="op">(</span>d2<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> h2<span class="op">);</span></span>
<span id="cb169-20"><a href="#cb169-20" aria-hidden="true" tabindex="-1"></a>    sha256<span class="op">(</span>d3<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> h3<span class="op">);</span> sha256<span class="op">(</span>d4<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> h4<span class="op">);</span></span>
<span id="cb169-21"><a href="#cb169-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-22"><a href="#cb169-22" aria-hidden="true" tabindex="-1"></a>    memcpy<span class="op">(</span>tmp<span class="op">,</span> h1<span class="op">,</span> <span class="dv">32</span><span class="op">);</span> memcpy<span class="op">(</span>tmp<span class="op">+</span><span class="dv">32</span><span class="op">,</span> h2<span class="op">,</span> <span class="dv">32</span><span class="op">);</span> sha256<span class="op">(</span>tmp<span class="op">,</span> <span class="dv">64</span><span class="op">,</span> h12<span class="op">);</span></span>
<span id="cb169-23"><a href="#cb169-23" aria-hidden="true" tabindex="-1"></a>    memcpy<span class="op">(</span>tmp<span class="op">,</span> h3<span class="op">,</span> <span class="dv">32</span><span class="op">);</span> memcpy<span class="op">(</span>tmp<span class="op">+</span><span class="dv">32</span><span class="op">,</span> h4<span class="op">,</span> <span class="dv">32</span><span class="op">);</span> sha256<span class="op">(</span>tmp<span class="op">,</span> <span class="dv">64</span><span class="op">,</span> h34<span class="op">);</span></span>
<span id="cb169-24"><a href="#cb169-24" aria-hidden="true" tabindex="-1"></a>    memcpy<span class="op">(</span>tmp<span class="op">,</span> h12<span class="op">,</span> <span class="dv">32</span><span class="op">);</span> memcpy<span class="op">(</span>tmp<span class="op">+</span><span class="dv">32</span><span class="op">,</span> h34<span class="op">,</span> <span class="dv">32</span><span class="op">);</span> sha256<span class="op">(</span>tmp<span class="op">,</span> <span class="dv">64</span><span class="op">,</span> root<span class="op">);</span></span>
<span id="cb169-25"><a href="#cb169-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-26"><a href="#cb169-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Merkle Root: "</span><span class="op">);</span> print_hex<span class="op">(</span>root<span class="op">,</span> <span class="dv">32</span><span class="op">);</span></span>
<span id="cb169-27"><a href="#cb169-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-69" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-69">Why It Matters</h4>
<ul>
<li><p>Integrity, any data change alters the root hash.</p></li>
<li><p>Efficiency, logarithmic proof size and verification.</p></li>
<li><p>Scalability, used in systems with millions of records.</p></li>
<li><p>Used in:</p>
<ul>
<li>Bitcoin and Ethereum blockchains</li>
<li>Git commits and version histories</li>
<li>IPFS and distributed file systems</li>
<li>Secure software updates (Merkle proofs)</li>
</ul></li>
</ul>
</section>
<section id="comparison-with-flat-hashing" class="level4">
<h4 class="anchored" data-anchor-id="comparison-with-flat-hashing">Comparison with Flat Hashing</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Method</th>
<th>Verification Cost</th>
<th>Data Tamper Detection</th>
<th>Proof Size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Single hash</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Whole file only</td>
<td>Full data</td>
</tr>
<tr class="even">
<td>Merkle tree</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td>Any block</td>
<td>Few hashes</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-69" class="level4">
<h4 class="anchored" data-anchor-id="complexity-69">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tree build</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-69" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-69">Try It Yourself</h4>
<ol type="1">
<li>Build a Merkle tree of 8 messages.</li>
<li>Modify one message, watch how the root changes.</li>
<li>Compute a Merkle proof for the 3rd message and verify it manually.</li>
<li>Implement double SHA-256 as used in Bitcoin.</li>
<li>Explore how Git uses trees and commits as Merkle DAGs.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-36" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-36">A Gentle Proof (Why It Works)</h4>
<p>Each node’s hash depends on its children, which depend recursively on all leaves below. Thus, changing even a single bit in any leaf alters all ancestor hashes and the root.</p>
<p>Because the underlying hash function is collision-resistant, two different datasets cannot produce the same root.</p>
<p>Mathematically, for a secure hash <span class="math inline">\(H\)</span>:</p>
<p><span class="math display">\[
H_{root}(D_1, D_2, ..., D_n) = H_{root}(D'_1, D'_2, ..., D'_n)
\Rightarrow D_i = D'_i \text{ for all } i
\]</span></p>
<p>A Merkle Tree is integrity made scalable — a digital fingerprint for forests of data, proving that every leaf is still what it claims to be.</p>
</section>
</section>
<section id="hash-collision-detection-birthday-bound-simulation" class="level3">
<h3 class="anchored" data-anchor-id="hash-collision-detection-birthday-bound-simulation">670 Hash Collision Detection (Birthday Bound Simulation)</h3>
<p>Every cryptographic hash function, even the strongest ones, can theoretically produce collisions, where two different inputs yield the same hash. The birthday paradox gives us a way to estimate how likely that is. This section explores collision probability, detection simulation, and why even a 256-bit hash can be “breakable” in principle, just not in practice.</p>
<section id="what-problem-are-we-solving-69" class="level4">
<h4 class="anchored" data-anchor-id="what-problem-are-we-solving-69">What Problem Are We Solving?</h4>
<p>When we hash data, we hope every message gets a unique output. But since the hash space is finite, collisions must exist. The key question is: <em>how many random hashes must we generate before we expect a collision?</em></p>
<p>This is the birthday problem in disguise, the same math that tells us 23 people suffice for a 50% chance of a shared birthday.</p>
</section>
<section id="the-core-idea-birthday-bound" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-birthday-bound">The Core Idea, Birthday Bound</h4>
<p>If a hash function produces <span class="math inline">\(N\)</span> possible outputs, then after about <span class="math inline">\(\sqrt{N}\)</span> random hashes, the probability of a collision reaches about 50%.</p>
<p>For a hash of <span class="math inline">\(b\)</span> bits:</p>
<p><span class="math display">\[
N = 2^b, \quad \text{so collisions appear around } 2^{b/2}.
\]</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Hash bits</th>
<th>Expected collision at</th>
<th>Practical security</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>32</td>
<td><span class="math inline">\(2^{16}\)</span> (≈65k)</td>
<td>Weak</td>
</tr>
<tr class="even">
<td>64</td>
<td><span class="math inline">\(2^{32}\)</span></td>
<td>Moderate</td>
</tr>
<tr class="odd">
<td>128 (MD5)</td>
<td><span class="math inline">\(2^{64}\)</span></td>
<td>Broken</td>
</tr>
<tr class="even">
<td>160 (SHA-1)</td>
<td><span class="math inline">\(2^{80}\)</span></td>
<td>Broken (feasible)</td>
</tr>
<tr class="odd">
<td>256 (SHA-256)</td>
<td><span class="math inline">\(2^{128}\)</span></td>
<td>Secure</td>
</tr>
<tr class="even">
<td>512 (SHA-512)</td>
<td><span class="math inline">\(2^{256}\)</span></td>
<td>Extremely secure</td>
</tr>
</tbody>
</table>
<p>Thus, SHA-256’s 128-bit collision resistance is strong enough for modern security.</p>
</section>
<section id="the-birthday-probability-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-birthday-probability-formula">The Birthday Probability Formula</h4>
<p>The probability of <em>at least one collision</em> after hashing <span class="math inline">\(k\)</span> random messages is:</p>
<p><span class="math display">\[
P(k) \approx 1 - e^{-k(k-1)/(2N)}
\]</span></p>
<p>If we set <span class="math inline">\(P(k) = 0.5\)</span>, solving for <span class="math inline">\(k\)</span> gives:</p>
<p><span class="math display">\[
k \approx 1.1774 \sqrt{N}
\]</span></p>
</section>
<section id="tiny-code-python-38" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-38">Tiny Code (Python)</h4>
<p>Let’s simulate hash collisions using SHA-1 and random data.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> hashlib, random, string</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> random_str(n<span class="op">=</span><span class="dv">8</span>):</span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(random.choice(string.ascii_letters) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n))</span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> collision_simulation(bits<span class="op">=</span><span class="dv">32</span>):</span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>    seen <span class="op">=</span> {}</span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> bits) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> random_str(<span class="dv">8</span>).encode()</span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> <span class="bu">int</span>.from_bytes(hashlib.sha256(s).digest(), <span class="st">'big'</span>) <span class="op">&amp;</span> mask</span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> h <span class="kw">in</span> seen:</span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> count, s, seen[h]</span>
<span id="cb170-15"><a href="#cb170-15" aria-hidden="true" tabindex="-1"></a>        seen[h] <span class="op">=</span> s</span>
<span id="cb170-16"><a href="#cb170-16" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb170-17"><a href="#cb170-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-18"><a href="#cb170-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Simulating 32-bit collision..."</span>)</span>
<span id="cb170-19"><a href="#cb170-19" aria-hidden="true" tabindex="-1"></a>count, s1, s2 <span class="op">=</span> collision_simulation(<span class="dv">32</span>)</span>
<span id="cb170-20"><a href="#cb170-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Collision after </span><span class="sc">{</span>count<span class="sc">}</span><span class="ss"> hashes:"</span>)</span>
<span id="cb170-21"><a href="#cb170-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>s1<span class="sc">}</span><span class="ss"> and </span><span class="sc">{</span>s2<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Typical output:</p>
<pre><code>Simulating 32-bit collision...
Collision after 68314 hashes:
b'FqgWbUzk' and b'yLpTGZxu'</code></pre>
<p>This matches the theoretical expectation: around <span class="math inline">\(\sqrt{2^{32}} = 65,536\)</span> trials.</p>
</section>
<section id="tiny-code-c-simple-model" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-simple-model">Tiny Code (C, simple model)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb172"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;openssl/sha.h&gt;</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> seen<span class="op">[</span><span class="dv">65536</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> hash<span class="op">[</span>SHA_DIGEST_LENGTH<span class="op">];</span></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> input<span class="op">[</span><span class="dv">16</span><span class="op">];</span></span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>        sprintf<span class="op">((</span><span class="dt">char</span><span class="op">*)</span>input<span class="op">,</span> <span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> rand<span class="op">());</span></span>
<span id="cb172-14"><a href="#cb172-14" aria-hidden="true" tabindex="-1"></a>        SHA1<span class="op">(</span>input<span class="op">,</span> strlen<span class="op">((</span><span class="dt">char</span><span class="op">*)</span>input<span class="op">),</span> hash<span class="op">);</span></span>
<span id="cb172-15"><a href="#cb172-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> h <span class="op">=</span> <span class="op">(</span>hash<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">|</span> hash<span class="op">[</span><span class="dv">1</span><span class="op">];</span>  <span class="co">// take 16 bits</span></span>
<span id="cb172-16"><a href="#cb172-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>seen<span class="op">[</span>h<span class="op">])</span> <span class="op">{</span></span>
<span id="cb172-17"><a href="#cb172-17" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Collision found after </span><span class="sc">%d</span><span class="st"> hashes</span><span class="sc">\n</span><span class="st">"</span><span class="op">,</span> count<span class="op">);</span></span>
<span id="cb172-18"><a href="#cb172-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb172-19"><a href="#cb172-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb172-20"><a href="#cb172-20" aria-hidden="true" tabindex="-1"></a>        seen<span class="op">[</span>h<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb172-21"><a href="#cb172-21" aria-hidden="true" tabindex="-1"></a>        count<span class="op">++;</span></span>
<span id="cb172-22"><a href="#cb172-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb172-23"><a href="#cb172-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-70" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-70">Why It Matters</h4>
<ul>
<li>Every hash can collide, but for large bit sizes, collisions are <em>astronomically unlikely</em>.</li>
<li>Helps explain why MD5 and SHA-1 are no longer safe, their “birthday bound” can be reached by modern GPUs.</li>
<li>Used in security proofs for digital signatures, blockchain mining, and random oracles.</li>
</ul>
</section>
<section id="visualization" class="level4">
<h4 class="anchored" data-anchor-id="visualization">Visualization</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Hash bits</th>
<th>Trial count for 50% collision</th>
<th>Equivalent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>16</td>
<td>300</td>
<td>trivial</td>
</tr>
<tr class="even">
<td>32</td>
<td>65,000</td>
<td>toy example</td>
</tr>
<tr class="odd">
<td>64</td>
<td>4 billion</td>
<td>feasible for testing</td>
</tr>
<tr class="even">
<td>128</td>
<td><span class="math inline">\(2^{64}\)</span> ≈ <span class="math inline">\(1.8\times10^{19}\)</span></td>
<td>too large</td>
</tr>
<tr class="odd">
<td>256</td>
<td><span class="math inline">\(2^{128}\)</span> ≈ <span class="math inline">\(3.4\times10^{38}\)</span></td>
<td>impossible</td>
</tr>
</tbody>
</table>
<p>For comparison, the total number of atoms in the observable universe is about <span class="math inline">\(10^{80}\)</span>, still smaller than <span class="math inline">\(2^{256}\)</span>.</p>
</section>
<section id="complexity-70" class="level4">
<h4 class="anchored" data-anchor-id="complexity-70">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Simulation</td>
<td><span class="math inline">\(O(\sqrt{N})\)</span></td>
<td><span class="math inline">\(O(\sqrt{N})\)</span></td>
</tr>
<tr class="even">
<td>Verification</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>Hash collision detection scales quadratically with output bits, making brute-force infeasible for modern algorithms.</p>
</section>
<section id="try-it-yourself-70" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-70">Try It Yourself</h4>
<ol type="1">
<li>Run the Python simulation for 24-bit, 28-bit, and 32-bit masks.</li>
<li>Compare empirical counts to the theoretical <span class="math inline">\(\sqrt{2^b}\)</span> curve.</li>
<li>Visualize probability vs.&nbsp;number of hashes using <code>matplotlib</code>.</li>
<li>Replace SHA-256 with SHA3-256, same collision statistics.</li>
<li>Estimate the expected collision time for SHA-1 given GPU speeds (you’ll find it’s real).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-37" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-37">A Gentle Proof (Why It Works)</h4>
<p>Let <span class="math inline">\(N = 2^b\)</span> possible hashes. After <span class="math inline">\(k\)</span> draws, the chance that all are distinct is approximately:</p>
<p><span class="math display">\[
P_{\text{no-collision}} = \prod_{i=1}^{k-1} \left(1 - \frac{i}{N}\right)
\approx e^{-k(k-1)/(2N)}
\]</span></p>
<p>Taking the complement gives the collision probability <span class="math inline">\(P(k)\)</span>. Setting <span class="math inline">\(P(k)=0.5\)</span> yields the familiar <span class="math inline">\(\sqrt{N}\)</span> bound, a purely combinatorial fact independent of the hash algorithm.</p>
<p>Hash collision detection is where probability meets cryptography — a quiet reminder that even perfect functions have limits, and that randomness itself defines how close we dare to get to them.</p>
</section>
</section>
</section>
<section id="section-68.-approximate-and-streaming-matching" class="level1">
<h1>Section 68. Approximate and Streaming Matching</h1>
<section id="k-approximate-string-matching" class="level3">
<h3 class="anchored" data-anchor-id="k-approximate-string-matching">671 K-Approximate String Matching</h3>
<p>The K-Approximate String Matching problem asks: given a pattern <code>P</code> and a text <code>T</code>, find all positions in <code>T</code> where <code>P</code> appears with at most <code>k</code> differences (insertions, deletions, or substitutions).</p>
<p>This problem underlies fuzzy search, spell correction, bioinformatics alignment, and error-tolerant pattern recognition.</p>
<section id="the-core-idea-10" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-10">The Core Idea</h4>
<p>Exact matching requires all characters to align perfectly. Approximate matching allows small differences, quantified by edit distance ≤ k.</p>
<p>We use dynamic programming or bit-parallel techniques to efficiently detect these approximate matches.</p>
</section>
<section id="the-dynamic-programming-formulation" class="level4">
<h4 class="anchored" data-anchor-id="the-dynamic-programming-formulation">The Dynamic Programming Formulation</h4>
<p>Let pattern <code>P</code> of length <code>m</code>, text <code>T</code> of length <code>n</code>, and distance threshold <code>k</code>.</p>
<p>Define a DP table:</p>
<p><span class="math display">\[
dp[i][j] = \text{minimum edit distance between } P[1..i] \text{ and } T[1..j]
\]</span></p>
<p>Recurrence:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
dp[i-1][j-1], &amp; \text{if } P[i] = T[j],\\[4pt]
1 + \min\big(dp[i-1][j],\ dp[i][j-1],\ dp[i-1][j-1]\big), &amp; \text{otherwise.}
\end{cases}
\]</span></p>
<p>At each position <code>j</code>, if <span class="math inline">\(dp[m][j] \le k\)</span>, then the substring <code>T[j-m+1..j]</code> approximately matches <code>P</code>.</p>
</section>
<section id="example-51" class="level4">
<h4 class="anchored" data-anchor-id="example-51">Example</h4>
<p>Let <code>T = "abcdefg"</code> <code>P = "abxd"</code> <code>k = 1</code></p>
<p>Dynamic programming finds one approximate match at position 1 because <code>"abxd"</code> differs from <code>"abcd"</code> by a single substitution.</p>
</section>
<section id="bit-parallel-simplification-for-small-k" class="level4">
<h4 class="anchored" data-anchor-id="bit-parallel-simplification-for-small-k">Bit-Parallel Simplification (for small k)</h4>
<p>The Bitap (Shift-Or) algorithm can be extended to handle up to <code>k</code> errors using bitmasks and shift operations.</p>
<p>Each bit represents whether a prefix of <code>P</code> matches at a given alignment.</p>
<p>Time complexity becomes:</p>
<p><span class="math display">\[
O\left(\frac{n \cdot k}{w}\right)
\]</span></p>
<p>where <code>w</code> is the machine word size (typically 64).</p>
</section>
<section id="tiny-code-python-dp-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-dp-version">Tiny Code (Python, DP Version)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb173"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> k_approx_match(text, pattern, k):</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pattern)</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="bu">list</span>(<span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>))] <span class="op">+</span> [[<span class="dv">0</span>] <span class="op">*</span> (m <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> text[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> pattern[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># insertion</span></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a>                dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,      <span class="co"># deletion</span></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> cost  <span class="co"># substitution</span></span>
<span id="cb173-12"><a href="#cb173-12" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb173-13"><a href="#cb173-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dp[i][m] <span class="op">&lt;=</span> k:</span>
<span id="cb173-14"><a href="#cb173-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Match ending at </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">, distance </span><span class="sc">{</span>dp[i][m]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb173-15"><a href="#cb173-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-16"><a href="#cb173-16" aria-hidden="true" tabindex="-1"></a>k_approx_match(<span class="st">"abcdefg"</span>, <span class="st">"abxd"</span>, <span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Match ending at 4, distance 1</code></pre>
</section>
<section id="tiny-code-c-bitap-style" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-bitap-style">Tiny Code (C, Bitap-Style)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb175"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bitap_approx<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>pattern<span class="op">);</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> mask<span class="op">[</span><span class="dv">256</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> mask<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>pattern<span class="op">[</span>i<span class="op">]]</span> <span class="op">|=</span> <span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> R<span class="op">[</span>k<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> d <span class="op">&lt;=</span> k<span class="op">;</span> d<span class="op">++)</span> R<span class="op">[</span>d<span class="op">]</span> <span class="op">=</span> <span class="op">~</span><span class="dv">0</span><span class="bu">ULL</span><span class="op">;</span></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> pattern_mask <span class="op">=</span> <span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint64_t</span> oldR <span class="op">=</span> R<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>        R<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">((</span>R<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">|</span> <span class="dv">1</span><span class="bu">ULL</span><span class="op">)</span> <span class="op">&amp;</span> mask<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>text<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> d <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> d <span class="op">&lt;=</span> k<span class="op">;</span> d<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">uint64_t</span> tmp <span class="op">=</span> R<span class="op">[</span>d<span class="op">];</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>            R<span class="op">[</span>d<span class="op">]</span> <span class="op">=</span> <span class="op">((</span>R<span class="op">[</span>d<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">|</span> <span class="dv">1</span><span class="bu">ULL</span><span class="op">)</span> <span class="op">&amp;</span> mask<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>text<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>            R<span class="op">[</span>d<span class="op">]</span> <span class="op">|=</span> <span class="op">(</span>oldR <span class="op">|</span> <span class="op">(</span>R<span class="op">[</span>d<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">|</span> oldR <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a>            oldR <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!(</span>R<span class="op">[</span>k<span class="op">]</span> <span class="op">&amp;</span> pattern_mask<span class="op">))</span></span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Approximate match ending at </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-71" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-71">Why It Matters</h4>
<p>Approximate matching powers:</p>
<ul>
<li>Spell-checking (“recieve” → “receive”)</li>
<li>DNA alignment (A-C-T mismatches)</li>
<li>Search engines with typo tolerance</li>
<li>Real-time text recognition and OCR correction</li>
<li>Command-line fuzzy filters (like <code>fzf</code>)</li>
</ul>
</section>
<section id="complexity-71" class="level4">
<h4 class="anchored" data-anchor-id="complexity-71">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DP (naive)</td>
<td><span class="math inline">\(O(nm)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Bitap (for small k)</td>
<td><span class="math inline">\(O(nk/w)\)</span></td>
<td><span class="math inline">\(O(k)\)</span></td>
</tr>
</tbody>
</table>
<p>For small edit distances (k ≤ 3), bit-parallel methods are extremely fast.</p>
</section>
<section id="try-it-yourself-71" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-71">Try It Yourself</h4>
<ol type="1">
<li>Run the DP version and visualize the <code>dp</code> table.</li>
<li>Increase <code>k</code> and see how matches expand.</li>
<li>Test with random noise in the text.</li>
<li>Implement early termination when <code>dp[i][m] &gt; k</code>.</li>
<li>Compare Bitap’s speed to the DP algorithm for large inputs.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-38" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-38">A Gentle Proof (Why It Works)</h4>
<p>The DP recurrence ensures that each mismatch, insertion, or deletion contributes exactly 1 to the total distance. By scanning the last column of the DP table, we detect substrings whose minimal edit distance is ≤ k. Because all transitions are local, the algorithm guarantees correctness for every alignment.</p>
<p>Approximate matching brings tolerance to the rigid world of algorithms — finding patterns not as they <em>are</em>, but as they <em>almost are</em>.</p>
</section>
</section>
<section id="bitap-algorithm-bitwise-dynamic-programming" class="level3">
<h3 class="anchored" data-anchor-id="bitap-algorithm-bitwise-dynamic-programming">672 Bitap Algorithm (Bitwise Dynamic Programming)</h3>
<p>The Bitap algorithm, also known as Shift-Or or Bitwise Pattern Matching, performs fast text search by encoding the pattern as a bitmask and updating it with simple bitwise operations. It is one of the earliest and most elegant examples of bit-parallel algorithms for string matching.</p>
<section id="the-core-idea-11" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-11">The Core Idea</h4>
<p>Instead of comparing characters one by one, Bitap represents the state of matching as a bit vector. Each bit indicates whether a prefix of the pattern matches a substring of the text up to the current position.</p>
<p>This allows us to process up to 64 pattern characters per CPU word using bitwise operations, making it much faster than naive scanning.</p>
</section>
<section id="the-bitmask-setup" class="level4">
<h4 class="anchored" data-anchor-id="the-bitmask-setup">The Bitmask Setup</h4>
<p>Let:</p>
<ul>
<li>Pattern <code>P</code> of length <code>m</code></li>
<li>Text <code>T</code> of length <code>n</code></li>
<li>Machine word of width <code>w</code> (typically 64 bits)</li>
</ul>
<p>For each character <code>c</code>, we precompute a bitmask:</p>
<p><span class="math display">\[
B[c] = \text{bitmask where } B[c]_i = 0 \text{ if } P[i] = c, \text{ else } 1
\]</span></p>
</section>
<section id="the-matching-process" class="level4">
<h4 class="anchored" data-anchor-id="the-matching-process">The Matching Process</h4>
<p>We maintain a running state vector <span class="math inline">\(R\)</span> initialized as all 1s:</p>
<p><span class="math display">\[
R_0 = \text{all bits set to } 1
\]</span></p>
<p>For each character <span class="math inline">\(T[j]\)</span>:</p>
<p><span class="math display">\[
R_j = \big((R_{j-1} \ll 1) \,\vert\, 1\big) \,\&amp;\, B[T[j]]
\]</span></p>
<p>If the bit corresponding to the last pattern position becomes 0, a match is found at position <span class="math inline">\(j - m + 1\)</span>.</p>
</section>
<section id="example-52" class="level4">
<h4 class="anchored" data-anchor-id="example-52">Example</h4>
<p>Let <code>T = "abcxabcdabxabcdabcdabcy"</code> <code>P = "abcdabcy"</code></p>
<p>Pattern length <span class="math inline">\(m = 8\)</span>. When processing the text, each bit of <code>R</code> shifts left to represent the growing match. When the 8th bit becomes zero, it signals a full match of <code>P</code>.</p>
</section>
<section id="tiny-code-python-bitap-exact-match" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-bitap-exact-match">Tiny Code (Python, Bitap Exact Match)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bitap_search(text, pattern):</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pattern)</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> {}</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">set</span>(text):</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>        mask[c] <span class="op">=</span> <span class="op">~</span><span class="dv">0</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(pattern):</span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>        mask[c] <span class="op">&amp;=</span> <span class="op">~</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)</span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> <span class="op">~</span><span class="dv">0</span></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j, c <span class="kw">in</span> <span class="bu">enumerate</span>(text):</span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a>        R <span class="op">=</span> ((R <span class="op">&lt;&lt;</span> <span class="dv">1</span>) <span class="op">|</span> <span class="dv">1</span>) <span class="op">&amp;</span> mask.get(c, <span class="op">~</span><span class="dv">0</span>)</span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (R <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (m <span class="op">-</span> <span class="dv">1</span>))) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Match found ending at position </span><span class="sc">{</span>j<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a>bitap_search(<span class="st">"abcxabcdabxabcdabcdabcy"</span>, <span class="st">"abcdabcy"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Match found ending at position 23</code></pre>
</section>
<section id="bitap-with-k-errors-approximate-matching" class="level4">
<h4 class="anchored" data-anchor-id="bitap-with-k-errors-approximate-matching">Bitap with K Errors (Approximate Matching)</h4>
<p>Bitap can be extended to allow up to <span class="math inline">\(k\)</span> mismatches (insertions, deletions, or substitutions). We maintain <span class="math inline">\(k + 1\)</span> bit vectors <span class="math inline">\(R_0, R_1, ..., R_k\)</span>:</p>
<p><span class="math display">\[
R_j = \big((R_{j-1} \ll 1) \,\vert\, 1\big) \,\&amp;\, B[T[j]]
\]</span></p>
<p>and for <span class="math inline">\(d &gt; 0\)</span>:</p>
<p><span class="math display">\[
R_d = \big((R_d \ll 1) \,\vert\, 1\big) \,\&amp;\, B[T[j]]
      \,\vert\, R_{d-1}
      \,\vert\, \big((R_{d-1} \ll 1) \,\vert\, (R_{d-1} \gg 1)\big)
\]</span></p>
<p>If any <span class="math inline">\(R_d\)</span> has the last bit zero, a match within <span class="math inline">\(d\)</span> edits exists.</p>
</section>
<section id="tiny-code-c-exact-match" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-exact-match">Tiny Code (C, Exact Match)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb178"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bitap<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern<span class="op">)</span> <span class="op">{</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">),</span> m <span class="op">=</span> strlen<span class="op">(</span>pattern<span class="op">);</span></span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> mask<span class="op">[</span><span class="dv">256</span><span class="op">];</span></span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">256</span><span class="op">;</span> i<span class="op">++)</span> mask<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">~</span><span class="dv">0</span><span class="bu">ULL</span><span class="op">;</span></span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> mask<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>pattern<span class="op">[</span>i<span class="op">]]</span> <span class="op">&amp;=</span> <span class="op">~(</span><span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> i<span class="op">);</span></span>
<span id="cb178-10"><a href="#cb178-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-11"><a href="#cb178-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> R <span class="op">=</span> <span class="op">~</span><span class="dv">0</span><span class="bu">ULL</span><span class="op">;</span></span>
<span id="cb178-12"><a href="#cb178-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb178-13"><a href="#cb178-13" aria-hidden="true" tabindex="-1"></a>        R <span class="op">=</span> <span class="op">((</span>R <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">|</span> <span class="dv">1</span><span class="bu">ULL</span><span class="op">)</span> <span class="op">&amp;</span> mask<span class="op">[(</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">)</span>text<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb178-14"><a href="#cb178-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!(</span>R <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">))))</span></span>
<span id="cb178-15"><a href="#cb178-15" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match ending at position </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb178-16"><a href="#cb178-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb178-17"><a href="#cb178-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-72" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-72">Why It Matters</h4>
<ul>
<li>Compact and fast: uses pure bitwise logic</li>
<li>Suitable for short patterns (fits within machine word)</li>
<li>Foundation for approximate matching and fuzzy search</li>
<li>Practical in grep, spell correction, DNA search, and streaming text</li>
</ul>
</section>
<section id="complexity-72" class="level4">
<h4 class="anchored" data-anchor-id="complexity-72">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exact Match</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(\sigma)\)</span></td>
</tr>
<tr class="even">
<td>With k errors</td>
<td><span class="math inline">\(O(nk)\)</span></td>
<td><span class="math inline">\(O(\sigma + k)\)</span></td>
</tr>
</tbody>
</table>
<p>Here <span class="math inline">\(\sigma\)</span> is the alphabet size.</p>
</section>
<section id="try-it-yourself-72" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-72">Try It Yourself</h4>
<ol type="1">
<li>Modify the Python version to return match start positions instead of ends.</li>
<li>Test with long texts and observe near-linear runtime.</li>
<li>Extend it to allow 1 mismatch using an array of <code>R[k]</code>.</li>
<li>Visualize <code>R</code> bit patterns to see how the prefix match evolves.</li>
<li>Compare performance with KMP and Naive matching.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-39" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-39">A Gentle Proof (Why It Works)</h4>
<p>Each left shift of <code>R</code> corresponds to extending the matched prefix by one character. Masking by <code>B[c]</code> zeroes bits where the pattern character matches the text character. Thus, a 0 at position <code>m−1</code> means the entire pattern has matched — the algorithm simulates a dynamic programming table with bitwise parallelism.</p>
<p>Bitap is a perfect illustration of algorithmic elegance — compressing a full table of comparisons into a handful of bits that dance in sync with the text.</p>
</section>
</section>
<section id="landauvishkin-algorithm-edit-distance-k" class="level3">
<h3 class="anchored" data-anchor-id="landauvishkin-algorithm-edit-distance-k">673 Landau–Vishkin Algorithm (Edit Distance ≤ k)</h3>
<p>The Landau–Vishkin algorithm solves the <em>k-approximate string matching</em> problem efficiently by computing the edit distance up to a fixed threshold k without constructing a full dynamic programming table. It’s one of the most elegant linear-time algorithms for approximate matching when k is small.</p>
<section id="the-core-idea-12" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-12">The Core Idea</h4>
<p>We want to find all positions in text T where pattern P matches with at most k edits (insertions, deletions, or substitutions).</p>
<p>Instead of computing the full <span class="math inline">\(m \times n\)</span> edit distance table, the algorithm tracks diagonals in the DP grid and extends matches as far as possible along each diagonal.</p>
<p>This diagonal-based thinking makes it much faster for small k.</p>
</section>
<section id="the-dp-view-in-brief" class="level4">
<h4 class="anchored" data-anchor-id="the-dp-view-in-brief">The DP View in Brief</h4>
<p>In the classic edit distance DP, each cell <span class="math inline">\((i, j)\)</span> represents the edit distance between <span class="math inline">\(P[1..i]\)</span> and <span class="math inline">\(T[1..j]\)</span>.</p>
<p>Cells with the same difference <span class="math inline">\(d = j - i\)</span> lie on the same diagonal. Each edit operation shifts you slightly between diagonals.</p>
<p>The Landau–Vishkin algorithm computes, for each edit distance e (0 ≤ e ≤ k), how far we can match along each diagonal after e edits.</p>
</section>
<section id="the-main-recurrence" class="level4">
<h4 class="anchored" data-anchor-id="the-main-recurrence">The Main Recurrence</h4>
<p>Let:</p>
<ul>
<li><code>L[e][d]</code> = furthest matched prefix length on diagonal <code>d</code> (offset <code>j - i</code>) after <code>e</code> edits.</li>
</ul>
<p>We update as:</p>
<p><span class="math display">\[
L[e][d] =
\begin{cases}
L[e-1][d-1] + 1, &amp; \text{insertion},\\[4pt]
L[e-1][d+1], &amp; \text{deletion},\\[4pt]
L[e-1][d] + 1, &amp; \text{substitution (if mismatch)}.
\end{cases}
\]</span></p>
<p>Then, from that position, we extend as far as possible while characters match:</p>
<p><span class="math display">\[
\text{while } P[L[e][d]+1] = T[L[e][d]+d+1],\ L[e][d]++
\]</span></p>
<p>If at any point <span class="math inline">\(L[e][d] \ge m\)</span>, we found a match with ≤ e edits.</p>
</section>
<section id="example-plain-intuition" class="level4">
<h4 class="anchored" data-anchor-id="example-plain-intuition">Example (Plain Intuition)</h4>
<p>Let <code>P = "kitten"</code>, <code>T = "sitting"</code>, and <span class="math inline">\(k = 2\)</span>.</p>
<p>The algorithm starts by matching all diagonals with 0 edits. It then allows 1 edit (skip, replace, insert) and tracks how far matching can continue. In the end, it confirms that <code>"kitten"</code> matches <code>"sitting"</code> with 2 edits.</p>
</section>
<section id="tiny-code-python-version-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-version-1">Tiny Code (Python Version)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> landau_vishkin(text, pattern, k):</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pattern)</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>        max_edits <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>        e <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>        L <span class="op">=</span> {<span class="dv">0</span>: <span class="op">-</span><span class="dv">1</span>}</span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> e <span class="op">&lt;=</span> k:</span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>            newL <span class="op">=</span> {}</span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> d <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span>e, e <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a>                best <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>                    L.get(d <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a>                    L.get(d <span class="op">+</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>),</span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>                    L.get(d, <span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb179-14"><a href="#cb179-14" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb179-15"><a href="#cb179-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> best <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> m <span class="kw">and</span> s <span class="op">+</span> best <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> n <span class="kw">and</span> pattern[best <span class="op">+</span> <span class="dv">1</span>] <span class="op">==</span> text[s <span class="op">+</span> best <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb179-16"><a href="#cb179-16" aria-hidden="true" tabindex="-1"></a>                    best <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb179-17"><a href="#cb179-17" aria-hidden="true" tabindex="-1"></a>                newL[d] <span class="op">=</span> best</span>
<span id="cb179-18"><a href="#cb179-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> best <span class="op">&gt;=</span> m <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb179-19"><a href="#cb179-19" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Match at text position </span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">, edits ≤ </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb179-20"><a href="#cb179-20" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span></span>
<span id="cb179-21"><a href="#cb179-21" aria-hidden="true" tabindex="-1"></a>            L <span class="op">=</span> newL</span>
<span id="cb179-22"><a href="#cb179-22" aria-hidden="true" tabindex="-1"></a>            e <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb179-23"><a href="#cb179-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-24"><a href="#cb179-24" aria-hidden="true" tabindex="-1"></a>landau_vishkin(<span class="st">"sitting"</span>, <span class="st">"kitten"</span>, <span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Match at text position 0, edits ≤ 2</code></pre>
</section>
<section id="why-it-matters-73" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-73">Why It Matters</h4>
<ul>
<li><p>Linear-time for fixed k: <span class="math inline">\(O(kn)\)</span></p></li>
<li><p>Works beautifully for short error-tolerant searches</p></li>
<li><p>Foundation for algorithms in:</p>
<ul>
<li>Bioinformatics (DNA sequence alignment)</li>
<li>Spelling correction</li>
<li>Plagiarism detection</li>
<li>Approximate substring search</li>
</ul></li>
</ul>
</section>
<section id="complexity-73" class="level4">
<h4 class="anchored" data-anchor-id="complexity-73">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Match checking</td>
<td><span class="math inline">\(O(kn)\)</span></td>
<td><span class="math inline">\(O(k)\)</span></td>
</tr>
</tbody>
</table>
<p>When k is small (like 1–3), this is far faster than full DP (<span class="math inline">\(O(nm)\)</span>).</p>
</section>
<section id="try-it-yourself-73" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-73">Try It Yourself</h4>
<ol type="1">
<li>Modify to print all approximate match positions.</li>
<li>Visualize diagonals <code>d = j - i</code> for each edit step.</li>
<li>Test with random noise in text.</li>
<li>Compare runtime against DP for k=1,2,3.</li>
<li>Extend for alphabet sets (A, C, G, T).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-40" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-40">A Gentle Proof (Why It Works)</h4>
<p>Each diagonal represents a fixed alignment offset between <code>P</code> and <code>T</code>. After e edits, the algorithm records the furthest matched index reachable along each diagonal. Since each edit can only move one diagonal left or right, there are at most <span class="math inline">\(2e + 1\)</span> active diagonals per level, yielding total cost <span class="math inline">\(O(kn)\)</span>. Correctness follows from induction on the minimal number of edits.</p>
<p>Landau–Vishkin is the algorithmic art of skipping over mismatches — it finds structure in the grid of possibilities and walks the few paths that truly matter.</p>
</section>
</section>
<section id="filtering-algorithm-fast-approximate-search" class="level3">
<h3 class="anchored" data-anchor-id="filtering-algorithm-fast-approximate-search">674 Filtering Algorithm (Fast Approximate Search)</h3>
<p>The Filtering Algorithm accelerates approximate string matching by skipping most of the text using a fast exact filtering step, then confirming potential matches with a slower verification step (like dynamic programming). It is the central idea behind many modern search tools and bioinformatics systems.</p>
<section id="the-core-idea-13" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-13">The Core Idea</h4>
<p>Approximate matching is expensive if you check every substring. So instead of testing all positions, the filtering algorithm splits the pattern into segments and searches each segment <em>exactly</em>.</p>
<p>If a substring of the text approximately matches the pattern with at most <span class="math inline">\(k\)</span> errors, then at least one segment must match <em>exactly</em> (Pigeonhole principle).</p>
<p>That’s the key insight.</p>
</section>
<section id="step-by-step-breakdown" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-breakdown">Step-by-Step Breakdown</h4>
<p>Let:</p>
<ul>
<li><code>P</code> = pattern of length <span class="math inline">\(m\)</span></li>
<li><code>T</code> = text of length <span class="math inline">\(n\)</span></li>
<li><code>k</code> = maximum allowed errors</li>
</ul>
<p>We divide <code>P</code> into <span class="math inline">\(k + 1\)</span> equal (or nearly equal) blocks:</p>
<p><span class="math display">\[
P = P_1 P_2 \dots P_{k+1}
\]</span></p>
<p>If <span class="math inline">\(T\)</span> contains a substring <code>S</code> such that the edit distance between <code>P</code> and <code>S</code> ≤ <span class="math inline">\(k\)</span>, then at least one block <span class="math inline">\(P_i\)</span> must appear <em>exactly</em> inside <code>S</code>.</p>
<p>We can therefore:</p>
<ol type="1">
<li>Search each block <code>P_i</code> exactly using a fast method (like KMP or Boyer–Moore).</li>
<li>Verify surrounding regions around each found occurrence using DP up to distance <span class="math inline">\(k\)</span>.</li>
</ol>
</section>
<section id="example-53" class="level4">
<h4 class="anchored" data-anchor-id="example-53">Example</h4>
<p>Pattern <code>P = "abcdefgh"</code> k = 2 Split into 3 blocks: <code>abc | def | gh</code></p>
<p>Search the text for each block:</p>
<pre><code>T: xabcydzdefh...</code></pre>
<p>If we find <code>"abc"</code> at position 2 and <code>"def"</code> at position 8, we check their neighborhoods to see if the whole pattern aligns within 2 edits.</p>
</section>
<section id="algorithm-outline-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-outline-1">Algorithm Outline</h4>
<ol type="1">
<li><p>Divide pattern <code>P</code> into <span class="math inline">\(k + 1\)</span> blocks.</p></li>
<li><p>For each block:</p>
<ul>
<li>Find all exact matches in <code>T</code> (e.g., via KMP).</li>
<li>For each match at position <code>pos</code>, verify the surrounding substring <code>T[pos - offset : pos + m]</code> using edit distance DP.</li>
</ul></li>
<li><p>Report matches with total edits ≤ <span class="math inline">\(k\)</span>.</p></li>
</ol>
</section>
<section id="tiny-code-python-39" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-39">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb182"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> filtering_match(text, pattern, k):</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(text), <span class="bu">len</span>(pattern)</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    block_size <span class="op">=</span> m <span class="op">//</span> (k <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    matches <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> b <span class="op">*</span> block_size</span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> m <span class="cf">if</span> b <span class="op">==</span> k <span class="cf">else</span> (b <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> block_size</span>
<span id="cb182-9"><a href="#cb182-9" aria-hidden="true" tabindex="-1"></a>        block <span class="op">=</span> pattern[start:end]</span>
<span id="cb182-10"><a href="#cb182-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-11"><a href="#cb182-11" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> text.find(block)</span>
<span id="cb182-12"><a href="#cb182-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pos <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb182-13"><a href="#cb182-13" aria-hidden="true" tabindex="-1"></a>            window_start <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, pos <span class="op">-</span> start <span class="op">-</span> k)</span>
<span id="cb182-14"><a href="#cb182-14" aria-hidden="true" tabindex="-1"></a>            window_end <span class="op">=</span> <span class="bu">min</span>(n, pos <span class="op">-</span> start <span class="op">+</span> m <span class="op">+</span> k)</span>
<span id="cb182-15"><a href="#cb182-15" aria-hidden="true" tabindex="-1"></a>            window <span class="op">=</span> text[window_start:window_end]</span>
<span id="cb182-16"><a href="#cb182-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> edit_distance(window, pattern) <span class="op">&lt;=</span> k:</span>
<span id="cb182-17"><a href="#cb182-17" aria-hidden="true" tabindex="-1"></a>                matches.add(window_start)</span>
<span id="cb182-18"><a href="#cb182-18" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> text.find(block, pos <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb182-19"><a href="#cb182-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-20"><a href="#cb182-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> mpos <span class="kw">in</span> <span class="bu">sorted</span>(matches):</span>
<span id="cb182-21"><a href="#cb182-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Approximate match at position </span><span class="sc">{</span>mpos<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb182-22"><a href="#cb182-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-23"><a href="#cb182-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edit_distance(a, b):</span>
<span id="cb182-24"><a href="#cb182-24" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[i <span class="op">+</span> j <span class="cf">if</span> i <span class="op">*</span> j <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(b) <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(a) <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb182-25"><a href="#cb182-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(a) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb182-26"><a href="#cb182-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(b) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb182-27"><a href="#cb182-27" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb182-28"><a href="#cb182-28" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb182-29"><a href="#cb182-29" aria-hidden="true" tabindex="-1"></a>                dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb182-30"><a href="#cb182-30" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> (a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">!=</span> b[j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb182-31"><a href="#cb182-31" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb182-32"><a href="#cb182-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="bu">len</span>(a)][<span class="bu">len</span>(b)]</span>
<span id="cb182-33"><a href="#cb182-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-34"><a href="#cb182-34" aria-hidden="true" tabindex="-1"></a>filtering_match(<span class="st">"xxabcdefyy"</span>, <span class="st">"abcdefgh"</span>, <span class="dv">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Approximate match at position 2</code></pre>
</section>
<section id="why-it-works" class="level4">
<h4 class="anchored" data-anchor-id="why-it-works">Why It Works</h4>
<p>By the pigeonhole principle, if there are at most <span class="math inline">\(k\)</span> mismatches, then at least one segment of the pattern must be intact. So exact search on the segments drastically reduces the number of candidates to check.</p>
<p>This is especially effective for small k, where <span class="math inline">\(k + 1\)</span> segments cover the pattern evenly.</p>
</section>
<section id="complexity-74" class="level4">
<h4 class="anchored" data-anchor-id="complexity-74">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Phase</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Filtering (exact search)</td>
<td><span class="math inline">\(O((k+1)n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Verification (DP)</td>
<td><span class="math inline">\(O(km)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
</tbody>
</table>
<p>Overall, the algorithm is sublinear for small <span class="math inline">\(k\)</span> and long texts.</p>
</section>
<section id="applications" class="level4">
<h4 class="anchored" data-anchor-id="applications">Applications</h4>
<ul>
<li>Fast approximate text search</li>
<li>DNA sequence alignment (seed-and-extend model)</li>
<li>Plagiarism and similarity detection</li>
<li>Fuzzy search in large databases</li>
</ul>
</section>
<section id="try-it-yourself-74" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-74">Try It Yourself</h4>
<ol type="1">
<li>Change k and observe how filtering reduces comparisons.</li>
<li>Use Boyer–Moore for the filtering phase.</li>
<li>Measure performance on large inputs.</li>
<li>Replace edit distance DP with Myers’ bit-parallel method for speed.</li>
<li>Visualize overlapping verified regions.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-41" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-41">A Gentle Proof (Why It Works)</h4>
<p>If a substring <code>S</code> of <code>T</code> matches <code>P</code> with ≤ k errors, then after dividing <code>P</code> into <span class="math inline">\(k+1\)</span> parts, there must exist at least one block <code>P_i</code> that matches exactly within <code>S</code>. Hence, checking neighborhoods of exact block matches ensures correctness. This allows exponential pruning of non-candidate regions.</p>
<p>The filtering algorithm embodies a simple philosophy — find anchors first, verify later, turning brute-force matching into smart, scalable search.</p>
</section>
</section>
<section id="wumanber-algorithm-multi-pattern-approximate-search" class="level3">
<h3 class="anchored" data-anchor-id="wumanber-algorithm-multi-pattern-approximate-search">675 Wu–Manber Algorithm (Multi-Pattern Approximate Search)</h3>
<p>The Wu–Manber algorithm is a practical and highly efficient method for approximate multi-pattern matching. It generalizes the ideas of Boyer–Moore and Shift-And/Bitap, using block-based hashing and shift tables to skip large portions of text while still allowing for a limited number of errors.</p>
<p>It powers many classic search tools, including agrep and early grep -F variants with error tolerance.</p>
<section id="the-core-idea-14" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-14">The Core Idea</h4>
<p>Wu–Manber extends the filtering principle: search for blocks of the pattern(s) in the text, and only verify locations that might match.</p>
<p>But instead of processing one pattern at a time, it handles multiple patterns simultaneously using:</p>
<ol type="1">
<li>A hash-based block lookup table</li>
<li>A shift table that tells how far we can safely skip</li>
<li>A verification table for potential matches</li>
</ol>
</section>
<section id="how-it-works-high-level" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works-high-level">How It Works (High-Level)</h4>
<p>Let:</p>
<ul>
<li><code>P₁, P₂, ..., P_r</code> be patterns, each of length ≥ <code>B</code></li>
<li><code>B</code> = block size (typically 2 or 3)</li>
<li><code>T</code> = text of length <code>n</code></li>
<li><code>k</code> = maximum number of allowed mismatches</li>
</ul>
<p>The algorithm slides a window over <code>T</code>, considering the last <code>B</code> characters of the window as a key block.</p>
<p>If the block does not occur in any pattern, skip ahead by a precomputed shift value. If it does occur, run an approximate verification around that position.</p>
</section>
<section id="preprocessing-steps" class="level4">
<h4 class="anchored" data-anchor-id="preprocessing-steps">Preprocessing Steps</h4>
<ol type="1">
<li><p>Shift Table Construction</p>
<p>For each block <code>x</code> in the patterns, store the <em>minimum distance from the end</em> of any pattern that contains <code>x</code>. Blocks that do not appear can have a large default shift value.</p>
<p><span class="math display">\[
\text{SHIFT}[x] = \min{m - i - B + 1\ |\ P[i..i+B-1] = x}
\]</span></p></li>
<li><p>Hash Table</p>
<p>For each block, store the list of patterns that end with that block.</p>
<p><span class="math display">\[
\text{HASH}[x] = {P_j\ |\ P_j\text{ ends with }x}
\]</span></p></li>
<li><p>Verification Table</p>
<p>Store where and how to perform edit-distance verification for candidate patterns.</p></li>
</ol>
</section>
<section id="search-phase" class="level4">
<h4 class="anchored" data-anchor-id="search-phase">Search Phase</h4>
<p>Slide a window through the text from left to right:</p>
<ol type="1">
<li>Read the last <code>B</code> characters <code>x</code> of the window.</li>
<li>If <code>SHIFT[x] &gt; 0</code>, skip ahead by that value.</li>
<li>If <code>SHIFT[x] == 0</code>, possible match, verify candidate patterns in <code>HASH[x]</code> using DP or bit-parallel edit distance.</li>
</ol>
<p>Repeat until the end of text.</p>
</section>
<section id="example-54" class="level4">
<h4 class="anchored" data-anchor-id="example-54">Example</h4>
<p>Let <code>patterns = ["data", "date"]</code>, <code>B = 2</code>, and <code>k = 1</code>.</p>
<p>Text: <code>"the dataset was updated yesterday"</code></p>
<ol type="1">
<li><p>Precompute:</p>
<pre><code>SHIFT["ta"] = 0
SHIFT["da"] = 1
SHIFT["at"] = 1
others = 3</code></pre></li>
<li><p>While scanning:</p>
<ul>
<li>When the last two chars are <code>"ta"</code>, SHIFT = 0 → verify “data” and “date”.</li>
<li>At other positions, skip ahead by 1–3 chars.</li>
</ul></li>
</ol>
<p>This allows skipping most of the text while only verifying a handful of positions.</p>
</section>
<section id="tiny-code-simplified-python-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-python-version">Tiny Code (Simplified Python Version)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb185"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wu_manber(text, patterns, k<span class="op">=</span><span class="dv">0</span>, B<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>    shift <span class="op">=</span> {}</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    hash_table <span class="op">=</span> {}</span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">min</span>(<span class="bu">len</span>(p) <span class="cf">for</span> p <span class="kw">in</span> patterns)</span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>    default_shift <span class="op">=</span> m <span class="op">-</span> B <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Preprocessing</span></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> p <span class="kw">in</span> patterns:</span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">-</span> B <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>            block <span class="op">=</span> p[i:i<span class="op">+</span>B]</span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>            shift[block] <span class="op">=</span> <span class="bu">min</span>(shift.get(block, default_shift), m <span class="op">-</span> i <span class="op">-</span> B)</span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>            hash_table.setdefault(block, []).append(p)</span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Searching</span></span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> pos <span class="op">&lt;=</span> <span class="bu">len</span>(text) <span class="op">-</span> m:</span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>        block <span class="op">=</span> text[pos <span class="op">+</span> m <span class="op">-</span> B: pos <span class="op">+</span> m]</span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> shift.get(block, default_shift) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">+=</span> shift.get(block, default_shift)</span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb185-21"><a href="#cb185-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> p <span class="kw">in</span> hash_table.get(block, []):</span>
<span id="cb185-22"><a href="#cb185-22" aria-hidden="true" tabindex="-1"></a>                segment <span class="op">=</span> text[pos:pos<span class="op">+</span><span class="bu">len</span>(p)]</span>
<span id="cb185-23"><a href="#cb185-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> edit_distance(segment, p) <span class="op">&lt;=</span> k:</span>
<span id="cb185-24"><a href="#cb185-24" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Match '</span><span class="sc">{</span>p<span class="sc">}</span><span class="ss">' at position </span><span class="sc">{</span>pos<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb185-25"><a href="#cb185-25" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb185-26"><a href="#cb185-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-27"><a href="#cb185-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> edit_distance(a, b):</span>
<span id="cb185-28"><a href="#cb185-28" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[i <span class="op">+</span> j <span class="cf">if</span> i<span class="op">*</span>j <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span> <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(b) <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(a) <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb185-29"><a href="#cb185-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(a)<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb185-30"><a href="#cb185-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(b)<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb185-31"><a href="#cb185-31" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb185-32"><a href="#cb185-32" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb185-33"><a href="#cb185-33" aria-hidden="true" tabindex="-1"></a>                dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb185-34"><a href="#cb185-34" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> (a[i<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> b[j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb185-35"><a href="#cb185-35" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb185-36"><a href="#cb185-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb185-37"><a href="#cb185-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-38"><a href="#cb185-38" aria-hidden="true" tabindex="-1"></a>wu_manber(<span class="st">"the dataset was updated yesterday"</span>, [<span class="st">"data"</span>, <span class="st">"date"</span>], <span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Match 'data' at position 4
Match 'date' at position 4</code></pre>
</section>
<section id="why-it-matters-74" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-74">Why It Matters</h4>
<ul>
<li><p>Handles multiple patterns at once</p></li>
<li><p>Supports approximate matching (few mismatches)</p></li>
<li><p>Efficient on large texts (sublinear skipping)</p></li>
<li><p>Used in:</p>
<ul>
<li>agrep</li>
<li>text indexing engines</li>
<li>bioinformatics search tools</li>
</ul></li>
</ul>
</section>
<section id="complexity-75" class="level4">
<h4 class="anchored" data-anchor-id="complexity-75">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Preprocessing</td>
<td><span class="math inline">\(O(rm)\)</span></td>
<td><span class="math inline">\(O(rm)\)</span></td>
</tr>
<tr class="even">
<td>Searching</td>
<td><span class="math inline">\(O(n)\)</span> average</td>
<td><span class="math inline">\(O(rm)\)</span></td>
</tr>
</tbody>
</table>
<p>where:</p>
<ul>
<li><span class="math inline">\(r\)</span> = number of patterns</li>
<li><span class="math inline">\(m\)</span> = average pattern length</li>
</ul>
</section>
<section id="try-it-yourself-75" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-75">Try It Yourself</h4>
<ol type="1">
<li>Change block size B to 3, observe skip behavior.</li>
<li>Add more patterns with common suffixes.</li>
<li>Compare with Boyer–Moore and Aho–Corasick for speed.</li>
<li>Experiment with k = 1 and 2 (approximate case).</li>
<li>Implement bit-parallel verification (Myers’ algorithm).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-42" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-42">A Gentle Proof (Why It Works)</h4>
<p>Every true match must include at least one block that appears unchanged in both the pattern and the text segment. By hashing blocks, we find only those positions that <em>could</em> be valid matches. Shift values ensure that skipped blocks cannot possibly match, making the algorithm both correct and efficient.</p>
<p>The Wu–Manber algorithm is the master craftsman of fuzzy searching — combining hashing, skipping, and verification into one fast, elegant sweep through text.</p>
</section>
</section>
<section id="streaming-kmp-online-prefix-updates" class="level3">
<h3 class="anchored" data-anchor-id="streaming-kmp-online-prefix-updates">676 Streaming KMP (Online Prefix Updates)</h3>
<p>The Streaming KMP algorithm adapts the classical Knuth–Morris–Pratt pattern matching algorithm to the <em>streaming model</em>, where characters arrive one by one, and we must detect matches <em>immediately</em> without re-scanning previous text.</p>
<p>This is essential for real-time systems, network traffic monitoring, and live log filtering, where storing the entire input isn’t feasible.</p>
<section id="the-core-idea-15" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-15">The Core Idea</h4>
<p>In classical KMP, we precompute a prefix function <code>π</code> for the pattern <code>P</code> that helps us efficiently shift after mismatches.</p>
<p>In Streaming KMP, we maintain this same prefix state incrementally while reading characters in real time. Each new character updates the match state based only on the previous state and the current symbol.</p>
<p>This yields constant-time updates per character and constant memory overhead.</p>
</section>
<section id="the-prefix-function-refresher" class="level4">
<h4 class="anchored" data-anchor-id="the-prefix-function-refresher">The Prefix Function Refresher</h4>
<p>For a pattern <span class="math inline">\(P[0..m-1]\)</span>, the prefix function <code>π[i]</code> is defined as:</p>
<p><span class="math display">\[
π[i] = \text{length of the longest proper prefix of } P[0..i] \text{ that is also a suffix.}
\]</span></p>
<p>Example: For <code>P = "ababc"</code>, the prefix table is:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i</th>
<th>P[i]</th>
<th>π[i]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>a</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>b</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>a</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>b</td>
<td>2</td>
</tr>
<tr class="odd">
<td>4</td>
<td>c</td>
<td>0</td>
</tr>
</tbody>
</table>
</section>
<section id="streaming-update-rule" class="level4">
<h4 class="anchored" data-anchor-id="streaming-update-rule">Streaming Update Rule</h4>
<p>We maintain:</p>
<ul>
<li><code>state</code> = number of pattern characters currently matched.</li>
</ul>
<p>When a new character <code>c</code> arrives from the stream:</p>
<pre><code>while state &gt; 0 and P[state] != c:
    state = π[state - 1]
if P[state] == c:
    state += 1
if state == m:
    report match
    state = π[state - 1]</code></pre>
<p>This ensures that every input character updates the match status in O(1) time.</p>
</section>
<section id="example-55" class="level4">
<h4 class="anchored" data-anchor-id="example-55">Example</h4>
<p>Pattern: <code>"abcab"</code></p>
<p>Incoming stream: <code>"xabcabcabz"</code></p>
<p>We track the matching state:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Stream char</th>
<th>state before</th>
<th>state after</th>
<th>Match?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr class="even">
<td>a</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr class="odd">
<td>b</td>
<td>1</td>
<td>2</td>
<td></td>
</tr>
<tr class="even">
<td>c</td>
<td>2</td>
<td>3</td>
<td></td>
</tr>
<tr class="odd">
<td>a</td>
<td>3</td>
<td>4</td>
<td></td>
</tr>
<tr class="even">
<td>b</td>
<td>4</td>
<td>5</td>
<td>Ok</td>
</tr>
<tr class="odd">
<td>c</td>
<td>5→2</td>
<td>3</td>
<td></td>
</tr>
<tr class="even">
<td>a</td>
<td>3</td>
<td>4</td>
<td></td>
</tr>
<tr class="odd">
<td>b</td>
<td>4</td>
<td>5</td>
<td>Ok</td>
</tr>
</tbody>
</table>
<p>Thus, matches occur at positions 5 and 9.</p>
</section>
<section id="tiny-code-python-streaming-kmp" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-streaming-kmp">Tiny Code (Python Streaming KMP)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb188"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_prefix(P):</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(P)</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    π <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> m</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> P[i] <span class="op">!=</span> P[j]:</span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> π[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb188-8"><a href="#cb188-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> P[i] <span class="op">==</span> P[j]:</span>
<span id="cb188-9"><a href="#cb188-9" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb188-10"><a href="#cb188-10" aria-hidden="true" tabindex="-1"></a>        π[i] <span class="op">=</span> j</span>
<span id="cb188-11"><a href="#cb188-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> π</span>
<span id="cb188-12"><a href="#cb188-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-13"><a href="#cb188-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stream_kmp(P):</span>
<span id="cb188-14"><a href="#cb188-14" aria-hidden="true" tabindex="-1"></a>    π <span class="op">=</span> compute_prefix(P)</span>
<span id="cb188-15"><a href="#cb188-15" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb188-16"><a href="#cb188-16" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb188-17"><a href="#cb188-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Streaming..."</span>)</span>
<span id="cb188-18"><a href="#cb188-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-19"><a href="#cb188-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb188-20"><a href="#cb188-20" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> <span class="cf">yield</span>  <span class="co"># receive one character at a time</span></span>
<span id="cb188-21"><a href="#cb188-21" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb188-22"><a href="#cb188-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> state <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> (state <span class="op">==</span> <span class="bu">len</span>(P) <span class="kw">or</span> P[state] <span class="op">!=</span> c):</span>
<span id="cb188-23"><a href="#cb188-23" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> π[state <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb188-24"><a href="#cb188-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> P[state] <span class="op">==</span> c:</span>
<span id="cb188-25"><a href="#cb188-25" aria-hidden="true" tabindex="-1"></a>            state <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb188-26"><a href="#cb188-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="op">==</span> <span class="bu">len</span>(P):</span>
<span id="cb188-27"><a href="#cb188-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Match ending at position </span><span class="sc">{</span>pos<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb188-28"><a href="#cb188-28" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> π[state <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb188-29"><a href="#cb188-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-30"><a href="#cb188-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb188-31"><a href="#cb188-31" aria-hidden="true" tabindex="-1"></a>matcher <span class="op">=</span> stream_kmp(<span class="st">"abcab"</span>)</span>
<span id="cb188-32"><a href="#cb188-32" aria-hidden="true" tabindex="-1"></a><span class="bu">next</span>(matcher)</span>
<span id="cb188-33"><a href="#cb188-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> c <span class="kw">in</span> <span class="st">"xabcabcabz"</span>:</span>
<span id="cb188-34"><a href="#cb188-34" aria-hidden="true" tabindex="-1"></a>    matcher.send(c)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Match ending at position 5
Match ending at position 9</code></pre>
</section>
<section id="tiny-code-c-version" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-version">Tiny Code (C Version)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb190"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> compute_prefix<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>P<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>pi<span class="op">,</span> <span class="dt">int</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>    pi<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> P<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> P<span class="op">[</span>j<span class="op">])</span> j <span class="op">=</span> pi<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>P<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> P<span class="op">[</span>j<span class="op">])</span> j<span class="op">++;</span></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>        pi<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> stream_kmp<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>P<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>P<span class="op">);</span></span>
<span id="cb190-16"><a href="#cb190-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> pi<span class="op">[</span>m<span class="op">];</span></span>
<span id="cb190-17"><a href="#cb190-17" aria-hidden="true" tabindex="-1"></a>    compute_prefix<span class="op">(</span>P<span class="op">,</span> pi<span class="op">,</span> m<span class="op">);</span></span>
<span id="cb190-18"><a href="#cb190-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> state <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-19"><a href="#cb190-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> pos <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> stream<span class="op">[</span>pos<span class="op">];</span> pos<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb190-20"><a href="#cb190-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>state <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> P<span class="op">[</span>state<span class="op">]</span> <span class="op">!=</span> stream<span class="op">[</span>pos<span class="op">])</span></span>
<span id="cb190-21"><a href="#cb190-21" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> pi<span class="op">[</span>state <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb190-22"><a href="#cb190-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>P<span class="op">[</span>state<span class="op">]</span> <span class="op">==</span> stream<span class="op">[</span>pos<span class="op">])</span></span>
<span id="cb190-23"><a href="#cb190-23" aria-hidden="true" tabindex="-1"></a>            state<span class="op">++;</span></span>
<span id="cb190-24"><a href="#cb190-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>state <span class="op">==</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb190-25"><a href="#cb190-25" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">"Match ending at position </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> pos <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb190-26"><a href="#cb190-26" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> pi<span class="op">[</span>state <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb190-27"><a href="#cb190-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb190-28"><a href="#cb190-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb190-29"><a href="#cb190-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb190-30"><a href="#cb190-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-31"><a href="#cb190-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb190-32"><a href="#cb190-32" aria-hidden="true" tabindex="-1"></a>    stream_kmp<span class="op">(</span><span class="st">"abcab"</span><span class="op">,</span> <span class="st">"xabcabcabz"</span><span class="op">);</span></span>
<span id="cb190-33"><a href="#cb190-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-75" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-75">Why It Matters</h4>
<ul>
<li><p>Processes infinite streams, only keeps current state</p></li>
<li><p>No re-scanning, each symbol processed once</p></li>
<li><p>Perfect for:</p>
<ul>
<li>Real-time text filters</li>
<li>Intrusion detection systems</li>
<li>Network packet analysis</li>
<li>Online pattern analytics</li>
</ul></li>
</ul>
</section>
<section id="complexity-76" class="level4">
<h4 class="anchored" data-anchor-id="complexity-76">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Update per character</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Match detection</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-76" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-76">Try It Yourself</h4>
<ol type="1">
<li>Modify to count overlapping matches.</li>
<li>Test with continuous input streams (e.g., log tailing).</li>
<li>Implement version supporting multiple patterns (with Aho–Corasick).</li>
<li>Add reset on long mismatches.</li>
<li>Visualize prefix transitions for each new character.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-43" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-43">A Gentle Proof (Why It Works)</h4>
<p>The prefix function ensures that whenever a mismatch occurs, the algorithm knows exactly how far it can safely backtrack without losing potential matches. Streaming KMP carries this logic forward — the current <code>state</code> always equals the length of the longest prefix of <code>P</code> that matches the stream’s suffix. This invariant guarantees correctness with only constant-time updates.</p>
<p>Streaming KMP is a minimalist marvel — one integer of state, one table of prefixes, and a stream flowing through it — real-time matching with zero look-back.</p>
</section>
</section>
<section id="rolling-hash-sketch-sliding-window-hashing" class="level3">
<h3 class="anchored" data-anchor-id="rolling-hash-sketch-sliding-window-hashing">677 Rolling Hash Sketch (Sliding Window Hashing)</h3>
<p>The Rolling Hash Sketch is a fundamental trick for working with large text streams or long strings efficiently. It computes a hash of each substring (or window) of fixed length L in constant time per step, ideal for sliding-window algorithms, duplicate detection, fingerprinting, and similarity search.</p>
<p>This technique underpins many famous algorithms, including Rabin–Karp, Winnowing, and MinHash.</p>
<section id="the-core-idea-16" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-16">The Core Idea</h4>
<p>Suppose you want to hash every substring of length L in text T of length n.</p>
<p>A naive way computes each hash in <span class="math inline">\(O(L)\)</span>, giving total <span class="math inline">\(O(nL)\)</span> time. The rolling hash updates the hash in <span class="math inline">\(O(1)\)</span> as the window slides by one character.</p>
</section>
<section id="polynomial-rolling-hash" class="level4">
<h4 class="anchored" data-anchor-id="polynomial-rolling-hash">Polynomial Rolling Hash</h4>
<p>A common form treats the substring as a number in base B modulo a large prime M:</p>
<p><span class="math display">\[
H(i) = (T[i]B^{L-1} + T[i+1]B^{L-2} + \dots + T[i+L-1]) \bmod M
\]</span></p>
<p>When the window slides forward by one character, we remove the old character and add a new one:</p>
<p><span class="math display">\[
H(i+1) = (B(H(i) - T[i]B^{L-1}) + T[i+L]) \bmod M
\]</span></p>
<p>This recurrence lets us update the hash efficiently.</p>
</section>
<section id="example-56" class="level4">
<h4 class="anchored" data-anchor-id="example-56">Example</h4>
<p>Let $T = $ <code>"abcd"</code>, window length <span class="math inline">\(L = 3\)</span>, base <span class="math inline">\(B = 31\)</span>, modulus <span class="math inline">\(M = 10^9 + 9\)</span>.</p>
<p>Compute:</p>
<ul>
<li><span class="math inline">\(H(0)\)</span> for <code>"abc"</code></li>
<li>Slide one step → <span class="math inline">\(H(1)\)</span> for <code>"bcd"</code></li>
</ul>
<pre><code>H(0) = a*31^2 + b*31 + c
H(1) = (H(0) - a*31^2)*31 + d</code></pre>
</section>
<section id="tiny-code-python-40" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-40">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb192"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rolling_hash(text, L, B<span class="op">=</span><span class="dv">257</span>, M<span class="op">=</span><span class="dv">109</span> <span class="op">+</span> <span class="dv">7</span>):</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(text)</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> L:</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    hashes <span class="op">=</span> []</span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>    power <span class="op">=</span> <span class="bu">pow</span>(B, L <span class="op">-</span> <span class="dv">1</span>, M)</span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial hash</span></span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(L):</span>
<span id="cb192-12"><a href="#cb192-12" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> (h <span class="op">*</span> B <span class="op">+</span> <span class="bu">ord</span>(text[i])) <span class="op">%</span> M</span>
<span id="cb192-13"><a href="#cb192-13" aria-hidden="true" tabindex="-1"></a>    hashes.append(h)</span>
<span id="cb192-14"><a href="#cb192-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-15"><a href="#cb192-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rolling updates</span></span>
<span id="cb192-16"><a href="#cb192-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(L, n):</span>
<span id="cb192-17"><a href="#cb192-17" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> (B <span class="op">*</span> (h <span class="op">-</span> <span class="bu">ord</span>(text[i <span class="op">-</span> L]) <span class="op">*</span> power) <span class="op">+</span> <span class="bu">ord</span>(text[i])) <span class="op">%</span> M</span>
<span id="cb192-18"><a href="#cb192-18" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> (h <span class="op">+</span> M) <span class="op">%</span> M  <span class="co"># ensure non-negative</span></span>
<span id="cb192-19"><a href="#cb192-19" aria-hidden="true" tabindex="-1"></a>        hashes.append(h)</span>
<span id="cb192-20"><a href="#cb192-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-21"><a href="#cb192-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hashes</span>
<span id="cb192-22"><a href="#cb192-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-23"><a href="#cb192-23" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"abcdefg"</span></span>
<span id="cb192-24"><a href="#cb192-24" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb192-25"><a href="#cb192-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rolling_hash(text, L))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output (example hashes):</p>
<pre><code>$$6382170, 6487717, 6593264, 6698811, 6804358]</code></pre>
</section>
<section id="tiny-code-c-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-6">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb194"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MOD </span><span class="dv">1000000007</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BASE </span><span class="dv">257</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rolling_hash<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>text<span class="op">,</span> <span class="dt">int</span> L<span class="op">)</span> <span class="op">{</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> strlen<span class="op">(</span>text<span class="op">);</span></span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> L<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> power <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb194-13"><a href="#cb194-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> L<span class="op">;</span> i<span class="op">++)</span> power <span class="op">=</span> <span class="op">(</span>power <span class="op">*</span> BASE<span class="op">)</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb194-14"><a href="#cb194-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-15"><a href="#cb194-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> hash <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb194-16"><a href="#cb194-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> L<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb194-17"><a href="#cb194-17" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">=</span> <span class="op">(</span>hash <span class="op">*</span> BASE <span class="op">+</span> text<span class="op">[</span>i<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb194-18"><a href="#cb194-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-19"><a href="#cb194-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Hash[0] = </span><span class="sc">%llu\n</span><span class="st">"</span><span class="op">,</span> hash<span class="op">);</span></span>
<span id="cb194-20"><a href="#cb194-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> L<span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb194-21"><a href="#cb194-21" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">=</span> <span class="op">(</span>BASE <span class="op">*</span> <span class="op">(</span>hash <span class="op">-</span> text<span class="op">[</span>i <span class="op">-</span> L<span class="op">]</span> <span class="op">*</span> power <span class="op">%</span> MOD<span class="op">)</span> <span class="op">+</span> text<span class="op">[</span>i<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb194-22"><a href="#cb194-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span><span class="dt">int64_t</span><span class="op">)</span>hash <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> hash <span class="op">+=</span> MOD<span class="op">;</span></span>
<span id="cb194-23"><a href="#cb194-23" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"Hash[</span><span class="sc">%d</span><span class="st">] = </span><span class="sc">%llu\n</span><span class="st">"</span><span class="op">,</span> i <span class="op">-</span> L <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> hash<span class="op">);</span></span>
<span id="cb194-24"><a href="#cb194-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb194-25"><a href="#cb194-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb194-26"><a href="#cb194-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-27"><a href="#cb194-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb194-28"><a href="#cb194-28" aria-hidden="true" tabindex="-1"></a>    rolling_hash<span class="op">(</span><span class="st">"abcdefg"</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb194-29"><a href="#cb194-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-it-matters-76" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-76">Why It Matters</h4>
<ul>
<li><p>Incremental computation, perfect for streams</p></li>
<li><p>Enables constant-time substring comparison</p></li>
<li><p>Backbone of:</p>
<ul>
<li>Rabin–Karp pattern matching</li>
<li>Rolling checksum (rsync, zsync)</li>
<li>Winnowing fingerprinting</li>
<li>Deduplication systems</li>
</ul></li>
</ul>
</section>
<section id="complexity-77" class="level4">
<h4 class="anchored" data-anchor-id="complexity-77">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Initial hash</td>
<td><span class="math inline">\(O(L)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>Per update</td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Total for n windows</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-77" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-77">Try It Yourself</h4>
<ol type="1">
<li>Use two different moduli (double hashing) to reduce collisions.</li>
<li>Detect repeated substrings of length 10 in a long text.</li>
<li>Implement rolling hash for bytes (files) instead of characters.</li>
<li>Experiment with random vs sequential input for collision behavior.</li>
<li>Compare the speed against recomputing each hash from scratch.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-44" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-44">A Gentle Proof (Why It Works)</h4>
<p>When we slide the window, the contribution of the old character (<span class="math inline">\(T[i]B^{L-1}\)</span>) is subtracted, and all other characters are multiplied by <span class="math inline">\(B\)</span>. Then, the new character is added at the least significant position. This preserves the correct weighted polynomial representation modulo <span class="math inline">\(M\)</span> — so each substring’s hash is unique <em>with high probability</em>.</p>
<p>Rolling hash sketching is the algebraic heartbeat of modern text systems — each step forgets one symbol, learns another, and keeps the fingerprint of the stream alive in constant time.</p>
</section>
</section>
<section id="sketch-based-similarity-minhash-and-lsh" class="level3">
<h3 class="anchored" data-anchor-id="sketch-based-similarity-minhash-and-lsh">678 Sketch-Based Similarity (MinHash and LSH)</h3>
<p>When datasets or documents are too large to compare directly, we turn to sketch-based similarity, compact mathematical fingerprints that let us estimate how similar two pieces of text (or any data) are without reading them in full.</p>
<p>This idea powers search engines, duplicate detection, and recommendation systems through techniques like MinHash and Locality-Sensitive Hashing (LSH).</p>
<section id="the-problem" class="level4">
<h4 class="anchored" data-anchor-id="the-problem">The Problem</h4>
<p>You want to know if two long documents (say, millions of tokens each) are similar in content. Computing the exact Jaccard similarity between their sets of features (e.g.&nbsp;words, shingles, or n-grams) requires massive intersection and union operations.</p>
<p>We need a faster way, something sublinear in document size, yet accurate enough to compare at scale.</p>
</section>
<section id="the-core-idea-sketching" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-sketching">The Core Idea: Sketching</h4>
<p>A sketch is a compressed representation of a large object that preserves certain statistical properties. For text similarity, we use MinHash sketches that approximate Jaccard similarity:</p>
<p><span class="math display">\[
J(A, B) = \frac{|A \cap B|}{|A \cup B|}
\]</span></p>
<p>MinHash lets us estimate this value efficiently.</p>
</section>
<section id="minhash" class="level4">
<h4 class="anchored" data-anchor-id="minhash">MinHash</h4>
<p>For each set (say, of tokens), we apply h independent hash functions. Each hash function assigns every element a pseudo-random number, and we record the <em>minimum</em> hash value for that function.</p>
<p>Formally, for a set <span class="math inline">\(S\)</span> and hash function <span class="math inline">\(h_i\)</span>:</p>
<p><span class="math display">\[
\text{MinHash}*i(S) = \min*{x \in S} h_i(x)
\]</span></p>
<p>The resulting sketch is a vector:</p>
<p><span class="math display">\[
M(S) = [\text{MinHash}_1(S), \text{MinHash}_2(S), \dots, \text{MinHash}_h(S)]
\]</span></p>
<p>Then the similarity between two sets can be estimated by:</p>
<p><span class="math display">\[
\hat{J}(A, B) = \frac{\text{number of matching components in } M(A), M(B)}{h}
\]</span></p>
</section>
<section id="example-57" class="level4">
<h4 class="anchored" data-anchor-id="example-57">Example</h4>
<p>Let the sets be:</p>
<ul>
<li><span class="math inline">\(A = {1, 3, 5}\)</span></li>
<li><span class="math inline">\(B = {1, 2, 3, 6}\)</span></li>
</ul>
<p>and we use three simple hash functions:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Element</th>
<th>h₁(x)</th>
<th>h₂(x)</th>
<th>h₃(x)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>5</td>
<td>7</td>
<td>1</td>
</tr>
<tr class="even">
<td>2</td>
<td>6</td>
<td>3</td>
<td>4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2</td>
<td>5</td>
<td>3</td>
</tr>
<tr class="even">
<td>5</td>
<td>8</td>
<td>2</td>
<td>7</td>
</tr>
<tr class="odd">
<td>6</td>
<td>1</td>
<td>4</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>Then:</p>
<ul>
<li>MinHash(A) = [min(5,2,8)=2, min(7,5,2)=2, min(1,3,7)=1]</li>
<li>MinHash(B) = [min(5,6,2,1)=1, min(7,3,5,4)=3, min(1,4,3,6)=1]</li>
</ul>
<p>Compare elementwise: 1 of 3 match → estimated similarity <span class="math inline">\(\hat{J}=1/3\)</span>.</p>
<p>True Jaccard is <span class="math inline">\(|A∩B|/|A∪B| = 2/5 = 0.4\)</span>, so the sketch is close.</p>
</section>
<section id="tiny-code-python-41" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-41">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb195"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minhash(setA, setB, num_hashes<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>    max_hash <span class="op">=</span> <span class="dv">232</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>    seeds <span class="op">=</span> [random.randint(<span class="dv">0</span>, max_hash) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_hashes)]</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> hash_func(x, seed): <span class="cf">return</span> (<span class="bu">hash</span>((x, seed)) <span class="op">&amp;</span> max_hash)</span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> signature(s):</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [<span class="bu">min</span>(hash_func(x, seed) <span class="cf">for</span> x <span class="kw">in</span> s) <span class="cf">for</span> seed <span class="kw">in</span> seeds]</span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a>    sigA <span class="op">=</span> signature(setA)</span>
<span id="cb195-13"><a href="#cb195-13" aria-hidden="true" tabindex="-1"></a>    sigB <span class="op">=</span> signature(setB)</span>
<span id="cb195-14"><a href="#cb195-14" aria-hidden="true" tabindex="-1"></a>    matches <span class="op">=</span> <span class="bu">sum</span>(a <span class="op">==</span> b <span class="cf">for</span> a, b <span class="kw">in</span> <span class="bu">zip</span>(sigA, sigB))</span>
<span id="cb195-15"><a href="#cb195-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> matches <span class="op">/</span> num_hashes</span>
<span id="cb195-16"><a href="#cb195-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-17"><a href="#cb195-17" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> {<span class="st">"data"</span>, <span class="st">"machine"</span>, <span class="st">"learning"</span>, <span class="st">"hash"</span>}</span>
<span id="cb195-18"><a href="#cb195-18" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> {<span class="st">"data"</span>, <span class="st">"machine"</span>, <span class="st">"hash"</span>, <span class="st">"model"</span>}</span>
<span id="cb195-19"><a href="#cb195-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Estimated similarity:"</span>, minhash(A, B))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output (approximate):</p>
<pre><code>Estimated similarity: 0.75</code></pre>
</section>
<section id="from-minhash-to-lsh" class="level4">
<h4 class="anchored" data-anchor-id="from-minhash-to-lsh">From MinHash to LSH</h4>
<p>Locality-Sensitive Hashing (LSH) boosts MinHash for fast <em>lookup</em>. It groups similar sketches into the same “buckets” with high probability, so we can find near-duplicates in constant time.</p>
<p>Divide the sketch of length <code>h</code> into <code>b</code> <em>bands</em> of <code>r</code> rows each:</p>
<ul>
<li>Hash each band to a bucket.</li>
<li>If two documents share a bucket in <em>any</em> band, they’re likely similar.</li>
</ul>
<p>This transforms global comparison into probabilistic indexing.</p>
</section>
<section id="why-it-matters-77" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-77">Why It Matters</h4>
<ul>
<li><p>Enables fast similarity search in massive collections</p></li>
<li><p>Space-efficient: fixed-size sketches per document</p></li>
<li><p>Used in:</p>
<ul>
<li>Search engine deduplication (Google, Bing)</li>
<li>Document clustering</li>
<li>Plagiarism detection</li>
<li>Large-scale recommender systems</li>
</ul></li>
</ul>
</section>
<section id="complexity-78" class="level4">
<h4 class="anchored" data-anchor-id="complexity-78">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build sketch</td>
<td><span class="math inline">\(O(h       | S      | )\)</span></td>
<td><span class="math inline">\(O(h)\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Compare two sets</td>
<td><span class="math inline">\(O(h)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>LSH lookup</td>
<td><span class="math inline">\(O(1)\)</span> avg</td>
<td><span class="math inline">\(O(h)\)</span></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-78" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-78">Try It Yourself</h4>
<ol type="1">
<li>Create MinHash sketches for multiple documents and visualize pairwise similarities.</li>
<li>Vary number of hash functions (10, 100, 500), see accuracy tradeoff.</li>
<li>Experiment with 2-band and 3-band LSH grouping.</li>
<li>Compare with cosine similarity on TF-IDF vectors.</li>
<li>Apply to sets of n-grams from text paragraphs.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-45" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-45">A Gentle Proof (Why It Works)</h4>
<p>For a random hash function <span class="math inline">\(h\)</span>, the probability that <span class="math inline">\(\min(h(A)) = \min(h(B))\)</span> equals the Jaccard similarity <span class="math inline">\(J(A, B)\)</span>. Hence, the expected fraction of equal components in MinHash signatures approximates <span class="math inline">\(J(A, B)\)</span>. This elegant statistical property makes MinHash both unbiased and provably accurate.</p>
<p>Sketch-based similarity compresses meaning into a handful of numbers — tiny digital echoes of entire documents, allowing machines to remember, compare, and cluster the world’s text at scale.</p>
</section>
</section>
<section id="weighted-edit-distance-weighted-operations" class="level3">
<h3 class="anchored" data-anchor-id="weighted-edit-distance-weighted-operations">679 Weighted Edit Distance (Weighted Operations)</h3>
<p>The Weighted Edit Distance generalizes the classic Levenshtein distance by assigning <em>different costs</em> to insertions, deletions, and substitutions, or even to specific character pairs. This makes it far more flexible for real-world tasks such as spelling correction, speech recognition, OCR, and biological sequence analysis, where some errors are <em>more likely</em> than others.</p>
<section id="the-core-idea-17" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-17">The Core Idea</h4>
<p>In standard edit distance, every operation costs 1. In weighted edit distance, each operation has its own cost function:</p>
<ul>
<li><span class="math inline">\(w_{ins}(a)\)</span>, cost of inserting character <em>a</em></li>
<li><span class="math inline">\(w_{del}(a)\)</span>, cost of deleting character <em>a</em></li>
<li><span class="math inline">\(w_{sub}(a,b)\)</span>, cost of substituting <em>a</em> with <em>b</em></li>
</ul>
<p>The goal is to find the minimum total cost to transform one string into another.</p>
</section>
<section id="the-recurrence" class="level4">
<h4 class="anchored" data-anchor-id="the-recurrence">The Recurrence</h4>
<p>Let <span class="math inline">\(dp[i][j]\)</span> be the minimum cost to convert <span class="math inline">\(s_1[0..i-1]\)</span> into <span class="math inline">\(s_2[0..j-1]\)</span>. Then:</p>
<p><span class="math display">\[
dp[i][j] = \min
\begin{cases}
dp[i-1][j] + w_{\text{del}}(s_1[i-1]), &amp; \text{(deletion)},\\[4pt]
dp[i][j-1] + w_{\text{ins}}(s_2[j-1]), &amp; \text{(insertion)},\\[4pt]
dp[i-1][j-1] + w_{\text{sub}}(s_1[i-1], s_2[j-1]), &amp; \text{(substitution)}.
\end{cases}
\]</span></p>
<p>with the base cases:</p>
<p><span class="math display">\[
dp[0][j] = \sum_{k=1}^{j} w_{ins}(s_2[k-1])
\]</span></p>
<p><span class="math display">\[
dp[i][0] = \sum_{k=1}^{i} w_{del}(s_1[k-1])
\]</span></p>
</section>
<section id="example-58" class="level4">
<h4 class="anchored" data-anchor-id="example-58">Example</h4>
<p>Let’s compare <code>"kitten"</code> and <code>"sitting"</code> with:</p>
<ul>
<li><span class="math inline">\(w_{sub}(a,a)=0\)</span>, <span class="math inline">\(w_{sub}(a,b)=2\)</span></li>
<li><span class="math inline">\(w_{ins}(a)=1\)</span>, <span class="math inline">\(w_{del}(a)=1\)</span></li>
</ul>
<p>Then operations:</p>
<pre><code>kitten → sitten (substitute 'k'→'s', cost 2)
sitten → sittin (insert 'i', cost 1)
sittin → sitting (insert 'g', cost 1)</code></pre>
<p>Total cost = 4.</p>
</section>
<section id="tiny-code-python-42" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-42">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb198"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> weighted_edit_distance(s1, s2, w_sub, w_ins, w_del):</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s1), <span class="bu">len</span>(s2)</span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> w_del(s1[i<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> w_ins(s2[j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">min</span>(</span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> w_del(s1[i<span class="op">-</span><span class="dv">1</span>]),</span>
<span id="cb198-14"><a href="#cb198-14" aria-hidden="true" tabindex="-1"></a>                dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> w_ins(s2[j<span class="op">-</span><span class="dv">1</span>]),</span>
<span id="cb198-15"><a href="#cb198-15" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> w_sub(s1[i<span class="op">-</span><span class="dv">1</span>], s2[j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb198-16"><a href="#cb198-16" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb198-17"><a href="#cb198-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb198-18"><a href="#cb198-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-19"><a href="#cb198-19" aria-hidden="true" tabindex="-1"></a>w_sub <span class="op">=</span> <span class="kw">lambda</span> a,b: <span class="dv">0</span> <span class="cf">if</span> a<span class="op">==</span>b <span class="cf">else</span> <span class="dv">2</span></span>
<span id="cb198-20"><a href="#cb198-20" aria-hidden="true" tabindex="-1"></a>w_ins <span class="op">=</span> <span class="kw">lambda</span> a: <span class="dv">1</span></span>
<span id="cb198-21"><a href="#cb198-21" aria-hidden="true" tabindex="-1"></a>w_del <span class="op">=</span> <span class="kw">lambda</span> a: <span class="dv">1</span></span>
<span id="cb198-22"><a href="#cb198-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-23"><a href="#cb198-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(weighted_edit_distance(<span class="st">"kitten"</span>, <span class="st">"sitting"</span>, w_sub, w_ins, w_del))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>4</code></pre>
</section>
<section id="tiny-code-c-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-7">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb200"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min3<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&lt;</span> b <span class="op">?</span> <span class="op">(</span>a <span class="op">&lt;</span> c <span class="op">?</span> a <span class="op">:</span> c<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>b <span class="op">&lt;</span> c <span class="op">?</span> b <span class="op">:</span> c<span class="op">);</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> weighted_edit_distance<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>s1<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>s1<span class="op">),</span> n <span class="op">=</span> strlen<span class="op">(</span>s2<span class="op">);</span></span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-13"><a href="#cb200-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb200-14"><a href="#cb200-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb200-15"><a href="#cb200-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-16"><a href="#cb200-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb200-17"><a href="#cb200-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb200-18"><a href="#cb200-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> cost <span class="op">=</span> <span class="op">(</span>s1<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> s2<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb200-19"><a href="#cb200-19" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> min3<span class="op">(</span></span>
<span id="cb200-20"><a href="#cb200-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb200-21"><a href="#cb200-21" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb200-22"><a href="#cb200-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> cost</span>
<span id="cb200-23"><a href="#cb200-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">);</span></span>
<span id="cb200-24"><a href="#cb200-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb200-25"><a href="#cb200-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb200-26"><a href="#cb200-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb200-27"><a href="#cb200-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb200-28"><a href="#cb200-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-29"><a href="#cb200-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb200-30"><a href="#cb200-30" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> weighted_edit_distance<span class="op">(</span><span class="st">"kitten"</span><span class="op">,</span> <span class="st">"sitting"</span><span class="op">));</span></span>
<span id="cb200-31"><a href="#cb200-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>4</code></pre>
</section>
<section id="why-it-matters-78" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-78">Why It Matters</h4>
<p>Weighted edit distance lets us model real-world asymmetry in transformations:</p>
<ul>
<li>OCR: confusing “O” and “0” costs less than “O” → “X”</li>
<li>Phonetic comparison: “f” ↔︎ “ph” substitution is low cost</li>
<li>Bioinformatics: insertion/deletion penalties depend on gap length</li>
<li>Spelling correction: keyboard-adjacent errors cost less</li>
</ul>
<p>This fine-grained control gives both better accuracy and more natural error tolerance.</p>
</section>
<section id="complexity-79" class="level4">
<h4 class="anchored" data-anchor-id="complexity-79">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Full DP</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
<tr class="even">
<td>Space-optimized</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(\min(m,n))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-79" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-79">Try It Yourself</h4>
<ol type="1">
<li>Use real keyboard layout to define <span class="math inline">\(w_{sub}(a,b)\)</span> = distance on QWERTY grid.</li>
<li>Compare the difference between equal and asymmetric costs.</li>
<li>Modify insertion/deletion penalties to simulate gap opening vs extension.</li>
<li>Visualize DP cost surface as a heatmap.</li>
<li>Use weighted edit distance to rank OCR correction candidates.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-46" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-46">A Gentle Proof (Why It Works)</h4>
<p>Weighted edit distance preserves the dynamic programming principle: the minimal cost of transforming prefixes depends only on smaller subproblems. By assigning non-negative, consistent weights, the algorithm guarantees an optimal transformation under those cost definitions. It generalizes Levenshtein distance as a special case where all costs are 1.</p>
<p>Weighted edit distance turns string comparison from a rigid count of edits into a nuanced reflection of <em>how wrong</em> a change is — making it one of the most human-like measures in text algorithms.</p>
</section>
</section>
<section id="online-levenshtein-dynamic-stream-update" class="level3">
<h3 class="anchored" data-anchor-id="online-levenshtein-dynamic-stream-update">680 Online Levenshtein (Dynamic Stream Update)</h3>
<p>The Online Levenshtein algorithm brings edit distance computation into the streaming world, it updates the distance incrementally as new characters arrive, instead of recomputing the entire dynamic programming (DP) table. This is essential for real-time spell checking, voice transcription, and DNA stream alignment, where text or data comes one symbol at a time.</p>
<section id="the-core-idea-18" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-18">The Core Idea</h4>
<p>The classic Levenshtein distance builds a full table of size <span class="math inline">\(m \times n\)</span>, comparing all prefixes of strings <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. In an <em>online setting</em>, the text <span class="math inline">\(T\)</span> grows over time, but the pattern <span class="math inline">\(P\)</span> stays fixed.</p>
<p>We don’t want to rebuild everything each time a new character appears — instead, we update the last DP row efficiently to reflect the new input.</p>
<p>This means maintaining the current edit distance between the fixed pattern and the ever-growing text prefix.</p>
</section>
<section id="standard-levenshtein-recap" class="level4">
<h4 class="anchored" data-anchor-id="standard-levenshtein-recap">Standard Levenshtein Recap</h4>
<p>For strings <span class="math inline">\(P[0..m-1]\)</span> and <span class="math inline">\(T[0..n-1]\)</span>:</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
i, &amp; \text{if } j = 0,\\[4pt]
j, &amp; \text{if } i = 0,\\[6pt]
\min
\begin{cases}
dp[i-1][j] + 1, &amp; \text{(deletion)},\\[4pt]
dp[i][j-1] + 1, &amp; \text{(insertion)},\\[4pt]
dp[i-1][j-1] + [P[i-1] \ne T[j-1]], &amp; \text{(substitution)}.
\end{cases}
\end{cases}
\]</span></p>
<p>The final distance is <span class="math inline">\(dp[m][n]\)</span>.</p>
</section>
<section id="online-variant" class="level4">
<h4 class="anchored" data-anchor-id="online-variant">Online Variant</h4>
<p>When a new character <span class="math inline">\(t\)</span> arrives, we keep only the previous row and update it in <span class="math inline">\(O(m)\)</span> time.</p>
<p>Let <code>prev[i]</code> = cost for aligning <code>P[:i]</code> with <code>T[:j-1]</code>, and <code>curr[i]</code> = cost for <code>T[:j]</code>.</p>
<p>Update rule for new character <code>t</code>:</p>
<p><span class="math display">\[
curr[0] = j
\]</span></p>
<p><span class="math display">\[
curr[i] = \min
\begin{cases}
prev[i] + 1, &amp; \text{(deletion)},\\[4pt]
curr[i-1] + 1, &amp; \text{(insertion)},\\[4pt]
prev[i-1] + [P[i-1] \ne t], &amp; \text{(substitution)}.
\end{cases}
\]</span></p>
<p>After processing, replace <code>prev = curr</code>.</p>
</section>
<section id="example-59" class="level4">
<h4 class="anchored" data-anchor-id="example-59">Example</h4>
<p>Pattern <code>P = "kitten"</code> Streaming text: <code>"kit", "kitt", "kitte", "kitten"</code></p>
<p>We update one row per character:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Input</th>
<th>Distance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“k”</td>
<td>5</td>
<td></td>
</tr>
<tr class="even">
<td>“ki”</td>
<td>4</td>
<td></td>
</tr>
<tr class="odd">
<td>“kit”</td>
<td>3</td>
<td></td>
</tr>
<tr class="even">
<td>“kitt”</td>
<td>2</td>
<td></td>
</tr>
<tr class="odd">
<td>“kitte”</td>
<td>1</td>
<td></td>
</tr>
<tr class="even">
<td>“kitten”</td>
<td>0</td>
<td></td>
</tr>
</tbody>
</table>
<p>The distance drops gradually to 0 as we reach a full match.</p>
</section>
<section id="tiny-code-python-stream-based" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-stream-based">Tiny Code (Python, Stream-Based)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb202"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> online_levenshtein(pattern):</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(pattern)</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>    j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> <span class="cf">yield</span> prev[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># current distance</span></span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a>        j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb202-9"><a href="#cb202-9" aria-hidden="true" tabindex="-1"></a>        curr <span class="op">=</span> [j]</span>
<span id="cb202-10"><a href="#cb202-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb202-11"><a href="#cb202-11" aria-hidden="true" tabindex="-1"></a>            cost <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> pattern[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> c <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb202-12"><a href="#cb202-12" aria-hidden="true" tabindex="-1"></a>            curr.append(<span class="bu">min</span>(</span>
<span id="cb202-13"><a href="#cb202-13" aria-hidden="true" tabindex="-1"></a>                prev[i] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb202-14"><a href="#cb202-14" aria-hidden="true" tabindex="-1"></a>                curr[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb202-15"><a href="#cb202-15" aria-hidden="true" tabindex="-1"></a>                prev[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> cost</span>
<span id="cb202-16"><a href="#cb202-16" aria-hidden="true" tabindex="-1"></a>            ))</span>
<span id="cb202-17"><a href="#cb202-17" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> curr</span>
<span id="cb202-18"><a href="#cb202-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-19"><a href="#cb202-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb202-20"><a href="#cb202-20" aria-hidden="true" tabindex="-1"></a>stream <span class="op">=</span> online_levenshtein(<span class="st">"kitten"</span>)</span>
<span id="cb202-21"><a href="#cb202-21" aria-hidden="true" tabindex="-1"></a><span class="bu">next</span>(stream)</span>
<span id="cb202-22"><a href="#cb202-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ch <span class="kw">in</span> <span class="st">"kitten"</span>:</span>
<span id="cb202-23"><a href="#cb202-23" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> stream.send(ch)</span>
<span id="cb202-24"><a href="#cb202-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"After '</span><span class="sc">{</span>ch<span class="sc">}</span><span class="ss">': distance = </span><span class="sc">{</span>d<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>After 'k': distance = 5
After 'i': distance = 4
After 't': distance = 3
After 't': distance = 2
After 'e': distance = 1
After 'n': distance = 0</code></pre>
</section>
<section id="tiny-code-c-version-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-version-1">Tiny Code (C Version)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb204"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> online_levenshtein<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>pattern<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>stream<span class="op">)</span> <span class="op">{</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>pattern<span class="op">);</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>prev <span class="op">=</span> malloc<span class="op">((</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>curr <span class="op">=</span> malloc<span class="op">((</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> prev<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb204-11"><a href="#cb204-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-12"><a href="#cb204-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> stream<span class="op">[</span>j<span class="op">];</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb204-13"><a href="#cb204-13" aria-hidden="true" tabindex="-1"></a>        curr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb204-14"><a href="#cb204-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb204-15"><a href="#cb204-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> cost <span class="op">=</span> <span class="op">(</span>pattern<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> stream<span class="op">[</span>j<span class="op">])</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb204-16"><a href="#cb204-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> del <span class="op">=</span> prev<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb204-17"><a href="#cb204-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> ins <span class="op">=</span> curr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb204-18"><a href="#cb204-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> sub <span class="op">=</span> prev<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> cost<span class="op">;</span></span>
<span id="cb204-19"><a href="#cb204-19" aria-hidden="true" tabindex="-1"></a>            curr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> del <span class="op">&lt;</span> ins <span class="op">?</span> <span class="op">(</span>del <span class="op">&lt;</span> sub <span class="op">?</span> del <span class="op">:</span> sub<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>ins <span class="op">&lt;</span> sub <span class="op">?</span> ins <span class="op">:</span> sub<span class="op">);</span></span>
<span id="cb204-20"><a href="#cb204-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb204-21"><a href="#cb204-21" aria-hidden="true" tabindex="-1"></a>        memcpy<span class="op">(</span>prev<span class="op">,</span> curr<span class="op">,</span> <span class="op">(</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb204-22"><a href="#cb204-22" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"After '</span><span class="sc">%c</span><span class="st">': distance = </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> stream<span class="op">[</span>j<span class="op">],</span> prev<span class="op">[</span>m<span class="op">]);</span></span>
<span id="cb204-23"><a href="#cb204-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb204-24"><a href="#cb204-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-25"><a href="#cb204-25" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>prev<span class="op">);</span></span>
<span id="cb204-26"><a href="#cb204-26" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>curr<span class="op">);</span></span>
<span id="cb204-27"><a href="#cb204-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb204-28"><a href="#cb204-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-29"><a href="#cb204-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb204-30"><a href="#cb204-30" aria-hidden="true" tabindex="-1"></a>    online_levenshtein<span class="op">(</span><span class="st">"kitten"</span><span class="op">,</span> <span class="st">"kitten"</span><span class="op">);</span></span>
<span id="cb204-31"><a href="#cb204-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>After 'k': distance = 5
After 'i': distance = 4
After 't': distance = 3
After 't': distance = 2
After 'e': distance = 1
After 'n': distance = 0</code></pre>
</section>
<section id="why-it-matters-79" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-79">Why It Matters</h4>
<ul>
<li><p>Efficient for live input processing</p></li>
<li><p>No need to re-run full DP on each new symbol</p></li>
<li><p>Ideal for:</p>
<ul>
<li>Speech-to-text correction</li>
<li>DNA sequence alignment streaming</li>
<li>Autocorrect as-you-type</li>
<li>Real-time data cleaning</li>
</ul></li>
</ul>
</section>
<section id="complexity-80" class="level4">
<h4 class="anchored" data-anchor-id="complexity-80">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Per character</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Total (n characters)</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
</tbody>
</table>
<p>Linear time per symbol with constant memory reuse, a massive gain for continuous input streams.</p>
</section>
<section id="try-it-yourself-80" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-80">Try It Yourself</h4>
<ol type="1">
<li>Test with varying-length streams to see when distance stops changing.</li>
<li>Implement for k-bounded version (stop when distance &gt; k).</li>
<li>Use character weights for insert/delete penalties.</li>
<li>Visualize how the cost evolves over time for a noisy stream.</li>
<li>Connect to a live keyboard or file reader for interactive demos.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-47" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-47">A Gentle Proof (Why It Works)</h4>
<p>At any step, the online update only depends on the previous prefix cost vector and the new input symbol. Each update preserves the DP invariant: <code>prev[i]</code> equals the edit distance between <code>pattern[:i]</code> and the current text prefix. Thus, after processing the full stream, the last cell is the true edit distance, achieved incrementally.</p>
<p>The online Levenshtein algorithm turns edit distance into a living process — each new symbol nudges the score, one heartbeat at a time, making it the core of real-time similarity detection.</p>
</section>
</section>
</section>
<section id="section-69.-bioinformatics-alignment" class="level1">
<h1>Section 69. Bioinformatics Alignment</h1>
<section id="needlemanwunsch-global-sequence-alignment" class="level3">
<h3 class="anchored" data-anchor-id="needlemanwunsch-global-sequence-alignment">681 Needleman–Wunsch (Global Sequence Alignment)</h3>
<p>The Needleman–Wunsch algorithm is a foundational method in bioinformatics for computing the global alignment between two sequences. It finds the <em>best possible end-to-end match</em> by maximizing alignment score through dynamic programming.</p>
<p>Originally developed for aligning biological sequences (like DNA or proteins), it also applies to text similarity, time series, and version diffing, anywhere full-sequence comparison is needed.</p>
<section id="the-idea-1" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-1">The Idea</h4>
<p>Given two sequences, we want to align them so that:</p>
<ul>
<li>Similar characters are matched.</li>
<li>Gaps (insertions/deletions) are penalized.</li>
<li>The total alignment score is maximized.</li>
</ul>
<p>Each position in the alignment can be:</p>
<ul>
<li>Match (same symbol)</li>
<li>Mismatch (different symbols)</li>
<li>Gap (missing symbol in one sequence)</li>
</ul>
</section>
<section id="scoring-system" class="level4">
<h4 class="anchored" data-anchor-id="scoring-system">Scoring System</h4>
<p>We define:</p>
<ul>
<li>Match score: +1</li>
<li>Mismatch penalty: -1</li>
<li>Gap penalty: -2</li>
</ul>
<p>You can adjust these depending on the domain (e.g., biological substitutions or linguistic mismatches).</p>
</section>
<section id="the-dp-formulation" class="level4">
<h4 class="anchored" data-anchor-id="the-dp-formulation">The DP Formulation</h4>
<p>Let:</p>
<ul>
<li><span class="math inline">\(A[1..m]\)</span> = first sequence</li>
<li><span class="math inline">\(B[1..n]\)</span> = second sequence</li>
<li><span class="math inline">\(dp[i][j]\)</span> = maximum score aligning <span class="math inline">\(A[1..i]\)</span> with <span class="math inline">\(B[1..j]\)</span></li>
</ul>
<p>Then:</p>
<p><span class="math display">\[
dp[i][j] = \max
\begin{cases}
dp[i-1][j-1] + s(A_i, B_j), &amp; \text{(match/mismatch)},\\[4pt]
dp[i-1][j] + \text{gap}, &amp; \text{(deletion)},\\[4pt]
dp[i][j-1] + \text{gap}, &amp; \text{(insertion)}.
\end{cases}
\]</span></p>
<p>with initialization:</p>
<p><span class="math display">\[
dp[0][j] = j \times \text{gap}, \quad dp[i][0] = i \times \text{gap}
\]</span></p>
</section>
<section id="example-60" class="level4">
<h4 class="anchored" data-anchor-id="example-60">Example</h4>
<p>Let A = <code>"GATT"</code> B = <code>"GCAT"</code></p>
<p>Match = +1, Mismatch = -1, Gap = -2.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th></th>
<th>G</th>
<th>C</th>
<th>A</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>0</td>
<td>-2</td>
<td>-4</td>
<td>-6</td>
<td>-8</td>
</tr>
<tr class="even">
<td>G</td>
<td>-2</td>
<td>1</td>
<td>-1</td>
<td>-3</td>
<td>-5</td>
</tr>
<tr class="odd">
<td>A</td>
<td>-4</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>-2</td>
</tr>
<tr class="even">
<td>T</td>
<td>-6</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>T</td>
<td>-8</td>
<td>-5</td>
<td>-4</td>
<td>-3</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>The optimal global alignment score = 1.</p>
<p>Aligned sequences:</p>
<pre><code>G A T T
| | |  
G - A T</code></pre>
</section>
<section id="tiny-code-python-43" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-43">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb207"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> needleman_wunsch(seq1, seq2, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(seq1), <span class="bu">len</span>(seq2)</span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i <span class="op">*</span> gap</span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j <span class="op">*</span> gap</span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-10"><a href="#cb207-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb207-11"><a href="#cb207-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb207-12"><a href="#cb207-12" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> match <span class="cf">if</span> seq1[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> seq2[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb207-13"><a href="#cb207-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb207-14"><a href="#cb207-14" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> score,</span>
<span id="cb207-15"><a href="#cb207-15" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb207-16"><a href="#cb207-16" aria-hidden="true" tabindex="-1"></a>                dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb207-17"><a href="#cb207-17" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb207-18"><a href="#cb207-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-19"><a href="#cb207-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb208"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(needleman_wunsch(<span class="st">"GATT"</span>, <span class="st">"GCAT"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>1</code></pre>
</section>
<section id="tiny-code-c-8" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-8">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb210"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MATCH     </span><span class="dv">1</span></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MISMATCH </span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define GAP      </span><span class="op">-</span><span class="dv">2</span></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max3<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> <span class="op">(</span>a <span class="op">&gt;</span> c <span class="op">?</span> a <span class="op">:</span> c<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>b <span class="op">&gt;</span> c <span class="op">?</span> b <span class="op">:</span> c<span class="op">);</span></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb210-11"><a href="#cb210-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-12"><a href="#cb210-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> needleman_wunsch<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>A<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>B<span class="op">)</span> <span class="op">{</span></span>
<span id="cb210-13"><a href="#cb210-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>A<span class="op">),</span> n <span class="op">=</span> strlen<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb210-14"><a href="#cb210-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb210-15"><a href="#cb210-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-16"><a href="#cb210-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> GAP<span class="op">;</span></span>
<span id="cb210-17"><a href="#cb210-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> j <span class="op">*</span> GAP<span class="op">;</span></span>
<span id="cb210-18"><a href="#cb210-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-19"><a href="#cb210-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb210-20"><a href="#cb210-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb210-21"><a href="#cb210-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> score <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">?</span> MATCH <span class="op">:</span> MISMATCH<span class="op">;</span></span>
<span id="cb210-22"><a href="#cb210-22" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max3<span class="op">(</span></span>
<span id="cb210-23"><a href="#cb210-23" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> score<span class="op">,</span></span>
<span id="cb210-24"><a href="#cb210-24" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> GAP<span class="op">,</span></span>
<span id="cb210-25"><a href="#cb210-25" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> GAP</span>
<span id="cb210-26"><a href="#cb210-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">);</span></span>
<span id="cb210-27"><a href="#cb210-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb210-28"><a href="#cb210-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb210-29"><a href="#cb210-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb210-30"><a href="#cb210-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb210-31"><a href="#cb210-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-32"><a href="#cb210-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb210-33"><a href="#cb210-33" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Alignment score: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> needleman_wunsch<span class="op">(</span><span class="st">"GATT"</span><span class="op">,</span> <span class="st">"GCAT"</span><span class="op">));</span></span>
<span id="cb210-34"><a href="#cb210-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Alignment score: 1</code></pre>
</section>
<section id="why-it-matters-80" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-80">Why It Matters</h4>
<ul>
<li>The foundation of sequence alignment in computational biology</li>
<li>Finds best full-length alignment (not just a matching substring)</li>
<li>Extensible to affine gaps and probabilistic scoring (e.g., substitution matrices)</li>
</ul>
<p>Applications:</p>
<ul>
<li>DNA/protein sequence analysis</li>
<li>Diff tools for text comparison</li>
<li>Speech and handwriting recognition</li>
</ul>
</section>
<section id="complexity-81" class="level4">
<h4 class="anchored" data-anchor-id="complexity-81">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Full DP</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
<tr class="even">
<td>Space-optimized</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(\min(m, n))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-81" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-81">Try It Yourself</h4>
<ol type="1">
<li>Change scoring parameters and observe alignment changes.</li>
<li>Modify to print aligned sequences using traceback.</li>
<li>Apply to real DNA strings.</li>
<li>Compare with Smith–Waterman (local alignment).</li>
<li>Optimize memory to store only two rows.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-48" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-48">A Gentle Proof (Why It Works)</h4>
<p>Needleman–Wunsch obeys the principle of optimality: the optimal alignment of two prefixes must include the optimal alignment of their smaller prefixes. Dynamic programming guarantees global optimality by enumerating all possible gap/match paths and keeping the maximum score at each step.</p>
<p>Needleman–Wunsch is where modern sequence alignment began — a clear, elegant model for matching two worlds symbol by symbol, one step, one gap, one choice at a time.</p>
</section>
</section>
<section id="smithwaterman-local-sequence-alignment" class="level3">
<h3 class="anchored" data-anchor-id="smithwaterman-local-sequence-alignment">682 Smith–Waterman (Local Sequence Alignment)</h3>
<p>The Smith–Waterman algorithm is the local counterpart of Needleman–Wunsch. Instead of aligning entire sequences end to end, it finds the most similar local region, the best matching substring pair within two sequences.</p>
<p>This makes it ideal for gene or protein similarity search, plagiarism detection, and fuzzy substring matching, where only part of the sequences align well.</p>
<section id="the-core-idea-19" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-19">The Core Idea</h4>
<p>Given two sequences <span class="math inline">\(A[1..m]\)</span> and <span class="math inline">\(B[1..n]\)</span>, we want to find the maximum scoring local alignment, meaning:</p>
<ul>
<li>Substrings that align with the highest similarity score.</li>
<li>No penalty for unaligned prefixes or suffixes.</li>
</ul>
<p>To do this, we use dynamic programming like Needleman–Wunsch, but we never allow negative scores to propagate, once an alignment gets “too bad,” we reset it to 0.</p>
</section>
<section id="the-dp-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-dp-formula">The DP Formula</h4>
<p>Let <span class="math inline">\(dp[i][j]\)</span> be the best local alignment score ending at positions <span class="math inline">\(A[i]\)</span> and <span class="math inline">\(B[j]\)</span>. Then:</p>
<p><span class="math display">\[
dp[i][j] = \max
\begin{cases}
0,\\[4pt]
dp[i-1][j-1] + s(A_i, B_j), &amp; \text{(match/mismatch)},\\[4pt]
dp[i-1][j] + \text{gap}, &amp; \text{(deletion)},\\[4pt]
dp[i][j-1] + \text{gap}, &amp; \text{(insertion)}.
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(s(A_i, B_j)\)</span> is +1 for match and -1 for mismatch, and the <code>gap</code> penalty is negative.</p>
<p>The final alignment score is:</p>
<p><span class="math display">\[
\text{max\_score} = \max_{i,j} dp[i][j]
\]</span></p>
</section>
<section id="example-61" class="level4">
<h4 class="anchored" data-anchor-id="example-61">Example</h4>
<p>Let A = <code>"ACACACTA"</code> B = <code>"AGCACACA"</code></p>
<p>Scoring: Match = +2, Mismatch = -1, Gap = -2.</p>
<p>During DP computation, negative values are clamped to zero. The best local alignment is:</p>
<pre><code>ACACACTA
 ||||||
AGCACACA</code></pre>
<p>Local score = 10 (best substring match).</p>
</section>
<section id="tiny-code-python-44" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-44">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb213"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> smith_waterman(seq1, seq2, match<span class="op">=</span><span class="dv">2</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(seq1), <span class="bu">len</span>(seq2)</span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>    max_score <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb213-8"><a href="#cb213-8" aria-hidden="true" tabindex="-1"></a>            score <span class="op">=</span> match <span class="cf">if</span> seq1[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> seq2[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb213-9"><a href="#cb213-9" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb213-10"><a href="#cb213-10" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>,</span>
<span id="cb213-11"><a href="#cb213-11" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> score,</span>
<span id="cb213-12"><a href="#cb213-12" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb213-13"><a href="#cb213-13" aria-hidden="true" tabindex="-1"></a>                dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb213-14"><a href="#cb213-14" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb213-15"><a href="#cb213-15" aria-hidden="true" tabindex="-1"></a>            max_score <span class="op">=</span> <span class="bu">max</span>(max_score, dp[i][j])</span>
<span id="cb213-16"><a href="#cb213-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-17"><a href="#cb213-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_score</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb214"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(smith_waterman(<span class="st">"ACACACTA"</span>, <span class="st">"AGCACACA"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>10</code></pre>
</section>
<section id="tiny-code-c-9" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-9">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb216"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MATCH     </span><span class="dv">2</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MISMATCH </span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define GAP      </span><span class="op">-</span><span class="dv">2</span></span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max4<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m1 <span class="op">=</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m2 <span class="op">=</span> c <span class="op">&gt;</span> d <span class="op">?</span> c <span class="op">:</span> d<span class="op">;</span></span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> m1 <span class="op">&gt;</span> m2 <span class="op">?</span> m1 <span class="op">:</span> m2<span class="op">;</span></span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb216-13"><a href="#cb216-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-14"><a href="#cb216-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> smith_waterman<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>A<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>B<span class="op">)</span> <span class="op">{</span></span>
<span id="cb216-15"><a href="#cb216-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>A<span class="op">),</span> n <span class="op">=</span> strlen<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb216-16"><a href="#cb216-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb216-17"><a href="#cb216-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_score <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb216-18"><a href="#cb216-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-19"><a href="#cb216-19" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>dp<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>dp<span class="op">));</span></span>
<span id="cb216-20"><a href="#cb216-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-21"><a href="#cb216-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb216-22"><a href="#cb216-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb216-23"><a href="#cb216-23" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> score <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">?</span> MATCH <span class="op">:</span> MISMATCH<span class="op">;</span></span>
<span id="cb216-24"><a href="#cb216-24" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max4<span class="op">(</span></span>
<span id="cb216-25"><a href="#cb216-25" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span><span class="op">,</span></span>
<span id="cb216-26"><a href="#cb216-26" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> score<span class="op">,</span></span>
<span id="cb216-27"><a href="#cb216-27" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> GAP<span class="op">,</span></span>
<span id="cb216-28"><a href="#cb216-28" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> GAP</span>
<span id="cb216-29"><a href="#cb216-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">);</span></span>
<span id="cb216-30"><a href="#cb216-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&gt;</span> max_score<span class="op">)</span></span>
<span id="cb216-31"><a href="#cb216-31" aria-hidden="true" tabindex="-1"></a>                max_score <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb216-32"><a href="#cb216-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb216-33"><a href="#cb216-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb216-34"><a href="#cb216-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_score<span class="op">;</span></span>
<span id="cb216-35"><a href="#cb216-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb216-36"><a href="#cb216-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-37"><a href="#cb216-37" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb216-38"><a href="#cb216-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Local alignment score: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> smith_waterman<span class="op">(</span><span class="st">"ACACACTA"</span><span class="op">,</span> <span class="st">"AGCACACA"</span><span class="op">));</span></span>
<span id="cb216-39"><a href="#cb216-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Local alignment score: 10</code></pre>
</section>
<section id="why-it-matters-81" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-81">Why It Matters</h4>
<ul>
<li><p>Finds best-matching subsequences, not full alignments.</p></li>
<li><p>Resistant to noise and unrelated regions.</p></li>
<li><p>Used in:</p>
<ul>
<li>Gene/protein alignment (bioinformatics)</li>
<li>Text similarity (partial match detection)</li>
<li>Local pattern recognition</li>
</ul></li>
</ul>
</section>
<section id="complexity-82" class="level4">
<h4 class="anchored" data-anchor-id="complexity-82">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Full DP</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
<tr class="even">
<td>Space-optimized</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(\min(m,n))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-82" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-82">Try It Yourself</h4>
<ol type="1">
<li>Change scoring parameters to see local region shifts.</li>
<li>Modify the code to reconstruct the actual aligned substrings.</li>
<li>Compare to Needleman–Wunsch to visualize the difference between <em>global</em> and <em>local</em> alignments.</li>
<li>Use with real biological sequences (FASTA files).</li>
<li>Implement affine gaps for more realistic models.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-49" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-49">A Gentle Proof (Why It Works)</h4>
<p>By resetting negative values to zero, the DP ensures every alignment starts fresh when the score drops, isolating the highest scoring local region. This prevents weak or noisy alignments from diluting the true local maximum. Thus, Smith–Waterman always produces the <em>best possible</em> local alignment under the scoring scheme.</p>
<p>The Smith–Waterman algorithm teaches a subtle truth — sometimes the most meaningful alignment is not the whole story, but the part that matches perfectly, even for a while.</p>
</section>
</section>
<section id="gotoh-algorithm-affine-gap-penalties" class="level3">
<h3 class="anchored" data-anchor-id="gotoh-algorithm-affine-gap-penalties">683 Gotoh Algorithm (Affine Gap Penalties)</h3>
<p>The Gotoh algorithm refines classical sequence alignment by introducing affine gap penalties, a more realistic way to model insertions and deletions. Instead of charging a flat cost per gap, it distinguishes between opening and extending a gap. This better reflects real biological events, where starting a gap is costly, but continuing one is less so.</p>
<section id="the-motivation" class="level4">
<h4 class="anchored" data-anchor-id="the-motivation">The Motivation</h4>
<p>In Needleman–Wunsch or Smith–Waterman, gaps are penalized linearly: each insertion or deletion adds the same penalty.</p>
<p>But in practice (especially in biology), gaps often occur as long runs. For example:</p>
<pre><code>ACCTG---A
AC----TGA</code></pre>
<p>should not pay equally for every missing symbol. We want to penalize gap <em>creation</em> more heavily than <em>extension</em>.</p>
<p>So instead of a constant gap penalty, we use:</p>
<p><span class="math display">\[
\text{Gap cost} = g_\text{open} + k \times g_\text{extend}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(g_\text{open}\)</span> = cost to start a gap</li>
<li><span class="math inline">\(g_\text{extend}\)</span> = cost per additional gap symbol</li>
<li><span class="math inline">\(k\)</span> = length of the gap</li>
</ul>
</section>
<section id="the-dp-formulation-1" class="level4">
<h4 class="anchored" data-anchor-id="the-dp-formulation-1">The DP Formulation</h4>
<p>Gotoh introduced three DP matrices to handle these cases efficiently.</p>
<p>Let:</p>
<ul>
<li><span class="math inline">\(A[1..m]\)</span>, <span class="math inline">\(B[1..n]\)</span> be the sequences.</li>
<li><span class="math inline">\(M[i][j]\)</span> = best score ending with a match/mismatch at <span class="math inline">\((i, j)\)</span></li>
<li><span class="math inline">\(X[i][j]\)</span> = best score ending with a gap in A</li>
<li><span class="math inline">\(Y[i][j]\)</span> = best score ending with a gap in B</li>
</ul>
<p>Then:</p>
<p><span class="math display">\[
\begin{aligned}
M[i][j] &amp;= \max
\begin{cases}
M[i-1][j-1] + s(A_i, B_j) \
X[i-1][j-1] + s(A_i, B_j) \
Y[i-1][j-1] + s(A_i, B_j)
\end{cases} \
\
X[i][j] &amp;= \max
\begin{cases}
M[i-1][j] - g_\text{open} \
X[i-1][j] - g_\text{extend}
\end{cases} \
\
Y[i][j] &amp;= \max
\begin{cases}
M[i][j-1] - g_\text{open} \
Y[i][j-1] - g_\text{extend}
\end{cases}
\end{aligned}
\]</span></p>
<p>Finally, the optimal score is:</p>
<p><span class="math display">\[
S[i][j] = \max(M[i][j], X[i][j], Y[i][j])
\]</span></p>
</section>
<section id="example-parameters" class="level4">
<h4 class="anchored" data-anchor-id="example-parameters">Example Parameters</h4>
<p>Typical biological scoring setup:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Event</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Match</td>
<td>+2</td>
</tr>
<tr class="even">
<td>Mismatch</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>Gap open</td>
<td>-2</td>
</tr>
<tr class="even">
<td>Gap extend</td>
<td>-1</td>
</tr>
</tbody>
</table>
</section>
<section id="tiny-code-python-45" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-45">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb219"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gotoh(seq1, seq2, match<span class="op">=</span><span class="dv">2</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap_open<span class="op">=-</span><span class="dv">2</span>, gap_extend<span class="op">=-</span><span class="dv">1</span>):</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(seq1), <span class="bu">len</span>(seq2)</span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> [[<span class="bu">float</span>(<span class="st">'-inf'</span>)]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> [[<span class="bu">float</span>(<span class="st">'-inf'</span>)]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>        M[i][<span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a>        X[i][<span class="dv">0</span>] <span class="op">=</span> gap_open <span class="op">+</span> (i<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>gap_extend</span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a>        M[<span class="dv">0</span>][j] <span class="op">=</span> <span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a>        Y[<span class="dv">0</span>][j] <span class="op">=</span> gap_open <span class="op">+</span> (j<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>gap_extend</span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb219-15"><a href="#cb219-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb219-16"><a href="#cb219-16" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> match <span class="cf">if</span> seq1[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> seq2[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb219-17"><a href="#cb219-17" aria-hidden="true" tabindex="-1"></a>            M[i][j] <span class="op">=</span> <span class="bu">max</span>(M[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>], X[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>], Y[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> s</span>
<span id="cb219-18"><a href="#cb219-18" aria-hidden="true" tabindex="-1"></a>            X[i][j] <span class="op">=</span> <span class="bu">max</span>(M[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap_open, X[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap_extend)</span>
<span id="cb219-19"><a href="#cb219-19" aria-hidden="true" tabindex="-1"></a>            Y[i][j] <span class="op">=</span> <span class="bu">max</span>(M[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap_open, Y[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap_extend)</span>
<span id="cb219-20"><a href="#cb219-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-21"><a href="#cb219-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(M[m][n], X[m][n], Y[m][n])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb220"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(gotoh(<span class="st">"ACCTGA"</span>, <span class="st">"ACGGA"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>6</code></pre>
</section>
<section id="tiny-code-c-10" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-10">Tiny Code (C)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb222"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;float.h&gt;</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MATCH </span><span class="dv">2</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MISMATCH </span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define GAP_OPEN </span><span class="op">-</span><span class="dv">2</span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define GAP_EXTEND </span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NEG_INF </span><span class="op">-</span><span class="dv">1000000</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max2<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb222-13"><a href="#cb222-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max3<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> max2<span class="op">(</span>a<span class="op">,</span> max2<span class="op">(</span>b<span class="op">,</span> c<span class="op">));</span> <span class="op">}</span></span>
<span id="cb222-14"><a href="#cb222-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-15"><a href="#cb222-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> gotoh<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>A<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>B<span class="op">)</span> <span class="op">{</span></span>
<span id="cb222-16"><a href="#cb222-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>A<span class="op">),</span> n <span class="op">=</span> strlen<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb222-17"><a href="#cb222-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> M<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">],</span> X<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">],</span> Y<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb222-18"><a href="#cb222-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-19"><a href="#cb222-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb222-20"><a href="#cb222-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb222-21"><a href="#cb222-21" aria-hidden="true" tabindex="-1"></a>            M<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> X<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> Y<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> NEG_INF<span class="op">;</span></span>
<span id="cb222-22"><a href="#cb222-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb222-23"><a href="#cb222-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb222-24"><a href="#cb222-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-25"><a href="#cb222-25" aria-hidden="true" tabindex="-1"></a>    M<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb222-26"><a href="#cb222-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> X<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> GAP_OPEN <span class="op">+</span> <span class="op">(</span>i<span class="op">-</span><span class="dv">1</span><span class="op">)*</span>GAP_EXTEND<span class="op">;</span></span>
<span id="cb222-27"><a href="#cb222-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> Y<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> GAP_OPEN <span class="op">+</span> <span class="op">(</span>j<span class="op">-</span><span class="dv">1</span><span class="op">)*</span>GAP_EXTEND<span class="op">;</span></span>
<span id="cb222-28"><a href="#cb222-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-29"><a href="#cb222-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb222-30"><a href="#cb222-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb222-31"><a href="#cb222-31" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> score <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">?</span> MATCH <span class="op">:</span> MISMATCH<span class="op">;</span></span>
<span id="cb222-32"><a href="#cb222-32" aria-hidden="true" tabindex="-1"></a>            M<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max3<span class="op">(</span>M<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">],</span> X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">],</span> Y<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span> <span class="op">+</span> score<span class="op">;</span></span>
<span id="cb222-33"><a href="#cb222-33" aria-hidden="true" tabindex="-1"></a>            X<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max2<span class="op">(</span>M<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> GAP_OPEN<span class="op">,</span> X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> GAP_EXTEND<span class="op">);</span></span>
<span id="cb222-34"><a href="#cb222-34" aria-hidden="true" tabindex="-1"></a>            Y<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max2<span class="op">(</span>M<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> GAP_OPEN<span class="op">,</span> Y<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> GAP_EXTEND<span class="op">);</span></span>
<span id="cb222-35"><a href="#cb222-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb222-36"><a href="#cb222-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb222-37"><a href="#cb222-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-38"><a href="#cb222-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max3<span class="op">(</span>M<span class="op">[</span>m<span class="op">][</span>n<span class="op">],</span> X<span class="op">[</span>m<span class="op">][</span>n<span class="op">],</span> Y<span class="op">[</span>m<span class="op">][</span>n<span class="op">]);</span></span>
<span id="cb222-39"><a href="#cb222-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb222-40"><a href="#cb222-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-41"><a href="#cb222-41" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb222-42"><a href="#cb222-42" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"Affine gap alignment score: </span><span class="sc">%d\n</span><span class="st">"</span><span class="op">,</span> gotoh<span class="op">(</span><span class="st">"ACCTGA"</span><span class="op">,</span> <span class="st">"ACGGA"</span><span class="op">));</span></span>
<span id="cb222-43"><a href="#cb222-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>Affine gap alignment score: 6</code></pre>
</section>
<section id="why-it-matters-82" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-82">Why It Matters</h4>
<ul>
<li>Models biological insertions and deletions realistically.</li>
<li>Prevents over-penalization of long gaps.</li>
<li>Extends both Needleman–Wunsch (global) and Smith–Waterman (local) frameworks.</li>
<li>Used in most modern alignment tools (e.g., BLAST, ClustalW, MUSCLE).</li>
</ul>
</section>
<section id="complexity-83" class="level4">
<h4 class="anchored" data-anchor-id="complexity-83">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Full DP</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
<tr class="even">
<td>Space-optimized</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(\min(m, n))\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-83" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-83">Try It Yourself</h4>
<ol type="1">
<li>Vary <span class="math inline">\(g_\text{open}\)</span> and <span class="math inline">\(g_\text{extend}\)</span> to observe how long gaps are treated.</li>
<li>Switch between global (Needleman–Wunsch) and local (Smith–Waterman) variants.</li>
<li>Visualize matrix regions where gaps dominate.</li>
<li>Compare scoring differences between linear and affine gaps.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-50" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-50">A Gentle Proof (Why It Works)</h4>
<p>The Gotoh algorithm preserves dynamic programming optimality while efficiently representing three states (match, gap-in-A, gap-in-B). Affine penalties are decomposed into transitions between these states, separating the cost of <em>starting</em> and <em>continuing</em> a gap. This guarantees an optimal alignment under affine scoring without exploring redundant gap paths.</p>
<p>The Gotoh algorithm is a beautiful refinement — it teaches us that even gaps have structure, and the cost of starting one is not the same as staying in it.</p>
</section>
</section>
<section id="hirschberg-alignment-linear-space-global-alignment" class="level3">
<h3 class="anchored" data-anchor-id="hirschberg-alignment-linear-space-global-alignment">684 Hirschberg Alignment (Linear-Space Global Alignment)</h3>
<p>The Hirschberg algorithm is a clever optimization of the Needleman–Wunsch global alignment. It produces the same optimal alignment but uses linear space instead of quadratic. This is crucial when aligning very long DNA, RNA, or text sequences where memory is limited.</p>
<section id="the-problem-1" class="level4">
<h4 class="anchored" data-anchor-id="the-problem-1">The Problem</h4>
<p>The Needleman–Wunsch algorithm builds a full <span class="math inline">\(m \times n\)</span> dynamic programming table. For long sequences, this requires <span class="math inline">\(O(mn)\)</span> space, which quickly becomes infeasible.</p>
<p>Yet, the actual alignment path depends only on a single traceback path through that matrix. Hirschberg realized that we can compute it using divide and conquer with only two rows of the DP table at a time.</p>
</section>
<section id="the-idea-in-words" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-in-words">The Idea in Words</h4>
<ol type="1">
<li>Split the first sequence <span class="math inline">\(A\)</span> into two halves: <span class="math inline">\(A_\text{left}\)</span> and <span class="math inline">\(A_\text{right}\)</span>.</li>
<li>Compute the Needleman–Wunsch forward scores for aligning <span class="math inline">\(A_\text{left}\)</span> with all prefixes of <span class="math inline">\(B\)</span>.</li>
<li>Compute the reverse scores for aligning <span class="math inline">\(A_\text{right}\)</span> (reversed) with all suffixes of <span class="math inline">\(B\)</span>.</li>
<li>Combine the two to find the best split point in <span class="math inline">\(B\)</span>.</li>
<li>Recurse on the left and right halves.</li>
<li>When one sequence becomes very small, use the standard Needleman–Wunsch algorithm.</li>
</ol>
<p>This recursive divide-and-combine process yields the same alignment path with <span class="math inline">\(O(mn)\)</span> time but only <span class="math inline">\(O(\min(m, n))\)</span> space.</p>
</section>
<section id="the-dp-recurrence" class="level4">
<h4 class="anchored" data-anchor-id="the-dp-recurrence">The DP Recurrence</h4>
<p>The local scoring still follows the same Needleman–Wunsch formulation:</p>
<p><span class="math display">\[
dp[i][j] = \max
\begin{cases}
dp[i-1][j-1] + s(A_i, B_j), &amp; \text{(match/mismatch)},\\[4pt]
dp[i-1][j] + \text{gap}, &amp; \text{(deletion)},\\[4pt]
dp[i][j-1] + \text{gap}, &amp; \text{(insertion)}.
\end{cases}
\]</span></p>
<p>but Hirschberg only computes one row at a time (rolling array).</p>
<p>At each recursion step, we find the best split <span class="math inline">\(k\)</span> in <span class="math inline">\(B\)</span> such that:</p>
<p><span class="math display">\[
k = \arg\max_j (\text{forward}[j] + \text{reverse}[n-j])
\]</span></p>
<p>where <code>forward</code> and <code>reverse</code> are 1-D score arrays for partial alignments.</p>
</section>
<section id="tiny-code-python-46" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-46">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb224"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hirschberg(A, B, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> nw_score(X, Y):</span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> [j <span class="op">*</span> gap <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Y) <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(X) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>            curr <span class="op">=</span> [i <span class="op">*</span> gap]</span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(Y) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> match <span class="cf">if</span> X[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> Y[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a>                curr.append(<span class="bu">max</span>(</span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true" tabindex="-1"></a>                    prev[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> s,</span>
<span id="cb224-10"><a href="#cb224-10" aria-hidden="true" tabindex="-1"></a>                    prev[j] <span class="op">+</span> gap,</span>
<span id="cb224-11"><a href="#cb224-11" aria-hidden="true" tabindex="-1"></a>                    curr[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb224-12"><a href="#cb224-12" aria-hidden="true" tabindex="-1"></a>                ))</span>
<span id="cb224-13"><a href="#cb224-13" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> curr</span>
<span id="cb224-14"><a href="#cb224-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev</span>
<span id="cb224-15"><a href="#cb224-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-16"><a href="#cb224-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> hirsch(A, B):</span>
<span id="cb224-17"><a href="#cb224-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(A) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb224-18"><a href="#cb224-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="st">'-'</span> <span class="op">*</span> <span class="bu">len</span>(B), B)</span>
<span id="cb224-19"><a href="#cb224-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(B) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb224-20"><a href="#cb224-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (A, <span class="st">'-'</span> <span class="op">*</span> <span class="bu">len</span>(A))</span>
<span id="cb224-21"><a href="#cb224-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(A) <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> <span class="bu">len</span>(B) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb224-22"><a href="#cb224-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># fallback to simple Needleman–Wunsch</span></span>
<span id="cb224-23"><a href="#cb224-23" aria-hidden="true" tabindex="-1"></a>            <span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb224-24"><a href="#cb224-24" aria-hidden="true" tabindex="-1"></a>            best <span class="op">=</span> (<span class="op">-</span><span class="bu">float</span>(<span class="st">'inf'</span>), <span class="st">""</span>, <span class="st">""</span>)</span>
<span id="cb224-25"><a href="#cb224-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(B) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb224-26"><a href="#cb224-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(A) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb224-27"><a href="#cb224-27" aria-hidden="true" tabindex="-1"></a>                    a <span class="op">=</span> <span class="st">'-'</span> <span class="op">*</span> i <span class="op">+</span> A <span class="op">+</span> <span class="st">'-'</span> <span class="op">*</span> (<span class="bu">len</span>(B) <span class="op">-</span> i)</span>
<span id="cb224-28"><a href="#cb224-28" aria-hidden="true" tabindex="-1"></a>                    b <span class="op">=</span> B[:j] <span class="op">+</span> <span class="st">'-'</span> <span class="op">*</span> (<span class="bu">len</span>(A) <span class="op">+</span> <span class="bu">len</span>(B) <span class="op">-</span> j <span class="op">-</span> <span class="bu">len</span>(B))</span>
<span id="cb224-29"><a href="#cb224-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (A, B)</span>
<span id="cb224-30"><a href="#cb224-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-31"><a href="#cb224-31" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> <span class="bu">len</span>(A) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb224-32"><a href="#cb224-32" aria-hidden="true" tabindex="-1"></a>        score_l <span class="op">=</span> nw_score(A[:mid], B)</span>
<span id="cb224-33"><a href="#cb224-33" aria-hidden="true" tabindex="-1"></a>        score_r <span class="op">=</span> nw_score(A[mid:][::<span class="op">-</span><span class="dv">1</span>], B[::<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb224-34"><a href="#cb224-34" aria-hidden="true" tabindex="-1"></a>        split <span class="op">=</span> <span class="bu">max</span>(<span class="bu">range</span>(<span class="bu">len</span>(B) <span class="op">+</span> <span class="dv">1</span>),</span>
<span id="cb224-35"><a href="#cb224-35" aria-hidden="true" tabindex="-1"></a>                    key<span class="op">=</span><span class="kw">lambda</span> j: score_l[j] <span class="op">+</span> score_r[<span class="bu">len</span>(B) <span class="op">-</span> j])</span>
<span id="cb224-36"><a href="#cb224-36" aria-hidden="true" tabindex="-1"></a>        A_left, B_left <span class="op">=</span> hirsch(A[:mid], B[:split])</span>
<span id="cb224-37"><a href="#cb224-37" aria-hidden="true" tabindex="-1"></a>        A_right, B_right <span class="op">=</span> hirsch(A[mid:], B[split:])</span>
<span id="cb224-38"><a href="#cb224-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (A_left <span class="op">+</span> A_right, B_left <span class="op">+</span> B_right)</span>
<span id="cb224-39"><a href="#cb224-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-40"><a href="#cb224-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hirsch(A, B)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb225"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>A, B <span class="op">=</span> hirschberg(<span class="st">"ACCTG"</span>, <span class="st">"ACG"</span>)</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A)</span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(B)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output (one possible alignment):</p>
<pre><code>ACCTG
AC--G</code></pre>
</section>
<section id="tiny-code-c-core-recurrence-only" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-c-core-recurrence-only">Tiny Code (C, Core Recurrence Only)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb227"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MATCH </span><span class="dv">1</span></span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MISMATCH </span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define GAP </span><span class="op">-</span><span class="dv">2</span></span>
<span id="cb227-8"><a href="#cb227-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-9"><a href="#cb227-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max3<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> <span class="op">(</span>a <span class="op">&gt;</span> c <span class="op">?</span> a <span class="op">:</span> c<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>b <span class="op">&gt;</span> c <span class="op">?</span> b <span class="op">:</span> c<span class="op">);</span> <span class="op">}</span></span>
<span id="cb227-10"><a href="#cb227-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-11"><a href="#cb227-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> nw_score<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>A<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>B<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb227-12"><a href="#cb227-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> strlen<span class="op">(</span>A<span class="op">),</span> n <span class="op">=</span> strlen<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb227-13"><a href="#cb227-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>prev <span class="op">=</span> malloc<span class="op">((</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb227-14"><a href="#cb227-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>curr <span class="op">=</span> malloc<span class="op">((</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb227-15"><a href="#cb227-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-16"><a href="#cb227-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> prev<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> j <span class="op">*</span> GAP<span class="op">;</span></span>
<span id="cb227-17"><a href="#cb227-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb227-18"><a href="#cb227-18" aria-hidden="true" tabindex="-1"></a>        curr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> GAP<span class="op">;</span></span>
<span id="cb227-19"><a href="#cb227-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb227-20"><a href="#cb227-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> s <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> B<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">?</span> MATCH <span class="op">:</span> MISMATCH<span class="op">;</span></span>
<span id="cb227-21"><a href="#cb227-21" aria-hidden="true" tabindex="-1"></a>            curr<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> max3<span class="op">(</span>prev<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> s<span class="op">,</span> prev<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> GAP<span class="op">,</span> curr<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> GAP<span class="op">);</span></span>
<span id="cb227-22"><a href="#cb227-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb227-23"><a href="#cb227-23" aria-hidden="true" tabindex="-1"></a>        memcpy<span class="op">(</span>prev<span class="op">,</span> curr<span class="op">,</span> <span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb227-24"><a href="#cb227-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb227-25"><a href="#cb227-25" aria-hidden="true" tabindex="-1"></a>    memcpy<span class="op">(</span>out<span class="op">,</span> prev<span class="op">,</span> <span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb227-26"><a href="#cb227-26" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>prev<span class="op">);</span> free<span class="op">(</span>curr<span class="op">);</span></span>
<span id="cb227-27"><a href="#cb227-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This function computes the forward or reverse row scores used in Hirschberg’s recursion.</p>
</section>
<section id="why-it-matters-83" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-83">Why It Matters</h4>
<ul>
<li>Reduces space complexity from <span class="math inline">\(O(mn)\)</span> to <span class="math inline">\(O(m + n)\)</span>.</li>
<li>Maintains the same optimal global alignment.</li>
<li>Used in genome alignment, text diff tools, and compression systems.</li>
<li>Demonstrates how divide and conquer combines with dynamic programming.</li>
</ul>
</section>
<section id="complexity-84" class="level4">
<h4 class="anchored" data-anchor-id="complexity-84">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Full DP</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
<tr class="even">
<td>Hirschberg</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(m + n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-84" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-84">Try It Yourself</h4>
<ol type="1">
<li>Align very long strings (thousands of symbols) to observe space savings.</li>
<li>Compare runtime and memory usage with standard Needleman–Wunsch.</li>
<li>Add traceback reconstruction to output aligned strings.</li>
<li>Combine with affine gaps (Gotoh + Hirschberg hybrid).</li>
<li>Experiment with text diff scenarios instead of biological data.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-51" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-51">A Gentle Proof (Why It Works)</h4>
<p>Hirschberg’s method exploits the additivity of DP alignment scores: the total optimal score can be decomposed into left and right halves at an optimal split point. By recursively aligning halves, it reconstructs the same alignment without storing the full DP table.</p>
<p>This divide-and-conquer dynamic programming pattern is a powerful general idea, later reused in parallel and external-memory algorithms.</p>
<p>The Hirschberg algorithm reminds us that sometimes we don’t need to hold the whole world in memory — just the frontier between what came before and what’s next.</p>
</section>
</section>
<section id="multiple-sequence-alignment-msa" class="level3">
<h3 class="anchored" data-anchor-id="multiple-sequence-alignment-msa">685 Multiple Sequence Alignment (MSA)</h3>
<p>The Multiple Sequence Alignment (MSA) problem extends pairwise alignment to three or more sequences. Its goal is to align all sequences together so that homologous positions, characters that share a common origin, line up in columns. This is a central task in bioinformatics, used for protein family analysis, phylogenetic tree construction, and motif discovery.</p>
<section id="the-problem-2" class="level4">
<h4 class="anchored" data-anchor-id="the-problem-2">The Problem</h4>
<p>Given <span class="math inline">\(k\)</span> sequences <span class="math inline">\(S_1, S_2, \ldots, S_k\)</span> of varying lengths, we want to find alignments that maximize a global similarity score.</p>
<p>Each column of the alignment represents a possible evolutionary relationship, characters are aligned if they descend from the same ancestral position.</p>
<p>The score for an MSA is often defined by the sum-of-pairs method:</p>
<p><span class="math display">\[
\text{Score}(A) = \sum_{1 \le i &lt; j \le k} \text{Score}(A_i, A_j)
\]</span></p>
<p>where <span class="math inline">\(\text{Score}(A_i, A_j)\)</span> is a pairwise alignment score (e.g., from Needleman–Wunsch).</p>
</section>
<section id="why-its-hard" class="level4">
<h4 class="anchored" data-anchor-id="why-its-hard">Why It’s Hard</h4>
<p>While pairwise alignment is solvable in <span class="math inline">\(O(mn)\)</span> time, MSA grows exponentially with the number of sequences:</p>
<p><span class="math display">\[
O(n^k)
\]</span></p>
<p>This is because each cell in a <span class="math inline">\(k\)</span>-dimensional DP table represents one position in each sequence.</p>
<p>For example:</p>
<ul>
<li>2 sequences → 2D matrix</li>
<li>3 sequences → 3D cube</li>
<li>4 sequences → 4D hypercube, and so on.</li>
</ul>
<p>Therefore, exact MSA is computationally infeasible for more than 3 or 4 sequences, so practical algorithms use heuristics.</p>
</section>
<section id="progressive-alignment-heuristic" class="level4">
<h4 class="anchored" data-anchor-id="progressive-alignment-heuristic">Progressive Alignment (Heuristic)</h4>
<p>The most common practical approach is progressive alignment, used in tools like ClustalW and MUSCLE. It works in three major steps:</p>
<ol type="1">
<li>Compute pairwise distances between all sequences (using quick alignments).</li>
<li>Build a guide tree (a simple phylogenetic tree using clustering methods like UPGMA or neighbor-joining).</li>
<li>Progressively align sequences following the tree, starting from the most similar pairs and merging upward.</li>
</ol>
<p>At each merge step, previously aligned groups are treated as profiles, where each column holds probabilities of characters.</p>
</section>
<section id="example-progressive-alignment-sketch" class="level4">
<h4 class="anchored" data-anchor-id="example-progressive-alignment-sketch">Example (Progressive Alignment Sketch)</h4>
<pre><code>Sequences:
A: GATTACA
B: GCATGCU
C: GATTGCA

Step 1: Align (A, C)
GATTACA
GATTGCA

Step 2: Align with B
G-ATTACA
G-CATGCU
G-ATTGCA</code></pre>
<p>This gives a rough but biologically reasonable alignment, not necessarily the global optimum, but fast and usable.</p>
</section>
<section id="scoring-example" class="level4">
<h4 class="anchored" data-anchor-id="scoring-example">Scoring Example</h4>
<p>For three sequences, the DP recurrence becomes:</p>
<p><span class="math display">\[
dp[i][j][k] = \max
\begin{cases}
dp[i-1][j-1][k-1] + s(A_i, B_j, C_k), \
dp[i-1][j][k] + g, \
dp[i][j-1][k] + g, \
dp[i][j][k-1] + g, \
\text{(and combinations of two gaps)}
\end{cases}
\]</span></p>
<p>but this is impractical for large inputs, hence the reliance on heuristics.</p>
</section>
<section id="tiny-code-pairwise-progressive-alignment-example" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-pairwise-progressive-alignment-example">Tiny Code (Pairwise Progressive Alignment Example)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb229"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pairwise_score(a, b, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(<span class="bu">len</span>(b)<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(a)<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(a)<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i <span class="op">*</span> gap</span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(b)<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j <span class="op">*</span> gap</span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(a)<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(b)<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> match <span class="cf">if</span> a[i<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> b[j<span class="op">-</span><span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb229-12"><a href="#cb229-12" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb229-13"><a href="#cb229-13" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> s,</span>
<span id="cb229-14"><a href="#cb229-14" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb229-15"><a href="#cb229-15" aria-hidden="true" tabindex="-1"></a>                dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb229-16"><a href="#cb229-16" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb229-17"><a href="#cb229-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb229-18"><a href="#cb229-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-19"><a href="#cb229-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> guide_tree(sequences):</span>
<span id="cb229-20"><a href="#cb229-20" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> {}</span>
<span id="cb229-21"><a href="#cb229-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i, s1), (j, s2) <span class="kw">in</span> combinations(<span class="bu">enumerate</span>(sequences), <span class="dv">2</span>):</span>
<span id="cb229-22"><a href="#cb229-22" aria-hidden="true" tabindex="-1"></a>        scores[(i, j)] <span class="op">=</span> pairwise_score(s1, s2)</span>
<span id="cb229-23"><a href="#cb229-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(scores.items(), key<span class="op">=</span><span class="kw">lambda</span> x: <span class="op">-</span>x[<span class="dv">1</span>])</span>
<span id="cb229-24"><a href="#cb229-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-25"><a href="#cb229-25" aria-hidden="true" tabindex="-1"></a>sequences <span class="op">=</span> [<span class="st">"GATTACA"</span>, <span class="st">"GCATGCU"</span>, <span class="st">"GATTGCA"</span>]</span>
<span id="cb229-26"><a href="#cb229-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(guide_tree(sequences))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This produces pairwise scores, a simple starting point for building a guide tree.</p>
</section>
<section id="why-it-matters-84" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-84">Why It Matters</h4>
<ul>
<li><p>Foundational tool in genomics, proteomics, and computational biology.</p></li>
<li><p>Reveals evolutionary relationships and conserved patterns.</p></li>
<li><p>Used in:</p>
<ul>
<li>Protein family classification</li>
<li>Phylogenetic reconstruction</li>
<li>Functional motif prediction</li>
<li>Comparative genomics</li>
</ul></li>
</ul>
</section>
<section id="complexity-85" class="level4">
<h4 class="anchored" data-anchor-id="complexity-85">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Method</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exact (k-D DP)</td>
<td><span class="math inline">\(O(n^k)\)</span></td>
<td><span class="math inline">\(O(n^k)\)</span></td>
</tr>
<tr class="even">
<td>Progressive (ClustalW, MUSCLE)</td>
<td><span class="math inline">\(O(k^2 n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
</tr>
<tr class="odd">
<td>Profile–profile refinement</td>
<td><span class="math inline">\(O(k n^2)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-85" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-85">Try It Yourself</h4>
<ol type="1">
<li>Try aligning 3 DNA sequences manually.</li>
<li>Compare pairwise and progressive results.</li>
<li>Use different scoring schemes and gap penalties.</li>
<li>Build a guide tree using your own distance metric.</li>
<li>Run your test sequences through Clustal Omega or MUSCLE to compare.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-52" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-52">A Gentle Proof (Why It Works)</h4>
<p>Progressive alignment does not guarantee optimality, but it approximates the sum-of-pairs scoring function by reusing the dynamic programming backbone iteratively. Each local alignment guides the next, preserving local homologies that reflect biological relationships.</p>
<p>This approach embodies a fundamental idea: approximation guided by structure can often achieve near-optimal results when full optimization is impossible.</p>
<p>MSA is both science and art — aligning sequences, patterns, and histories into a single evolutionary story.</p>
</section>
</section>
<section id="profile-alignment-sequence-to-profile-and-profile-to-profile" class="level3">
<h3 class="anchored" data-anchor-id="profile-alignment-sequence-to-profile-and-profile-to-profile">686 Profile Alignment (Sequence-to-Profile and Profile-to-Profile)</h3>
<p>The Profile Alignment algorithm generalizes pairwise sequence alignment to handle groups of sequences that have already been aligned, called <em>profiles</em>. A profile represents the consensus structure of an aligned set, capturing position-specific frequencies, gaps, and weights. Aligning a new sequence to a profile (or two profiles to each other) allows multiple sequence alignments to scale gracefully and improve biological accuracy.</p>
<section id="the-concept" class="level4">
<h4 class="anchored" data-anchor-id="the-concept">The Concept</h4>
<p>A profile can be viewed as a matrix:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Position</th>
<th>A</th>
<th>C</th>
<th>G</th>
<th>T</th>
<th>Gap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0.9</td>
<td>0.0</td>
<td>0.1</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="even">
<td>2</td>
<td>0.1</td>
<td>0.8</td>
<td>0.0</td>
<td>0.1</td>
<td>0.0</td>
</tr>
<tr class="odd">
<td>3</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="even">
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Each column stores the observed frequencies of nucleotides or amino acids at that position. We can align:</p>
<ul>
<li>a new sequence against this profile (sequence-to-profile), or</li>
<li>two profiles against each other (profile-to-profile).</li>
</ul>
</section>
<section id="scoring-between-profiles" class="level4">
<h4 class="anchored" data-anchor-id="scoring-between-profiles">Scoring Between Profiles</h4>
<p>To compare a symbol <span class="math inline">\(a\)</span> and a profile column <span class="math inline">\(C\)</span>, use expected substitution score:</p>
<p><span class="math display">\[
S(a, C) = \sum_{b \in \Sigma} p_C(b) \cdot s(a, b)
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(\Sigma\)</span> is the alphabet (e.g., {A, C, G, T}),</li>
<li><span class="math inline">\(p_C(b)\)</span> is the frequency of <span class="math inline">\(b\)</span> in column <span class="math inline">\(C\)</span>,</li>
<li><span class="math inline">\(s(a, b)\)</span> is the substitution score (e.g., from PAM or BLOSUM matrix).</li>
</ul>
<p>For profile-to-profile comparison:</p>
<p><span class="math display">\[
S(C_1, C_2) = \sum_{a,b \in \Sigma} p_{C_1}(a) \cdot p_{C_2}(b) \cdot s(a, b)
\]</span></p>
<p>This reflects how compatible two alignment columns are based on their statistical composition.</p>
</section>
<section id="dynamic-programming-recurrence" class="level4">
<h4 class="anchored" data-anchor-id="dynamic-programming-recurrence">Dynamic Programming Recurrence</h4>
<p>The DP recurrence is the same as for Needleman–Wunsch, but with scores based on columns instead of single symbols.</p>
<p><span class="math display">\[
dp[i][j] = \max
\begin{cases}
dp[i-1][j-1] + S(C_i, D_j), &amp; \text{(column match)},\\[4pt]
dp[i-1][j] + g, &amp; \text{(gap in profile D)},\\[4pt]
dp[i][j-1] + g, &amp; \text{(gap in profile C)}.
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(C_i\)</span> and <span class="math inline">\(D_j\)</span> are profile columns, and <span class="math inline">\(g\)</span> is the gap penalty.</p>
</section>
<section id="example-sequence-to-profile" class="level4">
<h4 class="anchored" data-anchor-id="example-sequence-to-profile">Example (Sequence-to-Profile)</h4>
<p>Profile (from previous alignments):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Pos</th>
<th>A</th>
<th>C</th>
<th>G</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0.7</td>
<td>0.1</td>
<td>0.2</td>
<td>0.0</td>
</tr>
<tr class="even">
<td>2</td>
<td>0.0</td>
<td>0.8</td>
<td>0.1</td>
<td>0.1</td>
</tr>
<tr class="odd">
<td>3</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<p>New sequence: <code>ACG</code></p>
<p>At each DP step, we compute the expected score between each symbol in <code>ACG</code> and profile columns, then use standard DP recursion to find the best global or local alignment.</p>
</section>
<section id="tiny-code-python-47" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-47">Tiny Code (Python)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb230"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expected_score(col, a, subs_matrix):</span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(col[b] <span class="op">*</span> subs_matrix[a][b] <span class="cf">for</span> b <span class="kw">in</span> subs_matrix[a])</span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> profile_align(profile, seq, subs_matrix, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(profile), <span class="bu">len</span>(seq)</span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> gap</span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb230-12"><a href="#cb230-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-13"><a href="#cb230-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb230-14"><a href="#cb230-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb230-15"><a href="#cb230-15" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> expected_score(profile[i<span class="op">-</span><span class="dv">1</span>], seq[j<span class="op">-</span><span class="dv">1</span>], subs_matrix)</span>
<span id="cb230-16"><a href="#cb230-16" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb230-17"><a href="#cb230-17" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> s,</span>
<span id="cb230-18"><a href="#cb230-18" aria-hidden="true" tabindex="-1"></a>                dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb230-19"><a href="#cb230-19" aria-hidden="true" tabindex="-1"></a>                dp[i][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb230-20"><a href="#cb230-20" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb230-21"><a href="#cb230-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb230-22"><a href="#cb230-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-23"><a href="#cb230-23" aria-hidden="true" tabindex="-1"></a>subs_matrix <span class="op">=</span> {</span>
<span id="cb230-24"><a href="#cb230-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'A'</span>: {<span class="st">'A'</span>: <span class="dv">1</span>, <span class="st">'C'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'G'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'T'</span>: <span class="op">-</span><span class="dv">1</span>},</span>
<span id="cb230-25"><a href="#cb230-25" aria-hidden="true" tabindex="-1"></a>    <span class="st">'C'</span>: {<span class="st">'A'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'C'</span>: <span class="dv">1</span>, <span class="st">'G'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'T'</span>: <span class="op">-</span><span class="dv">1</span>},</span>
<span id="cb230-26"><a href="#cb230-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">'G'</span>: {<span class="st">'A'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'C'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'G'</span>: <span class="dv">1</span>, <span class="st">'T'</span>: <span class="op">-</span><span class="dv">1</span>},</span>
<span id="cb230-27"><a href="#cb230-27" aria-hidden="true" tabindex="-1"></a>    <span class="st">'T'</span>: {<span class="st">'A'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'C'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'G'</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">'T'</span>: <span class="dv">1</span>}</span>
<span id="cb230-28"><a href="#cb230-28" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb230-29"><a href="#cb230-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-30"><a href="#cb230-30" aria-hidden="true" tabindex="-1"></a>profile <span class="op">=</span> [</span>
<span id="cb230-31"><a href="#cb230-31" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'A'</span>: <span class="fl">0.7</span>, <span class="st">'C'</span>: <span class="fl">0.1</span>, <span class="st">'G'</span>: <span class="fl">0.2</span>, <span class="st">'T'</span>: <span class="fl">0.0</span>},</span>
<span id="cb230-32"><a href="#cb230-32" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'A'</span>: <span class="fl">0.0</span>, <span class="st">'C'</span>: <span class="fl">0.8</span>, <span class="st">'G'</span>: <span class="fl">0.1</span>, <span class="st">'T'</span>: <span class="fl">0.1</span>},</span>
<span id="cb230-33"><a href="#cb230-33" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'A'</span>: <span class="fl">0.0</span>, <span class="st">'C'</span>: <span class="fl">0.0</span>, <span class="st">'G'</span>: <span class="fl">1.0</span>, <span class="st">'T'</span>: <span class="fl">0.0</span>}</span>
<span id="cb230-34"><a href="#cb230-34" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb230-35"><a href="#cb230-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-36"><a href="#cb230-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(profile_align(profile, <span class="st">"ACG"</span>, subs_matrix))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>1.6</code></pre>
</section>
<section id="why-it-matters-85" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-85">Why It Matters</h4>
<ul>
<li>Extends MSA efficiently: new sequences can be added to existing alignments without recomputing everything.</li>
<li>Profile-to-profile alignment forms the core of modern MSA software (MUSCLE, MAFFT, ClustalΩ).</li>
<li>Statistical robustness: captures biological conservation patterns at each position.</li>
<li>Handles ambiguity: each column represents uncertainty, not just a single symbol.</li>
</ul>
</section>
<section id="complexity-86" class="level4">
<h4 class="anchored" data-anchor-id="complexity-86">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sequence–Profile</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Profile–Profile</td>
<td><span class="math inline">\(O(mn   | \Sigma  | ^2)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-86" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-86">Try It Yourself</h4>
<ol type="1">
<li>Construct a profile from two sequences manually (count and normalize).</li>
<li>Align a new sequence to that profile.</li>
<li>Compare results with direct pairwise alignment.</li>
<li>Extend to profile–profile and compute expected match scores.</li>
<li>Experiment with different substitution matrices (PAM250, BLOSUM62).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-53" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-53">A Gentle Proof (Why It Works)</h4>
<p>Profile alignment works because expected substitution scores preserve linearity: the expected score between profiles is equal to the sum of expected pairwise scores between their underlying sequences. Thus, profile alignment yields the same optimal alignment that would result from averaging over all pairwise combinations — but computed in linear time instead of exponential time.</p>
<p>Profile alignment is the mathematical backbone of modern bioinformatics — it replaces rigid characters with flexible probability landscapes, allowing alignments to evolve as dynamically as the sequences they describe.</p>
</section>
</section>
<section id="hidden-markov-model-hmm-alignment" class="level3">
<h3 class="anchored" data-anchor-id="hidden-markov-model-hmm-alignment">687 Hidden Markov Model (HMM) Alignment</h3>
<p>The Hidden Markov Model (HMM) alignment method treats sequence alignment as a <em>probabilistic inference</em> problem. Instead of deterministic scores and penalties, it models the process of generating sequences using states, transitions, and emission probabilities. This gives a statistically rigorous foundation for sequence alignment, profile detection, and domain identification.</p>
<section id="the-core-idea-20" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-20">The Core Idea</h4>
<p>An HMM defines a probabilistic model with:</p>
<ul>
<li>States that represent positions in an alignment (match, insertion, deletion).</li>
<li>Transitions between states, capturing how likely we move from one to another.</li>
<li>Emission probabilities describing how likely each state emits a particular symbol (A, C, G, T, etc.).</li>
</ul>
<p>For sequence alignment, we use an HMM to represent how one sequence might have evolved from another through substitutions, insertions, and deletions.</p>
</section>
<section id="typical-hmm-architecture-for-pairwise-alignment" class="level4">
<h4 class="anchored" data-anchor-id="typical-hmm-architecture-for-pairwise-alignment">Typical HMM Architecture for Pairwise Alignment</h4>
<p>Each column of an alignment is modeled with three states:</p>
<pre><code>   ┌───────────┐
   │  Match M  │
   └─────┬─────┘
         │
   ┌─────▼─────┐
   │ Insert I  │
   └─────┬─────┘
         │
   ┌─────▼─────┐
   │ Delete D  │
   └───────────┘</code></pre>
<p>Each has:</p>
<ul>
<li>Transitions (e.g., M→M, M→I, M→D, etc.)</li>
<li>Emissions: M and I emit symbols, D emits nothing.</li>
</ul>
</section>
<section id="model-parameters" class="level4">
<h4 class="anchored" data-anchor-id="model-parameters">Model Parameters</h4>
<p>Let:</p>
<ul>
<li><span class="math inline">\(P(M_i \rightarrow M_{i+1})\)</span> = transition probability between match states.</li>
<li><span class="math inline">\(e_M(x)\)</span> = emission probability of symbol <span class="math inline">\(x\)</span> from match state.</li>
<li><span class="math inline">\(e_I(x)\)</span> = emission probability of symbol <span class="math inline">\(x\)</span> from insert state.</li>
</ul>
<p>Then the probability of an alignment path <span class="math inline">\(Q = (q_1, q_2, ..., q_T)\)</span> with emitted sequence <span class="math inline">\(X = (x_1, x_2, ..., x_T)\)</span> is:</p>
<p><span class="math display">\[
P(X, Q) = \prod_{t=1}^{T} P(q_t \mid q_{t-1}) \cdot e_{q_t}(x_t)
\]</span></p>
<p>The alignment problem becomes finding the most likely path through the model that explains both sequences.</p>
</section>
<section id="the-viterbi-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="the-viterbi-algorithm">The Viterbi Algorithm</h4>
<p>We use dynamic programming to find the maximum likelihood alignment path.</p>
<p>Let <span class="math inline">\(V_t(s)\)</span> be the probability of the most likely path ending in state <span class="math inline">\(s\)</span> at position <span class="math inline">\(t\)</span>.</p>
<p>The recurrence is:</p>
<p><span class="math display">\[
V_t(s) = e_s(x_t) \cdot \max_{s'} [V_{t-1}(s') \cdot P(s' \rightarrow s)]
\]</span></p>
<p>with backpointers for reconstruction.</p>
<p>Finally, the best path probability is:</p>
<p><span class="math display">\[
P^* = \max_s V_T(s)
\]</span></p>
</section>
<section id="example-of-matchinsertdelete-transitions" class="level4">
<h4 class="anchored" data-anchor-id="example-of-matchinsertdelete-transitions">Example of Match–Insert–Delete Transitions</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>From → To</th>
<th>Transition Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>M → M</td>
<td>0.8</td>
</tr>
<tr class="even">
<td>M → I</td>
<td>0.1</td>
</tr>
<tr class="odd">
<td>M → D</td>
<td>0.1</td>
</tr>
<tr class="even">
<td>I → I</td>
<td>0.7</td>
</tr>
<tr class="odd">
<td>I → M</td>
<td>0.3</td>
</tr>
<tr class="even">
<td>D → D</td>
<td>0.6</td>
</tr>
<tr class="odd">
<td>D → M</td>
<td>0.4</td>
</tr>
</tbody>
</table>
<p>Emissions from Match or Insert states define the sequence content probabilities.</p>
</section>
<section id="tiny-code-python-simplified-viterbi" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-simplified-viterbi">Tiny Code (Python, Simplified Viterbi)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb233"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> [<span class="st">'M'</span>, <span class="st">'I'</span>, <span class="st">'D'</span>]</span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>trans <span class="op">=</span> {</span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'M'</span>: {<span class="st">'M'</span>: <span class="fl">0.8</span>, <span class="st">'I'</span>: <span class="fl">0.1</span>, <span class="st">'D'</span>: <span class="fl">0.1</span>},</span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'I'</span>: {<span class="st">'I'</span>: <span class="fl">0.7</span>, <span class="st">'M'</span>: <span class="fl">0.3</span>, <span class="st">'D'</span>: <span class="fl">0.0</span>},</span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'D'</span>: {<span class="st">'D'</span>: <span class="fl">0.6</span>, <span class="st">'M'</span>: <span class="fl">0.4</span>, <span class="st">'I'</span>: <span class="fl">0.0</span>}</span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true" tabindex="-1"></a>emit <span class="op">=</span> {</span>
<span id="cb233-10"><a href="#cb233-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'M'</span>: {<span class="st">'A'</span>: <span class="fl">0.3</span>, <span class="st">'C'</span>: <span class="fl">0.2</span>, <span class="st">'G'</span>: <span class="fl">0.3</span>, <span class="st">'T'</span>: <span class="fl">0.2</span>},</span>
<span id="cb233-11"><a href="#cb233-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'I'</span>: {<span class="st">'A'</span>: <span class="fl">0.25</span>, <span class="st">'C'</span>: <span class="fl">0.25</span>, <span class="st">'G'</span>: <span class="fl">0.25</span>, <span class="st">'T'</span>: <span class="fl">0.25</span>},</span>
<span id="cb233-12"><a href="#cb233-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'D'</span>: {}</span>
<span id="cb233-13"><a href="#cb233-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb233-14"><a href="#cb233-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-15"><a href="#cb233-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> viterbi(seq):</span>
<span id="cb233-16"><a href="#cb233-16" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(seq)</span>
<span id="cb233-17"><a href="#cb233-17" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> np.zeros((n<span class="op">+</span><span class="dv">1</span>, <span class="bu">len</span>(states)))</span>
<span id="cb233-18"><a href="#cb233-18" aria-hidden="true" tabindex="-1"></a>    V[<span class="dv">0</span>, :] <span class="op">=</span> np.log([<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">3</span>])  <span class="co"># uniform start</span></span>
<span id="cb233-19"><a href="#cb233-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-20"><a href="#cb233-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb233-21"><a href="#cb233-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j, s <span class="kw">in</span> <span class="bu">enumerate</span>(states):</span>
<span id="cb233-22"><a href="#cb233-22" aria-hidden="true" tabindex="-1"></a>            emis <span class="op">=</span> np.log(emit[s].get(seq[t<span class="op">-</span><span class="dv">1</span>], <span class="fl">1e-9</span>)) <span class="cf">if</span> s <span class="op">!=</span> <span class="st">'D'</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb233-23"><a href="#cb233-23" aria-hidden="true" tabindex="-1"></a>            V[t, j] <span class="op">=</span> emis <span class="op">+</span> <span class="bu">max</span>(</span>
<span id="cb233-24"><a href="#cb233-24" aria-hidden="true" tabindex="-1"></a>                V[t<span class="op">-</span><span class="dv">1</span>, k] <span class="op">+</span> np.log(trans[states[k]].get(s, <span class="fl">1e-9</span>))</span>
<span id="cb233-25"><a href="#cb233-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(states))</span>
<span id="cb233-26"><a href="#cb233-26" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb233-27"><a href="#cb233-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> V</span>
<span id="cb233-28"><a href="#cb233-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-29"><a href="#cb233-29" aria-hidden="true" tabindex="-1"></a>seq <span class="op">=</span> <span class="st">"ACGT"</span></span>
<span id="cb233-30"><a href="#cb233-30" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> viterbi(seq)</span>
<span id="cb233-31"><a href="#cb233-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.exp(V[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> np.<span class="bu">max</span>(V[<span class="op">-</span><span class="dv">1</span>])))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output (relative likelihood of alignment path):</p>
<pre><code>$$0.82 0.09 0.09]</code></pre>
</section>
<section id="why-it-matters-86" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-86">Why It Matters</h4>
<ul>
<li><p>Provides a probabilistic foundation for alignment instead of heuristic scoring.</p></li>
<li><p>Naturally models insertions, deletions, and substitutions.</p></li>
<li><p>Forms the mathematical basis for:</p>
<ul>
<li>Profile HMMs (used in HMMER, Pfam)</li>
<li>Gene finding and domain detection</li>
<li>Speech recognition and natural language models</li>
</ul></li>
</ul>
<p>HMM alignment can also be trained from data using Baum–Welch (EM) to learn emission and transition probabilities.</p>
</section>
<section id="complexity-87" class="level4">
<h4 class="anchored" data-anchor-id="complexity-87">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Viterbi (max likelihood)</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
<tr class="even">
<td>Forward–Backward (expectation)</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-87" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-87">Try It Yourself</h4>
<ol type="1">
<li>Build a 3-state match–insert–delete HMM and run Viterbi decoding.</li>
<li>Compare probabilities under different transition matrices.</li>
<li>Visualize the alignment path as a sequence of states.</li>
<li>Extend to Profile HMMs by chaining match states for each alignment column.</li>
<li>Train HMM parameters using Baum–Welch on known alignments.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-54" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-54">A Gentle Proof (Why It Works)</h4>
<p>Each possible alignment corresponds to a path through the HMM. By dynamic programming, Viterbi ensures the Markov property holds — the probability of each prefix alignment depends only on the previous state. This makes global optimization tractable while capturing uncertainty and evolution probabilistically.</p>
<p>HMM alignment reframes alignment as <em>inference over structure and noise</em> — a model that doesn’t just align sequences, but explains how they came to differ.</p>
</section>
</section>
<section id="blast-basic-local-alignment-search-tool" class="level3">
<h3 class="anchored" data-anchor-id="blast-basic-local-alignment-search-tool">688 BLAST (Basic Local Alignment Search Tool)</h3>
<p>The BLAST algorithm is a fast heuristic method for finding local sequence alignments. It’s designed to search large biological databases quickly, comparing a query sequence against millions of others to find similar regions. Rather than computing full dynamic programming matrices, BLAST cleverly balances speed and sensitivity by using <em>word-based seeding and extension</em>.</p>
<section id="the-problem-3" class="level4">
<h4 class="anchored" data-anchor-id="the-problem-3">The Problem</h4>
<p>Classical algorithms like Needleman–Wunsch or Smith–Waterman are exact but expensive: they require <span class="math inline">\(O(mn)\)</span> time per pairwise alignment.</p>
<p>When you need to search a query (like a DNA or protein sequence) against a database of billions of letters, that’s completely infeasible.</p>
<p>BLAST trades a bit of optimality for speed, detecting high-scoring regions (local matches) much faster through a multi-phase heuristic pipeline.</p>
</section>
<section id="the-core-idea-21" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-21">The Core Idea</h4>
<p>BLAST works in three main phases:</p>
<ol type="1">
<li><p>Word Generation (Seeding) The query sequence is split into short fixed-length words (e.g., length 3 for proteins, 11 for DNA). Example: For <code>"AGCTTAGC"</code>, the 3-letter words are <code>AGC</code>, <code>GCT</code>, <code>CTT</code>, <code>TTA</code>, etc.</p></li>
<li><p>Database Scan Each word is looked up in the database for exact or near-exact matches. BLAST uses a <em>substitution matrix</em> (like BLOSUM or PAM) to expand words to similar ones with acceptable scores.</p></li>
<li><p>Extension and Scoring When a word match is found, BLAST extends it in both directions to form a local alignment — using a simple dynamic scoring model until the score drops below a threshold.</p></li>
</ol>
<p>This is similar to Smith–Waterman, but only around promising seed matches rather than every possible position.</p>
</section>
<section id="scoring-system-1" class="level4">
<h4 class="anchored" data-anchor-id="scoring-system-1">Scoring System</h4>
<p>Like other alignment methods, BLAST uses substitution matrices for match/mismatch scores and gap penalties for insertions/deletions.</p>
<p>Typical protein scoring (BLOSUM62):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Pair</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Match</td>
<td>+4</td>
</tr>
<tr class="even">
<td>Conservative substitution</td>
<td>+1</td>
</tr>
<tr class="odd">
<td>Non-conservative</td>
<td>-2</td>
</tr>
<tr class="even">
<td>Gap open</td>
<td>-11</td>
</tr>
<tr class="odd">
<td>Gap extend</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>Each alignment’s bit score <span class="math inline">\(S'\)</span> and E-value (expected number of matches by chance) are then computed as:</p>
<p><span class="math display">\[
S' = \frac{\lambda S - \ln K}{\ln 2}
\]</span></p>
<p><span class="math display">\[
E = K m n e^{-\lambda S}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(S\)</span> = raw alignment score,</li>
<li><span class="math inline">\(m, n\)</span> = sequence lengths,</li>
<li><span class="math inline">\(K, \lambda\)</span> = statistical parameters from the scoring system.</li>
</ul>
</section>
<section id="example-simplified-flow" class="level4">
<h4 class="anchored" data-anchor-id="example-simplified-flow">Example (Simplified Flow)</h4>
<p>Query: <code>ACCTGA</code> Database sequence: <code>ACGTGA</code></p>
<ol type="1">
<li><p>Seed: <code>ACC</code>, <code>CCT</code>, <code>CTG</code>, <code>TGA</code></p></li>
<li><p>Matches: finds <code>TGA</code> in database.</p></li>
<li><p>Extension:</p>
<pre><code>Query:     ACCTGA
Database:  ACGTGA
              ↑↑ ↑</code></pre>
<p>Extends to include nearby matches until score decreases.</p></li>
</ol>
</section>
<section id="tiny-code-simplified-blast-like-demo" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-blast-like-demo">Tiny Code (Simplified BLAST-like Demo)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb236"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> blast(query, database, word_size<span class="op">=</span><span class="dv">3</span>, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, threshold<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a>    words <span class="op">=</span> [query[i:i<span class="op">+</span>word_size] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(query)<span class="op">-</span>word_size<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>    hits <span class="op">=</span> []</span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> word <span class="kw">in</span> words:</span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(database)<span class="op">-</span>word_size<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> word <span class="op">==</span> database[j:j<span class="op">+</span>word_size]:</span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a>                score <span class="op">=</span> word_size <span class="op">*</span> match</span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a>                left, right <span class="op">=</span> j<span class="op">-</span><span class="dv">1</span>, j<span class="op">+</span>word_size</span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> query[<span class="dv">0</span>] <span class="op">!=</span> database[left]:</span>
<span id="cb236-10"><a href="#cb236-10" aria-hidden="true" tabindex="-1"></a>                    score <span class="op">+=</span> mismatch</span>
<span id="cb236-11"><a href="#cb236-11" aria-hidden="true" tabindex="-1"></a>                    left <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb236-12"><a href="#cb236-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> right <span class="op">&lt;</span> <span class="bu">len</span>(database) <span class="kw">and</span> query[<span class="op">-</span><span class="dv">1</span>] <span class="op">!=</span> database[right]:</span>
<span id="cb236-13"><a href="#cb236-13" aria-hidden="true" tabindex="-1"></a>                    score <span class="op">+=</span> mismatch</span>
<span id="cb236-14"><a href="#cb236-14" aria-hidden="true" tabindex="-1"></a>                    right <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb236-15"><a href="#cb236-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> score <span class="op">&gt;=</span> threshold:</span>
<span id="cb236-16"><a href="#cb236-16" aria-hidden="true" tabindex="-1"></a>                    hits.append((word, j, score))</span>
<span id="cb236-17"><a href="#cb236-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hits</span>
<span id="cb236-18"><a href="#cb236-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-19"><a href="#cb236-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(blast(<span class="st">"ACCTGA"</span>, <span class="st">"TTACGTGACCTGATTACGA"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$('ACCT', 8, 4), ('CTGA', 10, 4)]</code></pre>
<p>This simplified version just finds exact 4-mer seeds and reports matches.</p>
</section>
<section id="why-it-matters-87" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-87">Why It Matters</h4>
<ul>
<li><p>Revolutionized bioinformatics by making large-scale sequence searches practical.</p></li>
<li><p>Used for:</p>
<ul>
<li>Gene and protein identification</li>
<li>Database annotation</li>
<li>Homology inference</li>
<li>Evolutionary analysis</li>
</ul></li>
<li><p>Variants include:</p>
<ul>
<li>blastn (DNA)</li>
<li>blastp (proteins)</li>
<li>blastx (translated DNA → protein)</li>
<li>psiblast (position-specific iterative search)</li>
</ul></li>
</ul>
<p>BLAST’s success lies in its elegant balance between statistical rigor and computational pragmatism.</p>
</section>
<section id="complexity-88" class="level4">
<h4 class="anchored" data-anchor-id="complexity-88">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Phase</th>
<th>Approximate Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Word search</td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Extension</td>
<td>proportional to #seeds</td>
</tr>
<tr class="odd">
<td>Overall</td>
<td>sublinear in database size (with indexing)</td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-88" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-88">Try It Yourself</h4>
<ol type="1">
<li>Vary the word size and observe how sensitivity changes.</li>
<li>Use different scoring thresholds.</li>
<li>Compare BLAST’s output to Smith–Waterman’s full local alignment.</li>
<li>Build a simple index (hash map) of k-mers for faster searching.</li>
<li>Explore <code>psiblast</code>, iterative refinement using profile scores.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-55" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-55">A Gentle Proof (Why It Works)</h4>
<p>The seed-and-extend principle works because most biologically significant local alignments contain short exact matches. These act as “anchors” that can be found quickly without scanning the entire DP matrix. Once found, local extensions around them reconstruct the alignment almost as effectively as exhaustive methods.</p>
<p>Thus, BLAST approximates local alignment by focusing computation where it matters most.</p>
<p>BLAST changed the scale of biological search — from hours of exact computation to seconds of smart discovery.</p>
</section>
</section>
<section id="fasta-word-based-local-alignment" class="level3">
<h3 class="anchored" data-anchor-id="fasta-word-based-local-alignment">689 FASTA (Word-Based Local Alignment)</h3>
<p>The FASTA algorithm is another foundational heuristic for local sequence alignment, preceding BLAST. It introduced the idea of using word matches (k-tuples) to find regions of similarity between sequences efficiently. FASTA balances speed and accuracy by focusing on high-scoring short matches and extending them into longer alignments.</p>
<section id="the-idea-2" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-2">The Idea</h4>
<p>FASTA avoids computing full dynamic programming over entire sequences. Instead, it:</p>
<ol type="1">
<li>Finds short <em>exact matches</em> (called k-tuples) between the query and database sequences.</li>
<li>Scores diagonals where many matches occur.</li>
<li>Selects high-scoring regions and extends them using dynamic programming.</li>
</ol>
<p>This allows fast identification of candidate regions likely to yield meaningful local alignments.</p>
</section>
<section id="step-1-k-tuple-matching" class="level4">
<h4 class="anchored" data-anchor-id="step-1-k-tuple-matching">Step 1: k-Tuple Matching</h4>
<p>Given a query of length <span class="math inline">\(m\)</span> and a database sequence of length <span class="math inline">\(n\)</span>, FASTA first identifies all short identical substrings of length <span class="math inline">\(k\)</span> (for proteins, typically <span class="math inline">\(k=2\)</span>; for DNA, <span class="math inline">\(k=6\)</span>).</p>
<p>Example (DNA, <span class="math inline">\(k=3\)</span>):</p>
<p>Query: <code>ACCTGA</code> Database: <code>ACGTGA</code></p>
<p>k-tuples: <code>ACC</code>, <code>CCT</code>, <code>CTG</code>, <code>TGA</code></p>
<p>Matches found:</p>
<ul>
<li>Query <code>CTG</code> ↔︎ Database <code>CTG</code> at different positions</li>
<li>Query <code>TGA</code> ↔︎ Database <code>TGA</code></li>
</ul>
<p>Each match defines a diagonal in an alignment matrix (difference between indices in query and database).</p>
</section>
<section id="step-2-diagonal-scoring" class="level4">
<h4 class="anchored" data-anchor-id="step-2-diagonal-scoring">Step 2: Diagonal Scoring</h4>
<p>FASTA then scores each diagonal by counting the number of word hits along it. High-density diagonals suggest potential regions of alignment.</p>
<p>For each diagonal <span class="math inline">\(d = i - j\)</span>: <span class="math display">\[
S_d = \sum_{(i,j) \in \text{hits on } d} 1
\]</span></p>
<p>Top diagonals with highest <span class="math inline">\(S_d\)</span> are kept for further analysis.</p>
</section>
<section id="step-3-rescoring-and-extension" class="level4">
<h4 class="anchored" data-anchor-id="step-3-rescoring-and-extension">Step 3: Rescoring and Extension</h4>
<p>FASTA then rescans the top regions using a substitution matrix (e.g., PAM or BLOSUM) to refine scores for similar but not identical matches.</p>
<p>Finally, a Smith–Waterman local alignment is performed only on these regions, not across the entire sequences, drastically improving efficiency.</p>
</section>
<section id="example-simplified-flow-1" class="level4">
<h4 class="anchored" data-anchor-id="example-simplified-flow-1">Example (Simplified Flow)</h4>
<p>Query: <code>ACCTGA</code> Database: <code>ACGTGA</code></p>
<ol type="1">
<li><p>Word matches:</p>
<ul>
<li><code>CTG</code> (positions 3–5 in query, 3–5 in database)</li>
<li><code>TGA</code> (positions 4–6 in query, 4–6 in database)</li>
</ul></li>
<li><p>Both lie near the same diagonal → high-scoring region.</p></li>
<li><p>Dynamic programming only extends this region locally:</p>
<pre><code>ACCTGA
|| |||
ACGTGA</code></pre>
<p>Result: alignment with a small substitution (C→G).</p></li>
</ol>
</section>
<section id="tiny-code-simplified-fasta-demo" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-fasta-demo">Tiny Code (Simplified FASTA Demo)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb239"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fasta(query, database, k<span class="op">=</span><span class="dv">3</span>, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>):</span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a>    words <span class="op">=</span> {query[i:i<span class="op">+</span>k]: i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(query)<span class="op">-</span>k<span class="op">+</span><span class="dv">1</span>)}</span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a>    diagonals <span class="op">=</span> {}</span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(database)<span class="op">-</span>k<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>        word <span class="op">=</span> database[j:j<span class="op">+</span>k]</span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> word <span class="kw">in</span> words:</span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a>            diag <span class="op">=</span> words[word] <span class="op">-</span> j</span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a>            diagonals[diag] <span class="op">=</span> diagonals.get(diag, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a>    top_diag <span class="op">=</span> <span class="bu">max</span>(diagonals, key<span class="op">=</span>diagonals.get)</span>
<span id="cb239-11"><a href="#cb239-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top_diag, diagonals[top_diag]</span>
<span id="cb239-12"><a href="#cb239-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-13"><a href="#cb239-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(fasta(<span class="st">"ACCTGA"</span>, <span class="st">"ACGTGA"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>(0, 2)</code></pre>
<p>This means the best alignment diagonal (offset 0) has 2 matching k-tuples.</p>
</section>
<section id="why-it-matters-88" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-88">Why It Matters</h4>
<ul>
<li>Precursor to BLAST, FASTA pioneered the k-tuple method and inspired BLAST’s design.</li>
<li>Statistical scoring, introduced expectation values (E-values) and normalized bit scores.</li>
<li>Scalable, can search entire databases efficiently without losing much sensitivity.</li>
<li>Flexible, supports DNA, RNA, and protein comparisons.</li>
</ul>
<p>Still widely used for sensitive homology detection in genomics and proteomics.</p>
</section>
<section id="complexity-89" class="level4">
<h4 class="anchored" data-anchor-id="complexity-89">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k-tuple matching</td>
<td><span class="math inline">\(O(m + n)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Diagonal scoring</td>
<td>proportional to hits</td>
<td>small</td>
</tr>
<tr class="odd">
<td>Local DP refinement</td>
<td><span class="math inline">\(O(k^2)\)</span></td>
<td>small</td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-89" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-89">Try It Yourself</h4>
<ol type="1">
<li>Experiment with different k values (smaller k → more sensitive, slower).</li>
<li>Compare FASTA’s hits to BLAST’s on the same sequences.</li>
<li>Implement scoring with a substitution matrix (like BLOSUM62).</li>
<li>Plot diagonal density maps to visualize candidate alignments.</li>
<li>Use FASTA to align short reads (DNA) against reference genomes.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-56" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-56">A Gentle Proof (Why It Works)</h4>
<p>Word matches on the same diagonal indicate that two sequences share a common substring alignment. By counting and rescoring diagonals, FASTA focuses computational effort only on promising regions — a probabilistic shortcut that preserves most biologically relevant alignments while skipping over unrelated sequence noise.</p>
<p>FASTA taught us the power of local heuristics: you don’t need to search everywhere, just where patterns start to sing.</p>
</section>
</section>
<section id="pairwise-dynamic-programming-alignment" class="level3">
<h3 class="anchored" data-anchor-id="pairwise-dynamic-programming-alignment">690 Pairwise Dynamic Programming Alignment</h3>
<p>The pairwise dynamic programming alignment algorithm is the general framework behind many alignment methods such as Needleman–Wunsch (global) and Smith–Waterman (local). It provides a systematic way to compare two sequences by filling a matrix of scores that captures all possible alignments. This is the foundation of computational sequence comparison.</p>
<section id="the-problem-4" class="level4">
<h4 class="anchored" data-anchor-id="the-problem-4">The Problem</h4>
<p>Given two sequences:</p>
<ul>
<li>Query: <span class="math inline">\(A = a_1 a_2 \dots a_m\)</span></li>
<li>Target: <span class="math inline">\(B = b_1 b_2 \dots b_n\)</span></li>
</ul>
<p>we want to find an alignment that maximizes a similarity score based on matches, mismatches, and gaps.</p>
<p>Each position pair <span class="math inline">\((i, j)\)</span> in the matrix represents an alignment between <span class="math inline">\(a_i\)</span> and <span class="math inline">\(b_j\)</span>.</p>
</section>
<section id="scoring-system-2" class="level4">
<h4 class="anchored" data-anchor-id="scoring-system-2">Scoring System</h4>
<p>We define:</p>
<ul>
<li>Match score: <span class="math inline">\(+s\)</span></li>
<li>Mismatch penalty: <span class="math inline">\(-p\)</span></li>
<li>Gap penalty: <span class="math inline">\(-g\)</span></li>
</ul>
<p>Then, the recurrence relation for the DP matrix <span class="math inline">\(dp[i][j]\)</span> is:</p>
<p><span class="math display">\[
dp[i][j] =
\max
\begin{cases}
dp[i-1][j-1] + \text{score}(a_i, b_j), &amp; \text{(match/mismatch)},\\[4pt]
dp[i-1][j] - g, &amp; \text{(gap in B)},\\[4pt]
dp[i][j-1] - g, &amp; \text{(gap in A)}.
\end{cases}
\]</span></p>
<p>with initialization:</p>
<p><span class="math display">\[
dp[0][j] = -jg, \quad dp[i][0] = -ig
\]</span></p>
<p>and base case:</p>
<p><span class="math display">\[
dp[0][0] = 0
\]</span></p>
</section>
<section id="global-vs-local-alignment" class="level4">
<h4 class="anchored" data-anchor-id="global-vs-local-alignment">Global vs Local Alignment</h4>
<ul>
<li><p>Global alignment (Needleman–Wunsch): Considers the entire sequence. The best score is at <span class="math inline">\(dp[m][n]\)</span>.</p></li>
<li><p>Local alignment (Smith–Waterman): Allows partial alignments, setting <span class="math display">\[dp[i][j] = \max(0, \text{previous terms})\]</span> and taking the maximum over all cells as the final score.</p></li>
</ul>
</section>
<section id="example-global-alignment" class="level4">
<h4 class="anchored" data-anchor-id="example-global-alignment">Example (Global Alignment)</h4>
<p>Query: <code>ACGT</code> Target: <code>AGT</code></p>
<p>Let match = +1, mismatch = -1, gap = -2.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>i/j</th>
<th>0</th>
<th>A</th>
<th>G</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>-2</td>
<td>-4</td>
<td>-6</td>
</tr>
<tr class="even">
<td>A</td>
<td>-2</td>
<td>1</td>
<td>-1</td>
<td>-3</td>
</tr>
<tr class="odd">
<td>C</td>
<td>-4</td>
<td>-1</td>
<td>0</td>
<td>-2</td>
</tr>
<tr class="even">
<td>G</td>
<td>-6</td>
<td>-3</td>
<td>1</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>T</td>
<td>-8</td>
<td>-5</td>
<td>-1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>The best score is 2, corresponding to alignment:</p>
<pre><code>A C G T
|   | |
A - G T</code></pre>
</section>
<section id="tiny-code-python-implementation-1" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation-1">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb242"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pairwise_align(a, b, match<span class="op">=</span><span class="dv">1</span>, mismatch<span class="op">=-</span><span class="dv">1</span>, gap<span class="op">=-</span><span class="dv">2</span>):</span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(a), <span class="bu">len</span>(b)</span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> i <span class="op">*</span> gap</span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> j <span class="op">*</span> gap</span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb242-11"><a href="#cb242-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb242-12"><a href="#cb242-12" aria-hidden="true" tabindex="-1"></a>            s <span class="op">=</span> match <span class="cf">if</span> a[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> b[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">else</span> mismatch</span>
<span id="cb242-13"><a href="#cb242-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb242-14"><a href="#cb242-14" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> s,</span>
<span id="cb242-15"><a href="#cb242-15" aria-hidden="true" tabindex="-1"></a>                dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> gap,</span>
<span id="cb242-16"><a href="#cb242-16" aria-hidden="true" tabindex="-1"></a>                dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> gap</span>
<span id="cb242-17"><a href="#cb242-17" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb242-18"><a href="#cb242-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb242-19"><a href="#cb242-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-20"><a href="#cb242-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pairwise_align(<span class="st">"ACGT"</span>, <span class="st">"AGT"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>2</code></pre>
</section>
<section id="why-it-matters-89" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-89">Why It Matters</h4>
<ul>
<li>Provides a unified foundation for sequence comparison.</li>
<li>Forms the basis for global, local, semi-global, and affine-gap alignments.</li>
<li>Guarantees optimal alignment given the scoring scheme.</li>
<li>Extensible to profile and multiple alignments.</li>
</ul>
<p>This framework underlies most algorithms in bioinformatics, text comparison, and natural language alignment.</p>
</section>
<section id="complexity-90" class="level4">
<h4 class="anchored" data-anchor-id="complexity-90">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Fill DP table</td>
<td><span class="math inline">\(O(mn)\)</span></td>
<td><span class="math inline">\(O(mn)\)</span></td>
</tr>
<tr class="even">
<td>Traceback (optional)</td>
<td><span class="math inline">\(O(m + n)\)</span></td>
<td>,</td>
</tr>
</tbody>
</table>
<p>With linear-space optimization (e.g., Hirschberg’s algorithm), space can be reduced to <span class="math inline">\(O(m + n)\)</span>.</p>
</section>
<section id="try-it-yourself-90" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-90">Try It Yourself</h4>
<ol type="1">
<li>Implement both global and local variants by changing initialization.</li>
<li>Add affine gap penalties with separate gap-open and gap-extend parameters.</li>
<li>Visualize the alignment matrix and traceback arrows.</li>
<li>Compare with BLAST/FASTA outputs on short sequences.</li>
<li>Experiment with different scoring matrices (e.g., BLOSUM62 for proteins).</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-57" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-57">A Gentle Proof (Why It Works)</h4>
<p>The dynamic programming recurrence ensures optimal substructure: the best alignment up to <span class="math inline">\((i,j)\)</span> must include an optimal alignment of a prefix. By filling the table in increasing order of <span class="math inline">\((i, j)\)</span>, we guarantee that all subproblems are solved before being used.</p>
<p>The final cell thus contains the maximum achievable alignment score.</p>
<p>Pairwise alignment is the root from which all sequence comparison methods grow — a precise balance between structure, similarity, and evolution.</p>
</section>
</section>
</section>
<section id="section-70.-text-indexing-and-search-structure" class="level1">
<h1>Section 70. Text Indexing and Search Structure</h1>
<section id="inverted-index-build" class="level3">
<h3 class="anchored" data-anchor-id="inverted-index-build">691 Inverted Index Build</h3>
<p>The inverted index is the core data structure behind modern search engines. It maps each term (word or token) to a list of documents (and optionally positions) where that term appears. This allows extremely fast keyword lookup, ranking, and retrieval across millions of documents.</p>
<section id="the-idea-3" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-3">The Idea</h4>
<p>Instead of storing documents as sequences of words, an inverted index stores words as keys and document IDs as values.</p>
<p>This is called <em>inversion</em> because it flips the direction of lookup:</p>
<ul>
<li>A <em>forward index</em> maps document → words.</li>
<li>An <em>inverted index</em> maps word → documents.</li>
</ul>
</section>
<section id="example-62" class="level4">
<h4 class="anchored" data-anchor-id="example-62">Example</h4>
<p>Suppose we have 3 documents:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>ID</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>“data structures and algorithms”</td>
</tr>
<tr class="even">
<td>2</td>
<td>“algorithms for text processing”</td>
</tr>
<tr class="odd">
<td>3</td>
<td>“data compression and encoding”</td>
</tr>
</tbody>
</table>
<p>The inverted index becomes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Term</th>
<th>Documents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>algorithms</td>
<td>[1, 2]</td>
</tr>
<tr class="even">
<td>and</td>
<td>[1, 3]</td>
</tr>
<tr class="odd">
<td>compression</td>
<td>[3]</td>
</tr>
<tr class="even">
<td>data</td>
<td>[1, 3]</td>
</tr>
<tr class="odd">
<td>encoding</td>
<td>[3]</td>
</tr>
<tr class="even">
<td>for</td>
<td>[2]</td>
</tr>
<tr class="odd">
<td>processing</td>
<td>[2]</td>
</tr>
<tr class="even">
<td>structures</td>
<td>[1]</td>
</tr>
<tr class="odd">
<td>text</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<p>This lets us find all documents containing a term in <span class="math inline">\(O(1)\)</span> average lookup time per term.</p>
</section>
<section id="step-by-step-construction" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-construction">Step-by-Step Construction</h4>
<ol type="1">
<li><p>Tokenize Documents Split text into normalized tokens (lowercased, stripped of punctuation, stopwords removed).</p>
<p>Example: <code>"Data Structures and Algorithms"</code> → <code>["data", "structures", "algorithms"]</code></p></li>
<li><p>Assign Document IDs Each document in the collection gets a unique integer ID.</p></li>
<li><p>Build Postings Lists For each term, append the document ID to its posting list.</p></li>
<li><p>Sort and Deduplicate Sort postings lists and remove duplicate document IDs.</p></li>
<li><p>Optionally Compress Store gaps instead of full IDs and compress using variable-length encoding or delta coding.</p></li>
</ol>
</section>
<section id="tiny-code-python-implementation-2" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation-2">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb244"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_inverted_index(docs):</span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> defaultdict(<span class="bu">set</span>)</span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> doc_id, text <span class="kw">in</span> <span class="bu">enumerate</span>(docs, start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a>        tokens <span class="op">=</span> text.lower().split()</span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> token <span class="kw">in</span> tokens:</span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true" tabindex="-1"></a>            index[token].add(doc_id)</span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {term: <span class="bu">sorted</span>(<span class="bu">list</span>(ids)) <span class="cf">for</span> term, ids <span class="kw">in</span> index.items()}</span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true" tabindex="-1"></a>docs <span class="op">=</span> [</span>
<span id="cb244-12"><a href="#cb244-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data structures and algorithms"</span>,</span>
<span id="cb244-13"><a href="#cb244-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"algorithms for text processing"</span>,</span>
<span id="cb244-14"><a href="#cb244-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data compression and encoding"</span></span>
<span id="cb244-15"><a href="#cb244-15" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb244-16"><a href="#cb244-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-17"><a href="#cb244-17" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> build_inverted_index(docs)</span>
<span id="cb244-18"><a href="#cb244-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> term, postings <span class="kw">in</span> index.items():</span>
<span id="cb244-19"><a href="#cb244-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>term<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>postings<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>algorithms: [1, 2]
and: [1, 3]
compression: [3]
data: [1, 3]
encoding: [3]
for: [2]
processing: [2]
structures: [1]
text: [2]</code></pre>
</section>
<section id="mathematical-formulation-1" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-formulation-1">Mathematical Formulation</h4>
<p>Let the document collection be <span class="math inline">\(D = {d_1, d_2, \dots, d_N}\)</span> and the vocabulary be <span class="math inline">\(V = {t_1, t_2, \dots, t_M}\)</span>.</p>
<p>Then the inverted index is a mapping:</p>
<p><span class="math display">\[
I: t_i \mapsto P_i = {d_j \mid t_i \in d_j}
\]</span></p>
<p>where <span class="math inline">\(P_i\)</span> is the <em>posting list</em> of documents containing term <span class="math inline">\(t_i\)</span>.</p>
<p>If we include positional information, we can define:</p>
<p><span class="math display">\[
I: t_i \mapsto {(d_j, \text{positions}(t_i, d_j))}
\]</span></p>
</section>
<section id="storage-optimization" class="level4">
<h4 class="anchored" data-anchor-id="storage-optimization">Storage Optimization</h4>
<p>A typical inverted index stores:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Component</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Vocabulary table</td>
<td>List of unique terms</td>
</tr>
<tr class="even">
<td>Postings list</td>
<td>Document IDs where term appears</td>
</tr>
<tr class="odd">
<td>Term frequencies</td>
<td>How many times each term appears per document</td>
</tr>
<tr class="even">
<td>Positions (optional)</td>
<td>Word offsets for phrase queries</td>
</tr>
<tr class="odd">
<td>Skip pointers</td>
<td>Accelerate large posting list traversal</td>
</tr>
</tbody>
</table>
<p>Compression methods (e.g., delta encoding, variable-byte, Golomb, or Elias gamma) dramatically reduce storage size.</p>
</section>
<section id="why-it-matters-90" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-90">Why It Matters</h4>
<ul>
<li><p>Enables instant search across billions of documents.</p></li>
<li><p>Core structure in systems like Lucene, Elasticsearch, and Google Search.</p></li>
<li><p>Supports advanced features like:</p>
<ul>
<li>Boolean queries (<code>AND</code>, <code>OR</code>, <code>NOT</code>)</li>
<li>Phrase queries (“data compression”)</li>
<li>Proximity and fuzzy matching</li>
<li>Ranking (TF–IDF, BM25, etc.)</li>
</ul></li>
</ul>
</section>
<section id="complexity-91" class="level4">
<h4 class="anchored" data-anchor-id="complexity-91">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 28%">
<col style="width: 19%">
<col style="width: 1%">
<col style="width: 5%">
<col style="width: 3%">
<col style="width: 1%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Building index</td>
<td><span class="math inline">\(O(N \times L)\)</span></td>
<td><span class="math inline">\(O(V + P)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Query lookup</td>
<td><span class="math inline">\(O(1)\)</span> per term</td>
<td>,</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Boolean AND/OR merge</td>
<td><span class="math inline">\(O(             | P_1        | + | P_2 | )\)</span></td>
<td>,</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Where:</p>
<ul>
<li><span class="math inline">\(N\)</span> = number of documents</li>
<li><span class="math inline">\(L\)</span> = average document length</li>
<li><span class="math inline">\(V\)</span> = vocabulary size</li>
<li><span class="math inline">\(P\)</span> = total number of postings</li>
</ul>
</section>
<section id="try-it-yourself-91" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-91">Try It Yourself</h4>
<ol type="1">
<li>Extend the code to store term frequencies per document.</li>
<li>Add phrase query support using positional postings.</li>
<li>Implement compression with gap encoding.</li>
<li>Compare search time before and after compression.</li>
<li>Visualize posting list merging for queries like <code>"data AND algorithms"</code>.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-58" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-58">A Gentle Proof (Why It Works)</h4>
<p>Because every document contributes its words independently, the inverted index represents a union of local term-document relations. Thus, any query term lookup reduces to simple set intersections of precomputed lists — transforming expensive text scanning into efficient Boolean algebra on small sets.</p>
<p>The inverted index is the heartbeat of information retrieval, turning words into structure, and search into instant insight.</p>
</section>
</section>
<section id="positional-index" class="level3">
<h3 class="anchored" data-anchor-id="positional-index">692 Positional Index</h3>
<p>A positional index extends the inverted index by recording the exact positions of each term within a document. It enables more advanced queries such as phrase search, proximity search, and context-sensitive retrieval, which are essential for modern search engines and text analysis systems.</p>
<section id="the-idea-4" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-4">The Idea</h4>
<p>In a standard inverted index, each entry maps a term to a list of documents where it appears:</p>
<p><span class="math display">\[
I(t) = {d_1, d_2, \dots}
\]</span></p>
<p>A positional index refines this idea by mapping each term to pairs of (document ID, positions list):</p>
<p><span class="math display">\[
I(t) = {(d_1, [p_{11}, p_{12}, \dots]), (d_2, [p_{21}, p_{22}, \dots]), \dots}
\]</span></p>
<p>where <span class="math inline">\(p_{ij}\)</span> are the word offsets (positions) where term <span class="math inline">\(t\)</span> occurs in document <span class="math inline">\(d_i\)</span>.</p>
</section>
<section id="example-63" class="level4">
<h4 class="anchored" data-anchor-id="example-63">Example</h4>
<p>Consider 3 documents:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>ID</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>“data structures and algorithms”</td>
</tr>
<tr class="even">
<td>2</td>
<td>“algorithms for data compression”</td>
</tr>
<tr class="odd">
<td>3</td>
<td>“data and data encoding”</td>
</tr>
</tbody>
</table>
<p>Then the positional index looks like:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Term</th>
<th>Postings</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>algorithms</td>
<td>(1, [3]), (2, [1])</td>
</tr>
<tr class="even">
<td>and</td>
<td>(1, [2]), (3, [2])</td>
</tr>
<tr class="odd">
<td>compression</td>
<td>(2, [3])</td>
</tr>
<tr class="even">
<td>data</td>
<td>(1, [1]), (2, [2]), (3, [1, 3])</td>
</tr>
<tr class="odd">
<td>encoding</td>
<td>(3, [4])</td>
</tr>
<tr class="even">
<td>for</td>
<td>(2, [2])</td>
</tr>
<tr class="odd">
<td>structures</td>
<td>(1, [2])</td>
</tr>
</tbody>
</table>
<p>Each posting now stores both document IDs and position lists.</p>
</section>
<section id="how-phrase-queries-work" class="level4">
<h4 class="anchored" data-anchor-id="how-phrase-queries-work">How Phrase Queries Work</h4>
<p>To find a phrase like <code>"data structures"</code>, we must locate documents where:</p>
<ul>
<li><code>data</code> appears at position <span class="math inline">\(p\)</span></li>
<li><code>structures</code> appears at position <span class="math inline">\(p+1\)</span></li>
</ul>
<p>This is done by intersecting posting lists with positional offsets.</p>
</section>
<section id="phrase-query-example" class="level4">
<h4 class="anchored" data-anchor-id="phrase-query-example">Phrase Query Example</h4>
<p>Phrase: <code>"data structures"</code></p>
<ol type="1">
<li><p>From the index:</p>
<ul>
<li><code>data</code> → (1, [1]), (2, [2]), (3, [1, 3])</li>
<li><code>structures</code> → (1, [2])</li>
</ul></li>
<li><p>Intersection by document:</p>
<ul>
<li>Only doc 1 contains both.</li>
</ul></li>
<li><p>Compare positions:</p>
<ul>
<li>In doc 1: <code>1</code> (for <code>data</code>) and <code>2</code> (for <code>structures</code>)</li>
<li>Difference = 1 → phrase match confirmed.</li>
</ul></li>
</ol>
<p>Result: document 1.</p>
</section>
<section id="tiny-code-python-implementation-3" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation-3">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb246"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_positional_index(docs):</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> defaultdict(<span class="kw">lambda</span>: defaultdict(<span class="bu">list</span>))</span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> doc_id, text <span class="kw">in</span> <span class="bu">enumerate</span>(docs, start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>        tokens <span class="op">=</span> text.lower().split()</span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pos, token <span class="kw">in</span> <span class="bu">enumerate</span>(tokens):</span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>            index[token][doc_id].append(pos)</span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> index</span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>docs <span class="op">=</span> [</span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data structures and algorithms"</span>,</span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"algorithms for data compression"</span>,</span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data and data encoding"</span></span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> build_positional_index(docs)</span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> term, posting <span class="kw">in</span> index.items():</span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(term, <span class="bu">dict</span>(posting))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>data {1: [0], 2: [2], 3: [0, 2]}
structures {1: [1]}
and {1: [2], 3: [1]}
algorithms {1: [3], 2: [0]}
for {2: [1]}
compression {2: [3]}
encoding {3: [3]}</code></pre>
</section>
<section id="phrase-query-search" class="level4">
<h4 class="anchored" data-anchor-id="phrase-query-search">Phrase Query Search</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb248"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> phrase_query(index, term1, term2):</span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> doc <span class="kw">in</span> <span class="bu">set</span>(index[term1]) <span class="op">&amp;</span> <span class="bu">set</span>(index[term2]):</span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>        pos1 <span class="op">=</span> index[term1][doc]</span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>        pos2 <span class="op">=</span> index[term2][doc]</span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">any</span>(p2 <span class="op">-</span> p1 <span class="op">==</span> <span class="dv">1</span> <span class="cf">for</span> p1 <span class="kw">in</span> pos1 <span class="cf">for</span> p2 <span class="kw">in</span> pos2):</span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a>            results.append(doc)</span>
<span id="cb248-8"><a href="#cb248-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span>
<span id="cb248-9"><a href="#cb248-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-10"><a href="#cb248-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(phrase_query(index, <span class="st">"data"</span>, <span class="st">"structures"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$1]</code></pre>
</section>
<section id="mathematical-view" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-view">Mathematical View</h4>
<p>For a phrase query of <span class="math inline">\(k\)</span> terms <span class="math inline">\(t_1, t_2, \dots, t_k\)</span>, we find documents <span class="math inline">\(d\)</span> such that:</p>
<p><span class="math display">\[
\exists p_1, p_2, \dots, p_k \text{ with } p_{i+1} = p_i + 1
\]</span></p>
<p>for all <span class="math inline">\(i \in [1, k-1]\)</span>.</p>
</section>
<section id="why-it-matters-91" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-91">Why It Matters</h4>
<p>A positional index enables:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Phrase search</td>
<td>Exact multi-word matches (“machine learning”)</td>
</tr>
<tr class="even">
<td>Proximity search</td>
<td>Terms appearing near each other</td>
</tr>
<tr class="odd">
<td>Order sensitivity</td>
<td>“data compression” ≠ “compression data”</td>
</tr>
<tr class="even">
<td>Context retrieval</td>
<td>Extract sentence windows efficiently</td>
</tr>
</tbody>
</table>
<p>It trades additional storage for much more expressive search capability.</p>
</section>
<section id="complexity-92" class="level4">
<h4 class="anchored" data-anchor-id="complexity-92">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 27%">
<col style="width: 18%">
<col style="width: 1%">
<col style="width: 5%">
<col style="width: 3%">
<col style="width: 1%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build index</td>
<td><span class="math inline">\(O(N \times L)\)</span></td>
<td><span class="math inline">\(O(V + P)\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Phrase query (2 terms)</td>
<td><span class="math inline">\(O(             | P_1        | + | P_2 | )\)</span></td>
<td>,</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Phrase query (k terms)</td>
<td><span class="math inline">\(O(k \times P)\)</span></td>
<td>,</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Where <span class="math inline">\(P\)</span> is the average posting list length.</p>
</section>
<section id="try-it-yourself-92" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-92">Try It Yourself</h4>
<ol type="1">
<li>Extend to n-gram queries for phrases of arbitrary length.</li>
<li>Add a window constraint for “within k words” search.</li>
<li>Implement compressed positional storage using delta encoding.</li>
<li>Test with a large corpus and measure query speed.</li>
<li>Visualize how positional overlaps form phrase matches.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-59" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-59">A Gentle Proof (Why It Works)</h4>
<p>Each position in the text defines a coordinate in a grid of word order. By intersecting these coordinates across words, we reconstruct contiguous patterns — just as syntax and meaning emerge from words in sequence.</p>
<p>The positional index is the bridge from word to phrase, turning text search into understanding of structure and order.</p>
</section>
</section>
<section id="tfidf-weighting" class="level3">
<h3 class="anchored" data-anchor-id="tfidf-weighting">693 TF–IDF Weighting</h3>
<p>TF–IDF (Term Frequency–Inverse Document Frequency) is one of the most influential ideas in information retrieval. It quantifies how <em>important</em> a word is to a document in a collection by balancing two opposing effects:</p>
<ul>
<li>Words that appear frequently in a document are important.</li>
<li>Words that appear in many documents are less informative.</li>
</ul>
<p>Together, these ideas let us score documents by how well they match a query, forming the basis for ranked retrieval systems like search engines.</p>
<section id="the-core-idea-22" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-22">The Core Idea</h4>
<p>The TF–IDF score for term <span class="math inline">\(t\)</span> in document <span class="math inline">\(d\)</span> within a corpus <span class="math inline">\(D\)</span> is:</p>
<p><span class="math display">\[
\text{tfidf}(t, d, D) = \text{tf}(t, d) \times \text{idf}(t, D)
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(\text{tf}(t, d)\)</span> = term frequency (how often <span class="math inline">\(t\)</span> appears in <span class="math inline">\(d\)</span>)</li>
<li><span class="math inline">\(\text{idf}(t, D)\)</span> = inverse document frequency (how rare <span class="math inline">\(t\)</span> is across <span class="math inline">\(D\)</span>)</li>
</ul>
</section>
<section id="step-1-term-frequency-tf" class="level4">
<h4 class="anchored" data-anchor-id="step-1-term-frequency-tf">Step 1: Term Frequency (TF)</h4>
<p>Term frequency measures how often a term appears in a single document:</p>
<p><span class="math display">\[
\text{tf}(t, d) = \frac{f_{t,d}}{\sum_{t'} f_{t',d}}
\]</span></p>
<p>where <span class="math inline">\(f_{t,d}\)</span> is the raw count of term <span class="math inline">\(t\)</span> in document <span class="math inline">\(d\)</span>.</p>
<p>Common variations:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Formula</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f_{t,d}\)</span></td>
<td>raw count</td>
</tr>
<tr class="even">
<td><span class="math inline">\(1 + \log f_{t,d}\)</span></td>
<td>logarithmic scaling</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\frac{f_{t,d}}{\max_{t'} f_{t',d}}\)</span></td>
<td>normalized by max term count</td>
</tr>
</tbody>
</table>
</section>
<section id="step-2-inverse-document-frequency-idf" class="level4">
<h4 class="anchored" data-anchor-id="step-2-inverse-document-frequency-idf">Step 2: Inverse Document Frequency (IDF)</h4>
<p>IDF downweights common words (like <em>the</em>, <em>and</em>, <em>data</em>) that appear in many documents:</p>
<p><span class="math display">\[
\text{idf}(t, D) = \log \frac{N}{n_t}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(N\)</span> = total number of documents</li>
<li><span class="math inline">\(n_t\)</span> = number of documents containing term <span class="math inline">\(t\)</span></li>
</ul>
<p>A smoothed version avoids division by zero:</p>
<p><span class="math display">\[
\text{idf}(t, D) = \log \frac{1 + N}{1 + n_t} + 1
\]</span></p>
</section>
<section id="step-3-tfidf-weight" class="level4">
<h4 class="anchored" data-anchor-id="step-3-tfidf-weight">Step 3: TF–IDF Weight</h4>
<p>Combining both parts:</p>
<p><span class="math display">\[
w_{t,d} = \text{tf}(t, d) \times \log \frac{N}{n_t}
\]</span></p>
<p>The resulting weight <span class="math inline">\(w_{t,d}\)</span> represents how much <em>term <span class="math inline">\(t\)</span></em> contributes to identifying <em>document <span class="math inline">\(d\)</span></em>.</p>
</section>
<section id="example-64" class="level4">
<h4 class="anchored" data-anchor-id="example-64">Example</h4>
<p>Suppose our corpus has three documents:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>ID</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>“data structures and algorithms”</td>
</tr>
<tr class="even">
<td>2</td>
<td>“algorithms for data analysis”</td>
</tr>
<tr class="odd">
<td>3</td>
<td>“machine learning and data”</td>
</tr>
</tbody>
</table>
<p>Vocabulary: <code>["data", "structures", "algorithms", "analysis", "machine", "learning", "and", "for"]</code></p>
<p>Total <span class="math inline">\(N = 3\)</span> documents.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Term</th>
<th><span class="math inline">\(n_t\)</span></th>
<th><span class="math inline">\(\text{idf}(t)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>data</td>
<td>3</td>
<td><span class="math inline">\(\log(3/3) = 0\)</span></td>
</tr>
<tr class="even">
<td>structures</td>
<td>1</td>
<td><span class="math inline">\(\log(3/1) = 1.10\)</span></td>
</tr>
<tr class="odd">
<td>algorithms</td>
<td>2</td>
<td><span class="math inline">\(\log(3/2) = 0.40\)</span></td>
</tr>
<tr class="even">
<td>analysis</td>
<td>1</td>
<td>1.10</td>
</tr>
<tr class="odd">
<td>machine</td>
<td>1</td>
<td>1.10</td>
</tr>
<tr class="even">
<td>learning</td>
<td>1</td>
<td>1.10</td>
</tr>
<tr class="odd">
<td>and</td>
<td>2</td>
<td>0.40</td>
</tr>
<tr class="even">
<td>for</td>
<td>1</td>
<td>1.10</td>
</tr>
</tbody>
</table>
<p>So “data” is not distinctive (IDF = 0), while rare words like “structures” or “analysis” carry more weight.</p>
</section>
<section id="tiny-code-python-implementation-4" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation-4">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb250"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_tfidf(docs):</span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(docs)</span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>    term_doc_count <span class="op">=</span> Counter()</span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>    term_freqs <span class="op">=</span> []</span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> doc <span class="kw">in</span> docs:</span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a>        tokens <span class="op">=</span> doc.lower().split()</span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true" tabindex="-1"></a>        counts <span class="op">=</span> Counter(tokens)</span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true" tabindex="-1"></a>        term_freqs.append(counts)</span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true" tabindex="-1"></a>        term_doc_count.update(<span class="bu">set</span>(tokens))</span>
<span id="cb250-14"><a href="#cb250-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-15"><a href="#cb250-15" aria-hidden="true" tabindex="-1"></a>    tfidf <span class="op">=</span> []</span>
<span id="cb250-16"><a href="#cb250-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> counts <span class="kw">in</span> term_freqs:</span>
<span id="cb250-17"><a href="#cb250-17" aria-hidden="true" tabindex="-1"></a>        doc_scores <span class="op">=</span> {}</span>
<span id="cb250-18"><a href="#cb250-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> term, freq <span class="kw">in</span> counts.items():</span>
<span id="cb250-19"><a href="#cb250-19" aria-hidden="true" tabindex="-1"></a>            tf <span class="op">=</span> freq <span class="op">/</span> <span class="bu">sum</span>(counts.values())</span>
<span id="cb250-20"><a href="#cb250-20" aria-hidden="true" tabindex="-1"></a>            idf <span class="op">=</span> math.log((<span class="dv">1</span> <span class="op">+</span> N) <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> term_doc_count[term])) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb250-21"><a href="#cb250-21" aria-hidden="true" tabindex="-1"></a>            doc_scores[term] <span class="op">=</span> tf <span class="op">*</span> idf</span>
<span id="cb250-22"><a href="#cb250-22" aria-hidden="true" tabindex="-1"></a>        tfidf.append(doc_scores)</span>
<span id="cb250-23"><a href="#cb250-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tfidf</span>
<span id="cb250-24"><a href="#cb250-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-25"><a href="#cb250-25" aria-hidden="true" tabindex="-1"></a>docs <span class="op">=</span> [</span>
<span id="cb250-26"><a href="#cb250-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data structures and algorithms"</span>,</span>
<span id="cb250-27"><a href="#cb250-27" aria-hidden="true" tabindex="-1"></a>    <span class="st">"algorithms for data analysis"</span>,</span>
<span id="cb250-28"><a href="#cb250-28" aria-hidden="true" tabindex="-1"></a>    <span class="st">"machine learning and data"</span></span>
<span id="cb250-29"><a href="#cb250-29" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb250-30"><a href="#cb250-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-31"><a href="#cb250-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, scores <span class="kw">in</span> <span class="bu">enumerate</span>(compute_tfidf(docs), <span class="dv">1</span>):</span>
<span id="cb250-32"><a href="#cb250-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Doc </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>scores<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tfidf-vector-representation" class="level4">
<h4 class="anchored" data-anchor-id="tfidf-vector-representation">TF–IDF Vector Representation</h4>
<p>Each document becomes a vector in term space:</p>
<p><span class="math display">\[
\mathbf{d} = [w_{t_1,d}, w_{t_2,d}, \dots, w_{t_M,d}]
\]</span></p>
<p>Similarity between a query <span class="math inline">\(\mathbf{q}\)</span> and document <span class="math inline">\(\mathbf{d}\)</span> is measured by cosine similarity:</p>
<p><span class="math display">\[
\text{sim}(\mathbf{q}, \mathbf{d}) =
\frac{\mathbf{q} \cdot \mathbf{d}}
{|\mathbf{q}| , |\mathbf{d}|}
\]</span></p>
<p>This allows ranked retrieval by sorting documents by similarity score.</p>
</section>
<section id="why-it-matters-92" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-92">Why It Matters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>Benefit</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Balances relevance</td>
<td>Highlights words frequent in a doc but rare in the corpus</td>
</tr>
<tr class="even">
<td>Lightweight and effective</td>
<td>Simple to compute and works well for text retrieval</td>
</tr>
<tr class="odd">
<td>Foundation for ranking</td>
<td>Used in BM25, vector search, and embeddings</td>
</tr>
<tr class="even">
<td>Intuitive</td>
<td>Mirrors human sense of “keyword importance”</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-93" class="level4">
<h4 class="anchored" data-anchor-id="complexity-93">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compute term frequencies</td>
<td><span class="math inline">\(O(N \times L)\)</span></td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
<tr class="even">
<td>Compute IDF</td>
<td><span class="math inline">\(O(V)\)</span></td>
<td><span class="math inline">\(O(V)\)</span></td>
</tr>
<tr class="odd">
<td>Compute TF–IDF weights</td>
<td><span class="math inline">\(O(N \times V)\)</span></td>
<td><span class="math inline">\(O(N \times V)\)</span></td>
</tr>
</tbody>
</table>
<p>Where <span class="math inline">\(N\)</span> = number of documents, <span class="math inline">\(L\)</span> = average document length, <span class="math inline">\(V\)</span> = vocabulary size.</p>
</section>
<section id="try-it-yourself-93" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-93">Try It Yourself</h4>
<ol type="1">
<li>Normalize all TF–IDF vectors and compare with cosine similarity.</li>
<li>Add stopword removal and stemming to improve weighting.</li>
<li>Compare TF–IDF ranking vs raw term frequency.</li>
<li>Build a simple query-matching system using dot products.</li>
<li>Visualize document clusters using PCA on TF–IDF vectors.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-60" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-60">A Gentle Proof (Why It Works)</h4>
<p>TF–IDF expresses information gain: a term’s weight is proportional to how much it reduces uncertainty about which document we’re reading. Common words provide little information, while rare, specific terms (like “entropy” or “suffix tree”) pinpoint documents effectively.</p>
<p>TF–IDF remains one of the most elegant bridges between statistics and semantics — a simple equation that made machines understand what matters in text.</p>
</section>
</section>
<section id="bm25-ranking" class="level3">
<h3 class="anchored" data-anchor-id="bm25-ranking">694 BM25 Ranking</h3>
<p>BM25 (Best Matching 25) is a ranking function used in modern search engines to score how relevant a document is to a query. It improves upon TF–IDF by modeling term saturation and document length normalization, making it more robust and accurate for practical retrieval tasks.</p>
<section id="the-idea-5" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-5">The Idea</h4>
<p>BM25 builds on TF–IDF but introduces two realistic corrections:</p>
<ol type="1">
<li>Term frequency saturation, extra occurrences of a term contribute less after a point.</li>
<li>Length normalization, longer documents are penalized so they don’t dominate results.</li>
</ol>
<p>It estimates the probability that a document <span class="math inline">\(d\)</span> is relevant to a query <span class="math inline">\(q\)</span> using a scoring function based on term frequencies and document statistics.</p>
</section>
<section id="the-bm25-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-bm25-formula">The BM25 Formula</h4>
<p>For a query <span class="math inline">\(q = {t_1, t_2, \dots, t_n}\)</span> and a document <span class="math inline">\(d\)</span>, the BM25 score is:</p>
<p><span class="math display">\[
\text{score}(d, q) = \sum_{t \in q} \text{idf}(t) \cdot
\frac{f(t, d) \cdot (k_1 + 1)}{f(t, d) + k_1 \cdot \left(1 - b + b \cdot \frac{|d|}{\text{avgdl}}\right)}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(f(t, d)\)</span>, frequency of term <span class="math inline">\(t\)</span> in document <span class="math inline">\(d\)</span></li>
<li><span class="math inline">\(|d|\)</span>, length of document <span class="math inline">\(d\)</span> (in words)</li>
<li><span class="math inline">\(\text{avgdl}\)</span>, average document length in the corpus</li>
<li><span class="math inline">\(k_1\)</span>, term frequency scaling factor (commonly <span class="math inline">\(1.2\)</span> to <span class="math inline">\(2.0\)</span>)</li>
<li><span class="math inline">\(b\)</span>, length normalization factor (commonly <span class="math inline">\(0.75\)</span>)</li>
</ul>
<p>and</p>
<p><span class="math display">\[
\text{idf}(t) = \log\frac{N - n_t + 0.5}{n_t + 0.5} + 1
\]</span></p>
<p>where <span class="math inline">\(N\)</span> is the total number of documents, and <span class="math inline">\(n_t\)</span> is the number of documents containing term <span class="math inline">\(t\)</span>.</p>
</section>
<section id="intuition-behind-the-formula" class="level4">
<h4 class="anchored" data-anchor-id="intuition-behind-the-formula">Intuition Behind the Formula</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Concept</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\text{idf}(t)\)</span></td>
<td>Rare terms get higher weight</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f(t, d)\)</span></td>
<td>Term frequency boosts relevance</td>
</tr>
<tr class="odd">
<td>Saturation term</td>
<td>Prevents frequent words from dominating</td>
</tr>
<tr class="even">
<td>Length normalization</td>
<td>Adjusts for longer documents</td>
</tr>
</tbody>
</table>
<p>When <span class="math inline">\(b = 0\)</span>, length normalization is disabled. When <span class="math inline">\(b = 1\)</span>, it fully normalizes by document length.</p>
</section>
<section id="example-65" class="level4">
<h4 class="anchored" data-anchor-id="example-65">Example</h4>
<p>Suppose:</p>
<ul>
<li><span class="math inline">\(N = 3\)</span>, <span class="math inline">\(\text{avgdl} = 5\)</span>, <span class="math inline">\(k_1 = 1.5\)</span>, <span class="math inline">\(b = 0.75\)</span></li>
<li>Query: <code>["data", "compression"]</code></li>
</ul>
<p>Documents:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>ID</th>
<th>Text</th>
<th>Length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>“data structures and algorithms”</td>
<td>4</td>
</tr>
<tr class="even">
<td>2</td>
<td>“algorithms for data compression”</td>
<td>4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>“data compression and encoding”</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Compute <span class="math inline">\(n_t\)</span>:</p>
<ul>
<li><span class="math inline">\(\text{data}\)</span> in 3 docs → <span class="math inline">\(n_{\text{data}} = 3\)</span></li>
<li><span class="math inline">\(\text{compression}\)</span> in 2 docs → <span class="math inline">\(n_{\text{compression}} = 2\)</span></li>
</ul>
<p>Then:</p>
<p><span class="math display">\[
\text{idf(data)} = \log\frac{3 - 3 + 0.5}{3 + 0.5} + 1 = 0.86
\]</span> <span class="math display">\[
\text{idf(compression)} = \log\frac{3 - 2 + 0.5}{2 + 0.5} + 1 = 1.22
\]</span></p>
<p>Each document gets a score depending on how many times these terms appear and their lengths. The one containing both “data” and “compression” (doc 3) will rank highest.</p>
</section>
<section id="tiny-code-python-implementation-5" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation-5">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb251"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bm25_score(query, docs, k1<span class="op">=</span><span class="fl">1.5</span>, b<span class="op">=</span><span class="fl">0.75</span>):</span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(docs)</span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a>    avgdl <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">len</span>(doc.split()) <span class="cf">for</span> doc <span class="kw">in</span> docs) <span class="op">/</span> N</span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> Counter()</span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> doc <span class="kw">in</span> docs:</span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> term <span class="kw">in</span> <span class="bu">set</span>(doc.split()):</span>
<span id="cb251-10"><a href="#cb251-10" aria-hidden="true" tabindex="-1"></a>            df[term] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb251-11"><a href="#cb251-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-12"><a href="#cb251-12" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> []</span>
<span id="cb251-13"><a href="#cb251-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> doc <span class="kw">in</span> docs:</span>
<span id="cb251-14"><a href="#cb251-14" aria-hidden="true" tabindex="-1"></a>        words <span class="op">=</span> doc.split()</span>
<span id="cb251-15"><a href="#cb251-15" aria-hidden="true" tabindex="-1"></a>        tf <span class="op">=</span> Counter(words)</span>
<span id="cb251-16"><a href="#cb251-16" aria-hidden="true" tabindex="-1"></a>        score <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb251-17"><a href="#cb251-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> term <span class="kw">in</span> query:</span>
<span id="cb251-18"><a href="#cb251-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> term <span class="kw">not</span> <span class="kw">in</span> tf:</span>
<span id="cb251-19"><a href="#cb251-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb251-20"><a href="#cb251-20" aria-hidden="true" tabindex="-1"></a>            idf <span class="op">=</span> math.log((N <span class="op">-</span> df[term] <span class="op">+</span> <span class="fl">0.5</span>) <span class="op">/</span> (df[term] <span class="op">+</span> <span class="fl">0.5</span>)) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb251-21"><a href="#cb251-21" aria-hidden="true" tabindex="-1"></a>            numerator <span class="op">=</span> tf[term] <span class="op">*</span> (k1 <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb251-22"><a href="#cb251-22" aria-hidden="true" tabindex="-1"></a>            denominator <span class="op">=</span> tf[term] <span class="op">+</span> k1 <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> b <span class="op">+</span> b <span class="op">*</span> <span class="bu">len</span>(words) <span class="op">/</span> avgdl)</span>
<span id="cb251-23"><a href="#cb251-23" aria-hidden="true" tabindex="-1"></a>            score <span class="op">+=</span> idf <span class="op">*</span> (numerator <span class="op">/</span> denominator)</span>
<span id="cb251-24"><a href="#cb251-24" aria-hidden="true" tabindex="-1"></a>        scores.append(score)</span>
<span id="cb251-25"><a href="#cb251-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> scores</span>
<span id="cb251-26"><a href="#cb251-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-27"><a href="#cb251-27" aria-hidden="true" tabindex="-1"></a>docs <span class="op">=</span> [</span>
<span id="cb251-28"><a href="#cb251-28" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data structures and algorithms"</span>,</span>
<span id="cb251-29"><a href="#cb251-29" aria-hidden="true" tabindex="-1"></a>    <span class="st">"algorithms for data compression"</span>,</span>
<span id="cb251-30"><a href="#cb251-30" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data compression and encoding"</span></span>
<span id="cb251-31"><a href="#cb251-31" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb251-32"><a href="#cb251-32" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> [<span class="st">"data"</span>, <span class="st">"compression"</span>]</span>
<span id="cb251-33"><a href="#cb251-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(bm25_score(query, docs))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output (approximate):</p>
<pre><code>$$0.86, 1.78, 2.10]</code></pre>
</section>
<section id="why-it-matters-93" class="level4">
<h4 class="anchored" data-anchor-id="why-it-matters-93">Why It Matters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 41%">
<col style="width: 58%">
</colgroup>
<thead>
<tr class="header">
<th>Advantage</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Improves TF–IDF</td>
<td>Models term saturation and document length</td>
</tr>
<tr class="even">
<td>Practical and robust</td>
<td>Works well across domains</td>
</tr>
<tr class="odd">
<td>Foundation of IR systems</td>
<td>Used in Lucene, Elasticsearch, Solr, and others</td>
</tr>
<tr class="even">
<td>Balances recall and precision</td>
<td>Retrieves both relevant and concise results</td>
</tr>
</tbody>
</table>
<p>BM25 is now the de facto standard for keyword-based ranking before vector embeddings.</p>
</section>
<section id="complexity-94" class="level4">
<h4 class="anchored" data-anchor-id="complexity-94">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 45%">
<col style="width: 10%">
<col style="width: 17%">
<col style="width: 1%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Time</th>
<th>Space</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compute IDF</td>
<td><span class="math inline">\(O(V)\)</span></td>
<td><span class="math inline">\(O(V)\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Score each doc</td>
<td><span class="math inline">\(O(                        | q      | \times N)\)</span></td>
<td>,</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Index lookup</td>
<td><span class="math inline">\(O(\log N)\)</span> per query term</td>
<td>,</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-94" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-94">Try It Yourself</h4>
<ol type="1">
<li>Experiment with different <span class="math inline">\(k_1\)</span> and <span class="math inline">\(b\)</span> values and observe ranking changes.</li>
<li>Add TF–IDF normalization and compare results.</li>
<li>Use a small corpus to visualize term contribution to scores.</li>
<li>Combine BM25 with inverted index retrieval for efficiency.</li>
<li>Extend to multi-term or weighted queries.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-61" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-61">A Gentle Proof (Why It Works)</h4>
<p>BM25 approximates a probabilistic retrieval model: it assumes that the likelihood of a document being relevant increases with term frequency, but saturates logarithmically as repetitions add diminishing information.</p>
<p>By adjusting for document length, it ensures that relevance reflects <em>content density</em>, not document size.</p>
<p>BM25 elegantly bridges probability and information theory — it’s TF–IDF, evolved for the real world of messy, uneven text.</p>
</section>
</section>
<section id="trie-index" class="level3">
<h3 class="anchored" data-anchor-id="trie-index">695 Trie Index</h3>
<p>A Trie Index (short for <em>retrieval tree</em>) is a prefix-based data structure used for fast word lookup, auto-completion, and prefix search. It’s especially powerful for dictionary storage, query suggestion, and full-text search systems where matching prefixes efficiently is essential.</p>
<section id="the-idea-6" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-6">The Idea</h4>
<p>A trie organizes words character by character in a tree form, where each path from the root to a terminal node represents one word.</p>
<p>Formally, a trie for a set of strings <span class="math inline">\(S = {s_1, s_2, \dots, s_n}\)</span> is a rooted tree such that:</p>
<ul>
<li>Each edge is labeled by a character.</li>
<li>The concatenation of labels along a path from the root to a terminal node equals one string <span class="math inline">\(s_i\)</span>.</li>
<li>Shared prefixes are stored only once.</li>
</ul>
</section>
<section id="example-66" class="level4">
<h4 class="anchored" data-anchor-id="example-66">Example</h4>
<p>Insert the words: <code>data</code>, <code>database</code>, <code>datum</code>, <code>dog</code></p>
<p>The trie structure looks like:</p>
<pre><code>(root)
 ├─ d
 │   ├─ a
 │   │   ├─ t
 │   │   │   ├─ a (✓)
 │   │   │   ├─ b → a → s → e (✓)
 │   │   │   └─ u → m (✓)
 │   └─ o → g (✓)</code></pre>
<p>✓ marks the end of a complete word.</p>
</section>
<section id="mathematical-view-1" class="level4">
<h4 class="anchored" data-anchor-id="mathematical-view-1">Mathematical View</h4>
<p>Let <span class="math inline">\(\Sigma\)</span> be the alphabet and <span class="math inline">\(n = |S|\)</span> the number of words. The total number of nodes in the trie is bounded by:</p>
<p><span class="math display">\[
O\left(\sum_{s \in S} |s|\right)
\]</span></p>
<p>Each search or insertion of a string of length <span class="math inline">\(m\)</span> takes time:</p>
<p><span class="math display">\[
O(m)
\]</span></p>
<p>— independent of the number of stored words.</p>
</section>
<section id="how-search-works" class="level4">
<h4 class="anchored" data-anchor-id="how-search-works">How Search Works</h4>
<p>To check if a word exists:</p>
<ol type="1">
<li>Start at the root.</li>
<li>Follow the edge for each successive character.</li>
<li>If you reach a node marked “end of word”, the word exists.</li>
</ol>
<p>To find all words with prefix <code>"dat"</code>:</p>
<ol type="1">
<li>Traverse <code>"d" → "a" → "t"</code>.</li>
<li>Collect all descendants of that node recursively.</li>
</ol>
</section>
<section id="tiny-code-python-implementation-6" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation-6">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb254"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TrieNode:</span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> {}</span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.is_end <span class="op">=</span> <span class="va">False</span></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Trie:</span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> TrieNode()</span>
<span id="cb254-9"><a href="#cb254-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-10"><a href="#cb254-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> insert(<span class="va">self</span>, word):</span>
<span id="cb254-11"><a href="#cb254-11" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb254-12"><a href="#cb254-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb254-13"><a href="#cb254-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> node.children:</span>
<span id="cb254-14"><a href="#cb254-14" aria-hidden="true" tabindex="-1"></a>                node.children[ch] <span class="op">=</span> TrieNode()</span>
<span id="cb254-15"><a href="#cb254-15" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.children[ch]</span>
<span id="cb254-16"><a href="#cb254-16" aria-hidden="true" tabindex="-1"></a>        node.is_end <span class="op">=</span> <span class="va">True</span></span>
<span id="cb254-17"><a href="#cb254-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-18"><a href="#cb254-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> search(<span class="va">self</span>, word):</span>
<span id="cb254-19"><a href="#cb254-19" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb254-20"><a href="#cb254-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> word:</span>
<span id="cb254-21"><a href="#cb254-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> node.children:</span>
<span id="cb254-22"><a href="#cb254-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb254-23"><a href="#cb254-23" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.children[ch]</span>
<span id="cb254-24"><a href="#cb254-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node.is_end</span>
<span id="cb254-25"><a href="#cb254-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-26"><a href="#cb254-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> starts_with(<span class="va">self</span>, prefix):</span>
<span id="cb254-27"><a href="#cb254-27" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb254-28"><a href="#cb254-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> prefix:</span>
<span id="cb254-29"><a href="#cb254-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ch <span class="kw">not</span> <span class="kw">in</span> node.children:</span>
<span id="cb254-30"><a href="#cb254-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> []</span>
<span id="cb254-31"><a href="#cb254-31" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.children[ch]</span>
<span id="cb254-32"><a href="#cb254-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._collect(node, prefix)</span>
<span id="cb254-33"><a href="#cb254-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-34"><a href="#cb254-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _collect(<span class="va">self</span>, node, prefix):</span>
<span id="cb254-35"><a href="#cb254-35" aria-hidden="true" tabindex="-1"></a>        words <span class="op">=</span> []</span>
<span id="cb254-36"><a href="#cb254-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.is_end:</span>
<span id="cb254-37"><a href="#cb254-37" aria-hidden="true" tabindex="-1"></a>            words.append(prefix)</span>
<span id="cb254-38"><a href="#cb254-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch, child <span class="kw">in</span> node.children.items():</span>
<span id="cb254-39"><a href="#cb254-39" aria-hidden="true" tabindex="-1"></a>            words.extend(<span class="va">self</span>._collect(child, prefix <span class="op">+</span> ch))</span>
<span id="cb254-40"><a href="#cb254-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> words</span>
<span id="cb254-41"><a href="#cb254-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-42"><a href="#cb254-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb254-43"><a href="#cb254-43" aria-hidden="true" tabindex="-1"></a>trie <span class="op">=</span> Trie()</span>
<span id="cb254-44"><a href="#cb254-44" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word <span class="kw">in</span> [<span class="st">"data"</span>, <span class="st">"database"</span>, <span class="st">"datum"</span>, <span class="st">"dog"</span>]:</span>
<span id="cb254-45"><a href="#cb254-45" aria-hidden="true" tabindex="-1"></a>    trie.insert(word)</span>
<span id="cb254-46"><a href="#cb254-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-47"><a href="#cb254-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(trie.search(<span class="st">"data"</span>))       <span class="co"># True</span></span>
<span id="cb254-48"><a href="#cb254-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(trie.starts_with(<span class="st">"dat"</span>))   <span class="co"># ['data', 'database', 'datum']</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="variations" class="level4">
<h4 class="anchored" data-anchor-id="variations">Variations</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>Variant</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Compressed Trie (Radix Tree)</td>
<td>Merges chains of single children for compactness</td>
</tr>
<tr class="even">
<td>Suffix Trie</td>
<td>Stores all suffixes for substring search</td>
</tr>
<tr class="odd">
<td>Patricia Trie</td>
<td>Bitwise trie used in networking (IP routing)</td>
</tr>
<tr class="even">
<td>DAWG</td>
<td>Deduplicated trie for all substrings</td>
</tr>
<tr class="odd">
<td>Trie + Hashing</td>
<td>Hybrid used in modern search indexes</td>
</tr>
</tbody>
</table>
</section>
<section id="applications-1" class="level4">
<h4 class="anchored" data-anchor-id="applications-1">Applications</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Use Case</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Autocomplete</td>
<td>Suggest next words based on prefix</td>
</tr>
<tr class="even">
<td>Spell checking</td>
<td>Lookup closest valid words</td>
</tr>
<tr class="odd">
<td>Dictionary compression</td>
<td>Store large lexicons efficiently</td>
</tr>
<tr class="even">
<td>Search engines</td>
<td>Fast prefix and wildcard query support</td>
</tr>
<tr class="odd">
<td>Routing tables</td>
<td>IP prefix matching via Patricia trie</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-95" class="level4">
<h4 class="anchored" data-anchor-id="complexity-95">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert word</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(m)\)</span></td>
</tr>
<tr class="even">
<td>Search word</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Prefix query</td>
<td><span class="math inline">\(O(m + k)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>where:</p>
<ul>
<li><span class="math inline">\(m\)</span> = word length</li>
<li><span class="math inline">\(k\)</span> = number of results returned</li>
</ul>
<p>Space can be large if many words share few prefixes, but compression (Radix / DAWG) reduces overhead.</p>
</section>
<section id="try-it-yourself-95" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-95">Try It Yourself</h4>
<ol type="1">
<li>Build a trie for all words in a text corpus and query by prefix.</li>
<li>Extend it to support wildcard matching (<code>d?t*</code>).</li>
<li>Add frequency counts at nodes to rank autocomplete suggestions.</li>
<li>Visualize prefix sharing across words.</li>
<li>Compare space usage vs a hash-based dictionary.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-62" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-62">A Gentle Proof (Why It Works)</h4>
<p>A trie transforms string comparison from linear search over words to character traversal — replacing many string comparisons with a single prefix walk. The prefix paths ensure <span class="math inline">\(O(m)\)</span> search cost, a fundamental speedup when large sets share overlapping beginnings.</p>
<p>A Trie Index is the simplest glimpse of structure inside language — where shared prefixes reveal both efficiency and meaning.</p>
</section>
</section>
<section id="suffix-array-index" class="level3">
<h3 class="anchored" data-anchor-id="suffix-array-index">696 Suffix Array Index</h3>
<p>A Suffix Array Index is a compact data structure for fast substring search. It stores all suffixes of a text in sorted order, allowing binary search–based lookups for any substring pattern. Unlike suffix trees, suffix arrays are space-efficient, simple to implement, and widely used in text search, bioinformatics, and data compression.</p>
<section id="the-idea-7" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-7">The Idea</h4>
<p>Given a string <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span>, consider all its suffixes:</p>
<p><span class="math display">\[
S_1 = S[1:n], \quad S_2 = S[2:n], \quad \dots, \quad S_n = S[n:n]
\]</span></p>
<p>A suffix array is an array of integers that gives the starting indices of these suffixes in lexicographic order.</p>
<p>Formally:</p>
<p><span class="math display">\[
\text{SA}[i] = \text{the starting position of the } i^\text{th} \text{ smallest suffix}
\]</span></p>
</section>
<section id="example-67" class="level4">
<h4 class="anchored" data-anchor-id="example-67">Example</h4>
<p>Let <span class="math inline">\(S = \text{"banana"}\)</span>.</p>
<p>All suffixes:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Index</th>
<th>Suffix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>banana</td>
</tr>
<tr class="even">
<td>1</td>
<td>anana</td>
</tr>
<tr class="odd">
<td>2</td>
<td>nana</td>
</tr>
<tr class="even">
<td>3</td>
<td>ana</td>
</tr>
<tr class="odd">
<td>4</td>
<td>na</td>
</tr>
<tr class="even">
<td>5</td>
<td>a</td>
</tr>
</tbody>
</table>
<p>Sort them lexicographically:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Rank</th>
<th>Suffix</th>
<th>Start</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>a</td>
<td>5</td>
</tr>
<tr class="even">
<td>1</td>
<td>ana</td>
<td>3</td>
</tr>
<tr class="odd">
<td>2</td>
<td>anana</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>banana</td>
<td>0</td>
</tr>
<tr class="odd">
<td>4</td>
<td>na</td>
<td>4</td>
</tr>
<tr class="even">
<td>5</td>
<td>nana</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Hence the suffix array:</p>
<p><span class="math display">\[
\text{SA} = [5, 3, 1, 0, 4, 2]
\]</span></p>
</section>
<section id="substring-search-using-sa" class="level4">
<h4 class="anchored" data-anchor-id="substring-search-using-sa">Substring Search Using SA</h4>
<p>To find all occurrences of pattern <span class="math inline">\(P\)</span> in <span class="math inline">\(S\)</span>:</p>
<ol type="1">
<li>Binary search for the lexicographic lower bound of <span class="math inline">\(P\)</span>.</li>
<li>Binary search for the upper bound of <span class="math inline">\(P\)</span>.</li>
<li>The matching suffixes are between these indices.</li>
</ol>
<p>Each comparison takes <span class="math inline">\(O(m)\)</span> for pattern length <span class="math inline">\(m\)</span>, and the binary search takes <span class="math inline">\(O(\log n)\)</span> comparisons.</p>
<p>Total complexity: <span class="math inline">\(O(m \log n)\)</span>.</p>
</section>
<section id="example-search" class="level4">
<h4 class="anchored" data-anchor-id="example-search">Example Search</h4>
<p>Search for <code>"ana"</code> in <code>"banana"</code>.</p>
<ul>
<li><p>Binary search over suffixes:</p>
<ul>
<li>Compare <code>"ana"</code> with <code>"banana"</code>, <code>"anana"</code>, etc.</li>
</ul></li>
<li><p>Matches found at SA indices <code>[1, 3]</code>, corresponding to positions 1 and 3 in the text.</p></li>
</ul>
</section>
<section id="tiny-code-python-implementation-7" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-python-implementation-7">Tiny Code (Python Implementation)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb255"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_suffix_array(s):</span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(<span class="bu">range</span>(<span class="bu">len</span>(s)), key<span class="op">=</span><span class="kw">lambda</span> i: s[i:])</span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> suffix_array_search(s, sa, pattern):</span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a>    n, m <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(pattern)</span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a>    l, r <span class="op">=</span> <span class="dv">0</span>, n</span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> l <span class="op">&lt;</span> r:</span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> (l <span class="op">+</span> r) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[sa[mid]:sa[mid] <span class="op">+</span> m] <span class="op">&lt;</span> pattern:</span>
<span id="cb255-10"><a href="#cb255-10" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb255-11"><a href="#cb255-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb255-12"><a href="#cb255-12" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> mid</span>
<span id="cb255-13"><a href="#cb255-13" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> l</span>
<span id="cb255-14"><a href="#cb255-14" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> n</span>
<span id="cb255-15"><a href="#cb255-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> l <span class="op">&lt;</span> r:</span>
<span id="cb255-16"><a href="#cb255-16" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> (l <span class="op">+</span> r) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb255-17"><a href="#cb255-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[sa[mid]:sa[mid] <span class="op">+</span> m] <span class="op">&lt;=</span> pattern:</span>
<span id="cb255-18"><a href="#cb255-18" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb255-19"><a href="#cb255-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb255-20"><a href="#cb255-20" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> mid</span>
<span id="cb255-21"><a href="#cb255-21" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> l</span>
<span id="cb255-22"><a href="#cb255-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sa[start:end]</span>
<span id="cb255-23"><a href="#cb255-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-24"><a href="#cb255-24" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"banana"</span></span>
<span id="cb255-25"><a href="#cb255-25" aria-hidden="true" tabindex="-1"></a>sa <span class="op">=</span> build_suffix_array(text)</span>
<span id="cb255-26"><a href="#cb255-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sa)</span>
<span id="cb255-27"><a href="#cb255-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(suffix_array_search(text, sa, <span class="st">"ana"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>$$5, 3, 1, 0, 4, 2]
$$1, 3]</code></pre>
</section>
<section id="relationship-to-lcp-array" class="level4">
<h4 class="anchored" data-anchor-id="relationship-to-lcp-array">Relationship to LCP Array</h4>
<p>The LCP array (Longest Common Prefix) stores the lengths of common prefixes between consecutive suffixes in the sorted order:</p>
<p><span class="math display">\[
\text{LCP}[i] = \text{LCP}(S[\text{SA}[i]], S[\text{SA}[i-1]])
\]</span></p>
<p>This helps skip repeated comparisons during substring search or pattern matching.</p>
</section>
<section id="construction-algorithms" class="level4">
<h4 class="anchored" data-anchor-id="construction-algorithms">Construction Algorithms</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 21%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Complexity</th>
<th>Idea</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Naive sort</td>
<td><span class="math inline">\(O(n^2 \log n)\)</span></td>
<td>Sort suffixes directly</td>
</tr>
<tr class="even">
<td>Prefix-doubling</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td>Sort by 2^k-length prefixes</td>
</tr>
<tr class="odd">
<td>SA-IS</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>Induced sorting (used in modern systems)</td>
</tr>
</tbody>
</table>
</section>
<section id="applications-2" class="level4">
<h4 class="anchored" data-anchor-id="applications-2">Applications</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 59%">
</colgroup>
<thead>
<tr class="header">
<th>Area</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Text search</td>
<td>Fast substring lookup</td>
</tr>
<tr class="even">
<td>Data compression</td>
<td>Used in Burrows–Wheeler Transform (BWT)</td>
</tr>
<tr class="odd">
<td>Bioinformatics</td>
<td>Genome pattern search</td>
</tr>
<tr class="even">
<td>Plagiarism detection</td>
<td>Common substring discovery</td>
</tr>
<tr class="odd">
<td>Natural language processing</td>
<td>Phrase frequency and suffix clustering</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-96" class="level4">
<h4 class="anchored" data-anchor-id="complexity-96">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build suffix array (naive)</td>
<td><span class="math inline">\(O(n \log^2 n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Search substring</td>
<td><span class="math inline">\(O(m \log n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>With LCP optimization</td>
<td><span class="math inline">\(O(m + \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-96" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-96">Try It Yourself</h4>
<ol type="1">
<li>Build a suffix array for <code>"mississippi"</code>.</li>
<li>Search for <code>"iss"</code> and <code>"sip"</code> using binary search.</li>
<li>Compare performance with the naive substring search.</li>
<li>Visualize lexicographic order of suffixes.</li>
<li>Extend the index to support case-insensitive matching.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-63" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-63">A Gentle Proof (Why It Works)</h4>
<p>Suffix arrays rely on the lexicographic order of suffixes, which aligns perfectly with substring search: all substrings starting with a pattern form a contiguous block in sorted suffix order. Binary search efficiently locates this block, ensuring deterministic <span class="math inline">\(O(m \log n)\)</span> matching.</p>
<p>The Suffix Array Index is the minimalist sibling of the suffix tree — compact, elegant, and at the heart of fast search engines and genome analysis tools.</p>
</section>
</section>
<section id="compressed-suffix-array" class="level3">
<h3 class="anchored" data-anchor-id="compressed-suffix-array">697 Compressed Suffix Array</h3>
<p>A Compressed Suffix Array (CSA) is a space-efficient version of the classic suffix array. It preserves all the power of substring search while reducing memory usage from <span class="math inline">\(O(n \log n)\)</span> bits to near the information-theoretic limit, roughly the entropy of the text itself. CSAs are the backbone of compressed text indexes used in large-scale search and bioinformatics systems.</p>
<section id="the-idea-8" class="level4">
<h4 class="anchored" data-anchor-id="the-idea-8">The Idea</h4>
<p>A standard suffix array explicitly stores sorted suffix indices. A compressed suffix array replaces that explicit array with a compact, self-indexed representation, allowing:</p>
<ul>
<li>substring search without storing the original text, and</li>
<li>access to suffix array positions using compressed data structures.</li>
</ul>
<p>Formally, a CSA supports three key operations in time <span class="math inline">\(O(\log n)\)</span> or better:</p>
<ol type="1">
<li><code>find(P)</code> – find all occurrences of pattern <span class="math inline">\(P\)</span> in <span class="math inline">\(S\)</span></li>
<li><code>locate(i)</code> – recover the position in the text for suffix array index <span class="math inline">\(i\)</span></li>
<li><code>extract(l, r)</code> – retrieve substring <span class="math inline">\(S[l:r]\)</span> directly from the index</li>
</ol>
</section>
<section id="key-components" class="level4">
<h4 class="anchored" data-anchor-id="key-components">Key Components</h4>
<p>A compressed suffix array uses several coordinated structures:</p>
<ol type="1">
<li><p>Burrows–Wheeler Transform (BWT) Rearranges <span class="math inline">\(S\)</span> to cluster similar characters. Enables efficient backward searching.</p></li>
<li><p>Rank/Select Data Structures Allow counting and locating characters within BWT efficiently.</p></li>
<li><p>Sampling Periodically store full suffix positions; reconstruct others by walking backward through BWT.</p></li>
</ol>
</section>
<section id="construction-sketch" class="level4">
<h4 class="anchored" data-anchor-id="construction-sketch">Construction Sketch</h4>
<p>Given text <span class="math inline">\(S\)</span> of length <span class="math inline">\(n\)</span> (ending with a unique terminator <code>$</code>):</p>
<ol type="1">
<li><p>Build suffix array <span class="math inline">\(\text{SA}\)</span> for <span class="math inline">\(S\)</span>.</p></li>
<li><p>Derive Burrows–Wheeler Transform:</p></li>
</ol>
<p><span class="math display">\[
\text{BWT}[i] =
\begin{cases}
S[\text{SA}[i] - 1], &amp; \text{if } \text{SA}[i] &gt; 0,\\[4pt]
\text{\$}, &amp; \text{if } \text{SA}[i] = 0.
\end{cases}
\]</span></p>
<ol start="3" type="1">
<li><p>Compute the C array, where <span class="math inline">\(C[c]\)</span> = number of characters in <span class="math inline">\(S\)</span> smaller than <span class="math inline">\(c\)</span>.</p></li>
<li><p>Store rank structures over BWT for fast character counting.</p></li>
<li><p>Keep samples of <span class="math inline">\(\text{SA}[i]\)</span> at fixed intervals (e.g., every <span class="math inline">\(t\)</span> entries).</p></li>
</ol>
</section>
<section id="backward-search-pattern-matching" class="level4">
<h4 class="anchored" data-anchor-id="backward-search-pattern-matching">Backward Search (Pattern Matching)</h4>
<p>The pattern <span class="math inline">\(P = p_1 p_2 \dots p_m\)</span> is searched <em>backward</em>:</p>
<p>Initialize: <span class="math display">\[
l = 0, \quad r = n - 1
\]</span></p>
<p>For each character <span class="math inline">\(p_i\)</span> from last to first:</p>
<p><span class="math display">\[
l = C[p_i] + \text{rank}(p_i, l - 1) + 1
\]</span> <span class="math display">\[
r = C[p_i] + \text{rank}(p_i, r)
\]</span></p>
<p>When <span class="math inline">\(l &gt; r\)</span>, no match exists. Otherwise, all occurrences of <span class="math inline">\(P\)</span> are between <span class="math inline">\(\text{SA}[l]\)</span> and <span class="math inline">\(\text{SA}[r]\)</span> (reconstructed via sampling).</p>
</section>
<section id="example-68" class="level4">
<h4 class="anchored" data-anchor-id="example-68">Example</h4>
<p>Let <span class="math inline">\(S=\texttt{"banana\textdollar"}\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(\text{SA} = [6,\,5,\,3,\,1,\,0,\,4,\,2]\)</span></li>
<li><span class="math inline">\(\text{BWT} = [a,\, n,\, n,\, b,\, \textdollar,\, a,\, a]\)</span></li>
<li><span class="math inline">\(C = \{\textdollar\!:0,\, a\!:\!1,\, b\!:\!3,\, n\!:\!4\}\)</span></li>
</ol>
<p>Search for <span class="math inline">\(P=\texttt{"ana"}\)</span> backward:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>char</th>
<th>new <span class="math inline">\([l,r]\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>init</td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td><span class="math inline">\([0,6]\)</span></td>
</tr>
<tr class="even">
<td>1</td>
<td><span class="math inline">\(a\)</span></td>
<td><span class="math inline">\([1,3]\)</span></td>
</tr>
<tr class="odd">
<td>2</td>
<td><span class="math inline">\(n\)</span></td>
<td><span class="math inline">\([4,5]\)</span></td>
</tr>
<tr class="even">
<td>3</td>
<td><span class="math inline">\(a\)</span></td>
<td><span class="math inline">\([2,3]\)</span></td>
</tr>
</tbody>
</table>
<p>Result: matches at <span class="math inline">\(\text{SA}[2]\)</span> and <span class="math inline">\(\text{SA}[3]\)</span> which are positions <span class="math inline">\(1\)</span> and <span class="math inline">\(3\)</span> in <span class="math inline">\(\texttt{"banana"}\)</span>.</p>
</section>
<section id="tiny-code-simplified-python-prototype" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-python-prototype">Tiny Code (Simplified Python Prototype)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb257"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> bisect_left, bisect_right</span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> suffix_array(s):</span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(<span class="bu">range</span>(<span class="bu">len</span>(s)), key<span class="op">=</span><span class="kw">lambda</span> i: s[i:])</span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bwt_from_sa(s, sa):</span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">''</span>.join(s[i <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> i <span class="cf">else</span> <span class="st">'$'</span> <span class="cf">for</span> i <span class="kw">in</span> sa)</span>
<span id="cb257-8"><a href="#cb257-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-9"><a href="#cb257-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search_bwt(bwt, pattern, sa, s):</span>
<span id="cb257-10"><a href="#cb257-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># naive backward search using bisect</span></span>
<span id="cb257-11"><a href="#cb257-11" aria-hidden="true" tabindex="-1"></a>    suffixes <span class="op">=</span> [s[i:] <span class="cf">for</span> i <span class="kw">in</span> sa]</span>
<span id="cb257-12"><a href="#cb257-12" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> bisect_left(suffixes, pattern)</span>
<span id="cb257-13"><a href="#cb257-13" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> bisect_right(suffixes, pattern)</span>
<span id="cb257-14"><a href="#cb257-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sa[l:r]</span>
<span id="cb257-15"><a href="#cb257-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-16"><a href="#cb257-16" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">"banana$"</span></span>
<span id="cb257-17"><a href="#cb257-17" aria-hidden="true" tabindex="-1"></a>sa <span class="op">=</span> suffix_array(s)</span>
<span id="cb257-18"><a href="#cb257-18" aria-hidden="true" tabindex="-1"></a>bwt <span class="op">=</span> bwt_from_sa(s, sa)</span>
<span id="cb257-19"><a href="#cb257-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SA:"</span>, sa)</span>
<span id="cb257-20"><a href="#cb257-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"BWT:"</span>, bwt)</span>
<span id="cb257-21"><a href="#cb257-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Match:"</span>, search_bwt(bwt, <span class="st">"ana"</span>, sa, s))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>SA: [6, 5, 3, 1, 0, 4, 2]
BWT: annb$aa
Match: [1, 3]</code></pre>
<p><em>(This is an uncompressed version, real CSAs replace the arrays with bit-packed rank/select structures.)</em></p>
</section>
<section id="compression-techniques" class="level4">
<h4 class="anchored" data-anchor-id="compression-techniques">Compression Techniques</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>Technique</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Wavelet Tree</td>
<td>Encodes BWT using hierarchical bitmaps</td>
</tr>
<tr class="even">
<td>Run-Length BWT (RLBWT)</td>
<td>Compresses repeated runs in BWT</td>
</tr>
<tr class="odd">
<td>Sampling</td>
<td>Store only every <span class="math inline">\(t\)</span>-th suffix; recover others via LF-mapping</td>
</tr>
<tr class="even">
<td>Bitvectors with Rank/Select</td>
<td>Enable constant-time navigation without decompression</td>
</tr>
</tbody>
</table>
</section>
<section id="applications-3" class="level4">
<h4 class="anchored" data-anchor-id="applications-3">Applications</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Field</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search engines</td>
<td>Full-text search over compressed corpora</td>
</tr>
<tr class="even">
<td>Bioinformatics</td>
<td>Genome alignment (FM-index in Bowtie, BWA)</td>
</tr>
<tr class="odd">
<td>Data compression</td>
<td>Core of self-indexing compressors</td>
</tr>
<tr class="even">
<td>Versioned storage</td>
<td>Deduplicated document storage</td>
</tr>
</tbody>
</table>
</section>
<section id="complexity-97" class="level4">
<h4 class="anchored" data-anchor-id="complexity-97">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 27%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search</td>
<td><span class="math inline">\(O(m \log \sigma)\)</span></td>
<td><span class="math inline">\((1 + \epsilon) n H_k(S)\)</span> bits</td>
</tr>
<tr class="even">
<td>Locate</td>
<td><span class="math inline">\(O(t \log \sigma)\)</span></td>
<td><span class="math inline">\(O(n / t)\)</span> sampled entries</td>
</tr>
<tr class="odd">
<td>Extract substring</td>
<td><span class="math inline">\(O(\ell + \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span> compressed structure</td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(H_k(S)\)</span> is the <span class="math inline">\(k\)</span>-th order entropy of the text and <span class="math inline">\(\sigma\)</span> is alphabet size.</p>
</section>
<section id="try-it-yourself-97" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-97">Try It Yourself</h4>
<ol type="1">
<li>Build the suffix array and BWT for <code>"mississippi$"</code>.</li>
<li>Perform backward search for <code>"issi"</code>.</li>
<li>Compare memory usage vs uncompressed suffix array.</li>
<li>Implement LF-mapping for substring extraction.</li>
<li>Explore run-length encoding of BWT for repetitive text.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-64" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-64">A Gentle Proof (Why It Works)</h4>
<p>The compressed suffix array relies on the BWT’s local clustering — nearby characters in the text are grouped, reducing entropy. By maintaining rank/select structures over BWT, we can simulate suffix array navigation <em>without explicitly storing it</em>. Thus, compression and indexing coexist in one elegant framework.</p>
<p>A Compressed Suffix Array turns the suffix array into a self-indexing structure — the text, the index, and the compression all become one and the same.</p>
</section>
</section>
<section id="fm-index" class="level3">
<h3 class="anchored" data-anchor-id="fm-index">698 FM-Index</h3>
<p>The FM-Index is a powerful, compressed full-text index that combines the Burrows–Wheeler Transform (BWT), rank/select bit operations, and sampling to support fast substring search without storing the original text. It achieves this while using space close to the entropy of the text, a key milestone in succinct data structures and modern search systems.</p>
<section id="the-core-idea-23" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-23">The Core Idea</h4>
<p>The FM-Index is a practical realization of the Compressed Suffix Array (CSA). It allows searching a pattern <span class="math inline">\(P\)</span> within a text <span class="math inline">\(S\)</span> in <span class="math inline">\(O(m)\)</span> time (for pattern length <span class="math inline">\(m\)</span>) and uses space proportional to the compressed size of <span class="math inline">\(S\)</span>.</p>
<p>It relies on the Burrows–Wheeler Transform (BWT) of <span class="math inline">\(S\)</span>, which rearranges the text into a form that groups similar contexts, enabling efficient backward navigation.</p>
</section>
<section id="burrowswheeler-transform-bwt-recap" class="level4">
<h4 class="anchored" data-anchor-id="burrowswheeler-transform-bwt-recap">Burrows–Wheeler Transform (BWT) Recap</h4>
<p>Given text <span class="math inline">\(S\)</span> ending with a unique terminator ($), the BWT is defined as:</p>
<p><span class="math display">\[
\text{BWT}[i] =
\begin{cases}
S[\text{SA}[i]-1], &amp; \text{if } \text{SA}[i] &gt; 0,\\
\text{\$}, &amp; \text{if } \text{SA}[i] = 0.
\end{cases}
\]</span></p>
<p>For <span class="math inline">\(S=\texttt{"banana\textdollar"}\)</span>, the suffix array is: <span class="math display">\[
\text{SA} = [6,\,5,\,3,\,1,\,0,\,4,\,2].
\]</span></p>
<p>and the BWT string becomes: <span class="math display">\[
\text{BWT} = \texttt{"annb\textdollar{}aa"}.
\]</span></p>
</section>
<section id="key-components-1" class="level4">
<h4 class="anchored" data-anchor-id="key-components-1">Key Components</h4>
<ol type="1">
<li>BWT String: The transformed text.</li>
<li>C array: For each character <span class="math inline">\(c\)</span>, <span class="math inline">\(C[c]\)</span> = number of characters in <span class="math inline">\(S\)</span> lexicographically smaller than <span class="math inline">\(c\)</span>.</li>
<li>Rank Structure: Supports <span class="math inline">\(\text{rank}(c, i)\)</span>, number of occurrences of <span class="math inline">\(c\)</span> in <span class="math inline">\(\text{BWT}[0:i]\)</span>.</li>
<li>Sampling Array: Periodically stores suffix array values for recovery of original positions.</li>
</ol>
</section>
<section id="backward-search-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="backward-search-algorithm">Backward Search Algorithm</h4>
<p>The fundamental operation of the FM-Index is backward search. It processes the pattern <span class="math inline">\(P = p_1 p_2 \dots p_m\)</span> from right to left and maintains a range <span class="math inline">\([l, r]\)</span> in the suffix array such that all suffixes starting with <span class="math inline">\(P[i:m]\)</span> fall within it.</p>
<p>Initialize: <span class="math display">\[
l = 0, \quad r = n - 1
\]</span></p>
<p>Then for <span class="math inline">\(i = m, m-1, \dots, 1\)</span>:</p>
<p><span class="math display">\[
l = C[p_i] + \text{rank}(p_i, l - 1) + 1
\]</span></p>
<p><span class="math display">\[
r = C[p_i] + \text{rank}(p_i, r)
\]</span></p>
<p>When <span class="math inline">\(l &gt; r\)</span>, no match exists. Otherwise, all occurrences of <span class="math inline">\(P\)</span> are found between <span class="math inline">\(\text{SA}[l]\)</span> and <span class="math inline">\(\text{SA}[r]\)</span>.</p>
</section>
<section id="example-search-in-banana" class="level4">
<h4 class="anchored" data-anchor-id="example-search-in-banana">Example: Search in “banana$”</h4>
<p>Text <span class="math inline">\(S = \text{"banana\$"}\)</span> BWT = <code>annb$aa</code> C = {<span class="math inline">\(:0\)</span>, a:1, b:3, n:4}</p>
<p>Pattern <span class="math inline">\(P = \text{"ana"}\)</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Step</th>
<th>Char</th>
<th><span class="math inline">\([l, r]\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Init</td>
<td>,</td>
<td>[0, 6]</td>
</tr>
<tr class="even">
<td>a</td>
<td>[1, 3]</td>
<td></td>
</tr>
<tr class="odd">
<td>n</td>
<td>[4, 5]</td>
<td></td>
</tr>
<tr class="even">
<td>a</td>
<td>[2, 3]</td>
<td></td>
</tr>
</tbody>
</table>
<p>Match found at SA[2] = 1 and SA[3] = 3 → positions 1 and 3 in the original text.</p>
</section>
<section id="tiny-code-simplified-prototype" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified-prototype">Tiny Code (Simplified Prototype)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb259"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bwt_transform(s):</span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="st">"$"</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a>    table <span class="op">=</span> <span class="bu">sorted</span>(s[i:] <span class="op">+</span> s[:i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)))</span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">""</span>.join(row[<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> row <span class="kw">in</span> table)</span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_c_array(bwt):</span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true" tabindex="-1"></a>    chars <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">set</span>(bwt))</span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> {}</span>
<span id="cb259-10"><a href="#cb259-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> chars:</span>
<span id="cb259-11"><a href="#cb259-11" aria-hidden="true" tabindex="-1"></a>        C[c] <span class="op">=</span> count</span>
<span id="cb259-12"><a href="#cb259-12" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> bwt.count(c)</span>
<span id="cb259-13"><a href="#cb259-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> C</span>
<span id="cb259-14"><a href="#cb259-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-15"><a href="#cb259-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rank(bwt, c, i):</span>
<span id="cb259-16"><a href="#cb259-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> bwt[:i <span class="op">+</span> <span class="dv">1</span>].count(c)</span>
<span id="cb259-17"><a href="#cb259-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-18"><a href="#cb259-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backward_search(bwt, C, pattern):</span>
<span id="cb259-19"><a href="#cb259-19" aria-hidden="true" tabindex="-1"></a>    l, r <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(bwt) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb259-20"><a href="#cb259-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch <span class="kw">in</span> <span class="bu">reversed</span>(pattern):</span>
<span id="cb259-21"><a href="#cb259-21" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> C[ch] <span class="op">+</span> rank(bwt, ch, l <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb259-22"><a href="#cb259-22" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> C[ch] <span class="op">+</span> rank(bwt, ch, r) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb259-23"><a href="#cb259-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> l <span class="op">&gt;</span> r:</span>
<span id="cb259-24"><a href="#cb259-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> []</span>
<span id="cb259-25"><a href="#cb259-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">range</span>(l, r <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb259-26"><a href="#cb259-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-27"><a href="#cb259-27" aria-hidden="true" tabindex="-1"></a>bwt <span class="op">=</span> bwt_transform(<span class="st">"banana"</span>)</span>
<span id="cb259-28"><a href="#cb259-28" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> build_c_array(bwt)</span>
<span id="cb259-29"><a href="#cb259-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"BWT:"</span>, bwt)</span>
<span id="cb259-30"><a href="#cb259-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Matches:"</span>, <span class="bu">list</span>(backward_search(bwt, C, <span class="st">"ana"</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>BWT: annb$aa
Matches: [2, 3]</code></pre>
</section>
<section id="accessing-text-positions" class="level4">
<h4 class="anchored" data-anchor-id="accessing-text-positions">Accessing Text Positions</h4>
<p>Because we don’t store the original suffix array, positions are recovered through LF-mapping (Last-to-First mapping):</p>
<p><span class="math display">\[
\text{LF}(i) = C[\text{BWT}[i]] + \text{rank}(\text{BWT}[i], i)
\]</span></p>
<p>Repeatedly applying LF-mapping moves backward through the text. Every <span class="math inline">\(t\)</span>-th suffix array value is stored explicitly for quick reconstruction.</p>
</section>
<section id="why-it-works-1" class="level4">
<h4 class="anchored" data-anchor-id="why-it-works-1">Why It Works</h4>
<p>The BWT clusters identical characters by context, so rank and prefix boundaries can efficiently reconstruct which parts of the text start with any given pattern.</p>
<p>Backward search turns the BWT into an implicit suffix array traversal — no explicit storage of the suffixes is needed.</p>
</section>
<section id="complexity-98" class="level4">
<h4 class="anchored" data-anchor-id="complexity-98">Complexity</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 26%">
<col style="width: 27%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pattern search</td>
<td><span class="math inline">\(O(m \log \sigma)\)</span></td>
<td><span class="math inline">\((1 + \epsilon) n H_k(S)\)</span> bits</td>
</tr>
<tr class="even">
<td>Locate</td>
<td><span class="math inline">\(O(t \log \sigma)\)</span></td>
<td><span class="math inline">\(O(n/t)\)</span> samples</td>
</tr>
<tr class="odd">
<td>Extract substring</td>
<td><span class="math inline">\(O(\ell + \log n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span> compressed</td>
</tr>
</tbody>
</table>
<p>Here <span class="math inline">\(\sigma\)</span> is alphabet size, and <span class="math inline">\(H_k(S)\)</span> is the <span class="math inline">\(k\)</span>-th order entropy of the text.</p>
</section>
<section id="applications-4" class="level4">
<h4 class="anchored" data-anchor-id="applications-4">Applications</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Search engines</td>
<td>Compressed text search with fast lookup</td>
</tr>
<tr class="even">
<td>Bioinformatics</td>
<td>Genome alignment (e.g., BWA, Bowtie, FM-mapper)</td>
</tr>
<tr class="odd">
<td>Data compression</td>
<td>Core of self-indexing compressed storage</td>
</tr>
<tr class="even">
<td>Version control</td>
<td>Deduplicated content retrieval</td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-98" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-98">Try It Yourself</h4>
<ol type="1">
<li>Compute the BWT for <code>"mississippi$"</code> and build its FM-Index.</li>
<li>Run backward search for <code>"issi"</code>.</li>
<li>Modify the algorithm to return document IDs for a multi-document corpus.</li>
<li>Add rank/select bitvectors to optimize counting.</li>
<li>Compare FM-Index vs raw suffix array in memory usage.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-65" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-65">A Gentle Proof (Why It Works)</h4>
<p>The FM-Index leverages the invertibility of the BWT and the monotonicity of lexicographic order. Backward search narrows the valid suffix range with each character, using rank/select to simulate suffix array traversal inside a compressed domain. Thus, text indexing becomes possible <em>without ever expanding the text</em>.</p>
<p>The FM-Index is the perfect marriage of compression and search — small enough to fit a genome, powerful enough to index the web.</p>
</section>
</section>
<section id="directed-acyclic-word-graph-dawg" class="level3">
<h3 class="anchored" data-anchor-id="directed-acyclic-word-graph-dawg">699 Directed Acyclic Word Graph (DAWG)</h3>
<p>A Directed Acyclic Word Graph (DAWG) is a compact data structure that represents all substrings or words of a given text or dictionary. It merges common suffixes or prefixes to reduce redundancy, forming a minimal deterministic finite automaton (DFA) for all suffixes of a string. DAWGs are essential in text indexing, pattern search, auto-completion, and dictionary compression.</p>
<section id="the-core-idea-24" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-24">The Core Idea</h4>
<p>A DAWG is essentially a suffix automaton or a minimal automaton that recognizes all substrings of a text. It can be built incrementally in linear time and space proportional to the text length.</p>
<p>Each state in the DAWG represents a set of end positions of substrings, and each edge is labeled by a character transition.</p>
<p>Key properties:</p>
<ul>
<li>Directed and acyclic (no loops except for transitions by characters)</li>
<li>Deterministic (no ambiguity in transitions)</li>
<li>Minimal (merges equivalent states)</li>
<li>Recognizes all substrings of the input string</li>
</ul>
</section>
<section id="example-69" class="level4">
<h4 class="anchored" data-anchor-id="example-69">Example</h4>
<p>Let’s build a DAWG for the string <code>"aba"</code>.</p>
<p>All substrings:</p>
<pre><code>a, b, ab, ba, aba</code></pre>
<p>The minimal automaton has:</p>
<ul>
<li>States for distinct substring contexts</li>
<li>Transitions labeled by <code>a</code>, <code>b</code></li>
<li>Merged common parts like shared suffixes <code>"a"</code> and <code>"ba"</code></li>
</ul>
<p>Resulting transitions:</p>
<pre><code>(0) --a--&gt; (1)
(1) --b--&gt; (2)
(2) --a--&gt; (3)
(1) --a--&gt; (3)   (via suffix merging)</code></pre>
</section>
<section id="suffix-automaton-connection" class="level4">
<h4 class="anchored" data-anchor-id="suffix-automaton-connection">Suffix Automaton Connection</h4>
<p>The DAWG for all substrings of a string is isomorphic to its suffix automaton. Each state in the suffix automaton represents one or more substrings that share the same set of right contexts.</p>
<p>Formally, the automaton accepts all substrings of a given text <span class="math inline">\(S\)</span> such that:</p>
<p><span class="math display">\[
L(A) = { S[i:j] \mid 0 \le i &lt; j \le |S| }
\]</span></p>
</section>
<section id="construction-algorithm-suffix-automaton-method" class="level4">
<h4 class="anchored" data-anchor-id="construction-algorithm-suffix-automaton-method">Construction Algorithm (Suffix Automaton Method)</h4>
<p>The DAWG can be built incrementally in <span class="math inline">\(O(n)\)</span> time using the suffix automaton algorithm.</p>
<p>Each step extends the automaton with the next character and updates transitions.</p>
<p>Algorithm sketch:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb263"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_dawg(s):</span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a>    sa <span class="op">=</span> [{}, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>]  <span class="co"># transitions, suffix link, length</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>    last <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch <span class="kw">in</span> s:</span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a>        cur <span class="op">=</span> <span class="bu">len</span>(sa) <span class="op">//</span> <span class="dv">3</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a>        sa <span class="op">+=</span> [{}, <span class="dv">0</span>, sa[<span class="dv">3</span><span class="op">*</span>last<span class="op">+</span><span class="dv">2</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> last</span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> p <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">and</span> ch <span class="kw">not</span> <span class="kw">in</span> sa[<span class="dv">3</span><span class="op">*</span>p]:</span>
<span id="cb263-9"><a href="#cb263-9" aria-hidden="true" tabindex="-1"></a>            sa[<span class="dv">3</span><span class="op">*</span>p][ch] <span class="op">=</span> cur</span>
<span id="cb263-10"><a href="#cb263-10" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> sa[<span class="dv">3</span><span class="op">*</span>p<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb263-11"><a href="#cb263-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb263-12"><a href="#cb263-12" aria-hidden="true" tabindex="-1"></a>            sa[<span class="dv">3</span><span class="op">*</span>cur<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb263-13"><a href="#cb263-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb263-14"><a href="#cb263-14" aria-hidden="true" tabindex="-1"></a>            q <span class="op">=</span> sa[<span class="dv">3</span><span class="op">*</span>p][ch]</span>
<span id="cb263-15"><a href="#cb263-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> sa[<span class="dv">3</span><span class="op">*</span>p<span class="op">+</span><span class="dv">2</span>] <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> sa[<span class="dv">3</span><span class="op">*</span>q<span class="op">+</span><span class="dv">2</span>]:</span>
<span id="cb263-16"><a href="#cb263-16" aria-hidden="true" tabindex="-1"></a>                sa[<span class="dv">3</span><span class="op">*</span>cur<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> q</span>
<span id="cb263-17"><a href="#cb263-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb263-18"><a href="#cb263-18" aria-hidden="true" tabindex="-1"></a>                clone <span class="op">=</span> <span class="bu">len</span>(sa) <span class="op">//</span> <span class="dv">3</span></span>
<span id="cb263-19"><a href="#cb263-19" aria-hidden="true" tabindex="-1"></a>                sa <span class="op">+=</span> [sa[<span class="dv">3</span><span class="op">*</span>q].copy(), sa[<span class="dv">3</span><span class="op">*</span>q<span class="op">+</span><span class="dv">1</span>], sa[<span class="dv">3</span><span class="op">*</span>p<span class="op">+</span><span class="dv">2</span>] <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb263-20"><a href="#cb263-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> p <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">and</span> sa[<span class="dv">3</span><span class="op">*</span>p].get(ch, <span class="va">None</span>) <span class="op">==</span> q:</span>
<span id="cb263-21"><a href="#cb263-21" aria-hidden="true" tabindex="-1"></a>                    sa[<span class="dv">3</span><span class="op">*</span>p][ch] <span class="op">=</span> clone</span>
<span id="cb263-22"><a href="#cb263-22" aria-hidden="true" tabindex="-1"></a>                    p <span class="op">=</span> sa[<span class="dv">3</span><span class="op">*</span>p<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb263-23"><a href="#cb263-23" aria-hidden="true" tabindex="-1"></a>                sa[<span class="dv">3</span><span class="op">*</span>q<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> sa[<span class="dv">3</span><span class="op">*</span>cur<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> clone</span>
<span id="cb263-24"><a href="#cb263-24" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> cur</span>
<span id="cb263-25"><a href="#cb263-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sa</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><em>(This is a compact suffix automaton builder, each node stores transitions and a suffix link.)</em></p>
</section>
<section id="properties" class="level4">
<h4 class="anchored" data-anchor-id="properties">Properties</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Deterministic</td>
<td>Each character transition is unique</td>
</tr>
<tr class="even">
<td>Acyclic</td>
<td>No cycles, except via transitions through the text</td>
</tr>
<tr class="odd">
<td>Compact</td>
<td>Merges equivalent suffix states</td>
</tr>
<tr class="even">
<td>Linear size</td>
<td>At most <span class="math inline">\(2n - 1\)</span> states and <span class="math inline">\(3n - 4\)</span> edges for text of length <span class="math inline">\(n\)</span></td>
</tr>
<tr class="odd">
<td>Incremental</td>
<td>Supports online building</td>
</tr>
</tbody>
</table>
</section>
<section id="visualization-example" class="level4">
<h4 class="anchored" data-anchor-id="visualization-example">Visualization Example</h4>
<p>For <code>"banana"</code>:</p>
<p>Each added letter expands the automaton:</p>
<ul>
<li>After <code>"b"</code> → states for <code>"b"</code></li>
<li>After <code>"ba"</code> → <code>"a"</code>, <code>"ba"</code></li>
<li>After <code>"ban"</code> → <code>"n"</code>, <code>"an"</code>, <code>"ban"</code></li>
<li>Common suffixes like <code>"ana"</code>, <code>"na"</code> get merged efficiently.</li>
</ul>
<p>The result compactly encodes all 21 substrings of <code>"banana"</code> with about 11 states.</p>
</section>
<section id="applications-5" class="level4">
<h4 class="anchored" data-anchor-id="applications-5">Applications</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 39%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>Domain</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Text indexing</td>
<td>Store all substrings for fast queries</td>
</tr>
<tr class="even">
<td>Dictionary compression</td>
<td>Merge common suffixes between words</td>
</tr>
<tr class="odd">
<td>Pattern matching</td>
<td>Test if a substring exists in <span class="math inline">\(O(m)\)</span> time</td>
</tr>
<tr class="even">
<td>Bioinformatics</td>
<td>Match gene subsequences</td>
</tr>
<tr class="odd">
<td>Natural language processing</td>
<td>Auto-complete and lexicon representation</td>
</tr>
</tbody>
</table>
</section>
<section id="search-using-dawg" class="level4">
<h4 class="anchored" data-anchor-id="search-using-dawg">Search Using DAWG</h4>
<p>To check if a pattern <span class="math inline">\(P\)</span> is a substring of <span class="math inline">\(S\)</span>:</p>
<pre><code>state = start
for c in P:
    if c not in transitions[state]:
        return False
    state = transitions[state][c]
return True</code></pre>
<p>Time complexity: <span class="math inline">\(O(m)\)</span>, where <span class="math inline">\(m\)</span> is length of <span class="math inline">\(P\)</span>.</p>
</section>
<section id="space-and-time-complexity" class="level4">
<h4 class="anchored" data-anchor-id="space-and-time-complexity">Space and Time Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Time</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Build</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td>Search substring</td>
<td><span class="math inline">\(O(m)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>Count distinct substrings</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="counting-distinct-substrings" class="level4">
<h4 class="anchored" data-anchor-id="counting-distinct-substrings">Counting Distinct Substrings</h4>
<p>Each DAWG (suffix automaton) state represents multiple substrings. The number of distinct substrings of a string <span class="math inline">\(S\)</span> is:</p>
<p><span class="math display">\[
\text{count} = \sum_{v} (\text{len}[v] - \text{len}[\text{link}[v]])
\]</span></p>
<p>Example for <code>"aba"</code>:</p>
<ul>
<li><span class="math inline">\(\text{count} = 5\)</span> → substrings: <code>"a"</code>, <code>"b"</code>, <code>"ab"</code>, <code>"ba"</code>, <code>"aba"</code></li>
</ul>
</section>
<section id="try-it-yourself-99" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-99">Try It Yourself</h4>
<ol type="1">
<li>Build a DAWG for <code>"banana"</code> and count all substrings.</li>
<li>Modify the algorithm to support multiple words (a dictionary DAWG).</li>
<li>Visualize merged transitions, how common suffixes save space.</li>
<li>Extend to support prefix queries for auto-completion.</li>
<li>Measure time to query all substrings of <code>"mississippi"</code>.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-66" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-66">A Gentle Proof (Why It Works)</h4>
<p>Merging equivalent suffix states preserves language equivalence — each state corresponds to a unique set of right contexts. Since every substring of <span class="math inline">\(S\)</span> appears as a path in the automaton, the DAWG encodes the entire substring set without redundancy. Minimality ensures no two states represent the same substring set.</p>
<p>The Directed Acyclic Word Graph is the most compact way to represent all substrings of a string — it is both elegant and efficient, standing at the crossroads of automata, compression, and search.</p>
</section>
</section>
<section id="wavelet-tree-for-text" class="level3">
<h3 class="anchored" data-anchor-id="wavelet-tree-for-text">700 Wavelet Tree for Text</h3>
<p>A Wavelet Tree is a succinct data structure that encodes a sequence of symbols while supporting rank, select, and access operations efficiently. In text indexing, it is used as the core component of compressed suffix arrays and FM-indexes, allowing substring queries, frequency counts, and positional lookups without decompressing the text.</p>
<section id="the-core-idea-25" class="level4">
<h4 class="anchored" data-anchor-id="the-core-idea-25">The Core Idea</h4>
<p>Given a text <span class="math inline">\(S\)</span> over an alphabet <span class="math inline">\(\Sigma\)</span>, a Wavelet Tree recursively partitions the alphabet and represents the text as a series of bitvectors indicating which half of the alphabet each symbol belongs to.</p>
<p>This allows hierarchical navigation through the text based on bits, enabling queries like:</p>
<ul>
<li><span class="math inline">\(\text{access}(i)\)</span>, what character is at position <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(\text{rank}(c, i)\)</span>, how many times <span class="math inline">\(c\)</span> occurs up to position <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(\text{select}(c, k)\)</span>, where the <span class="math inline">\(k\)</span>-th occurrence of <span class="math inline">\(c\)</span> appears</li>
</ul>
<p>All these are done in <span class="math inline">\(O(\log |\Sigma|)\)</span> time using compact bitvectors.</p>
</section>
<section id="construction-1" class="level4">
<h4 class="anchored" data-anchor-id="construction-1">Construction</h4>
<p>Suppose <span class="math inline">\(S = \text{"banana"}\)</span>, with alphabet <span class="math inline">\(\Sigma = {a, b, n}\)</span>.</p>
<ol type="1">
<li><p>Split alphabet: Left = {a}, Right = {b, n}</p></li>
<li><p>Build root bitvector: For each symbol in <span class="math inline">\(S\)</span>,</p>
<ul>
<li>write <code>0</code> if it belongs to Left,</li>
<li>write <code>1</code> if it belongs to Right.</li>
</ul>
<p>So:</p>
<pre><code>a b a n a n
↓ ↓ ↓ ↓ ↓ ↓
0 1 0 1 0 1</code></pre>
<p>Root bitvector = <code>010101</code></p></li>
<li><p>Recursively build subtrees:</p>
<ul>
<li>Left child handles <code>aaa</code> (positions of <code>0</code>s)</li>
<li>Right child handles <code>bnn</code> (positions of <code>1</code>s)</li>
</ul></li>
</ol>
<p>Each node corresponds to a subset of characters, and its bitvector encodes the mapping to child positions.</p>
</section>
<section id="example-query" class="level4">
<h4 class="anchored" data-anchor-id="example-query">Example Query</h4>
<p>Let’s find <span class="math inline">\(\text{rank}(\text{'n'}, 5)\)</span>, number of <code>'n'</code> in the first 5 characters of <code>"banana"</code>.</p>
<ol type="1">
<li><p>Start at root:</p>
<ul>
<li><code>'n'</code> is in Right half → follow bits <code>1</code>s</li>
<li>Count how many <code>1</code>s in first 5 bits of root (<code>01010</code>) → 2</li>
<li>Move to Right child with index 2</li>
</ul></li>
<li><p>In Right child:</p>
<ul>
<li>Alphabet {b, n}, <code>'n'</code> is in Right half again → follow <code>1</code>s</li>
<li>Bitvector of right child (<code>011</code>) → 2nd prefix has <code>1</code></li>
<li>Count how many <code>1</code>s in first 2 bits → 1</li>
</ul></li>
</ol>
<p>Answer: <code>'n'</code> appears once up to position 5.</p>
</section>
<section id="tiny-code-simplified" class="level4">
<h4 class="anchored" data-anchor-id="tiny-code-simplified">Tiny Code (Simplified)</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb266"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> WaveletTree:</span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, s, alphabet<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> alphabet <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a>            alphabet <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">set</span>(s))</span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(alphabet) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.symbol <span class="op">=</span> alphabet[<span class="dv">0</span>]</span>
<span id="cb266-7"><a href="#cb266-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.left <span class="op">=</span> <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb266-8"><a href="#cb266-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.bitvector <span class="op">=</span> <span class="va">None</span></span>
<span id="cb266-9"><a href="#cb266-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb266-10"><a href="#cb266-10" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> <span class="bu">len</span>(alphabet) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb266-11"><a href="#cb266-11" aria-hidden="true" tabindex="-1"></a>        left_set, right_set <span class="op">=</span> <span class="bu">set</span>(alphabet[:mid]), <span class="bu">set</span>(alphabet[mid:])</span>
<span id="cb266-12"><a href="#cb266-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bitvector <span class="op">=</span> [<span class="dv">0</span> <span class="cf">if</span> ch <span class="kw">in</span> left_set <span class="cf">else</span> <span class="dv">1</span> <span class="cf">for</span> ch <span class="kw">in</span> s]</span>
<span id="cb266-13"><a href="#cb266-13" aria-hidden="true" tabindex="-1"></a>        left_s <span class="op">=</span> [ch <span class="cf">for</span> ch <span class="kw">in</span> s <span class="cf">if</span> ch <span class="kw">in</span> left_set]</span>
<span id="cb266-14"><a href="#cb266-14" aria-hidden="true" tabindex="-1"></a>        right_s <span class="op">=</span> [ch <span class="cf">for</span> ch <span class="kw">in</span> s <span class="cf">if</span> ch <span class="kw">in</span> right_set]</span>
<span id="cb266-15"><a href="#cb266-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> WaveletTree(left_s, alphabet[:mid]) <span class="cf">if</span> left_s <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb266-16"><a href="#cb266-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> WaveletTree(right_s, alphabet[mid:]) <span class="cf">if</span> right_s <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb266-17"><a href="#cb266-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-18"><a href="#cb266-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rank(<span class="va">self</span>, c, i):</span>
<span id="cb266-19"><a href="#cb266-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.bitvector <span class="kw">or</span> i <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb266-20"><a href="#cb266-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb266-21"><a href="#cb266-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c <span class="op">==</span> <span class="bu">getattr</span>(<span class="va">self</span>, <span class="st">"symbol"</span>, <span class="va">None</span>):</span>
<span id="cb266-22"><a href="#cb266-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">min</span>(i, <span class="bu">len</span>(<span class="va">self</span>.bitvector))</span>
<span id="cb266-23"><a href="#cb266-23" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="dv">0</span> <span class="cf">if</span> c <span class="kw">in</span> <span class="bu">getattr</span>(<span class="va">self</span>.left, <span class="st">"alphabet"</span>, <span class="bu">set</span>()) <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb266-24"><a href="#cb266-24" aria-hidden="true" tabindex="-1"></a>        count <span class="op">=</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> b <span class="kw">in</span> <span class="va">self</span>.bitvector[:i] <span class="cf">if</span> b <span class="op">==</span> bit)</span>
<span id="cb266-25"><a href="#cb266-25" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> <span class="va">self</span>.left <span class="cf">if</span> bit <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">self</span>.right</span>
<span id="cb266-26"><a href="#cb266-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> child.rank(c, count) <span class="cf">if</span> child <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb266-27"><a href="#cb266-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-28"><a href="#cb266-28" aria-hidden="true" tabindex="-1"></a>wt <span class="op">=</span> WaveletTree(<span class="st">"banana"</span>)</span>
<span id="cb266-29"><a href="#cb266-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(wt.rank(<span class="st">'n'</span>, <span class="dv">5</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Output:</p>
<pre><code>1</code></pre>
</section>
<section id="visualization-1" class="level4">
<h4 class="anchored" data-anchor-id="visualization-1">Visualization</h4>
<pre><code>                [a,b,n]
                010101
              /        \
          [a]          [b,n]
                      011
                     /   \
                  [b]   [n]</code></pre>
<ul>
<li>Each level splits the alphabet range.</li>
<li>Traversing bits leads to the symbol’s leaf.</li>
</ul>
</section>
<section id="operations-summary" class="level4">
<h4 class="anchored" data-anchor-id="operations-summary">Operations Summary</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Operation</th>
<th>Meaning</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>access(i)</td>
<td>get <span class="math inline">\(S[i]\)</span></td>
<td><span class="math inline">\(O(\log \sigma)\)</span></td>
</tr>
<tr class="even">
<td>rank(c, i)</td>
<td># of c in <span class="math inline">\(S[1..i]\)</span></td>
<td><span class="math inline">\(O(\log \sigma)\)</span></td>
</tr>
<tr class="odd">
<td>select(c, k)</td>
<td>position of k-th c</td>
<td><span class="math inline">\(O(\log \sigma)\)</span></td>
</tr>
</tbody>
</table>
<p>Here <span class="math inline">\(\sigma = |\Sigma|\)</span> is alphabet size.</p>
</section>
<section id="integration-with-text-indexing" class="level4">
<h4 class="anchored" data-anchor-id="integration-with-text-indexing">Integration with Text Indexing</h4>
<p>Wavelet trees are integral to:</p>
<ul>
<li>FM-indexes, BWT rank/select operations</li>
<li>Compressed Suffix Arrays, fast access to character intervals</li>
<li>Document retrieval systems, word frequency and position queries</li>
<li>Bioinformatics tools, efficient pattern matching on genome data</li>
</ul>
<p>They allow random access over compressed text representations.</p>
</section>
<section id="complexity-99" class="level4">
<h4 class="anchored" data-anchor-id="complexity-99">Complexity</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Time per query</td>
<td><span class="math inline">\(O(\log \sigma)\)</span></td>
</tr>
<tr class="even">
<td>Space usage</td>
<td><span class="math inline">\(O(n \log \sigma)\)</span> bits (uncompressed)</td>
</tr>
<tr class="odd">
<td>Space (succinct)</td>
<td>close to <span class="math inline">\(n H_0(S)\)</span> bits</td>
</tr>
<tr class="even">
<td>Construction</td>
<td><span class="math inline">\(O(n \log \sigma)\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="try-it-yourself-100" class="level4">
<h4 class="anchored" data-anchor-id="try-it-yourself-100">Try It Yourself</h4>
<ol type="1">
<li>Build a wavelet tree for <code>"mississippi"</code>.</li>
<li>Query <span class="math inline">\(\text{rank}(\text{'s'}, 6)\)</span> and <span class="math inline">\(\text{select}(\text{'i'}, 3)\)</span>.</li>
<li>Extend it to support substring frequency queries.</li>
<li>Measure memory size versus a plain array.</li>
<li>Visualize the tree layers for each alphabet split.</li>
</ol>
</section>
<section id="a-gentle-proof-why-it-works-67" class="level4">
<h4 class="anchored" data-anchor-id="a-gentle-proof-why-it-works-67">A Gentle Proof (Why It Works)</h4>
<p>At each level, bits partition the alphabet into halves. Thus, rank and select operations translate into moving between levels, adjusting indices using prefix counts. Since the height of the tree is <span class="math inline">\(\log \sigma\)</span>, all queries finish in logarithmic time while maintaining perfect reversibility of data.</p>
<p>The Wavelet Tree unifies compression and search: it encodes, indexes, and queries text — all within the entropy limit of information itself.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../books/en-us/list-6.html" class="pagination-link" aria-label="Chapter 6. Mathematics for Algorithms">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Chapter 6. Mathematics for Algorithms</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../books/en-us/list-8.html" class="pagination-link" aria-label="Chapter 8. Geometry, Graphics and Spatial Algorithms">
        <span class="nav-page-text"><span class="chapter-title">Chapter 8. Geometry, Graphics and Spatial Algorithms</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>
% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={The Little Book of Algorithms},
  pdfauthor={Duc-Tam Nguyen},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{The Little Book of Algorithms}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Version 0.2.0}
\author{Duc-Tam Nguyen}
\date{2025-09-17}
\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter{Contents}\label{contents}

\subsubsection{Volume 1 --- What Is an
Algorithm?}\label{volume-1-what-is-an-algorithm}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Problems, procedures, and precision
\item
  Inputs, outputs, and assumptions
\item
  Deterministic vs.~nondeterministic steps
\item
  Decomposing big problems into small ones
\item
  Abstraction: hiding details to see structure
\item
  Representing data: numbers, text, and simple records
\item
  Correctness as a promise: pre/postconditions
\item
  Cost as effort: time, memory, and simplicity
\item
  Algorithms vs.~heuristics: when ``good enough'' wins
\item
  A tiny toolbox: three everyday recipes (sum, max, count)
\end{enumerate}

\subsubsection{Volume 2 --- Describing Algorithms
Clearly}\label{volume-2-describing-algorithms-clearly}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{10}
\tightlist
\item
  Pseudocode that reads like plain English
\item
  Flowcharts and step diagrams
\item
  Tracing by hand: dry runs on small examples
\item
  Input modeling: choose the right shape for data
\item
  Edge cases: empties, extremes, and errors
\item
  Step-invariants: what stays true while we work
\item
  Assertions and sanity checks
\item
  Naming things and writing clear steps
\item
  Turning pictures into procedures
\item
  From idea to draft algorithm
\end{enumerate}

\subsubsection{Volume 3 --- Reasoning About Cost (Complexity Without
Tears)}\label{volume-3-reasoning-about-cost-complexity-without-tears}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{20}
\tightlist
\item
  Constant time vs.~growing time
\item
  Counting simple loops
\item
  Nested loops as grids of work
\item
  Best, average, worst case thinking
\item
  Space cost and data copies
\item
  Big-O intuition (skip the calculus)
\item
  Practical performance vs.~asymptotics
\item
  Lower bounds as ``can't do better than''
\item
  Trade-offs: time vs.~space vs.~simplicity
\item
  Measuring in practice: micro-bench basics
\end{enumerate}

\subsubsection{Volume 4 --- Data Building Blocks I: Arrays, Lists,
Queues,
Stacks}\label{volume-4-data-building-blocks-i-arrays-lists-queues-stacks}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{30}
\tightlist
\item
  Arrays: indexed shelves
\item
  Traversal patterns and two-pointers
\item
  Dynamic arrays: growth and amortized cost
\item
  Linked lists: chains of nodes
\item
  Insert, delete, and search patterns
\item
  Stacks: undo, parse, and backtrack
\item
  Queues: first-in first-out thinking
\item
  Deques and circular buffers
\item
  Choosing between list and array
\item
  Real-world mini-projects (logs, history, task queues)
\end{enumerate}

\subsubsection{Volume 5 --- Data Building Blocks II: Trees, Hashes, and
Graphs
(Gentle)}\label{volume-5-data-building-blocks-ii-trees-hashes-and-graphs-gentle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{40}
\tightlist
\item
  Trees as nested boxes
\item
  Binary trees and traversal orders
\item
  Balanced vs.~unbalanced intuition
\item
  Hash tables: buckets from good mixing
\item
  Handling collisions: chaining and open addressing
\item
  Sets and maps as interfaces
\item
  Graphs as connections: nodes and edges
\item
  Adjacency lists vs.~matrices
\item
  Weighted, directed, and bipartite basics
\item
  Modeling real problems with graphs
\end{enumerate}

\subsubsection{Volume 6 --- Searching and Sorting
Fundamentals}\label{volume-6-searching-and-sorting-fundamentals}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{50}
\tightlist
\item
  Linear search and sentinel tricks
\item
  Binary search: halving the haystack
\item
  Sorting goals and stability
\item
  Selection: find min/max, kth element
\item
  Insertion sort: simple and local
\item
  Merge sort: split, sort, merge
\item
  Quick sort: partition and pivot
\item
  Counting and bucket sort: when keys are small
\item
  Practical mixtures and fallbacks
\item
  Where sorting shows up in life
\end{enumerate}

\subsubsection{Volume 7 --- Recursion \&
Divide-and-Conquer}\label{volume-7-recursion-divide-and-conquer}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{60}
\tightlist
\item
  The recursive mindset: self-reference safely
\item
  Base cases and progress measures
\item
  Visualizing call stacks
\item
  Classic examples (factorial, Fibonacci, binary search)
\item
  Divide-and-conquer pattern
\item
  Recurrence intuition (without heavy math)
\item
  Tail recursion and iteration conversion
\item
  Handling duplicates and boundaries cleanly
\item
  Debugging recursive code
\item
  Recursion in real tasks (parsing, image quadrants)
\end{enumerate}

\subsubsection{Volume 8 --- Greedy
Algorithms}\label{volume-8-greedy-algorithms}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{70}
\tightlist
\item
  What ``locally best'' means
\item
  Exchange arguments (why greedy can be right)
\item
  Interval scheduling and activity selection
\item
  Making change (when greedy works, when it fails)
\item
  Huffman coding intuition
\item
  Spanning trees with a greedy flavor
\item
  Greedy on graphs: pitfalls and patterns
\item
  Greedy vs.~dynamic programming: choose wisely
\item
  Counterexamples as teaching tools
\item
  Greedy checklists before you code
\end{enumerate}

\subsubsection{Volume 9 --- Dynamic Programming (DP) for
Humans}\label{volume-9-dynamic-programming-dp-for-humans}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{80}
\tightlist
\item
  Overlapping subproblems and optimal substructure
\item
  From recursion to memoization
\item
  Bottom-up tables and state diagrams
\item
  Longest common subsequence (LCS) story
\item
  Knapsack as choices on a grid
\item
  Path counting on grids with obstacles
\item
  Edit distance and spell-check vibes
\item
  Reconstructing solutions from tables
\item
  Space-saving DP tricks
\item
  Recognizing DP opportunities in the wild
\end{enumerate}

\subsubsection{Volume 10 --- Graph Algorithms I:
Exploration}\label{volume-10-graph-algorithms-i-exploration}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{90}
\tightlist
\item
  BFS: layers and shortest hops
\item
  DFS: depth trails and classification of edges
\item
  Connectivity: components and islands
\item
  Detecting cycles (directed/undirected)
\item
  Topological sort on DAGs
\item
  Using parents, levels, and timestamps
\item
  Flood fill and maze solving
\item
  Graph modeling patterns (grids, states)
\item
  Traversal pitfalls: visited sets and resets
\item
  When not to use graphs
\end{enumerate}

\subsubsection{Volume 11 --- Graph Algorithms II: Paths and
Trees}\label{volume-11-graph-algorithms-ii-paths-and-trees}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{100}
\tightlist
\item
  Weighted shortest paths mindset
\item
  Dijkstra: non-negative weights
\item
  Bellman--Ford: handle negatives carefully
\item
  All-pairs sketch: repeated single-source
\item
  Minimum spanning trees: cut and cycle views
\item
  Kruskal vs.~Prim: data structure choices
\item
  Union-Find (Disjoint Set Union) basics
\item
  DAG shortest paths as DP
\item
  Graph heuristics in practice (A* intuition)
\item
  Modeling road networks and deliveries
\end{enumerate}

\subsubsection{Volume 12 --- Strings, Text, and
Patterns}\label{volume-12-strings-text-and-patterns}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{110}
\tightlist
\item
  Strings as arrays of characters
\item
  Naive pattern matching and sliding windows
\item
  Prefix-function intuition (KMP idea, gently)
\item
  Z-function and borders (conceptual)
\item
  Rolling hash and Rabin--Karp
\item
  Tries for dictionaries and autocomplete
\item
  Simple compression ideas (run-length, Huffman revisit)
\item
  Tokenization and normalization basics
\item
  Anagrams, palindromes, frequency maps
\item
  Real tasks: search, dedup, and logs
\end{enumerate}

\subsubsection{Volume 13 --- Geometry and Spatial
Algorithms}\label{volume-13-geometry-and-spatial-algorithms}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{120}
\tightlist
\item
  Points, vectors, and distances (no heavy math)
\item
  Orientation tests: left, right, collinear
\item
  Bounding boxes and collision checks
\item
  Line segments: intersect or not
\item
  Polygons: perimeter, area, and winding
\item
  Grid geometry: raster thinking
\item
  Closest pair (divide-and-conquer idea)
\item
  Convex hull intuition
\item
  Spatial indexing intuition (quadtrees)
\item
  Practical tasks: maps, games, and UI hit-testing
\end{enumerate}

\subsubsection{Volume 14 --- Probability \& Randomized Algorithms
(Gentle)}\label{volume-14-probability-randomized-algorithms-gentle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{130}
\tightlist
\item
  Randomness as a tool, not magic
\item
  Sampling fairly and shuffling
\item
  Reservoir sampling for streams
\item
  Monte Carlo vs.~Las Vegas algorithms
\item
  Randomized quickselect intuition
\item
  Hashing and probabilistic data structures (bloom filter intuition)
\item
  Expectations without heavy formulas
\item
  Estimating large counts (Flajolet--Martin idea)
\item
  Random walks and simple simulations
\item
  When to prefer randomized approaches
\end{enumerate}

\subsubsection{Volume 15 --- Backtracking \& Constraint
Search}\label{volume-15-backtracking-constraint-search}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{140}
\tightlist
\item
  State spaces and search trees
\item
  Backtracking skeleton (choose → explore → undo)
\item
  Pruning with constraints
\item
  Permutations, combinations, and subsets
\item
  Sudoku/N-Queens: patterns of pruning
\item
  Ordering choices to speed up search
\item
  Constraint propagation intuition
\item
  Branch and bound basics
\item
  Detecting impossibility early
\item
  Turning search into solutions you can explain
\end{enumerate}

\subsubsection{Volume 16 --- Numbers, Data, and Simple
Numerics}\label{volume-16-numbers-data-and-simple-numerics}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{150}
\tightlist
\item
  Integer limits, overflow, and safe arithmetic
\item
  Fixed vs.~floating-point intuition
\item
  Summation stability and Kahan idea (gently)
\item
  Binary, decimal, and bases
\item
  Greatest common divisor and Euclid
\item
  Prime checks (simple) and factoring (why it's hard)
\item
  Modular arithmetic intuition
\item
  Root finding with bisection (no calculus)
\item
  Interpolation and simple smoothing
\item
  Units, precision, and error budgets
\end{enumerate}

\subsubsection{Volume 17 --- Working with Big Data (Beginner-Level
Ideas)}\label{volume-17-working-with-big-data-beginner-level-ideas}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{160}
\tightlist
\item
  Memory vs.~disk: locality matters
\item
  Chunking and batching
\item
  External sorting idea
\item
  Streaming: one pass, small memory
\item
  Map-Reduce as a mental model
\item
  Sketches for big counts (count-min intuition)
\item
  Windowed aggregates on streams
\item
  Caching and eviction (LRU intuition)
\item
  Parallelism vs.~concurrency (plain language)
\item
  Practical hygiene: logs, checkpoints, retries
\end{enumerate}

\subsubsection{Volume 18 --- Practical Algorithms in Everyday
Software}\label{volume-18-practical-algorithms-in-everyday-software}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{170}
\tightlist
\item
  Rate limiting (token/leaky bucket intuition)
\item
  Consistent hashing (balanced placement idea)
\item
  Pagination, search, and ranking basics
\item
  Recommendation heuristics (co-occurrence intuition)
\item
  Deduplication and fuzzy matching
\item
  Scheduling jobs and throttling
\item
  Pathfinding in apps and games
\item
  Simple image operations (filters as kernels)
\item
  Text pipelines (tokenize → normalize → index)
\item
  ``Good enough'' engineering: latency and budgets
\end{enumerate}

\subsubsection{Volume 19 --- Designing Algorithms: A
Playbook}\label{volume-19-designing-algorithms-a-playbook}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{180}
\tightlist
\item
  Clarify the goal and constraints
\item
  Model the data and operations
\item
  Choose patterns: brute force → prune → optimize
\item
  Identify invariants and loop structure
\item
  Prove or test correctness (lightweight)
\item
  Estimate cost and pick the right order of growth
\item
  Simplify first; optimize last
\item
  Reuse libraries vs.~reinventing
\item
  Communicate the approach (diagrams \& docs)
\item
  Post-mortems: learn from misses
\end{enumerate}

\subsubsection{Volume 20 --- Capstones, Case Studies, and
Practice}\label{volume-20-capstones-case-studies-and-practice}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{190}
\tightlist
\item
  Route planner for a small city (graphs)
\item
  Personal finance analyzer (arrays, scans, DP lite)
\item
  Study planner/scheduler (greedy + constraints)
\item
  Document search and dedup (strings + hashing)
\item
  Inventory allocator (greedy vs.~DP trade-offs)
\item
  Game pathfinding and AI (BFS/A*)
\item
  Image cleanup mini-tool (filters + queues)
\item
  Log analyzer for trends (streaming + sketches)
\item
  Data cleaning pipeline (practical robustness)
\item
  Build your own algorithm notebook (templates, checklists)
\end{enumerate}

\bookmarksetup{startatroot}

\chapter{Volume 1. What Is an
Algorithm?}\label{volume-1.-what-is-an-algorithm}

\section{Chapter 1. Problems, procedures, and
precision}\label{chapter-1.-problems-procedures-and-precision}

\subsection{1 --- Everyday Problems: Cooking, Travel,
Chores}\label{everyday-problems-cooking-travel-chores}

Before computers, algorithms lived in our lives. They are just
step-by-step instructions we already follow. Think of cooking a recipe,
planning a bus trip, or cleaning a room. Each task has a goal, a
sequence of steps, and rules that make it work.

\begin{itemize}
\tightlist
\item
  Cooking: follow a recipe → ingredients → steps → finished dish.
\item
  Travel: check timetable → buy ticket → get on bus → arrive.
\item
  Chores: pick up clothes → load machine → press start.
\end{itemize}

When the steps are clear, the outcome is predictable. That's the seed of
what an algorithm really is.

\subsubsection{Picture in Your Head}\label{picture-in-your-head}

Imagine a recipe card:

\begin{itemize}
\tightlist
\item
  Title: \emph{Bake a cake}
\item
  Ingredients: eggs, flour, sugar, butter
\item
  Steps: mix, pour, bake, cool
\item
  Result: a cake you can eat
\end{itemize}

Replace ``cake'' with ``answer,'' and you already have an algorithm.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe}

In pseudocode (plain English--like):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: daily chore algorithm}
\KeywordTok{def}\NormalTok{ do\_laundry(clothes):}
    \ControlFlowTok{if}\NormalTok{ clothes }\OperatorTok{==}\NormalTok{ empty:}
        \ControlFlowTok{return} \StringTok{"Nothing to wash"}
\NormalTok{    load\_washing\_machine(clothes)}
\NormalTok{    add\_detergent()}
\NormalTok{    press\_start()}
    \ControlFlowTok{return} \StringTok{"Laundry done"}
\end{Highlighting}
\end{Shaded}

The steps are precise, repeatable, and lead to a clear result.

\subsubsection{Try It Yourself}\label{try-it-yourself}

Pick one everyday task (e.g., making tea). Write down the inputs (what
you need), the steps (what you do), and the output (the result). Keep it
so clear that even a robot could follow it.

\subsection{2. From Vague Idea to Precise
Steps}\label{from-vague-idea-to-precise-steps}

A vague idea is like saying \emph{``let's clean the house''} or
\emph{``let's fix dinner.''} Everyone understands the goal, but the
exact steps are unclear. A precise step-by-step procedure transforms the
fuzzy goal into something a machine---or even another person---can
execute without guessing.

Computers are not good at filling in gaps. Where humans can improvise
(``oh, they meant sweep \emph{before} mopping''), machines need every
action described in detail. Precision is what separates a loose plan
from a working algorithm.

Think of a friend asking: \emph{``How do I get to your home?''}

\begin{itemize}
\tightlist
\item
  Vague: ``Take the bus, then walk.''
\item
  Precise: ``Take Bus 22 from Main Street at 5:15 PM, get off at Pine
  Road, walk 200 meters north to number 47.''
\end{itemize}

The difference is not just more words---it's about removing ambiguity so
that the result is reliable every time.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-1}

Visualize two instruction sheets:

\begin{itemize}
\item
  The vague sheet says: ``Cook rice.''
\item
  The precise sheet says:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Measure 1 cup of rice.
  \item
    Rinse until water runs clear.
  \item
    Add 2 cups of water.
  \item
    Bring to boil, then simmer for 15 minutes.
  \item
    Turn off heat, cover for 10 minutes.
  \end{enumerate}
\end{itemize}

The vague sheet leaves space for mistakes (too much water, wrong
timing). The precise sheet makes the outcome predictable---fluffy rice
every time.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-1}

Turning a vague task into code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Vague version}
\KeywordTok{def}\NormalTok{ make\_tea():}
\NormalTok{    boil\_water()}
\NormalTok{    add\_tea()}
\NormalTok{    serve()}
\end{Highlighting}
\end{Shaded}

This is incomplete. What kind of tea? How long to steep? What to add?

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Precise version}
\KeywordTok{def}\NormalTok{ make\_tea(cups):}
\NormalTok{    kettle.fill\_with\_water(cups }\OperatorTok{*} \DecValTok{250}\NormalTok{)   }\CommentTok{\# 250 ml per cup}
\NormalTok{    kettle.boil()}
\NormalTok{    place\_teabag\_in\_cup()}
\NormalTok{    pour\_water\_into\_cup()}
\NormalTok{    wait(}\DecValTok{3}\NormalTok{)  }\CommentTok{\# minutes}
\NormalTok{    remove\_teabag()}
\NormalTok{    add\_sugar\_or\_milk\_if\_desired()}
    \ControlFlowTok{return} \StringTok{"Tea ready"}
\end{Highlighting}
\end{Shaded}

The second version removes uncertainty. It's clear, repeatable, and
machine-executable.

\subsubsection{Everyday Examples}\label{everyday-examples}

\begin{itemize}
\tightlist
\item
  Travel: Instead of ``Go to Paris,'' the precise steps list the train
  number, departure time, ticket details, and directions once you
  arrive.
\item
  Shopping: Instead of ``Buy some fruit,'' specify ``Buy 6 apples and 3
  bananas, preferably ripe but not bruised.''
\item
  Homework: Instead of ``Study math,'' specify ``Review chapter 2, solve
  exercises 1--10, check answers in the appendix.''
\end{itemize}

Each transformation makes the task executable without confusion.

\subsubsection{Try It Yourself}\label{try-it-yourself-1}

Pick one vague instruction you often hear---like \emph{``clean your
room''} or \emph{``prepare for class.''} Rewrite it as a precise
algorithm. Include:

\begin{itemize}
\tightlist
\item
  Inputs (what you start with)
\item
  Steps (exact sequence of actions)
\item
  Output (what counts as ``done'')
\end{itemize}

Then hand it to a friend or sibling. If they can follow it without
asking you a single clarification, you've succeeded in turning a vague
idea into a precise algorithm.

\subsubsection{Key Takeaway}\label{key-takeaway}

Precision is the bridge between intent and execution. Humans tolerate
vagueness, but algorithms cannot. To make an idea computational, strip
away ambiguity until only crystal-clear steps remain.

\subsection{3. Deterministic vs.~Nondeterministic
Steps}\label{deterministic-vs.-nondeterministic-steps}

An algorithm is often judged by how predictable it is. A deterministic
step means that if you run the algorithm twice with the same input, you
always get the same output. For example, adding two
numbers---\texttt{2\ +\ 3}---always gives \texttt{5}.

A nondeterministic step introduces uncertainty. Imagine rolling a die.
Even if you roll it the same way, you can't guarantee which number will
appear. Some algorithms deliberately use randomness, like shuffling a
playlist or generating a random password.

Determinism is crucial when the result must be exact, like calculating
tax or verifying a password. Nondeterminism is useful when exploring
possibilities, sampling, or avoiding worst-case traps.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-2}

Think of two vending machines:

\begin{itemize}
\tightlist
\item
  Deterministic machine: press button ``C2,'' and you always get the
  same soda.
\item
  Nondeterministic machine: press ``C2,'' and you might get soda, chips,
  or candy.
\end{itemize}

Both can be useful: sometimes you want predictability, other times you
want variety.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-2}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Deterministic example}
\KeywordTok{def}\NormalTok{ square(x):}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}

\CommentTok{\# Nondeterministic example}
\ImportTok{import}\NormalTok{ random}
\KeywordTok{def}\NormalTok{ roll\_die():}
    \ControlFlowTok{return}\NormalTok{ random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{square(4)} will always return \texttt{16}.
\item
  \texttt{roll\_die()} could return 1, 2, 3, 4, 5, or 6---even if called
  twice in a row.
\end{itemize}

\subsubsection{Everyday Examples}\label{everyday-examples-1}

\begin{itemize}
\item
  Deterministic:

  \begin{itemize}
  \tightlist
  \item
    Multiplying numbers.
  \item
    Looking up a word in a dictionary.
  \item
    Following a recipe step by step without improvisation.
  \end{itemize}
\item
  Nondeterministic:

  \begin{itemize}
  \tightlist
  \item
    Drawing a card from a shuffled deck.
  \item
    Choosing a random song on shuffle mode.
  \item
    Guessing who will answer a question in class.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters}

\begin{itemize}
\tightlist
\item
  Deterministic algorithms are required for tasks needing exact
  correctness---banking transactions, medical dosage calculators,
  navigation systems.
\item
  Nondeterministic algorithms shine in large or complex search
  spaces---finding approximate solutions quickly, simulating randomness,
  or ensuring fairness (like in lotteries or sampling).
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-2}

Take the task \emph{``choose a restaurant to eat at tonight.''}

\begin{itemize}
\tightlist
\item
  Write a deterministic version: ``Always pick the closest restaurant
  within 10 minutes of walking.''
\item
  Write a nondeterministic version: ``Roll a die; if 1--2 → pizza, 3--4
  → burgers, 5--6 → sushi.''
\end{itemize}

Run each procedure twice and compare the results. Which feels more
reliable? Which feels more fun?

\subsubsection{Key Takeaway}\label{key-takeaway-1}

Determinism guarantees predictability, while nondeterminism embraces
uncertainty. Both are part of the algorithmic toolbox, and the choice
depends on whether you need reliability or variety.

\subsection{4. Decomposing Big Problems into Small
Ones}\label{decomposing-big-problems-into-small-ones}

Large problems often feel overwhelming because they look like a mountain
with no clear path. The key is decomposition---breaking the mountain
into climbable steps. Computers thrive on this because they can only
follow small, precise instructions.

When you decompose, you turn a complex task like ``organize a school
festival'' into smaller sub-tasks: book a venue, assign volunteers, plan
food stalls, schedule events. Each sub-task can itself be broken down
further until the pieces are simple enough to execute without
hesitation.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-3}

Imagine a tree:

\begin{itemize}
\tightlist
\item
  The root is the big problem (e.g., ``plan a birthday party'').
\item
  The branches are main tasks (buy cake, send invitations, decorate).
\item
  The leaves are atomic steps (choose flavor, write names on invites,
  hang balloons).
\end{itemize}

Solving the big problem becomes manageable once you focus on the leaves
one by one.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-3}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Big problem: plan a trip}
\KeywordTok{def}\NormalTok{ plan\_trip():}
\NormalTok{    book\_transport()}
\NormalTok{    book\_hotel()}
\NormalTok{    pack\_bags()}
\NormalTok{    create\_itinerary()}

\KeywordTok{def}\NormalTok{ book\_transport():}
\NormalTok{    search\_flights()}
\NormalTok{    choose\_flight()}
\NormalTok{    pay\_and\_confirm()}

\KeywordTok{def}\NormalTok{ pack\_bags():}
\NormalTok{    make\_packing\_list()}
\NormalTok{    put\_items\_in\_bag()}
\end{Highlighting}
\end{Shaded}

Each function hides details, but collectively they solve the big problem
step by step.

\subsubsection{Everyday Examples}\label{everyday-examples-2}

\begin{itemize}
\item
  Cooking dinner:

  \begin{itemize}
  \tightlist
  \item
    Big problem: prepare a meal.
  \item
    Subtasks: decide menu → shop ingredients → cook dishes → set table.
  \end{itemize}
\item
  Writing an essay:

  \begin{itemize}
  \tightlist
  \item
    Big problem: write 1,000 words.
  \item
    Subtasks: choose topic → outline → draft → revise → finalize.
  \end{itemize}
\item
  Cleaning your room:

  \begin{itemize}
  \tightlist
  \item
    Big problem: tidy the room.
  \item
    Subtasks: pick up clothes → dust surfaces → vacuum floor → empty
    trash.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-1}

\begin{itemize}
\tightlist
\item
  Decomposition helps you see progress sooner. Solving a 5-minute
  subtask builds momentum.
\item
  It improves collaboration---different people (or computer programs)
  can work on different subtasks in parallel.
\item
  It allows reuse: once you write a function \texttt{book\_transport()},
  you can reuse it in planning any trip, not just one vacation.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls}

\begin{itemize}
\tightlist
\item
  Over-fragmentation: making tasks too tiny can create overhead and
  confusion.
\item
  Under-specification: keeping tasks too large makes them hard to start
  or automate.
\item
  The sweet spot is: each piece should be small enough to feel doable,
  but large enough to make progress visible.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-3}

Pick a big task you're procrastinating on (like \emph{``study for
finals''}). Break it into at least 5 sub-tasks, then pick one of those
and break it again into smaller steps. Keep breaking until each step
feels like something you could do in under 15 minutes.

\subsubsection{Key Takeaway}\label{key-takeaway-2}

Decomposition is the art of taming complexity. Big problems are rarely
solved all at once---they're conquered by cutting them into smaller,
clearer, executable steps that fit together into the whole.

\subsection{5. Abstraction: Hiding Details to See
Structure}\label{abstraction-hiding-details-to-see-structure}

Abstraction is about focusing on the essence of a task while temporarily
ignoring the details. It's how we manage complexity in daily life. When
you say ``drive to work,'' you don't list ``turn key → check mirrors →
shift gear → press pedal'' every time. The phrase ``drive'' hides those
steps.

In algorithms, abstraction allows us to name a group of steps and treat
them as a single unit. Instead of worrying about \emph{how} something is
done, you focus on \emph{what} it achieves. This lets you build bigger
systems from simpler parts.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-4}

Think of a remote control. You press ``volume up,'' and the sound
increases. You don't think about the circuits, the signal transmission,
or the amplifier inside the TV. That complexity is
hidden---abstracted---so you can use it easily.

Algorithms work the same way: abstraction gives you simple ``buttons''
to use without rethinking every internal detail.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-4}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Without abstraction}
\KeywordTok{def}\NormalTok{ make\_breakfast():}
\NormalTok{    crack\_eggs()}
\NormalTok{    whisk\_eggs()}
\NormalTok{    heat\_pan()}
\NormalTok{    pour\_eggs()}
\NormalTok{    cook\_and\_flip()}
\NormalTok{    place\_on\_plate()}
\NormalTok{    slice\_bread()}
\NormalTok{    toast\_bread()}
\NormalTok{    butter\_bread()}
\NormalTok{    put\_on\_plate()}
\NormalTok{    serve()}

\CommentTok{\# With abstraction}
\KeywordTok{def}\NormalTok{ make\_breakfast():}
\NormalTok{    cook\_eggs()}
\NormalTok{    toast\_bread()}
\NormalTok{    serve()}
\end{Highlighting}
\end{Shaded}

The second version is easier to understand. Each abstracted function
still has details inside, but you don't need to see them every time.

\subsubsection{Everyday Examples}\label{everyday-examples-3}

\begin{itemize}
\tightlist
\item
  Cooking: Instead of explaining every knife movement, you just say
  ``chop onions.''
\item
  Math: Instead of adding numbers by hand each time, you trust the
  ``addition'' operation.
\item
  Technology: When you ``send an email,'' you don't think about TCP/IP,
  DNS, or mail servers.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-2}

\begin{itemize}
\tightlist
\item
  Abstraction helps in communication: one person can say ``sort the
  list,'' and everyone understands the intent without debating the
  internal method.
\item
  It improves reuse: once you've defined ``sort,'' you can use it
  anywhere without rewriting.
\item
  It supports layered design: higher-level algorithms build on
  lower-level building blocks.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-1}

\begin{itemize}
\tightlist
\item
  Too much abstraction: hiding so many details that you lose control or
  can't debug problems.
\item
  Too little abstraction: drowning in low-level steps makes algorithms
  unreadable and fragile.
\item
  The balance is to abstract only what is stable and reused, while
  keeping important details visible.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-4}

Write down the steps for ``making tea'' in full detail. Then rewrite the
same procedure using abstractions like ``boil water,'' ``steep tea,''
and ``serve.'' Notice how much easier the second version is to read,
while still being clear enough to act on.

\subsubsection{Key Takeaway}\label{key-takeaway-3}

Abstraction is the secret weapon of algorithm design. By hiding details
behind well-chosen names, you make problems easier to think about,
communicate, and solve---without losing the ability to dive back into
details when needed.

\subsection{6. Representing Data: Numbers, Text, and Simple
Records}\label{representing-data-numbers-text-and-simple-records}

An algorithm cannot operate in the abstract---it always works on data.
How you choose to represent that data is as important as the steps
themselves. Data representation is the bridge between the real-world
problem and the algorithmic solution.

Numbers, text, lists, and records are the most common building blocks.
Each has its own strengths: numbers capture quantities, text captures
language, lists capture sequences, and records capture structured
information. The right representation makes the algorithm simpler,
clearer, and often faster.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-5}

Imagine a toolbox with different containers:

\begin{itemize}
\tightlist
\item
  A jar holds individual numbers.
\item
  A string of beads represents text, each bead a letter.
\item
  A row of lockers is a list, where each locker has a number.
\item
  A file folder with labeled slots is a record, each slot holding a
  specific detail like ``name'' or ``age.''
\end{itemize}

Picking the right container determines how easy it is to store, find, or
modify the information.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-5}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Numbers}
\NormalTok{age }\OperatorTok{=} \DecValTok{21}
\NormalTok{price }\OperatorTok{=} \FloatTok{9.99}

\CommentTok{\# Text}
\NormalTok{name }\OperatorTok{=} \StringTok{"Alice"}
\NormalTok{greeting }\OperatorTok{=} \StringTok{"Hello, "} \OperatorTok{+}\NormalTok{ name}

\CommentTok{\# List}
\NormalTok{scores }\OperatorTok{=}\NormalTok{ [}\DecValTok{85}\NormalTok{, }\DecValTok{92}\NormalTok{, }\DecValTok{78}\NormalTok{, }\DecValTok{96}\NormalTok{]}

\CommentTok{\# Record (dictionary in Python)}
\NormalTok{student }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"name"}\NormalTok{: }\StringTok{"Alice"}\NormalTok{,}
    \StringTok{"age"}\NormalTok{: }\DecValTok{21}\NormalTok{,}
    \StringTok{"scores"}\NormalTok{: [}\DecValTok{85}\NormalTok{, }\DecValTok{92}\NormalTok{, }\DecValTok{78}\NormalTok{, }\DecValTok{96}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Each representation serves a different purpose. Numbers compute, text
communicates, lists organize, and records combine.

\subsubsection{Everyday Examples}\label{everyday-examples-4}

\begin{itemize}
\tightlist
\item
  Numbers: counting money, measuring time, calculating distance.
\item
  Text: writing messages, searching documents, labeling items.
\item
  Lists: grocery shopping order, to-do tasks, class roll.
\item
  Records: a student's profile with name, ID, age, and courses.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-3}

\begin{itemize}
\tightlist
\item
  Choosing the right representation simplifies the algorithm. Sorting is
  natural on lists; searching by key is natural on records.
\item
  A poor choice makes tasks harder. Imagine representing birthdays as
  plain text ``June 15, 2000'' vs.~a structured record
  \texttt{\{day:\ 15,\ month:\ 6,\ year:\ 2000\}}---the latter makes age
  calculations straightforward.
\item
  Representation also affects efficiency: a number takes less space than
  text; a structured record avoids repeated data.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-2}

\begin{itemize}
\tightlist
\item
  Overcomplication: storing everything as deeply nested records when a
  simple list would do.
\item
  Oversimplification: flattening complex information into plain text,
  making it hard to process later.
\item
  Inconsistency: mixing different formats (e.g., sometimes dates as
  \texttt{MM/DD/YYYY}, other times as \texttt{DD-MM-YY}).
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-5}

Think of planning a school library system. How would you represent:

\begin{itemize}
\tightlist
\item
  The title of a book?
\item
  The list of authors?
\item
  The record of who borrowed it and when?
\end{itemize}

Write down your choices using numbers, text, lists, and records. Then
imagine how different algorithms (like search, sort, overdue check)
would use them.

\subsubsection{Key Takeaway}\label{key-takeaway-4}

Data is the raw material of algorithms. Choosing the right
representation---numbers, text, lists, or records---turns messy
real-world information into something an algorithm can process clearly
and efficiently.

\subsection{7. Correctness as a Promise:
Pre/Postconditions}\label{correctness-as-a-promise-prepostconditions}

Correctness means that an algorithm does what it is supposed to do,
nothing more and nothing less. To make this concrete, we use
preconditions and postconditions:

\begin{itemize}
\tightlist
\item
  A precondition is what must already be true before the algorithm runs.
\item
  A postcondition is what must be true after the algorithm finishes.
\end{itemize}

Think of them as the promise an algorithm makes. If you give it valid
input (satisfying the precondition), it guarantees the result (the
postcondition). This way, we can reason about correctness without having
to rerun the algorithm endlessly.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-6}

Imagine a washing machine with a checklist:

\begin{itemize}
\tightlist
\item
  Before you start: clothes inside, door closed, detergent added.
\item
  After you finish: clothes are washed and door can be opened.
\end{itemize}

If you don't meet the before-conditions (door left open), the process
fails. If the machine doesn't meet the after-conditions (clothes not
washed), it broke its promise. Algorithms are no different.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-6}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: find maximum number in a list}
\KeywordTok{def}\NormalTok{ find\_max(numbers):}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(numbers) }\OperatorTok{\textgreater{}} \DecValTok{0}   \CommentTok{\# Precondition: list not empty}
\NormalTok{    max\_val }\OperatorTok{=}\NormalTok{ numbers[}\DecValTok{0}\NormalTok{]}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textgreater{}}\NormalTok{ max\_val:}
\NormalTok{            max\_val }\OperatorTok{=}\NormalTok{ n}
    \CommentTok{\# Postcondition: max\_val is the largest element in numbers}
    \ControlFlowTok{return}\NormalTok{ max\_val}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Precondition: \texttt{numbers} must not be empty.
\item
  Postcondition: returned value is at least as big as every number in
  the list.
\end{itemize}

\subsubsection{Everyday Examples}\label{everyday-examples-5}

\begin{itemize}
\item
  Calculator square root:

  \begin{itemize}
  \tightlist
  \item
    Precondition: input ≥ 0.
  \item
    Postcondition: output × output ≈ input.
  \end{itemize}
\item
  Sorting clothes by color:

  \begin{itemize}
  \tightlist
  \item
    Precondition: clothes are present.
  \item
    Postcondition: clothes grouped so that each pile has only one color.
  \end{itemize}
\item
  Booking a train ticket:

  \begin{itemize}
  \tightlist
  \item
    Precondition: seat available, payment method valid.
  \item
    Postcondition: ticket issued and seat reserved.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-4}

\begin{itemize}
\tightlist
\item
  Safety: Medical dosage software must enforce preconditions so that
  impossible or dangerous inputs (negative dosage) are caught early.
\item
  Reliability: Sorting must guarantee that after completion, the list is
  in non-decreasing order.
\item
  Debugging: Preconditions help catch errors at the start;
  postconditions confirm success at the end.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-3}

\begin{itemize}
\tightlist
\item
  Ignoring preconditions leads to crashes (e.g., dividing by zero,
  accessing empty lists).
\item
  Weak or vague postconditions create confusion (``sorted'' must mean
  fully ordered, not ``mostly sorted'').
\item
  Overly strict conditions can block useful cases (e.g., forbidding zero
  when zero is valid input).
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-6}

Write down the preconditions and postconditions for this task: ``reverse
a string.''

\begin{itemize}
\tightlist
\item
  Hint: Think about what must be true before (input is a valid string)
  and what must be true after (characters appear in opposite order,
  length unchanged).
\end{itemize}

\subsubsection{Key Takeaway}\label{key-takeaway-5}

Correctness is not magic---it is a contract. Algorithms promise:
\emph{``If you give me the right kind of input, I will guarantee the
right kind of output.''} Preconditions define the rules of entry, and
postconditions define the promise of completion.

\subsection{8. Cost as Effort: Time, Memory, and
Simplicity}\label{cost-as-effort-time-memory-and-simplicity}

Every algorithm consumes resources. The most obvious is time---how long
it takes to finish. Another is memory---how much space it uses to hold
data while working. A subtler cost is simplicity---how easy it is for
humans to read, maintain, and debug the algorithm.

Even simple tasks have costs. Adding two numbers takes almost no time
and memory. Sorting a million numbers takes a lot more. Being aware of
cost helps us choose the right method for the situation: sometimes we
need the fastest algorithm, other times we value the simplest one.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-7}

Imagine three piggy banks labeled Time, Memory, and Simplicity.

\begin{itemize}
\tightlist
\item
  Each algorithm spends coins differently.
\item
  Some spend more from Time (slow but clear).
\item
  Some spend more from Memory (fast but space-hungry).
\item
  Some sacrifice Simplicity (clever tricks, but hard to understand).
\end{itemize}

The art of algorithms is choosing where to spend coins wisely.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-7}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Double every number in a list}

\CommentTok{\# Version 1: Simple but uses extra memory}
\KeywordTok{def}\NormalTok{ double\_numbers\_copy(numbers):}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
\NormalTok{        result.append(n }\OperatorTok{*} \DecValTok{2}\NormalTok{)}
    \ControlFlowTok{return}\NormalTok{ result}

\CommentTok{\# Version 2: In{-}place (saves memory but overwrites input)}
\KeywordTok{def}\NormalTok{ double\_numbers\_inplace(numbers):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(numbers)):}
\NormalTok{        numbers[i] }\OperatorTok{*=} \DecValTok{2}
    \ControlFlowTok{return}\NormalTok{ numbers}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Version 1 is simpler to understand but uses extra memory.
\item
  Version 2 is memory efficient but modifies the original list.
\end{itemize}

Different situations call for different trade-offs.

\subsubsection{Everyday Examples}\label{everyday-examples-6}

\begin{itemize}
\tightlist
\item
  Time cost: waiting for a website to load, waiting for laundry to
  finish.
\item
  Memory cost: storing all photos on your phone vs.~keeping only
  thumbnails.
\item
  Simplicity cost: a short recipe everyone understands vs.~a complicated
  chef's trick that only experts can follow.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-5}

\begin{itemize}
\tightlist
\item
  Time is critical when users are waiting (web searches, traffic lights,
  medical scans).
\item
  Memory is critical when devices are limited (phones, IoT devices,
  embedded systems).
\item
  Simplicity is critical when humans must maintain the code (school
  projects, team software, safety systems).
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-4}

\begin{itemize}
\tightlist
\item
  Optimizing too early: making code complex before knowing if speed is
  really an issue.
\item
  Ignoring hidden costs: an algorithm might look fast but secretly use
  too much memory.
\item
  Overvaluing one resource: making code ultra-fast but unreadable, or
  ultra-simple but too slow for real use.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-7}

Suppose you want to find duplicates in a list of names:

\begin{itemize}
\tightlist
\item
  Solution A: Compare every name with every other (simple, but
  time-heavy).
\item
  Solution B: Use a dictionary/map to check quickly (fast, but more
  memory).
\end{itemize}

Write both approaches in pseudocode. Which one would you choose for a
list of 10 names? For 10 million names?

\subsubsection{Key Takeaway}\label{key-takeaway-6}

Every algorithm has a price tag measured in time, memory, and
simplicity. Choosing the right algorithm means balancing these costs
against the needs of the problem. There is no free lunch---every gain
comes with a trade-off.

\subsection{9. Algorithms vs.~Heuristics: When ``Good Enough''
Wins}\label{algorithms-vs.-heuristics-when-good-enough-wins}

An algorithm is a procedure that guarantees the correct answer if you
follow the steps. A heuristic is a rule of thumb---a shortcut that
doesn't always guarantee the best answer, but is often good enough.

Algorithms are like recipes that always produce the same dish if you
follow them carefully. Heuristics are like quick cooking hacks: they may
save time, but the results can vary. In practice, both have their
place---algorithms give certainty, heuristics give speed and
flexibility.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-8}

Imagine you're looking for your friend's house in a city:

\begin{itemize}
\tightlist
\item
  Algorithmic way: Follow the official map, turn-by-turn, until you
  arrive.
\item
  Heuristic way: Ask locals ``which way?'' and follow general directions
  like ``head toward the church, then left at the park.''
\end{itemize}

One guarantees arrival; the other is faster but riskier.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-8}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Algorithm: linear search (guaranteed to find target if present)}
\KeywordTok{def}\NormalTok{ linear\_search(arr, target):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(arr)):}
        \ControlFlowTok{if}\NormalTok{ arr[i] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ i}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}

\CommentTok{\# Heuristic: guess based on assumption (not guaranteed)}
\KeywordTok{def}\NormalTok{ heuristic\_guess(arr, target):}
    \CommentTok{\# assume target is near the middle}
\NormalTok{    mid }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr) }\OperatorTok{//} \DecValTok{2}
    \ControlFlowTok{if}\NormalTok{ arr[mid] }\OperatorTok{==}\NormalTok{ target:}
        \ControlFlowTok{return}\NormalTok{ mid}
    \CommentTok{\# might miss if assumption is wrong}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

The first always works but may take time. The second is faster but
unreliable.

\subsubsection{Everyday Examples}\label{everyday-examples-7}

\begin{itemize}
\item
  Algorithms:

  \begin{itemize}
  \tightlist
  \item
    Sorting a deck of cards with a defined method.
  \item
    Calculating tax using exact formulas.
  \item
    Navigating with GPS turn-by-turn instructions.
  \end{itemize}
\item
  Heuristics:

  \begin{itemize}
  \tightlist
  \item
    ``Choose the checkout line that looks shortest.''
  \item
    ``Guess the answer based on past patterns.''
  \item
    ``Pick the middle option on a menu because it's usually safe.''
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-6}

\begin{itemize}
\tightlist
\item
  Use algorithms when correctness is critical---banking, medicine,
  navigation, scientific computing.
\item
  Use heuristics when speed matters more than perfection---search
  engines, recommendations, AI systems, real-time decisions.
\end{itemize}

Often, systems combine both: heuristics suggest a likely answer quickly,
then algorithms verify it.

\subsubsection{Pitfalls}\label{pitfalls-5}

\begin{itemize}
\tightlist
\item
  Relying too much on heuristics can lead to mistakes or bias (e.g.,
  always guessing ``the bigger number wins'').
\item
  Insisting on algorithms when a heuristic is good enough can waste time
  and resources.
\item
  Forgetting to explain that a solution is heuristic may mislead others
  into thinking it's guaranteed.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-8}

You're planning dinner for 5 friends:

\begin{itemize}
\tightlist
\item
  Algorithmic way: Write a precise menu, shop for exact ingredients,
  follow the recipe exactly.
\item
  Heuristic way: Buy what looks fresh at the market, improvise a meal.
\end{itemize}

Which approach do you use on a busy weekday? Which for a formal event?
Why?

\subsubsection{Key Takeaway}\label{key-takeaway-7}

Algorithms guarantee correctness; heuristics trade certainty for speed
and simplicity. The art is knowing when perfection is required and when
``good enough'' is the smarter choice.

\subsection{10. A Tiny Toolbox: Three Everyday Recipes (Sum, Max,
Count)}\label{a-tiny-toolbox-three-everyday-recipes-sum-max-count}

Before diving into advanced techniques, it helps to have a few universal
building blocks---tiny algorithms so common that they appear everywhere.
Three of the most useful are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Sum --- add up a collection of numbers.
\item
  Max --- find the largest element.
\item
  Count --- tally how many items meet a condition.
\end{enumerate}

These are not just exercises. They are the seeds of much bigger
algorithms. Almost every analysis, report, or calculation begins with
these simple steps.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-9}

Think of three kitchen tools:

\begin{itemize}
\tightlist
\item
  A measuring cup (Sum): it gathers everything into one total.
\item
  A tallest ruler (Max): it shows which object is the biggest.
\item
  A tally counter (Count): click once for every item that matches.
\end{itemize}

With just these tools, you can answer many real-life questions.

\subsubsection{Tiny Code Recipes}\label{tiny-code-recipes}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sum: add all numbers}
\KeywordTok{def}\NormalTok{ sum\_list(numbers):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\CommentTok{\# Max: find largest number}
\KeywordTok{def}\NormalTok{ max\_list(numbers):}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(numbers) }\OperatorTok{\textgreater{}} \DecValTok{0}
\NormalTok{    max\_val }\OperatorTok{=}\NormalTok{ numbers[}\DecValTok{0}\NormalTok{]}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textgreater{}}\NormalTok{ max\_val:}
\NormalTok{            max\_val }\OperatorTok{=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ max\_val}

\CommentTok{\# Count: how many numbers above a threshold?}
\KeywordTok{def}\NormalTok{ count\_above(numbers, threshold):}
\NormalTok{    count }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textgreater{}}\NormalTok{ threshold:}
\NormalTok{            count }\OperatorTok{+=} \DecValTok{1}
    \ControlFlowTok{return}\NormalTok{ count}
\end{Highlighting}
\end{Shaded}

\subsubsection{Everyday Examples}\label{everyday-examples-8}

\begin{itemize}
\tightlist
\item
  Sum: total expenses in a week, calories eaten in a day, total points
  scored in a game.
\item
  Max: the fastest runner in a race, the highest grade in a class, the
  tallest building in town.
\item
  Count: how many emails are unread, how many friends liked a post, how
  many students passed an exam.
\end{itemize}

\subsubsection{Combining Recipes}\label{combining-recipes}

These simple tools can be composed:

\begin{itemize}
\tightlist
\item
  Average = Sum ÷ Count.
\item
  Min can be built like Max, just flipping the comparison.
\item
  Range = Max -- Min.
\end{itemize}

Many complex statistics start as combinations of these basics.

\subsubsection{When It Matters}\label{when-it-matters-7}

\begin{itemize}
\tightlist
\item
  They are the core of data analysis: every spreadsheet and database
  engine implements sum, max, and count.
\item
  They scale from small tasks (count items in your bag) to massive
  systems (count billions of web clicks).
\item
  They build confidence for beginners---understanding these fully
  prepares you for more advanced algorithms.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-6}

\begin{itemize}
\tightlist
\item
  Forgetting to handle empty inputs: what is the sum of an empty list?
  (Usually defined as 0.) What is the max of an empty list? (Undefined,
  so the algorithm should reject it.)
\item
  Mixing units: summing minutes and hours without converting.
\item
  Counting with unclear rules: does ``count emails'' include archived or
  only inbox?
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down your expenses for the last 7 days. Use sum to get the
  total, max to find the most expensive day, and count to see how many
  days cost more than \$20.
\item
  Think of a dataset from daily life (grades, step counts, hours of
  sleep). Apply these three recipes and see what insights they give.
\end{enumerate}

\subsubsection{Key Takeaway}\label{key-takeaway-8}

Sum, Max, and Count are the bread and butter of algorithms. They're
simple enough for anyone to understand, yet powerful enough to be the
foundation of entire data systems. Master these, and you already carry a
tiny but mighty toolbox for problem-solving.

\section{Chapter 2. Input, output and
assumption}\label{chapter-2.-input-output-and-assumption}

\subsection{11. Defining What Goes In and What Comes
Out}\label{defining-what-goes-in-and-what-comes-out}

Every algorithm has a starting point and an ending point. The starting
point is the input---the information you give it. The ending point is
the output---the result it produces. Without clearly defining both, an
algorithm is incomplete.

Think of a vending machine:

\begin{itemize}
\tightlist
\item
  Input → money + button choice.
\item
  Output → the snack you selected.
\end{itemize}

If the input is unclear (wrong coin, no button press), the output is
unpredictable. If the output is unclear (sometimes snack, sometimes
nothing), the machine feels broken. Algorithms require the same clarity:
\emph{what goes in, what comes out.}

\subsubsection{Picture in Your Head}\label{picture-in-your-head-10}

Imagine a function box:

\begin{itemize}
\tightlist
\item
  On the left side, arrows bring in input (numbers, words, data).
\item
  Inside the box, the algorithm transforms it.
\item
  On the right side, arrows show the output (answers, results).
\end{itemize}

This box metaphor is central to algorithmic thinking: algorithms are
black boxes that turn input into output by following rules.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-9}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Input: a list of numbers}
\CommentTok{\# Output: the sum of the list}
\KeywordTok{def}\NormalTok{ sum\_list(numbers):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\CommentTok{\# Example}
\BuiltInTok{print}\NormalTok{(sum\_list([}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{]))  }\CommentTok{\# Input = [2,4,6], Output = 12}
\end{Highlighting}
\end{Shaded}

Notice how clear it is: you know what must be provided (a list of
numbers) and what is guaranteed (a single number, their sum).

\subsubsection{Everyday Examples}\label{everyday-examples-9}

\begin{itemize}
\item
  Cooking recipe:

  \begin{itemize}
  \tightlist
  \item
    Input: raw ingredients.
  \item
    Output: finished dish.
  \end{itemize}
\item
  Bank ATM:

  \begin{itemize}
  \tightlist
  \item
    Input: card + PIN + withdrawal amount.
  \item
    Output: cash + receipt.
  \end{itemize}
\item
  Search engine:

  \begin{itemize}
  \tightlist
  \item
    Input: keywords typed.
  \item
    Output: ranked list of results.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-8}

\begin{itemize}
\tightlist
\item
  Clarity of input and output allows algorithms to be reused. If a
  function says ``input: list of numbers; output: maximum,'' you can use
  it in many contexts.
\item
  It also helps in testing correctness: if the input is well-defined,
  the expected output can be checked easily.
\item
  When building larger systems, defining inputs and outputs prevents
  confusion about how components interact.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-7}

\begin{itemize}
\tightlist
\item
  Vague input: ``Give me some data'' (unclear what format).
\item
  Vague output: ``It will calculate something'' (unclear what result to
  expect).
\item
  Hidden assumptions: expecting kilometers but receiving miles, or
  requiring integers when floats are given.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-10}

Pick a daily task, like \emph{``send an email.''} Define it in terms of
input and output:

\begin{itemize}
\tightlist
\item
  Input: recipient address, subject, message body.
\item
  Output: confirmation that the message was sent.
\end{itemize}

Then check: would someone else be able to use your algorithm without
guessing?

\subsubsection{Key Takeaway}\label{key-takeaway-9}

Algorithms live on the principle of clear boundaries: inputs must be
well-defined, and outputs must be guaranteed. This is how vague
intentions become reliable procedures.

\subsection{12. Numbers as Simple
Inputs}\label{numbers-as-simple-inputs}

Numbers are the most basic and universal kind of input for algorithms.
They represent quantities, measurements, and identifiers. Because
numbers are precise, they are easy for machines to process. When you
give an algorithm a number, you're providing a clear piece of
information it can transform into something else.

Examples:

\begin{itemize}
\tightlist
\item
  Input: the number \texttt{5} → Output: factorial of 5 (\texttt{120}).
\item
  Input: a person's age \texttt{21} → Output: ``eligible to vote''
  (true/false).
\item
  Input: coordinates \texttt{(3,\ 7)} → Output: the distance to the
  origin.
\end{itemize}

\subsubsection{Picture in Your Head}\label{picture-in-your-head-11}

Imagine a set of knobs on a machine. Each knob is a number you can set:

\begin{itemize}
\tightlist
\item
  Turn one knob to ``temperature = 200°C.''
\item
  Turn another to ``time = 30 minutes.''
\item
  The oven algorithm takes those inputs and produces a baked cake.
\end{itemize}

Numbers are the dials that control algorithmic behavior.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-10}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Input: a number}
\CommentTok{\# Output: square of that number}
\KeywordTok{def}\NormalTok{ square(x):}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}

\BuiltInTok{print}\NormalTok{(square(}\DecValTok{7}\NormalTok{))   }\CommentTok{\# Input = 7, Output = 49}
\end{Highlighting}
\end{Shaded}

This shows the simplest numerical transformation: input → process →
output.

\subsubsection{Everyday Examples}\label{everyday-examples-10}

\begin{itemize}
\tightlist
\item
  Elevator system: input floor number → elevator moves to that floor.
\item
  Cash register: input price and quantity → output total cost.
\item
  Thermostat: input desired temperature → output system turns
  heater/cooler on or off.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-9}

\begin{itemize}
\tightlist
\item
  Numbers are building blocks for almost every other kind of input
  (dates, times, IDs).
\item
  They make outputs easy to verify (2 + 2 always equals 4).
\item
  Many real-world tasks---finance, physics, sports scores---reduce to
  number inputs.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-8}

\begin{itemize}
\tightlist
\item
  Ambiguity of units: Is \texttt{100} dollars, euros, or yen? Is
  \texttt{5} in miles or kilometers?
\item
  Range issues: Asking for ``temperature = -500'' makes no sense.
\item
  Precision errors: Computers sometimes struggle with very large, very
  small, or fractional numbers.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-11}

Think of a vending machine algorithm. Define at least two number inputs
it might need (for example: amount of money inserted, product code).
What outputs would you expect from those inputs?

\subsubsection{Key Takeaway}\label{key-takeaway-10}

Numbers are the simplest, clearest form of input---precise, measurable,
and unambiguous when used correctly. They are the language of certainty
in algorithms, forming the foundation for more complex data types.

\subsection{13. Text and Strings as
Inputs}\label{text-and-strings-as-inputs}

Text is another common type of input. Unlike numbers, which represent
quantities, strings (sequences of characters) represent language,
labels, and symbols. Algorithms often need to process text: searching
for a word, comparing names, or transforming lowercase into uppercase.

While text feels natural to humans, it's trickier for machines.
Computers don't understand ``meaning,'' only sequences of characters.
That's why defining text inputs clearly---what alphabet, what encoding,
what rules---matters as much as for numbers.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-12}

Imagine a necklace of beads, where each bead is a letter. The necklace
``H-E-L-L-O'' is a string. An algorithm can:

\begin{itemize}
\tightlist
\item
  Count the beads (length of the string).
\item
  Replace beads (``H'' → ``J'' makes ``JELLO'').
\item
  Search for a bead pattern (``LL'' appears in the middle).
\end{itemize}

Every text algorithm treats strings like bead sequences.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-11}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Input: a string}
\CommentTok{\# Output: reversed string}
\KeywordTok{def}\NormalTok{ reverse\_text(s):}
    \ControlFlowTok{return}\NormalTok{ s[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(reverse\_text(}\StringTok{"hello"}\NormalTok{))  }\CommentTok{\# Output: "olleh"}
\end{Highlighting}
\end{Shaded}

This shows how an algorithm can manipulate characters without
``understanding'' them.

\subsubsection{Everyday Examples}\label{everyday-examples-11}

\begin{itemize}
\tightlist
\item
  Passwords: input is a string of characters checked for validity.
\item
  Search bars: input is text, output is matching results.
\item
  Chat apps: input is a message string, output is delivery to a
  recipient.
\item
  File names: treated as text for storage and retrieval.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-10}

\begin{itemize}
\tightlist
\item
  Text inputs are everywhere in human--computer interaction.
\item
  Many real problems---names, addresses, sentences---are inherently
  text-based.
\item
  Algorithms must handle formatting differences (case sensitivity,
  whitespace, punctuation).
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-9}

\begin{itemize}
\tightlist
\item
  Encoding errors: a name like ``José'' may break if the system expects
  plain ASCII.
\item
  Ambiguity: ``apple'' could mean the fruit or the company---machines
  don't know.
\item
  Case sensitivity: ``Hello'' vs.~``hello'' may be treated as different
  unless specified.
\item
  Input validation: text boxes may allow invalid characters (e.g.,
  letters in a phone number field).
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-12}

Design an algorithm that takes a sentence as input and counts how many
words are in it.

\begin{itemize}
\tightlist
\item
  Input: \texttt{"The\ quick\ brown\ fox\ jumps"}
\item
  Output: \texttt{5}
\end{itemize}

Write the steps in plain language before coding.

\subsubsection{Key Takeaway}\label{key-takeaway-11}

Text inputs open algorithms to the world of language, labels, and
communication. Though more complex than numbers, they are essential
because most human information is expressed as strings. Algorithms must
treat them with care---precisely defined rules for characters, encoding,
and comparison.

\subsection{14. Collections of Data: Lists,
Tables}\label{collections-of-data-lists-tables}

Numbers and text are useful on their own, but many problems involve
groups of items. That's where collections come in. A list is an ordered
sequence of elements, like a shopping list or a playlist. A table is a
structured grid of rows and columns, like a spreadsheet.

Collections let algorithms process many items at once---sorting them,
searching through them, or combining them. They are the foundation of
data handling, turning single inputs into sets of information that can
be explored and transformed.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-13}

\begin{itemize}
\tightlist
\item
  A list is like a line of lockers: each locker has a number (index) and
  contains an item.
\item
  A table is like a chessboard: rows and columns form cells, each
  holding a piece of information.
\end{itemize}

Algorithms can walk down the row of lockers (list traversal) or scan
across the chessboard (table traversal).

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-12}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Input: a list of numbers}
\CommentTok{\# Output: their average}
\KeywordTok{def}\NormalTok{ average(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(nums)}

\BuiltInTok{print}\NormalTok{(average([}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{]))  }\CommentTok{\# Output: 20}

\CommentTok{\# Input: a table of (name, age) pairs}
\NormalTok{people }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    [}\StringTok{"Alice"}\NormalTok{, }\DecValTok{21}\NormalTok{],}
\NormalTok{    [}\StringTok{"Bob"}\NormalTok{, }\DecValTok{19}\NormalTok{],}
\NormalTok{    [}\StringTok{"Cara"}\NormalTok{, }\DecValTok{22}\NormalTok{]}
\NormalTok{]}

\CommentTok{\# Find the oldest person}
\NormalTok{oldest }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(people, key}\OperatorTok{=}\KeywordTok{lambda}\NormalTok{ row: row[}\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(oldest)  }\CommentTok{\# Output: ["Cara", 22]}
\end{Highlighting}
\end{Shaded}

\subsubsection{Everyday Examples}\label{everyday-examples-12}

\begin{itemize}
\item
  Lists:

  \begin{itemize}
  \tightlist
  \item
    To-do tasks for the day.
  \item
    Playlist of favorite songs.
  \item
    Queue of customers waiting.
  \end{itemize}
\item
  Tables:

  \begin{itemize}
  \tightlist
  \item
    School gradebook (student × subject).
  \item
    Bank ledger (date × transaction × amount).
  \item
    Calendar grid (day × month).
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-11}

\begin{itemize}
\tightlist
\item
  Lists preserve order---useful when sequence matters (e.g., playback
  order).
\item
  Tables preserve structure---useful when relationships matter (e.g.,
  student name tied to grade).
\item
  Many algorithms rely on iterating over collections efficiently, rather
  than handling data one element at a time.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-10}

\begin{itemize}
\tightlist
\item
  Empty collections: asking for the max of an empty list causes errors.
\item
  Index confusion: forgetting whether the first item is position 0 or 1.
\item
  Table mismatch: rows with missing or inconsistent columns cause
  failures.
\item
  Scalability: collections that work for 10 items may break for 10
  million.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-13}

Take the list of numbers \texttt{{[}3,\ 7,\ 2,\ 9,\ 4{]}}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Find the sum.
\item
  Find the max.
\item
  Count how many are greater than 5.
\end{enumerate}

Then, imagine a table of students with columns (Name, Age). How would
you design an algorithm to find the youngest student?

\subsubsection{Key Takeaway}\label{key-takeaway-12}

Collections---lists and tables---are how algorithms handle many pieces
of data at once. Lists give order, tables give structure. Mastering them
unlocks the ability to process real-world information at scale.

\subsection{15. Outputs as Answers, Actions, or New
Data}\label{outputs-as-answers-actions-or-new-data}

Every algorithm produces an output---something that comes out after the
steps are finished. Outputs can take different forms depending on the
problem:

\begin{itemize}
\tightlist
\item
  An answer: the solution to a question (e.g., ``What is 2 + 2?'' → 4).
\item
  An action: something that changes the world (e.g., turn on the lights,
  send a message).
\item
  New data: a transformed version of the input (e.g., sorting a list,
  compressing a file).
\end{itemize}

Clearly defining the output is as important as defining the input. It
tells us when the algorithm has succeeded and what ``done'' means.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-14}

Imagine a mailbox. You put in a letter (input), the postal system
processes it (algorithm), and eventually, something arrives in another
mailbox (output). The type of output---whether it's a message, a
package, or just a notification---depends on the system's design.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-13}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example 1: Output as an answer}
\KeywordTok{def}\NormalTok{ add(a, b):}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b   }\CommentTok{\# Answer: sum}

\CommentTok{\# Example 2: Output as an action}
\KeywordTok{def}\NormalTok{ print\_greeting(name):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Hello,"}\NormalTok{, name)  }\CommentTok{\# Action: displays text}

\CommentTok{\# Example 3: Output as new data}
\KeywordTok{def}\NormalTok{ reverse\_list(lst):}
    \ControlFlowTok{return}\NormalTok{ lst[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]   }\CommentTok{\# New data: reversed list}
\end{Highlighting}
\end{Shaded}

Each case shows a different ``flavor'' of output.

\subsubsection{Everyday Examples}\label{everyday-examples-13}

\begin{itemize}
\item
  Answer:

  \begin{itemize}
  \tightlist
  \item
    A calculator returning 256 when asked 16 × 16.
  \item
    A search engine giving a ranked list of results.
  \end{itemize}
\item
  Action:

  \begin{itemize}
  \tightlist
  \item
    Pressing a button to start an elevator.
  \item
    Sending a text message to a friend.
  \end{itemize}
\item
  New data:

  \begin{itemize}
  \tightlist
  \item
    Sorting photos by date.
  \item
    Translating a paragraph from English to French.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-12}

\begin{itemize}
\tightlist
\item
  Outputs must be predictable: if you ask for the maximum number, you
  expect exactly one number, not ``maybe something.''
\item
  Outputs must be useful: an algorithm that processes data but doesn't
  return or act on it is incomplete.
\item
  Outputs define the contract between user and algorithm: ``If you give
  me this input, I guarantee this output.''
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-11}

\begin{itemize}
\tightlist
\item
  Undefined outputs: an algorithm that doesn't specify what happens in
  edge cases (e.g., max of an empty list).
\item
  Overloaded outputs: giving too much at once (mixing numbers, text, and
  errors without clarity).
\item
  Silent outputs: doing work but giving no visible result, leaving the
  user confused.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-14}

Pick one task---say \emph{``check if a number is even.''}

\begin{itemize}
\item
  Define the input clearly (one integer).
\item
  Define the output as:

  \begin{itemize}
  \tightlist
  \item
    Answer: true or false.
  \item
    Action: print ``even'' or ``odd.''
  \item
    New data: a string ``even'' or ``odd'' returned to the caller.
  \end{itemize}
\end{itemize}

Notice how the same problem can yield different types of outputs
depending on design.

\subsubsection{Key Takeaway}\label{key-takeaway-13}

Outputs are the visible footprint of an algorithm. They can be answers,
actions, or new data, but they must always be clearly defined, reliable,
and aligned with the problem the algorithm is meant to solve.

\subsection{16. Implicit Assumptions: Units,
Formats}\label{implicit-assumptions-units-formats}

Even when inputs and outputs are clearly defined, algorithms often hide
assumptions about how the data is represented. These are the units and
formats attached to values. If assumptions are not made explicit,
algorithms may fail silently or give wrong results.

\begin{itemize}
\tightlist
\item
  Units: ``100'' could mean 100 meters, 100 feet, or 100 seconds.
\item
  Formats: ``01/02/2025'' could mean January 2nd or February 1st,
  depending on region.
\end{itemize}

Humans are good at guessing context, but algorithms cannot. They need
unambiguous definitions.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-15}

Imagine two people using a measuring tape: one side marked in inches,
the other in centimeters. If they don't agree which side to use, their
results won't match. Similarly, if two programs exchange data without
agreeing on units or formats, chaos follows.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-14}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Implicit assumption: input is Celsius}
\KeywordTok{def}\NormalTok{ to\_fahrenheit(temp\_c):}
    \ControlFlowTok{return}\NormalTok{ (temp\_c }\OperatorTok{*} \DecValTok{9}\OperatorTok{/}\DecValTok{5}\NormalTok{) }\OperatorTok{+} \DecValTok{32}

\BuiltInTok{print}\NormalTok{(to\_fahrenheit(}\DecValTok{0}\NormalTok{))   }\CommentTok{\# Output: 32 (correct if input was Celsius)}
\BuiltInTok{print}\NormalTok{(to\_fahrenheit(}\DecValTok{32}\NormalTok{))  }\CommentTok{\# Wrong if input was Fahrenheit already!}
\end{Highlighting}
\end{Shaded}

The function works only if the input follows the assumed unit.
Otherwise, the result is meaningless.

\subsubsection{Everyday Examples}\label{everyday-examples-14}

\begin{itemize}
\tightlist
\item
  Temperature: 30° could be hot (Celsius) or freezing (Fahrenheit).
\item
  Time: 12:30 could be noon or midnight in 24-hour vs.~12-hour formats.
\item
  Money: 1,000 could mean dollars, euros, or yen.
\item
  Phone numbers: with or without country codes.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-13}

\begin{itemize}
\tightlist
\item
  In science and engineering, unit mistakes can be catastrophic. NASA
  famously lost a Mars orbiter because one team used pounds and another
  used newtons.
\item
  In finance, mixing up currency leads to massive miscalculations.
\item
  In data exchange, mismatched formats (e.g., commas vs.~dots for
  decimals) cause errors in spreadsheets and databases.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-12}

\begin{itemize}
\tightlist
\item
  Assuming defaults: believing everyone uses the same unit or format.
\item
  Silent failures: algorithms run but produce nonsense results.
\item
  Inconsistent conventions: different parts of a system use different
  standards.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-15}

Write down your height in two formats: centimeters and feet/inches.
Imagine giving just the number ``180'' to an algorithm. What different
outputs could result if the algorithm assumed centimeters vs.~inches?

\subsubsection{Key Takeaway}\label{key-takeaway-14}

Implicit assumptions about units and formats are invisible bugs waiting
to happen. Good algorithms make these assumptions explicit and
consistent, ensuring that data means the same thing everywhere it goes.

\subsection{17. When Inputs Are Missing or
Malformed}\label{when-inputs-are-missing-or-malformed}

Not every input arrives neat and perfect. Sometimes inputs are missing
(no value at all), and sometimes they are malformed (present, but in the
wrong shape or type). Robust algorithms must decide: what to do when the
data is incomplete or broken?

\begin{itemize}
\tightlist
\item
  Missing input: asking for age but nothing is given.
\item
  Malformed input: expecting a number but getting ``twenty-one.''
\item
  Wrong shape: expecting a list of scores but receiving just one score.
\end{itemize}

Handling these cases separates fragile algorithms from reliable ones.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-16}

Imagine trying to bake a cake:

\begin{itemize}
\tightlist
\item
  If eggs are missing, you can't follow the recipe.
\item
  If someone gives you a box labeled ``eggs'' but inside are apples, the
  recipe fails.
\item
  If they give you one egg when the recipe needs three, you're
  under-supplied.
\end{itemize}

Algorithms face the same problems with data.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-15}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ safe\_divide(a, b):}
    \CommentTok{\# Handle missing inputs}
    \ControlFlowTok{if}\NormalTok{ a }\KeywordTok{is} \VariableTok{None} \KeywordTok{or}\NormalTok{ b }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
        \ControlFlowTok{return} \StringTok{"Error: missing input"}
    
    \CommentTok{\# Handle malformed input}
    \ControlFlowTok{if} \KeywordTok{not} \BuiltInTok{isinstance}\NormalTok{(a, (}\BuiltInTok{int}\NormalTok{, }\BuiltInTok{float}\NormalTok{)) }\KeywordTok{or} \KeywordTok{not} \BuiltInTok{isinstance}\NormalTok{(b, (}\BuiltInTok{int}\NormalTok{, }\BuiltInTok{float}\NormalTok{)):}
        \ControlFlowTok{return} \StringTok{"Error: invalid type"}
    
    \CommentTok{\# Handle invalid values}
    \ControlFlowTok{if}\NormalTok{ b }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \ControlFlowTok{return} \StringTok{"Error: cannot divide by zero"}
    
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}

\BuiltInTok{print}\NormalTok{(safe\_divide(}\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{))   }\CommentTok{\# Output: 5.0}
\BuiltInTok{print}\NormalTok{(safe\_divide(}\VariableTok{None}\NormalTok{, }\DecValTok{2}\NormalTok{)) }\CommentTok{\# Error: missing input}
\BuiltInTok{print}\NormalTok{(safe\_divide(}\DecValTok{10}\NormalTok{, }\StringTok{"two"}\NormalTok{)) }\CommentTok{\# Error: invalid type}
\end{Highlighting}
\end{Shaded}

\subsubsection{Everyday Examples}\label{everyday-examples-15}

\begin{itemize}
\tightlist
\item
  Web forms: users submit without filling required fields.
\item
  Spreadsheets: cells contain ``N/A'' or mixed text in a numeric column.
\item
  Sensors: devices fail to record a reading, or report corrupted values.
\item
  Communication: missing attachments in an email, or unreadable file
  formats.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-14}

\begin{itemize}
\tightlist
\item
  In finance, missing data can skew reports or predictions.
\item
  In healthcare, malformed input (wrong units, wrong numbers) can lead
  to life-threatening errors.
\item
  In user interfaces, poor handling of bad input frustrates users or
  makes systems unsafe.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-13}

\begin{itemize}
\tightlist
\item
  Ignoring edge cases: assuming inputs are always correct.
\item
  Silent failures: returning wrong results instead of error messages.
\item
  Overly harsh rejections: discarding all data because of one bad entry.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-16}

Design an algorithm for ``finding the average test score.''

\begin{itemize}
\tightlist
\item
  What happens if one student forgot to enter their score?
\item
  What happens if one score is ``eighty'' instead of \texttt{80}? Decide
  how your algorithm should behave in each case---skip, correct, or
  report error.
\end{itemize}

\subsubsection{Key Takeaway}\label{key-takeaway-15}

Inputs are rarely perfect. Algorithms must be defensive---detecting,
rejecting, or repairing missing and malformed data. Reliability comes
not just from correct logic, but from gracefully handling the messy
edges of reality.

\subsection{18. Predicting Possible
Outputs}\label{predicting-possible-outputs}

Before running an algorithm, you should be able to predict the range of
outputs it might produce. This helps set expectations and detect when
something goes wrong. Algorithms are like machines---you want to know
what kinds of results can come out, even if you don't know the exact one
yet.

For example:

\begin{itemize}
\tightlist
\item
  A search algorithm may return zero, one, or many results.
\item
  A yes/no check will always return true or false.
\item
  A sorting algorithm will always return a list with the same items, but
  in order.
\end{itemize}

Thinking ahead about possible outputs turns surprises into prepared
cases.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-17}

Imagine a vending machine with a label: \emph{``Possible outputs: chips,
soda, candy bar.''} If a shoe suddenly drops out, you know something is
broken. Algorithms are the same---knowing the valid outputs makes it
easy to spot invalid ones.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-16}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Check if number is even}
\KeywordTok{def}\NormalTok{ is\_even(n):}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \ControlFlowTok{return} \VariableTok{True}   \CommentTok{\# valid output}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return} \VariableTok{False}  \CommentTok{\# valid output}

\CommentTok{\# Predictable: only True or False}
\BuiltInTok{print}\NormalTok{(is\_even(}\DecValTok{4}\NormalTok{))  }\CommentTok{\# True}
\BuiltInTok{print}\NormalTok{(is\_even(}\DecValTok{7}\NormalTok{))  }\CommentTok{\# False}
\end{Highlighting}
\end{Shaded}

By design, this algorithm has exactly two possible outputs.

\subsubsection{Everyday Examples}\label{everyday-examples-16}

\begin{itemize}
\tightlist
\item
  Elevator control: outputs are only valid floor numbers, nothing else.
\item
  Online payment: outputs may be ``success,'' ``failure,'' or
  ``pending.''
\item
  Weather forecast: outputs are limited to categories (sunny, cloudy,
  rainy, snowy).
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-15}

\begin{itemize}
\tightlist
\item
  Testing: If you know the range of valid outputs, you can quickly see
  if something went outside it.
\item
  Safety: Medical software should never output a negative dosage.
\item
  User experience: Clear, expected outputs prevent confusion (``login
  failed'' vs.~crashing silently).
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-14}

\begin{itemize}
\tightlist
\item
  Forgetting edge outputs: A search returning ``no results'' is as valid
  as finding many.
\item
  Overly broad outputs: Allowing too many undefined cases makes the
  algorithm unreliable.
\item
  Mismatched assumptions: One system expects ``success/fail,'' another
  expects ``yes/no''---integration breaks.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-17}

Think of an algorithm that takes a student's exam score (0--100) and
outputs a grade.

\begin{itemize}
\tightlist
\item
  Predict the possible outputs (A, B, C, D, F).
\item
  What should happen if the score is 105 or --3?
\end{itemize}

Write the rule for valid vs.~invalid outputs.

\subsubsection{Key Takeaway}\label{key-takeaway-16}

Good algorithms have predictable output spaces. By defining in advance
what results are possible---and ruling out the impossible---you ensure
reliability, safety, and clarity in every use.

\subsection{19. Framing Algorithms as Input → Process →
Output}\label{framing-algorithms-as-input-process-output}

At the heart of every algorithm is a simple, universal pattern: Input →
Process → Output.

\begin{itemize}
\tightlist
\item
  Input: the raw material, the information provided.
\item
  Process: the step-by-step instructions applied to the input.
\item
  Output: the result produced after the process.
\end{itemize}

This framing works for every kind of algorithm, from adding two numbers
to running a global search engine. Thinking in this way makes algorithms
less abstract---they're just machines that transform inputs into outputs
through a defined process.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-18}

Visualize a factory line:

\begin{itemize}
\tightlist
\item
  Trucks bring in raw materials (inputs).
\item
  Machines work on them in stages (process).
\item
  A finished product rolls out at the end (output).
\end{itemize}

The factory metaphor makes it clear that the process is not magic---it's
a predictable transformation.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-17}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: calculate average of numbers}
\KeywordTok{def}\NormalTok{ average(nums):           }\CommentTok{\# Input: list of numbers}
\NormalTok{    total }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(nums)        }\CommentTok{\# Process: add them up}
    \ControlFlowTok{return}\NormalTok{ total }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(nums) }\CommentTok{\# Output: one number (average)}

\BuiltInTok{print}\NormalTok{(average([}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{])) }\CommentTok{\# Output: 20}
\end{Highlighting}
\end{Shaded}

This maps directly: numbers go in, they're processed, and a single value
comes out.

\subsubsection{Everyday Examples}\label{everyday-examples-17}

\begin{itemize}
\item
  Cooking:

  \begin{itemize}
  \tightlist
  \item
    Input: raw ingredients.
  \item
    Process: chop, mix, cook.
  \item
    Output: meal on the plate.
  \end{itemize}
\item
  School grading:

  \begin{itemize}
  \tightlist
  \item
    Input: student scores.
  \item
    Process: apply weighting and formulas.
  \item
    Output: final grade.
  \end{itemize}
\item
  Navigation app:

  \begin{itemize}
  \tightlist
  \item
    Input: starting point and destination.
  \item
    Process: map lookup and path calculation.
  \item
    Output: step-by-step route.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-16}

\begin{itemize}
\tightlist
\item
  Helps communicate algorithms simply: even non-technical people
  understand the flow of input → process → output.
\item
  Makes it easier to design new algorithms by asking: ``What do I start
  with? What do I want to end with? What steps connect them?''
\item
  Clarifies responsibilities: inputs must be valid, process must be
  defined, outputs must be predictable.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-15}

\begin{itemize}
\tightlist
\item
  Unclear inputs: the process cannot even begin if the starting point is
  ambiguous.
\item
  Vague processes: ``do the calculation'' is not enough detail.
\item
  Undefined outputs: if the result isn't specified, nobody knows when
  the algorithm is done.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-18}

Pick one everyday task---say \emph{``making tea.''} Frame it as:

\begin{itemize}
\tightlist
\item
  Input: water, teabag, cup.
\item
  Process: boil water → steep teabag → wait 3 minutes.
\item
  Output: a cup of tea.
\end{itemize}

Now write another for a school assignment or a small household chore.

\subsubsection{Key Takeaway}\label{key-takeaway-17}

Framing algorithms as Input → Process → Output is the simplest way to
understand them. It's a universal pattern that works from the tiniest
function to the most complex system. Every algorithm, at its core, is
just a transformation.

\subsection{20. Simple Examples: Sum of a List, Reverse
Text}\label{simple-examples-sum-of-a-list-reverse-text}

The best way to see the input → process → output model in action is
through small, concrete examples. Two classics are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Sum of a list: take a collection of numbers and add them up.
\item
  Reverse text: take a word or sentence and flip the order of its
  characters.
\end{enumerate}

These are simple enough for beginners, yet powerful because they capture
the essence of what all algorithms do---transform inputs into outputs
through clear, repeatable steps.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-19}

\begin{itemize}
\tightlist
\item
  Sum of a list: imagine coins on a table. You push them into one pile,
  counting as you go. The pile at the end is the total.
\item
  Reverse text: imagine writing a word on a strip of paper, then holding
  it up to a mirror. The letters appear in the opposite order.
\end{itemize}

\subsubsection{Tiny Code Recipes}\label{tiny-code-recipes-1}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example 1: Sum of a list}
\KeywordTok{def}\NormalTok{ sum\_list(numbers):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\BuiltInTok{print}\NormalTok{(sum\_list([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]))  }\CommentTok{\# Output: 10}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example 2: Reverse text}
\KeywordTok{def}\NormalTok{ reverse\_text(s):}
    \ControlFlowTok{return}\NormalTok{ s[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(reverse\_text(}\StringTok{"hello"}\NormalTok{))   }\CommentTok{\# Output: "olleh"}
\end{Highlighting}
\end{Shaded}

Both show clearly: input goes in, a process happens, and an output comes
out.

\subsubsection{Everyday Examples}\label{everyday-examples-18}

\begin{itemize}
\item
  Sum:

  \begin{itemize}
  \tightlist
  \item
    Adding up prices in a shopping cart.
  \item
    Calculating total distance traveled.
  \item
    Counting total votes in an election.
  \end{itemize}
\item
  Reverse:

  \begin{itemize}
  \tightlist
  \item
    Reading palindromes (``racecar'' stays the same).
  \item
    Undoing typing mistakes by backspacing.
  \item
    Flipping the order of a phone number for a secret code.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-17}

\begin{itemize}
\tightlist
\item
  These examples introduce core patterns like looping through a list and
  indexing characters in a string.
\item
  They scale: summing can grow into averages, variances, or totals
  across big datasets. Reversing text is a first step toward more
  advanced text-processing tasks.
\item
  They are easy to test: you can predict the output and immediately
  verify correctness.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-16}

\begin{itemize}
\tightlist
\item
  Forgetting to handle empty inputs (\texttt{{[}{]}} or \texttt{""}).
\item
  Mixing data types (trying to sum numbers and words together).
\item
  Ignoring character encoding (reversing text with special characters
  like emojis may behave unexpectedly).
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-19}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three numbers: 7, 11, 14. Add them step by step on paper,
  then compare with an algorithm's result.
\item
  Write your name, then spell it backward. Compare with what an
  algorithm produces.
\end{enumerate}

\subsubsection{Key Takeaway}\label{key-takeaway-18}

Simple examples like sum of a list and reverse text are more than
exercises. They are archetypes: small windows into how algorithms turn
raw input into meaningful output, paving the way for more complex
procedures.

\section{Chapter 3. Deterministic and non deterministic
behavior}\label{chapter-3.-deterministic-and-non-deterministic-behavior}

\subsection{21. Deterministic: Same Input, Same
Output}\label{deterministic-same-input-same-output}

A deterministic algorithm always produces the same result when given the
same input. There is no surprise or randomness---just predictable,
repeatable behavior.

This property is what makes algorithms reliable. If you run
\texttt{2\ +\ 3} today or next year, you'll always get \texttt{5}.
Determinism is the foundation for trust in systems like calculators,
banking software, and navigation tools. Without it, correctness would be
impossible to guarantee.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-20}

Think of a vending machine that always gives you the same soda when you
press the same button. Every time you choose ``C2,'' you know exactly
what to expect. That's determinism: consistent cause and effect.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-18}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Deterministic function: square of a number}
\KeywordTok{def}\NormalTok{ square(n):}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n}

\BuiltInTok{print}\NormalTok{(square(}\DecValTok{4}\NormalTok{))   }\CommentTok{\# Always 16}
\BuiltInTok{print}\NormalTok{(square(}\DecValTok{4}\NormalTok{))   }\CommentTok{\# Still 16, no matter how many times}
\end{Highlighting}
\end{Shaded}

No randomness, no variation---just repeatable output.

\subsubsection{Everyday Examples}\label{everyday-examples-19}

\begin{itemize}
\tightlist
\item
  Math problems: multiplying 7 × 8 always gives 56.
\item
  Sorting names: the same list sorted today will look identical
  tomorrow.
\item
  Password check: same password string → same login result.
\item
  Maps: same start and destination → same shortest path (assuming fixed
  data).
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-18}

\begin{itemize}
\tightlist
\item
  Correctness: Scientific simulations, accounting systems, and legal
  records must give consistent results.
\item
  Testing: Determinism allows you to compare expected and actual outputs
  reliably.
\item
  Trust: Users depend on the idea that systems behave the same way every
  time.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-17}

\begin{itemize}
\tightlist
\item
  Hidden nondeterminism: algorithms may look deterministic but depend on
  environment (e.g., reading the current time, order of files).
\item
  Floating-point quirks: results can differ slightly between machines,
  breaking strict determinism.
\item
  Assuming determinism where none exists: e.g., thinking shuffling a
  playlist will always give the same order.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-20}

Pick one everyday task, like calculating the total price of groceries.
Write down the algorithm in steps. Then run it twice with the exact same
prices. Did you get the same total both times? That's determinism in
action.

\subsubsection{Key Takeaway}\label{key-takeaway-19}

Deterministic algorithms are predictable and repeatable: same input,
same output. They form the backbone of reliable computing, allowing
systems to be tested, trusted, and reused without surprises.

\subsection{22. Randomness in Daily Life: Dice,
Shuffling}\label{randomness-in-daily-life-dice-shuffling}

Unlike deterministic steps, randomness introduces unpredictability.
Rolling a die or shuffling a deck of cards are everyday examples: you
know the possible outcomes, but you cannot know which one will appear in
advance.

Algorithms sometimes use randomness deliberately---either to explore
many possibilities quickly or to make results less predictable.
Randomness doesn't mean chaos; it means controlled uncertainty within
defined boundaries.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-21}

Think of a lottery machine: numbered balls spin inside, and one pops
out. You can't predict which ball will appear, but you know it will
always be one of the valid numbers. Randomness is like shaking the box
of possibilities and letting one fall out.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-19}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\CommentTok{\# Simulate rolling a six{-}sided die}
\KeywordTok{def}\NormalTok{ roll\_die():}
    \ControlFlowTok{return}\NormalTok{ random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(roll\_die())  }\CommentTok{\# Could be any number 1–6}
\BuiltInTok{print}\NormalTok{(roll\_die())  }\CommentTok{\# Different each time}
\end{Highlighting}
\end{Shaded}

The input (nothing) is the same, but the output varies---by design.

\subsubsection{Everyday Examples}\label{everyday-examples-20}

\begin{itemize}
\tightlist
\item
  Games: dice rolls, shuffled cards, or random spins keep games fair and
  exciting.
\item
  Music apps: shuffle mode plays songs in unpredictable order.
\item
  Lottery: random draws ensure no one can guarantee the result.
\item
  Security: random numbers generate unique passwords and encryption
  keys.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-19}

\begin{itemize}
\tightlist
\item
  Randomness adds fairness: everyone has an equal chance in a lottery.
\item
  It prevents predictability: shuffling cards stops players from
  memorizing order.
\item
  It supports exploration: randomized algorithms can try different paths
  without bias.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-18}

\begin{itemize}
\tightlist
\item
  Fake randomness: some ``random'' generators aren't truly random, just
  repeating patterns.
\item
  Unfair distributions: if dice are weighted or shuffling is biased,
  outcomes are not truly random.
\item
  Overuse: randomness without reason makes algorithms unreliable instead
  of helpful.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-21}

Shuffle a deck of cards (or write the numbers 1--10 on paper and mix
them). Note the order. Shuffle again. Did you get the same sequence?
Probably not---that's randomness. Now think: if an algorithm had to
shuffle, what rules must it follow to make every order equally likely?

\subsubsection{Key Takeaway}\label{key-takeaway-20}

Randomness introduces unpredictability within limits. While
deterministic steps ensure reliability, random ones provide fairness,
variety, and exploration---making algorithms more flexible in uncertain
worlds.

\subsection{23. Nondeterministic Steps in
Algorithms}\label{nondeterministic-steps-in-algorithms}

A nondeterministic step is one where the algorithm doesn't guarantee the
same outcome every time, even with the same input. This doesn't mean
it's broken---it just means the process involves choice or uncertainty.

In theory, nondeterministic algorithms can ``magically'' pick the right
path among many possibilities. In practice, computers simulate this by
using randomness or by exploring many paths in parallel. These steps are
useful when problems are too large or complex to solve by brute force
alone.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-22}

Imagine standing at a fork in the road with multiple paths leading into
a forest.

\begin{itemize}
\tightlist
\item
  A deterministic traveler always chooses the left path.
\item
  A nondeterministic traveler might pick left today, right tomorrow, or
  even ``both at once'' if they could clone themselves.
\end{itemize}

Nondeterminism is about allowing multiple futures instead of just one.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-20}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\CommentTok{\# Nondeterministic choice: pick any element}
\KeywordTok{def}\NormalTok{ choose\_random(items):}
    \ControlFlowTok{return}\NormalTok{ random.choice(items)}

\NormalTok{options }\OperatorTok{=}\NormalTok{ [}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(choose\_random(options))  }\CommentTok{\# Could be "A", "B", or "C"}
\end{Highlighting}
\end{Shaded}

The same input list produces different outputs depending on the step
chosen.

\subsubsection{Everyday Examples}\label{everyday-examples-21}

\begin{itemize}
\tightlist
\item
  Guessing games: picking a card without knowing which one.
\item
  Search engines: when many equally good results exist, order may vary.
\item
  Scheduling: assigning jobs to workers where several options are valid.
\item
  Optimization: trying random configurations until a good one is found.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-20}

\begin{itemize}
\tightlist
\item
  Nondeterminism allows algorithms to explore possibilities quickly
  instead of being stuck with one rigid path.
\item
  It's essential in areas like artificial intelligence, cryptography,
  and optimization problems.
\item
  In theoretical computer science, nondeterminism is used to define
  complexity classes (like NP problems).
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-19}

\begin{itemize}
\tightlist
\item
  Unpredictability: makes debugging harder, since results differ across
  runs.
\item
  Reproducibility issues: scientific experiments need fixed seeds to
  reproduce random behavior.
\item
  False assumptions: treating nondeterministic outputs as deterministic
  can cause failures.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-22}

Design a simple algorithm for ``picking tonight's dinner.''

\begin{itemize}
\tightlist
\item
  Deterministic: always choose the cheapest option.
\item
  Nondeterministic: flip a coin to decide between pizza and sushi.
\end{itemize}

Run it multiple times. Do you get the same answer every time? Why or why
not?

\subsubsection{Key Takeaway}\label{key-takeaway-21}

Nondeterministic steps introduce choice and uncertainty into algorithms.
While they reduce predictability, they expand flexibility---allowing
algorithms to tackle problems where strict determinism is too slow or
too limiting.

\subsection{24. Why Determinism Matters for
Correctness}\label{why-determinism-matters-for-correctness}

Correctness in algorithms means reliable, predictable behavior: if the
same input is given, the same output must follow. This is only possible
when the algorithm is deterministic. If outputs vary unpredictably, you
can't guarantee correctness, only probability.

Imagine a bank transfer: you want certainty that sending \$100 always
subtracts exactly \$100 from one account and adds exactly \$100 to
another. If the algorithm sometimes transfers \$99 or \$101, correctness
is lost, and trust collapses.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-23}

Think of a weighing scale: if you put the same object on the scale, the
reading should always match. A deterministic scale gives the same weight
every time. A nondeterministic one would show 1kg now, 1.2kg later, and
0.9kg tomorrow. Nobody would call it ``correct.''

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-21}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Deterministic addition}
\KeywordTok{def}\NormalTok{ add(a, b):}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}

\BuiltInTok{print}\NormalTok{(add(}\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{))  }\CommentTok{\# Always 12}

\CommentTok{\# Bad example: pretending to add but injecting randomness}
\ImportTok{import}\NormalTok{ random}
\KeywordTok{def}\NormalTok{ unreliable\_add(a, b):}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{+}\NormalTok{ random.choice([}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(unreliable\_add(}\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{))  }\CommentTok{\# Could be 11, 12, or 13 (not correct!)}
\end{Highlighting}
\end{Shaded}

The first is correct by definition. The second cannot be called correct
because it doesn't guarantee the promised result.

\subsubsection{Everyday Examples}\label{everyday-examples-22}

\begin{itemize}
\tightlist
\item
  Medicine dosage: algorithms must output exact doses---deterministic
  and safe.
\item
  Airline ticketing: booking the same seat should always give the same
  confirmation, not change randomly.
\item
  Traffic lights: red must always mean stop, green must always mean
  go---predictable every time.
\item
  Tax calculation: same income should yield the same tax owed, without
  variation.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-21}

\begin{itemize}
\tightlist
\item
  Testing and verification: correctness checks depend on determinism;
  otherwise, results can't be compared.
\item
  Safety-critical systems: cars, planes, hospitals all rely on
  predictable algorithms.
\item
  Trust: users won't trust systems that behave differently on identical
  inputs.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-20}

\begin{itemize}
\tightlist
\item
  Hidden nondeterminism: floating-point rounding may differ on different
  machines.
\item
  Parallelism: race conditions can make results vary even if the logic
  is deterministic.
\item
  Misuse of randomness: injecting randomness where it doesn't belong
  breaks correctness.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-23}

Pick a small deterministic algorithm---like reversing a string. Run it
three times with the same input. Did you always get the same result? Now
imagine if sometimes the string came back scrambled---would you still
call it correct?

\subsubsection{Key Takeaway}\label{key-takeaway-22}

Determinism is the backbone of correctness. Without it, algorithms can't
make promises or guarantees. Correctness means: \emph{same input, same
output, every time.}

\subsection{25. Why Randomness Can Still Be
Useful}\label{why-randomness-can-still-be-useful}

Although determinism is vital for correctness, randomness has a special
role in algorithms. It can make certain tasks faster, fairer, or simpler
than purely deterministic methods. Randomness isn't about being
sloppy---it's about introducing controlled unpredictability where it
helps.

For some problems, a fully deterministic approach may be too slow or
complicated. A randomized algorithm can give a good answer quickly, even
if it doesn't guarantee the same result every run.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-24}

Think of searching for a needle in a haystack:

\begin{itemize}
\tightlist
\item
  A deterministic approach checks straw by straw, one after another.
\item
  A randomized approach pokes randomly in different spots, hoping to
  strike the needle faster.
\end{itemize}

It doesn't guarantee success immediately, but over time it often finds
the answer efficiently.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-22}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\CommentTok{\# Randomized quicksort: choose pivot randomly}
\KeywordTok{def}\NormalTok{ quicksort(arr):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(arr) }\OperatorTok{\textless{}=} \DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ arr}
\NormalTok{    pivot }\OperatorTok{=}\NormalTok{ random.choice(arr)       }\CommentTok{\# Random step}
\NormalTok{    left  }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ arr }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}}\NormalTok{ pivot]}
\NormalTok{    mid   }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ arr }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==}\NormalTok{ pivot]}
\NormalTok{    right }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ arr }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}}\NormalTok{ pivot]}
    \ControlFlowTok{return}\NormalTok{ quicksort(left) }\OperatorTok{+}\NormalTok{ mid }\OperatorTok{+}\NormalTok{ quicksort(right)}

\BuiltInTok{print}\NormalTok{(quicksort([}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

Here randomness avoids worst-case patterns that could slow the algorithm
down.

\subsubsection{Everyday Examples}\label{everyday-examples-23}

\begin{itemize}
\tightlist
\item
  Games: Randomness keeps them fair (dice rolls, shuffled cards).
\item
  Security: Random numbers generate strong passwords and cryptographic
  keys.
\item
  Sampling: Polling a random group of people estimates public opinion
  quickly.
\item
  Load balancing: Randomly assigning tasks prevents overload on a single
  machine.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-22}

\begin{itemize}
\tightlist
\item
  Efficiency: Randomized algorithms often cut down running time (e.g.,
  randomized quicksort).
\item
  Fairness: Random draws prevent bias in selections.
\item
  Exploration: Randomness helps avoid traps---like getting stuck in one
  solution when many exist.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-21}

\begin{itemize}
\tightlist
\item
  Over-reliance: randomness doesn't guarantee correctness in every case.
\item
  Reproducibility: results may differ, making debugging harder unless a
  fixed seed is used.
\item
  False sense of fairness: poor random generators can produce biased
  outcomes.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-24}

Suppose you want to pick a student at random from a class of 30.

\begin{itemize}
\tightlist
\item
  Deterministic: always pick the first student on the list (boring,
  predictable).
\item
  Randomized: use a random number generator between 1 and 30.
\end{itemize}

Run it a few times---notice how different names come up each time. Why
might this be fairer?

\subsubsection{Key Takeaway}\label{key-takeaway-23}

Randomness, when used wisely, is a tool for speed, fairness, and
exploration. It doesn't replace correctness where precision is required,
but it opens doors to practical solutions where determinism is too rigid
or costly.

\subsection{26. Controlled Randomness: Pseudorandom
Generators}\label{controlled-randomness-pseudorandom-generators}

Computers don't have dice or coins---they are deterministic machines. So
how do they generate randomness? The answer is pseudorandom number
generators (PRNGs): algorithms that produce sequences of numbers that
\emph{look random} even though they are created by deterministic rules.

A PRNG starts from a seed (an initial value). From the seed, it
generates a long sequence of numbers that appear unpredictable. If you
start from the same seed, you always get the same sequence. That's why
it's called \emph{pseudo}-random: it imitates randomness but is still
repeatable.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-25}

Imagine a shuffle machine in a casino:

\begin{itemize}
\tightlist
\item
  Put in a seed (like a single card).
\item
  The machine shuffles according to fixed rules, spitting out a long
  sequence of cards.
\item
  To outsiders, the sequence looks random, but if you know the seed and
  rules, you can predict the entire sequence.
\end{itemize}

That's exactly how computers ``fake'' randomness.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-23}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\CommentTok{\# Set seed for repeatability}
\NormalTok{random.seed(}\DecValTok{42}\NormalTok{)}

\CommentTok{\# Generate pseudorandom numbers}
\BuiltInTok{print}\NormalTok{(random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{))  }\CommentTok{\# Always the same if seed is fixed}
\BuiltInTok{print}\NormalTok{(random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Run this twice with the same seed (\texttt{42})---you'll get the exact
same sequence every time. Change the seed, and you get a different
sequence.

\subsubsection{Everyday Examples}\label{everyday-examples-24}

\begin{itemize}
\tightlist
\item
  Video games: random-looking enemy behavior or loot drops, but seeded
  for fairness.
\item
  Simulations: using the same seed ensures scientists can reproduce
  results.
\item
  Procedural generation: landscapes in games like Minecraft built from
  pseudorandom rules.
\item
  Testing: developers use fixed seeds to repeat ``random'' test
  scenarios reliably.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-23}

\begin{itemize}
\tightlist
\item
  Reproducibility: you can re-run experiments or tests exactly by using
  the same seed.
\item
  Control: you get the benefits of randomness while still being able to
  debug and replay.
\item
  Efficiency: PRNGs generate ``random enough'' numbers very quickly.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-22}

\begin{itemize}
\tightlist
\item
  Not truly random: if someone knows the seed, they can predict the
  sequence (a big problem in security).
\item
  Poor generators: bad algorithms produce biased or repeating patterns.
\item
  Seed mistakes: forgetting to change seeds may give the same ``random''
  result every time.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-25}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate a random sequence with a fixed seed.
\item
  Run it again---does it match exactly?
\item
  Change the seed and compare the difference.
\end{enumerate}

Reflect: which situations benefit from repeatable randomness, and which
demand unpredictability?

\subsubsection{Key Takeaway}\label{key-takeaway-24}

Pseudorandom generators are deterministic machines pretending to be
random. They balance unpredictability with control, making them
essential for simulations, games, and testing---while reminding us that
not all ``randomness'' is truly random.

\subsection{27. Repeatability
vs.~Unpredictability}\label{repeatability-vs.-unpredictability}

Randomness in algorithms has two faces:

\begin{itemize}
\tightlist
\item
  Repeatability: the ability to reproduce the exact same sequence if you
  start from the same seed.
\item
  Unpredictability: the inability to guess the next value without
  knowing the seed or the algorithm.
\end{itemize}

These are opposites, but both are useful. Scientists want repeatability
for experiments; security systems want unpredictability for safety. The
art is deciding which property your algorithm needs most.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-26}

Think of two dice:

\begin{itemize}
\tightlist
\item
  A loaded die that always rolls the same sequence if you know how it's
  weighted---repeatable but predictable.
\item
  A fair die that no one can predict---unpredictable but not repeatable.
\end{itemize}

Computers try to balance both, depending on the context.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-24}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\CommentTok{\# Repeatable randomness with a fixed seed}
\NormalTok{random.seed(}\DecValTok{123}\NormalTok{)}
\BuiltInTok{print}\NormalTok{([random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{)])  }\CommentTok{\# Always the same}

\CommentTok{\# Unpredictable randomness (no seed set)}
\NormalTok{random.seed()  }\CommentTok{\# Uses system time or entropy}
\BuiltInTok{print}\NormalTok{([random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{)])  }\CommentTok{\# Different each run}
\end{Highlighting}
\end{Shaded}

One sequence is reproducible, the other changes every time.

\subsubsection{Everyday Examples}\label{everyday-examples-25}

\begin{itemize}
\item
  Repeatability:

  \begin{itemize}
  \tightlist
  \item
    Running a simulation with the same initial conditions to compare
    outcomes.
  \item
    Debugging a video game bug that depends on ``random'' events.
  \end{itemize}
\item
  Unpredictability:

  \begin{itemize}
  \tightlist
  \item
    Generating secure passwords.
  \item
    Lottery number draws.
  \item
    Shuffling cards in online poker.
  \end{itemize}
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-24}

\begin{itemize}
\tightlist
\item
  Science \& testing need repeatability: without it, results can't be
  verified.
\item
  Security \& fairness demand unpredictability: without it, systems can
  be hacked or rigged.
\item
  Games \& entertainment often mix both: repeatable seeds for world
  generation, unpredictable randomness for fun.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-23}

\begin{itemize}
\tightlist
\item
  Using repeatable randomness where unpredictability is needed (e.g.,
  weak cryptography).
\item
  Using unpredictable randomness where repeatability is needed (e.g.,
  simulations become irreproducible).
\item
  Forgetting to document which mode is expected, leading to confusion in
  teams.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-26}

Run a simple dice-roll algorithm twice: once with a fixed seed, once
without. Which one would you trust for a scientific experiment? Which
one for an online casino?

\subsubsection{Key Takeaway}\label{key-takeaway-25}

Repeatability and unpredictability are two sides of randomness. Good
algorithms choose deliberately: repeatable randomness for science and
testing, unpredictable randomness for security and fairness.

\subsection{28. Reliability in Real-World
Processes}\label{reliability-in-real-world-processes}

Algorithms don't live in isolation---they run inside real systems where
users expect reliability. Reliability means that given the same
situation, the algorithm behaves in a consistent and trustworthy way.
Deterministic steps make this easier, but even when randomness is
involved, reliability comes from making the boundaries clear: the range
of possible outputs, the fairness of the process, and the rules of
execution.

If an elevator sometimes skips a floor or an ATM sometimes gives the
wrong balance, the whole system loses trust---even if the error happens
rarely. Reliability is the glue that makes algorithms usable in the
messy real world.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-27}

Imagine a train schedule:

\begin{itemize}
\tightlist
\item
  Deterministic: the 8:00 AM train always leaves at 8:00.
\item
  Randomness allowed: minor variations in arrival due to weather.
\item
  Reliability: even if random delays happen, passengers can trust that
  the train will eventually arrive, never at 3:00 PM by surprise.
\end{itemize}

Reliability means boundaries are respected and outcomes are predictable
enough to trust.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-25}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\CommentTok{\# Reliable coin flip: always either "Heads" or "Tails"}
\KeywordTok{def}\NormalTok{ coin\_flip():}
    \ControlFlowTok{return}\NormalTok{ random.choice([}\StringTok{"Heads"}\NormalTok{, }\StringTok{"Tails"}\NormalTok{])}

\NormalTok{results }\OperatorTok{=}\NormalTok{ [coin\_flip() }\ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{)]}
\BuiltInTok{print}\NormalTok{(results)  }\CommentTok{\# Each result is unpredictable, but always valid}
\end{Highlighting}
\end{Shaded}

Unpredictable in detail, but reliable in scope: the result is
\emph{always} ``Heads'' or ``Tails.''

\subsubsection{Everyday Examples}\label{everyday-examples-26}

\begin{itemize}
\tightlist
\item
  Banking apps: balances must always add up correctly, even across
  millions of transactions.
\item
  Navigation: routes may change based on traffic, but you can rely on
  getting a valid, drivable path.
\item
  Weather forecasts: the exact prediction may vary, but the output is
  always meaningful (e.g., ``20\% chance of rain'' is still reliable
  information).
\item
  Games: dice rolls or loot drops vary, but always within fair, expected
  rules.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-25}

\begin{itemize}
\tightlist
\item
  Safety-critical systems: airplanes, medical devices, traffic control
  must prioritize reliability above all else.
\item
  Customer trust: users won't stick with a service that feels random or
  flaky.
\item
  Legal and financial systems: reliability ensures fairness,
  consistency, and compliance.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-24}

\begin{itemize}
\tightlist
\item
  Silent failures: producing no output, leaving users confused.
\item
  Invalid outputs: e.g., weather app showing ``temperature = 1000°C.''
\item
  Inconsistent behavior: same input sometimes works, sometimes fails,
  with no explanation.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-27}

Think of a vending machine algorithm:

\begin{itemize}
\tightlist
\item
  Inputs: money + product code.
\item
  Outputs: either product dispensed or clear error message.
\end{itemize}

What outputs would make the machine feel unreliable? (Hint: sometimes
dispensing nothing, or giving the wrong product.)

\subsubsection{Key Takeaway}\label{key-takeaway-26}

Reliability is about consistency and trustworthiness. Even when
algorithms use randomness, they must stay within clear, valid
boundaries. An algorithm that is not reliable is not useful---no matter
how clever its design.

\subsection{29. Algorithms That Must Be
Deterministic}\label{algorithms-that-must-be-deterministic}

Some algorithms cannot afford randomness or uncertainty---they must
always produce the exact same result for the same input. These are
deterministic-only algorithms, and they are the backbone of systems
where correctness, safety, or fairness is non-negotiable.

If your bank account balance changed unpredictably, or if an airplane
navigation system sometimes gave different routes for the same
coordinates, trust would collapse. Determinism here is not just
convenient---it's essential.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-28}

Think of a recipe for medicine:

\begin{itemize}
\tightlist
\item
  Every dose must be measured exactly the same way.
\item
  Any variation, even small, can be dangerous. That's what deterministic
  algorithms guarantee---no variation, no surprises.
\end{itemize}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-26}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Deterministic tax calculation}
\KeywordTok{def}\NormalTok{ calculate\_tax(income):}
    \ControlFlowTok{if}\NormalTok{ income }\OperatorTok{\textless{}=} \DecValTok{10000}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ income }\OperatorTok{*} \FloatTok{0.1}
    \ControlFlowTok{elif}\NormalTok{ income }\OperatorTok{\textless{}=} \DecValTok{50000}\NormalTok{:}
        \ControlFlowTok{return} \DecValTok{1000} \OperatorTok{+}\NormalTok{ (income }\OperatorTok{{-}} \DecValTok{10000}\NormalTok{) }\OperatorTok{*} \FloatTok{0.2}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return} \DecValTok{9000} \OperatorTok{+}\NormalTok{ (income }\OperatorTok{{-}} \DecValTok{50000}\NormalTok{) }\OperatorTok{*} \FloatTok{0.3}

\BuiltInTok{print}\NormalTok{(calculate\_tax(}\DecValTok{30000}\NormalTok{))  }\CommentTok{\# Always 5000.0}
\BuiltInTok{print}\NormalTok{(calculate\_tax(}\DecValTok{30000}\NormalTok{))  }\CommentTok{\# Still 5000.0, every time}
\end{Highlighting}
\end{Shaded}

No matter how many times you run it, the result never changes.

\subsubsection{Everyday Examples}\label{everyday-examples-27}

\begin{itemize}
\tightlist
\item
  Banking systems: deposits, withdrawals, and transfers must always
  calculate the same way.
\item
  Cryptography: encryption and decryption must reliably transform data
  in a predictable manner.
\item
  Legal systems: same evidence, same verdict by the algorithm (e.g.,
  fraud detection rules).
\item
  File compression: compressing a file and then decompressing it must
  always give back the exact original.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-26}

\begin{itemize}
\tightlist
\item
  Safety: deterministic autopilot instructions or medical device
  controllers.
\item
  Fairness: student grades must be computed the same way for all.
\item
  Accountability: deterministic rules allow auditing and tracing of
  results.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-25}

\begin{itemize}
\tightlist
\item
  Hidden randomness: some programming environments may shuffle data
  structures internally, breaking determinism.
\item
  Environment dependence: same code may behave differently on different
  systems if assumptions aren't fixed (e.g., floating-point quirks).
\item
  Assuming determinism in nondeterministic contexts: e.g., using
  randomized load balancing for critical financial operations.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-28}

Imagine writing an algorithm for grading exams:

\begin{itemize}
\tightlist
\item
  Input: scores from multiple questions.
\item
  Output: final grade.
\end{itemize}

Should this be deterministic or nondeterministic? Why? Write the
reasoning as if explaining to a teacher or a parent.

\subsubsection{Key Takeaway}\label{key-takeaway-27}

Determinism is mandatory in domains where correctness and trust cannot
be compromised. For these algorithms, \emph{same input must always
produce the same output}---without exception.

\subsection{30. Algorithms That Benefit from
Randomness}\label{algorithms-that-benefit-from-randomness}

Not every algorithm must be deterministic. Some problems are so large,
complex, or uncertain that randomness actually makes them easier or
faster to solve. These are randomized algorithms---still precise in
their design, but using chance as a tool.

Instead of always exploring every option, randomness allows the
algorithm to sample possibilities, avoid worst-case scenarios, and find
good (or even optimal) solutions much more efficiently.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-29}

Imagine trying to find a hidden treasure in a massive field:

\begin{itemize}
\tightlist
\item
  A deterministic approach is to search row by row, covering every inch.
\item
  A randomized approach is to dig in random spots; you might get lucky
  and find the treasure much faster.
\end{itemize}

You sacrifice certainty for speed, but often the trade-off is worth it.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-27}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\CommentTok{\# Randomized search: keep guessing until target is found}
\KeywordTok{def}\NormalTok{ random\_search(target, n):}
    \ControlFlowTok{while} \VariableTok{True}\NormalTok{:}
\NormalTok{        guess }\OperatorTok{=}\NormalTok{ random.randint(}\DecValTok{1}\NormalTok{, n)}
        \ControlFlowTok{if}\NormalTok{ guess }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ guess}

\BuiltInTok{print}\NormalTok{(random\_search(}\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{))  }\CommentTok{\# May take 1 step or many, unpredictable}
\end{Highlighting}
\end{Shaded}

Deterministic search (linear) would take at most 10 steps. Random search
might find it on the first try---or the last.

\subsubsection{Everyday Examples}\label{everyday-examples-28}

\begin{itemize}
\tightlist
\item
  Quicksort with random pivot: avoids worst-case performance by
  randomizing choices.
\item
  Monte Carlo simulations: estimate probabilities by running many random
  trials.
\item
  Machine learning: random initialization helps models avoid getting
  stuck.
\item
  Games: AI opponents sometimes use randomness to avoid being
  predictable.
\end{itemize}

\subsubsection{When It Matters}\label{when-it-matters-27}

\begin{itemize}
\tightlist
\item
  Efficiency: randomized algorithms often run faster on average than
  deterministic ones.
\item
  Fairness: random lotteries or tie-breakers prevent bias.
\item
  Exploration: randomness helps explore huge search spaces where
  deterministic methods would be too slow.
\end{itemize}

\subsubsection{Pitfalls}\label{pitfalls-26}

\begin{itemize}
\tightlist
\item
  No guarantees: results may vary between runs.
\item
  Debugging difficulty: nondeterministic behavior makes bugs harder to
  reproduce.
\item
  False assumptions: believing randomness always improves
  performance---sometimes deterministic methods are better.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-29}

Suppose you're designing a seating algorithm for a school exam:

\begin{itemize}
\tightlist
\item
  Deterministic version: assign students alphabetically.
\item
  Randomized version: shuffle seats randomly to prevent cheating.
\end{itemize}

Which is better in this context? Why?

\subsubsection{Key Takeaway}\label{key-takeaway-28}

Randomness can be a powerful ally. Algorithms that use it wisely gain
speed, fairness, and robustness in complex problems. They don't replace
determinism, but they shine where certainty is too costly.

\section{Chapter 4. Decomposing big problems into small
ones}\label{chapter-4.-decomposing-big-problems-into-small-ones}

\subsection{31. Divide to Understand: The Problem
Tree}\label{divide-to-understand-the-problem-tree}

Big problems are hard to solve all at once. The key idea is
decomposition: splitting a large challenge into smaller, more manageable
parts. This way, each part is easier to understand, solve, and later
combine back into the whole.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-30}

Think of a tree. The trunk is your big problem. The branches are
subproblems. The twigs and leaves are the smallest steps. By solving the
leaves one by one, you gradually solve the trunk.

\subsubsection{Deep Dive}\label{deep-dive}

Decomposition has two main benefits. First, it reduces mental load---you
only focus on one small step at a time instead of the entire problem.
Second, it allows reuse and collaboration---smaller parts can be reused
in other algorithms, or handled by different people in parallel.

This technique is everywhere: project managers break tasks into
milestones, teachers break courses into lessons, and programmers break
big functions into smaller helper functions. The art is deciding how far
to decompose: too coarse, and the pieces are still overwhelming; too
fine, and you drown in details.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-28}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Goal: calculate the average of a list of numbers}
\CommentTok{\# Step 1: find the sum of numbers}
\CommentTok{\# Step 2: count how many numbers}
\CommentTok{\# Step 3: divide sum by count}

\KeywordTok{def}\NormalTok{ average(nums):}
    \CommentTok{\# Step 1: add all numbers together}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    
    \CommentTok{\# Step 2: count elements}
\NormalTok{    count }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(nums)}
    
    \CommentTok{\# Step 3: compute result}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ total }\OperatorTok{/}\NormalTok{ count}
    
    \ControlFlowTok{return}\NormalTok{ result}

\BuiltInTok{print}\NormalTok{(average([}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{]))  }\CommentTok{\# Output: 20}
\end{Highlighting}
\end{Shaded}

Here the big task (find average) was divided into three smaller, clear
steps.

\subsubsection{When It Matters}\label{when-it-matters-28}

Decomposition matters whenever a task feels too big to grasp at once. By
reducing it to smaller steps, you create clarity, reduce mistakes, and
make it possible to solve problems systematically.

\subsubsection{Try It Yourself}\label{try-it-yourself-30}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Break down making tea into substeps. How many branches and leaves can
  you find?
\item
  Plan a trip: trunk = plan trip, branches = transport, accommodation,
  activities. Write down at least three twigs for one branch.
\item
  For the problem ``find the maximum grade in a class,'' outline the
  trunk (main goal) and the two or three substeps you'd use.
\item
  Reflect: when was the last time you solved a problem by splitting it
  up without realizing it?
\end{enumerate}

\subsection{32. Breaking Down Chores: Cooking a Meal
Example}\label{breaking-down-chores-cooking-a-meal-example}

Cooking a meal is a perfect example of decomposition. A full dinner may
feel like a single big task, but it becomes easier once broken into
smaller steps: choosing dishes, preparing ingredients, cooking, and
serving. Each step is a subproblem that contributes to the larger goal.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-31}

Imagine a dinner plate as the trunk of the tree. The main dishes are the
big branches, side dishes are smaller branches, and individual steps
like chopping vegetables or boiling rice are the leaves. Completing the
leaves one by one builds the entire meal.

\subsubsection{Deep Dive}\label{deep-dive-1}

This example highlights that decomposition works across multiple layers.
At the top level, the problem is ``prepare a meal.'' At the next level,
you split into tasks like ``make soup'' and ``make rice.'' At the lowest
level, even ``make rice'' decomposes into rinse → measure water → boil →
steam.

Each subproblem can be assigned, solved, and verified independently.
This modularity mirrors programming: one function can call smaller
helper functions, each handling one precise step.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-29}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Goal: cook a meal with two dishes: rice and soup}

\KeywordTok{def}\NormalTok{ cook\_meal():}
\NormalTok{    rice }\OperatorTok{=}\NormalTok{ cook\_rice()}
\NormalTok{    soup }\OperatorTok{=}\NormalTok{ cook\_soup()}
    \ControlFlowTok{return} \SpecialStringTok{f"Meal is ready with }\SpecialCharTok{\{}\NormalTok{rice}\SpecialCharTok{\}}\SpecialStringTok{ and }\SpecialCharTok{\{}\NormalTok{soup}\SpecialCharTok{\}}\SpecialStringTok{"}

\KeywordTok{def}\NormalTok{ cook\_rice():}
\NormalTok{    rinse\_rice()}
\NormalTok{    boil\_water()}
\NormalTok{    steam()}
    \ControlFlowTok{return} \StringTok{"rice"}

\KeywordTok{def}\NormalTok{ cook\_soup():}
\NormalTok{    chop\_vegetables()}
\NormalTok{    boil\_broth()}
\NormalTok{    add\_vegetables()}
    \ControlFlowTok{return} \StringTok{"soup"}

\CommentTok{\# Helper stubs}
\KeywordTok{def}\NormalTok{ rinse\_rice(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Rinsing rice..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ boil\_water(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Boiling water..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ steam(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Steaming rice..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ chop\_vegetables(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Chopping vegetables..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ boil\_broth(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Boiling broth..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ add\_vegetables(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Adding vegetables to broth..."}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(cook\_meal())}
\end{Highlighting}
\end{Shaded}

Here the big task is solved by layering smaller functions. Each subtask
is simple and clear.

\subsubsection{When It Matters}\label{when-it-matters-29}

Breaking chores like cooking into substeps reduces stress, allows tasks
to be delegated, and ensures no part is forgotten. The same principle
applies to algorithms---clarity comes from structured decomposition.

\subsubsection{Try It Yourself}\label{try-it-yourself-31}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Choose a recipe you know. Write its steps as a problem tree: trunk =
  finished dish, branches = major steps, leaves = individual actions.
\item
  Imagine cooking with friends. Which subproblems could you delegate to
  others?
\item
  Write pseudocode for making tea. Identify at least three substeps.
\item
  Reflect: have you ever skipped a step in cooking and ruined the dish?
  How does decomposition prevent that?
\end{enumerate}

\subsection{33. Subtasks Within
Subtasks}\label{subtasks-within-subtasks}

Decomposition does not stop at the first layer. Every subtask can itself
be broken down into smaller subtasks. This layered approach ensures that
even complex activities eventually reach steps so simple that they can
be carried out without confusion.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-32}

Think of Russian nesting dolls. The outer doll is the main task, each
smaller doll inside is a subtask, and inside the smallest doll is the
atomic action that cannot be divided further.

\subsubsection{Deep Dive}\label{deep-dive-2}

Large problems are rarely solved in a single layer of decomposition. For
example, ``make soup'' can be divided into ``chop vegetables'' and
``boil broth.'' But ``chop vegetables'' can itself be decomposed into
``wash carrots,'' ``slice carrots,'' ``wash onions,'' ``dice onions.''

This recursive idea---tasks containing subtasks---parallels programming,
where functions call helper functions, which may call even smaller
utilities. The process stops when the step is simple enough to be
executed directly without more clarification. Knowing how deep to go is
part of designing clear algorithms.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-30}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Task: cook soup (broken down into subtasks and subtasks within them)}

\KeywordTok{def}\NormalTok{ cook\_soup():}
\NormalTok{    prepare\_vegetables()}
\NormalTok{    make\_broth()}
\NormalTok{    add\_vegetables()}
    \ControlFlowTok{return} \StringTok{"soup"}

\KeywordTok{def}\NormalTok{ prepare\_vegetables():}
\NormalTok{    wash\_carrots()}
\NormalTok{    slice\_carrots()}
\NormalTok{    wash\_onions()}
\NormalTok{    dice\_onions()}

\KeywordTok{def}\NormalTok{ make\_broth():}
\NormalTok{    boil\_water()}
\NormalTok{    add\_spices()}

\CommentTok{\# Smallest actions}
\KeywordTok{def}\NormalTok{ wash\_carrots(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Washing carrots..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ slice\_carrots(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Slicing carrots..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ wash\_onions(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Washing onions..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ dice\_onions(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Dicing onions..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ boil\_water(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Boiling water..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ add\_spices(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Adding spices..."}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(cook\_soup())}
\end{Highlighting}
\end{Shaded}

Here, each subtask expands into smaller steps until we reach the
smallest possible units, which can be executed directly.

\subsubsection{When It Matters}\label{when-it-matters-30}

Breaking subtasks further ensures clarity and prevents hidden
complexity. It allows systematic progress: no single step is
overwhelming, and nothing important is skipped.

\subsubsection{Try It Yourself}\label{try-it-yourself-32}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take the problem ``clean your room.'' Break it into subtasks, then
  choose one (like ``organize desk'') and decompose it further.
\item
  In programming terms, imagine writing a function for ``plan a trip.''
  What helper functions would you call inside it? What subtasks might
  those helpers need?
\item
  Reflect: can you think of a time you stopped decomposing too early and
  missed important details? What went wrong?
\end{enumerate}

\subsection{34. Sequencing vs.~Parallelism of
Subtasks}\label{sequencing-vs.-parallelism-of-subtasks}

Once a problem is broken into subtasks, the next question is order. Some
subtasks must happen in sequence---one after the other. Others can
happen in parallel---at the same time. Good decomposition not only
identifies parts but also arranges them correctly.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-33}

Imagine cooking dinner. You must boil pasta before draining it---a
strict sequence. But you can set the table while the pasta
boils---parallel tasks. Sequencing and parallelism together make the
whole process faster and more efficient.

\subsubsection{Deep Dive}\label{deep-dive-3}

Algorithms often involve a mix of sequential and parallel subtasks.
Sequencing enforces dependencies: you can't ``print the report'' until
you've ``generated the data.'' Parallelism exploits independence: you
can ``download file A'' and ``download file B'' at the same time.

This idea is not just theoretical. Modern computers use parallelism to
run tasks faster across multiple cores, while still respecting necessary
sequences. Recognizing which subtasks depend on each other and which
don't is central to both everyday problem-solving and algorithm design.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-31}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sequential: steps must occur one after another}
\KeywordTok{def}\NormalTok{ sequential\_task():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Step 1: Boil water"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Step 2: Add pasta"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Step 3: Drain pasta"}\NormalTok{)}

\CommentTok{\# Parallel (simulated here by interleaving tasks)}
\ImportTok{import}\NormalTok{ threading}

\KeywordTok{def}\NormalTok{ set\_table(): }
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Setting the table..."}\NormalTok{)}

\KeywordTok{def}\NormalTok{ cook\_sauce():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Cooking sauce..."}\NormalTok{)}

\KeywordTok{def}\NormalTok{ parallel\_task():}
\NormalTok{    t1 }\OperatorTok{=}\NormalTok{ threading.Thread(target}\OperatorTok{=}\NormalTok{set\_table)}
\NormalTok{    t2 }\OperatorTok{=}\NormalTok{ threading.Thread(target}\OperatorTok{=}\NormalTok{cook\_sauce)}
\NormalTok{    t1.start()}
\NormalTok{    t2.start()}
\NormalTok{    t1.join()}
\NormalTok{    t2.join()}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Dinner is ready!"}\NormalTok{)}

\NormalTok{sequential\_task()}
\NormalTok{parallel\_task()}
\end{Highlighting}
\end{Shaded}

Sequential steps are rigid and ordered. Parallel tasks can run at the
same time, as shown with threads.

\subsubsection{When It Matters}\label{when-it-matters-31}

Understanding sequencing ensures correctness---steps happen in the right
order. Recognizing parallelism saves time and resources by doing
independent tasks together. Both are essential for efficiency and
clarity.

\subsubsection{Try It Yourself}\label{try-it-yourself-33}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For ``doing laundry,'' list the steps. Which must be sequential (e.g.,
  wash → dry → fold) and which could be parallel (e.g., tidy your room
  while the laundry runs)?
\item
  Write pseudocode for ``organizing a party.'' Mark at least two tasks
  as sequential and two as parallel.
\item
  Reflect: have you ever done things in the wrong order (like adding
  sugar after baking a cake)? How did sequencing---or ignoring
  it---affect the result?
\end{enumerate}

\subsection{35. How Small Is ``Small
Enough''?}\label{how-small-is-small-enough}

When breaking a problem down, a natural question arises: how far should
you go? The answer is: stop when each step is clear, executable, and
unambiguous. If someone else could follow the step without asking
further questions, it's ``small enough.''

\subsubsection{Picture in Your Head}\label{picture-in-your-head-34}

Think of writing instructions for tying shoelaces. If you say ``tie your
shoes,'' that's too vague. If you say ``move your left hand 3 cm to the
left,'' that's too detailed. The sweet spot is steps like ``make a loop
with one lace,'' which are specific yet understandable.

\subsubsection{Deep Dive}\label{deep-dive-4}

The right level of decomposition depends on who or what will execute the
algorithm. Humans can handle some abstraction (``boil water'' is fine),
but a machine might need more precision (``heat liquid to 100°C'').

Too coarse: steps remain unclear and may cause mistakes. Too fine:
instructions become overwhelming and cluttered.

In computer science, this balance is similar to choosing the right level
of abstraction: low-level instructions (machine code) vs.~higher-level
commands (functions). The art is stopping where the step is both doable
and meaningful.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-32}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Too coarse: not clear enough}
\KeywordTok{def}\NormalTok{ make\_breakfast():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Cook breakfast"}\NormalTok{)  }

\CommentTok{\# Too fine: overwhelming detail}
\KeywordTok{def}\NormalTok{ make\_breakfast\_too\_detailed():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Move hand to fridge handle"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Grip handle with 4 fingers"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Rotate wrist by 30 degrees"}\NormalTok{)}
    \CommentTok{\# ... dozens more steps}

\CommentTok{\# Just right: clear and unambiguous}
\KeywordTok{def}\NormalTok{ make\_breakfast\_balanced():}
\NormalTok{    fry\_eggs()}
\NormalTok{    toast\_bread()}
\NormalTok{    brew\_tea()}

\KeywordTok{def}\NormalTok{ fry\_eggs(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Frying eggs..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ toast\_bread(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Toasting bread..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ brew\_tea(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Brewing tea..."}\NormalTok{)}

\NormalTok{make\_breakfast\_balanced()}
\end{Highlighting}
\end{Shaded}

This shows how different decomposition levels affect clarity.

\subsubsection{When It Matters}\label{when-it-matters-32}

Finding the right depth of decomposition keeps instructions useful. Stop
when the step is clear enough to execute, but not so detailed that it
clutters the solution.

\subsubsection{Try It Yourself}\label{try-it-yourself-34}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write steps for brushing your teeth. First, make them too coarse (3
  steps), then too detailed (15+ steps), then balanced (5--7 steps).
  Which version feels most natural?
\item
  Break down ``send an email.'' At what step do you stop? Why?
\item
  Reflect: in school or work, when have you over-explained or
  under-explained instructions? How could this principle have helped?
\end{enumerate}

\subsection{36. Benefits of Decomposition: Focus and
Reuse}\label{benefits-of-decomposition-focus-and-reuse}

Decomposition not only makes problems manageable but also brings two
powerful advantages: focus and reuse. By isolating each subproblem, you
can concentrate fully on solving it without distraction. Once solved,
the same piece can often be reused in other contexts, saving time and
effort.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-35}

Imagine building with Lego. You don't design the whole castle at
once---you focus on one wall, one tower, one gate. Later, the same tower
design might be reused in another castle. Each block is useful beyond
its original place.

\subsubsection{Deep Dive}\label{deep-dive-5}

Focus means smaller cognitive load. Instead of juggling an entire system
in your head, you only work on a single part. This reduces mistakes and
increases clarity.

Reuse means efficiency. A subproblem solved once becomes a building
block. In programming, a function written to ``sort a list'' can be
reused in hundreds of different applications. In daily life, a recipe
for rice can be reused in countless meals.

Decomposition is therefore not just about simplification, but about
creating a library of solutions you can trust and apply repeatedly.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-33}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Focus: solve one small task at a time}
\KeywordTok{def}\NormalTok{ sum\_list(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\CommentTok{\# Reuse: use sum\_list in bigger tasks}
\KeywordTok{def}\NormalTok{ average(nums):}
    \ControlFlowTok{return}\NormalTok{ sum\_list(nums) }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(nums)}

\KeywordTok{def}\NormalTok{ grade\_report(scores):}
\NormalTok{    total }\OperatorTok{=}\NormalTok{ sum\_list(scores)}
\NormalTok{    avg }\OperatorTok{=}\NormalTok{ average(scores)}
    \ControlFlowTok{return} \SpecialStringTok{f"Total = }\SpecialCharTok{\{}\NormalTok{total}\SpecialCharTok{\}}\SpecialStringTok{, Average = }\SpecialCharTok{\{}\NormalTok{avg}\SpecialCharTok{\}}\SpecialStringTok{"}

\BuiltInTok{print}\NormalTok{(grade\_report([}\DecValTok{80}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{100}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

The same \texttt{sum\_list} helper is reused across multiple bigger
problems.

\subsubsection{When It Matters}\label{when-it-matters-33}

Decomposition matters because it frees your mind from overload and
builds reusable parts that save time later. This is how small,
well-designed solutions grow into powerful systems.

\subsubsection{Try It Yourself}\label{try-it-yourself-35}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Pick a house chore (like doing laundry). Break it into 5--6 subtasks.
  Which ones could you reuse in another context (e.g., ``fold clothes''
  also works for unpacking luggage)?
\item
  Write pseudocode for calculating class averages. Which helper
  functions could you isolate for reuse?
\item
  Reflect: when have you solved a problem once and then reused the same
  idea again in a different situation?
\end{enumerate}

\subsection{37. Reassembling Solutions into the
Whole}\label{reassembling-solutions-into-the-whole}

Decomposition is only half the story. After breaking a big problem into
smaller subtasks, you must reassemble the solved pieces into a complete
solution. The real power of algorithms comes from this
recombination---small, clear steps joined together to achieve something
bigger than any one part.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-36}

Think of assembling furniture from flat-pack boxes. The instructions
break it into steps: attach legs, connect panels, tighten screws. Each
substep alone is not a table, but once combined in the right order, the
table is ready for use.

\subsubsection{Deep Dive}\label{deep-dive-6}

Reassembly requires paying attention to the interfaces between subtasks:
how the output of one becomes the input of the next. For example, if one
function ``calculates total sales'' and another ``computes average,''
the total must be in a form the second step can understand.

This mirrors programming, where functions compose like puzzle pieces. If
each piece is precise and reliable, the final system emerges naturally.
Poorly aligned pieces, however, create gaps---so decomposition only
succeeds if recombination is carefully designed.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-34}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Subtasks: sum, count, average}
\KeywordTok{def}\NormalTok{ sum\_list(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\KeywordTok{def}\NormalTok{ count\_list(nums):}
    \ControlFlowTok{return} \BuiltInTok{len}\NormalTok{(nums)}

\KeywordTok{def}\NormalTok{ average(nums):}
\NormalTok{    total }\OperatorTok{=}\NormalTok{ sum\_list(nums)           }\CommentTok{\# use result of first subtask}
\NormalTok{    count }\OperatorTok{=}\NormalTok{ count\_list(nums)         }\CommentTok{\# use result of second subtask}
    \ControlFlowTok{return}\NormalTok{ total }\OperatorTok{/}\NormalTok{ count             }\CommentTok{\# reassemble into full solution}

\BuiltInTok{print}\NormalTok{(average([}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{]))  }\CommentTok{\# Output: 20}
\end{Highlighting}
\end{Shaded}

Here, three independent subtasks come together to form a complete
algorithm.

\subsubsection{When It Matters}\label{when-it-matters-34}

Reassembly matters because solving subtasks alone is not enough---you
need a system where all parts work together. The whole solution emerges
only when the pieces connect smoothly.

\subsubsection{Try It Yourself}\label{try-it-yourself-36}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take the chore ``clean your room.'' Break it into subtasks, then write
  how you'd put them back together to finish the full task.
\item
  Write pseudocode for making tea with subtasks: boil water, steep tea,
  pour cup. How do these combine in order?
\item
  Reflect: have you ever solved parts of a project but failed to
  integrate them properly? What did that teach you about recombining
  pieces?
\end{enumerate}

\subsection{38. Real Examples: Long Division,
Navigation}\label{real-examples-long-division-navigation}

Decomposition shows up in familiar real-world and school tasks. Long
division in math and navigation in daily life are classic
demonstrations. Each is a big goal broken into smaller, repeatable
subtasks that, when combined, solve the larger challenge.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-37}

Think of long division written on paper: you don't solve it in one
leap---you break it into steps (divide, multiply, subtract, bring down
the next digit). Or picture a navigation app: it doesn't give the whole
trip in one line---it provides step-by-step directions: turn left, go
straight, take exit 12.

\subsubsection{Deep Dive}\label{deep-dive-7}

Long division decomposes a complex arithmetic problem into a loop of
smaller, familiar actions. At each stage, you repeat a cycle until the
problem is solved. This teaches us that decomposition can include
recurring subtasks.

Navigation decomposes travel into manageable legs. Instead of worrying
about the whole journey, you only need to focus on the next step. This
mirrors algorithm design, where problems are tackled in sequential steps
with local clarity but global purpose.

Both examples highlight that decomposition is not abstract---it is baked
into how humans naturally approach big tasks.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-35}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: navigation decomposed into steps}
\KeywordTok{def}\NormalTok{ navigate():}
\NormalTok{    steps }\OperatorTok{=}\NormalTok{ [}
        \StringTok{"Start at home"}\NormalTok{,}
        \StringTok{"Walk to bus stop"}\NormalTok{,}
        \StringTok{"Take bus to downtown"}\NormalTok{,}
        \StringTok{"Walk 2 blocks north"}\NormalTok{,}
        \StringTok{"Arrive at library"}
\NormalTok{    ]}
    \ControlFlowTok{for}\NormalTok{ step }\KeywordTok{in}\NormalTok{ steps:}
        \BuiltInTok{print}\NormalTok{(step)}

\NormalTok{navigate()}
\end{Highlighting}
\end{Shaded}

Each step is simple on its own. Together, they form the entire journey.

\subsubsection{When It Matters}\label{when-it-matters-35}

Examples like long division and navigation show that decomposition is
not optional---it's the only way to solve big, structured problems
reliably.

\subsubsection{Try It Yourself}\label{try-it-yourself-37}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Perform a long division problem (e.g., 154 ÷ 7). Write out each
  substep in words. How does it match the decomposition idea?
\item
  Plan a trip from your house to a nearby store. Write each step as a
  separate instruction. How many levels deep do you go?
\item
  Reflect: which feels easier---thinking about the whole problem at
  once, or solving it step by step? Why?
\end{enumerate}

\subsection{39. Pitfalls: Over-Fragmenting or
Under-Specifying}\label{pitfalls-over-fragmenting-or-under-specifying}

Decomposition works best when it strikes a balance. If you break tasks
into pieces that are too tiny, you drown in detail. If you leave them
too big, you miss clarity. Both extremes reduce usefulness.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-38}

Imagine writing instructions for brushing teeth. If you only say
\emph{``brush your teeth''}, it's too vague. If you say \emph{``move
your wrist two degrees clockwise, now three degrees counterclockwise''},
it's absurdly detailed. The sweet spot is something like \emph{``squeeze
toothpaste, brush upper teeth, brush lower teeth, rinse.''}

\subsubsection{Deep Dive}\label{deep-dive-8}

\begin{itemize}
\tightlist
\item
  Under-specifying: leaving a subtask so vague it can't be executed
  consistently. Machines especially fail here---they need explicit
  details humans often fill in automatically.
\item
  Over-fragmenting: breaking subtasks so far that you lose the big
  picture. Instead of simplifying, you introduce clutter and make the
  algorithm harder to follow.
\end{itemize}

The balance depends on the audience. For beginners, a recipe may include
every step. For a chef, ``make pasta sauce'' is enough. In algorithms,
the right level is where each step is clear, meaningful, and executable
without unnecessary micromanagement.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-36}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Under{-}specified: too vague}
\KeywordTok{def}\NormalTok{ make\_breakfast():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Cook breakfast"}\NormalTok{)  }

\CommentTok{\# Over{-}fragmented: too detailed}
\KeywordTok{def}\NormalTok{ make\_breakfast\_detailed():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Extend right arm 30cm"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Grip fridge handle with 4 fingers"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Rotate wrist 15 degrees"}\NormalTok{)}
    \CommentTok{\# ... dozens of tiny steps}

\CommentTok{\# Balanced: clear but not overwhelming}
\KeywordTok{def}\NormalTok{ make\_breakfast\_balanced():}
\NormalTok{    fry\_eggs()}
\NormalTok{    toast\_bread()}
\NormalTok{    brew\_coffee()}

\KeywordTok{def}\NormalTok{ fry\_eggs(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Frying eggs..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ toast\_bread(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Toasting bread..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ brew\_coffee(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Brewing coffee..."}\NormalTok{)}

\NormalTok{make\_breakfast\_balanced()}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-36}

Clarity comes from finding the right depth of decomposition. Too little
detail leaves gaps; too much detail causes overload. Balanced steps make
algorithms effective and readable.

\subsubsection{Try It Yourself}\label{try-it-yourself-38}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write instructions for making tea in three versions: too vague (3
  steps), too detailed (15 steps), and balanced (5--7 steps). Which
  feels most natural?
\item
  Break down the task ``clean your desk.'' Which steps risk being too
  vague? Which could be over-fragmented?
\item
  Reflect: think of a project you've worked on where instructions were
  either too sparse or too detailed. How did it affect progress?
\end{enumerate}

\subsection{40. Exercise: Break Down School Scheduling into
Subtasks}\label{exercise-break-down-school-scheduling-into-subtasks}

School scheduling sounds like one big, overwhelming task. But like any
large problem, it becomes approachable when broken into subtasks. Each
branch of the problem tree focuses on one area: courses, rooms,
teachers, times, and constraints.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-39}

Visualize a giant weekly calendar with blank squares. Instead of trying
to fill the entire thing at once, you handle it branch by
branch---assigning teachers, then courses, then times. The whole
schedule emerges only after the pieces are solved and combined.

\subsubsection{Deep Dive}\label{deep-dive-9}

The school scheduling problem is an example of constraint satisfaction:
there are many moving parts, but each subtask reduces complexity. For
example:

\begin{itemize}
\tightlist
\item
  Assigning teachers to subjects.
\item
  Ensuring no teacher is in two rooms at once.
\item
  Balancing classroom availability.
\item
  Spacing exams or heavy classes across the week.
\end{itemize}

Each constraint becomes a branch in the problem tree. By solving them
separately, you can gradually assemble a complete, feasible schedule.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-37}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Skeleton decomposition of scheduling problem}

\KeywordTok{def}\NormalTok{ build\_schedule():}
\NormalTok{    teachers }\OperatorTok{=}\NormalTok{ assign\_teachers()}
\NormalTok{    rooms }\OperatorTok{=}\NormalTok{ assign\_rooms()}
\NormalTok{    times }\OperatorTok{=}\NormalTok{ assign\_times()}
    \ControlFlowTok{return}\NormalTok{ combine(teachers, rooms, times)}

\KeywordTok{def}\NormalTok{ assign\_teachers():}
    \ControlFlowTok{return}\NormalTok{ \{}\StringTok{"Math"}\NormalTok{: }\StringTok{"Mr. Lee"}\NormalTok{, }\StringTok{"History"}\NormalTok{: }\StringTok{"Ms. Kim"}\NormalTok{\}}

\KeywordTok{def}\NormalTok{ assign\_rooms():}
    \ControlFlowTok{return}\NormalTok{ \{}\StringTok{"Room101"}\NormalTok{: }\StringTok{"Math"}\NormalTok{, }\StringTok{"Room202"}\NormalTok{: }\StringTok{"History"}\NormalTok{\}}

\KeywordTok{def}\NormalTok{ assign\_times():}
    \ControlFlowTok{return}\NormalTok{ \{}\StringTok{"Math"}\NormalTok{: }\StringTok{"Mon 9am"}\NormalTok{, }\StringTok{"History"}\NormalTok{: }\StringTok{"Tue 10am"}\NormalTok{\}}

\KeywordTok{def}\NormalTok{ combine(teachers, rooms, times):}
\NormalTok{    schedule }\OperatorTok{=}\NormalTok{ \{\}}
    \ControlFlowTok{for}\NormalTok{ subject }\KeywordTok{in}\NormalTok{ teachers:}
\NormalTok{        schedule[subject] }\OperatorTok{=}\NormalTok{ \{}
            \StringTok{"teacher"}\NormalTok{: teachers[subject],}
            \StringTok{"room"}\NormalTok{: rooms.get(subject),}
            \StringTok{"time"}\NormalTok{: times.get(subject)}
\NormalTok{        \}}
    \ControlFlowTok{return}\NormalTok{ schedule}

\BuiltInTok{print}\NormalTok{(build\_schedule())}
\end{Highlighting}
\end{Shaded}

This is a simplified version, but it illustrates how subtasks (teachers,
rooms, times) combine into a whole.

\subsubsection{When It Matters}\label{when-it-matters-37}

School scheduling shows how decomposition tackles even problems with
many moving pieces. By splitting into subtasks, each constraint is
easier to solve, and the final solution becomes possible.

\subsubsection{Try It Yourself}\label{try-it-yourself-39}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down the trunk: \emph{``Build a school schedule.''} What 5
  branches would you add (e.g., teachers, rooms, times, courses,
  constraints)?
\item
  Pick one branch (like assigning rooms). Break it into at least 3
  twigs.
\item
  Imagine two constraints that might conflict (e.g., two classes want
  the same room at the same time). How would you handle them as
  subtasks?
\item
  Reflect: could the same decomposition idea be applied to planning your
  own personal weekly schedule?
\end{enumerate}

\section{Chapter 5. Abstraction: hiding details to see
structure}\label{chapter-5.-abstraction-hiding-details-to-see-structure}

\subsection{41. Why Hide Details: Clarity and
Reuse}\label{why-hide-details-clarity-and-reuse}

Abstraction is about hiding details that aren't immediately needed so
you can focus on the bigger picture. By treating a complex process as a
single step, you gain clarity. Once defined, that abstract step can also
be reused across different problems without worrying about the details
each time.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-40}

Think of driving a car. You say \emph{``drive to school''} without
mentioning every tiny motion of turning the wheel or pressing pedals.
The complexity is hidden so you can focus on the journey, not the
mechanics.

\subsubsection{Deep Dive}\label{deep-dive-10}

Abstraction provides two main advantages:

\begin{itemize}
\tightlist
\item
  Clarity: you don't get lost in irrelevant details when solving
  higher-level problems.
\item
  Reuse: once an abstract component (like ``sort a list'') is defined,
  it can be used in many contexts without rewriting the logic.
\end{itemize}

In computer science, abstraction often takes the form of functions,
classes, or modules. You trust the internal workings are correct, but
you don't need to revisit them when solving a higher-level task. This is
why abstraction is considered one of the core pillars of algorithm
design.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-38}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Without abstraction: too many details every time}
\KeywordTok{def}\NormalTok{ pay\_salary(employee, hours, rate, tax\_rate):}
\NormalTok{    gross }\OperatorTok{=}\NormalTok{ hours }\OperatorTok{*}\NormalTok{ rate}
\NormalTok{    tax }\OperatorTok{=}\NormalTok{ gross }\OperatorTok{*}\NormalTok{ tax\_rate}
\NormalTok{    net }\OperatorTok{=}\NormalTok{ gross }\OperatorTok{{-}}\NormalTok{ tax}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{employee}\SpecialCharTok{\}}\SpecialStringTok{ paid }\SpecialCharTok{\{}\NormalTok{net}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# With abstraction: hide details in reusable helper}
\KeywordTok{def}\NormalTok{ calculate\_net(hours, rate, tax\_rate):}
\NormalTok{    gross }\OperatorTok{=}\NormalTok{ hours }\OperatorTok{*}\NormalTok{ rate}
\NormalTok{    tax }\OperatorTok{=}\NormalTok{ gross }\OperatorTok{*}\NormalTok{ tax\_rate}
    \ControlFlowTok{return}\NormalTok{ gross }\OperatorTok{{-}}\NormalTok{ tax}

\KeywordTok{def}\NormalTok{ pay\_salary(employee, hours, rate, tax\_rate):}
\NormalTok{    net }\OperatorTok{=}\NormalTok{ calculate\_net(hours, rate, tax\_rate)}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{employee}\SpecialCharTok{\}}\SpecialStringTok{ paid }\SpecialCharTok{\{}\NormalTok{net}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{pay\_salary(}\StringTok{"Alice"}\NormalTok{, }\DecValTok{160}\NormalTok{, }\DecValTok{20}\NormalTok{, }\FloatTok{0.2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The second version hides the detail of net calculation, making
\texttt{pay\_salary} clearer and reusable.

\subsubsection{When It Matters}\label{when-it-matters-38}

Abstraction matters when problems get too complex. By hiding details,
you keep focus at the right level, reduce errors, and make solutions
easier to extend and reuse.

\subsubsection{Try It Yourself}\label{try-it-yourself-40}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write steps for baking a cake with no abstraction (list every
  micro-step). Then rewrite it using abstraction (e.g., \emph{``make
  batter''}, \emph{``bake cake''}). Which version feels clearer?
\item
  Imagine you are designing a program that processes grades. Which
  details can you hide behind a helper function?
\item
  Reflect: can you think of a time you benefited from using a tool (like
  a calculator or map app) without needing to know its internal details?
  How did abstraction help you?
\end{enumerate}

\subsection{42. Black-Box Thinking: ``What''
vs.~``How''}\label{black-box-thinking-what-vs.-how}

A black box is something you can use without knowing its inner workings.
In algorithms, this means focusing on what a step accomplishes instead
of how it does it. This shift of perspective allows you to chain
together solutions without getting stuck in implementation details.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-41}

Imagine a vending machine. You press a button, and a soda comes out. You
know \emph{what} it does, but you don't need to know \emph{how} the
machine moves gears or drops the can. To you, it's a black box.

\subsubsection{Deep Dive}\label{deep-dive-11}

Black-box thinking is central to abstraction. It encourages you to
define operations in terms of input and output, not their internal
mechanics. For example:

\begin{itemize}
\tightlist
\item
  What: ``sort this list.''
\item
  How: quicksort, mergesort, or bubble sort---details hidden unless you
  care about efficiency.
\end{itemize}

By treating components as black boxes, you can build complex systems
layer by layer. Later, if you want to optimize, you can ``open the box''
and improve the internals, but the outside behavior stays the same.

This is why APIs, libraries, and modular code design work---they define
clear \emph{contracts} (``what''), while hiding implementation details
(``how'').

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-39}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Black{-}box function: we only care what it does}
\KeywordTok{def}\NormalTok{ sort\_numbers(nums):}
    \ControlFlowTok{return} \BuiltInTok{sorted}\NormalTok{(nums)   }\CommentTok{\# Python\textquotesingle{}s built{-}in sort is a black box here}

\NormalTok{data }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(sort\_numbers(data))  }\CommentTok{\# Output: [1, 2, 5, 8]}

\CommentTok{\# We don\textquotesingle{}t need to know which sorting algorithm Python uses internally.}
\end{Highlighting}
\end{Shaded}

Here the ``what'' is clear: return a sorted list. The ``how'' is
irrelevant to the user.

\subsubsection{When It Matters}\label{when-it-matters-39}

Black-box thinking matters when complexity grows. It lets you build and
reason about large systems without drowning in detail. You only dive
into the ``how'' when necessary.

\subsubsection{Try It Yourself}\label{try-it-yourself-41}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Think of a microwave. List inputs (time, power level, food) and
  outputs (heated food). How does it act like a black box?
\item
  In programming, name one function you use often without knowing its
  internals (e.g., \texttt{print}, \texttt{len}, \texttt{sorted}). What
  is the ``what''? What is the ``how''?
\item
  Design a black-box step for finding the highest grade in a class.
  Write only its input and output, ignoring internal details.
\end{enumerate}

\subsection{43. Everyday Abstraction: Driving a
Car}\label{everyday-abstraction-driving-a-car}

Abstraction isn't just a programming trick---it's something we use in
daily life. Driving a car is a perfect example. You don't think about
the fuel injection system or the chemistry of combustion. You think in
higher-level terms like \emph{``press the accelerator,''} \emph{``turn
the wheel,''} or \emph{``stop at the red light.''} The details are
hidden, but the controls are simple and reusable.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-42}

Picture a car dashboard. You see a steering wheel, pedals, and buttons.
Each control is an abstraction: a simple interface for a complex
machine.

\subsubsection{Deep Dive}\label{deep-dive-12}

The car example highlights how abstraction reduces cognitive burden. If
drivers had to manage pistons, valves, and fuel ratios, almost no one
could drive. Instead, abstraction defines clear, human-friendly
operations that let us use the car effectively.

In algorithms, abstraction works the same way. A complicated sorting
routine or network request can be hidden behind a simple function call.
The user doesn't care about the mechanism, only that it reliably
delivers the result.

Everyday abstractions---like using an ATM, cooking with a microwave, or
swiping a card---demonstrate that hiding detail is essential not only in
computing but also in human design.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-40}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Driving a car, abstracted into simple commands}

\KeywordTok{def}\NormalTok{ drive\_to\_school():}
\NormalTok{    start\_car()}
\NormalTok{    accelerate()}
\NormalTok{    steer(}\StringTok{"left"}\NormalTok{)}
\NormalTok{    brake()}
\NormalTok{    stop\_car()}

\KeywordTok{def}\NormalTok{ start\_car(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Turning key to start engine..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ accelerate(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Pressing accelerator pedal..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ steer(direction): }\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Turning steering wheel }\SpecialCharTok{\{}\NormalTok{direction}\SpecialCharTok{\}}\SpecialStringTok{..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ brake(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Pressing brake pedal..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ stop\_car(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Turning off engine..."}\NormalTok{)}

\NormalTok{drive\_to\_school()}
\end{Highlighting}
\end{Shaded}

Here, the complexity of the engine is hidden. You only work with simple,
high-level controls.

\subsubsection{When It Matters}\label{when-it-matters-40}

Everyday abstraction shows that hiding detail is a survival skill. It
frees you to operate systems without needing to master their inner
workings.

\subsubsection{Try It Yourself}\label{try-it-yourself-42}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  List three more everyday abstractions (e.g., ATM, smartphone apps,
  elevators). What details do they hide?
\item
  Write down what happens when you \emph{``make a phone call.''} What's
  the abstract version? What's hidden underneath?
\item
  Reflect: how would life change if you had to manage all hidden details
  yourself---like dialing phone circuits or managing engine combustion?
\end{enumerate}

\subsection{44. Abstracting Operations: Add, Sort,
Search}\label{abstracting-operations-add-sort-search}

Operations like add, sort, and search are everyday examples of
abstraction. Instead of worrying about how numbers are added, how lists
are sorted, or how an item is found, we treat these as simple commands.
Abstraction turns complex logic into reusable building blocks that can
be applied across countless problems.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-43}

Think of a toolbox. Each tool represents an operation: a hammer for
``add,'' a screwdriver for ``search,'' a wrench for ``sort.'' You don't
need to know how each tool was manufactured---you only need to know how
to use it.

\subsubsection{Deep Dive}\label{deep-dive-13}

Mathematical operations like addition are abstractions. You don't repeat
the proof of what ``2 + 3'' means every time---you simply apply the
rule. Likewise, sorting an array or searching for an element may involve
complex algorithms under the hood, but abstraction lets you think of
them as one step.

This is how software libraries work. Programmers rely on functions like
\texttt{len()}, \texttt{sorted()}, or \texttt{find()} without
reinventing them. Abstraction provides a contract: you trust the tool
works, so you can focus on the larger problem.

Over time, these reusable operations become the language of
problem-solving, enabling us to solve new challenges by combining known
abstractions.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-41}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Abstract operations in action}

\KeywordTok{def}\NormalTok{ demo\_operations():}
\NormalTok{    numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{]}

    \CommentTok{\# Abstract operation: add}
\NormalTok{    total }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(numbers)   }\CommentTok{\# no need to manually loop}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Sum:"}\NormalTok{, total)}

    \CommentTok{\# Abstract operation: sort}
\NormalTok{    sorted\_numbers }\OperatorTok{=} \BuiltInTok{sorted}\NormalTok{(numbers)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Sorted:"}\NormalTok{, sorted\_numbers)}

    \CommentTok{\# Abstract operation: search}
\NormalTok{    found }\OperatorTok{=} \DecValTok{8} \KeywordTok{in}\NormalTok{ numbers}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Is 8 in the list?"}\NormalTok{, found)}

\NormalTok{demo\_operations()}
\end{Highlighting}
\end{Shaded}

Each operation (\texttt{sum}, \texttt{sorted}, \texttt{in}) hides its
internal details and presents a clean, powerful abstraction.

\subsubsection{When It Matters}\label{when-it-matters-41}

Abstracting operations matters because it builds a shared toolkit. By
trusting these building blocks, we save time, reduce errors, and focus
on higher-level design instead of reinventing basics.

\subsubsection{Try It Yourself}\label{try-it-yourself-43}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down five operations you use daily in math or programming (e.g.,
  multiply, split, count, reverse, join). Which details are hidden in
  each?
\item
  Take the task ``find the highest grade in a class.'' How many abstract
  operations can you spot in your solution?
\item
  Reflect: how would programming feel if every time you needed
  \texttt{sort}, you had to write your own algorithm from scratch?
\end{enumerate}

\subsection{45. Layering Abstractions: Functions Calling
Functions}\label{layering-abstractions-functions-calling-functions}

Abstraction doesn't just happen once---it builds in layers. One function
can call another, and that function may call others below it. Each layer
hides detail from the one above, so you only focus on what matters at
your level. This hierarchy creates powerful systems out of simple parts.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-44}

Imagine a city map. At the top level, you see highways. Zoom in, and you
see streets. Zoom further, and you see individual driveways. Each layer
hides lower-level details until you need them. Functions in algorithms
work the same way.

\subsubsection{Deep Dive}\label{deep-dive-14}

Layering abstractions is like stacking building blocks. For example:

\begin{itemize}
\tightlist
\item
  High-level: \emph{``process payroll.''}
\item
  Mid-level: \emph{``calculate net pay for each employee.''}
\item
  Low-level: \emph{``subtract taxes from gross pay.''}
\end{itemize}

This hierarchy ensures clarity. The top layer only cares that the lower
layers work. If a detail changes inside a lower function, the
higher-level functions don't break---as long as the input/output
contract stays the same.

This is how complex software is built. Operating systems, apps, and web
services all rely on layers of abstraction---where each part delegates
detail to the layer below.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-42}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# High{-}level abstraction: process payroll}
\KeywordTok{def}\NormalTok{ process\_payroll(employees):}
    \ControlFlowTok{for}\NormalTok{ employee }\KeywordTok{in}\NormalTok{ employees:}
\NormalTok{        pay\_salary(employee)}

\CommentTok{\# Mid{-}level abstraction: pay one salary}
\KeywordTok{def}\NormalTok{ pay\_salary(employee):}
\NormalTok{    net }\OperatorTok{=}\NormalTok{ calculate\_net(employee[}\StringTok{"hours"}\NormalTok{], employee[}\StringTok{"rate"}\NormalTok{], employee[}\StringTok{"tax\_rate"}\NormalTok{])}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{employee[}\StringTok{\textquotesingle{}name\textquotesingle{}}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{ paid }\SpecialCharTok{\{}\NormalTok{net}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Low{-}level abstraction: actual calculation}
\KeywordTok{def}\NormalTok{ calculate\_net(hours, rate, tax\_rate):}
\NormalTok{    gross }\OperatorTok{=}\NormalTok{ hours }\OperatorTok{*}\NormalTok{ rate}
\NormalTok{    tax }\OperatorTok{=}\NormalTok{ gross }\OperatorTok{*}\NormalTok{ tax\_rate}
    \ControlFlowTok{return}\NormalTok{ gross }\OperatorTok{{-}}\NormalTok{ tax}

\NormalTok{employees }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Alice"}\NormalTok{, }\StringTok{"hours"}\NormalTok{: }\DecValTok{160}\NormalTok{, }\StringTok{"rate"}\NormalTok{: }\DecValTok{20}\NormalTok{, }\StringTok{"tax\_rate"}\NormalTok{: }\FloatTok{0.2}\NormalTok{\},}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Bob"}\NormalTok{, }\StringTok{"hours"}\NormalTok{: }\DecValTok{120}\NormalTok{, }\StringTok{"rate"}\NormalTok{: }\DecValTok{25}\NormalTok{, }\StringTok{"tax\_rate"}\NormalTok{: }\FloatTok{0.15}\NormalTok{\}}
\NormalTok{]}

\NormalTok{process\_payroll(employees)}
\end{Highlighting}
\end{Shaded}

The top layer \texttt{process\_payroll} ignores details of how pay is
calculated---it only delegates to lower layers.

\subsubsection{When It Matters}\label{when-it-matters-42}

Layering abstractions matters because it lets you manage complexity.
Each layer focuses on its own scope, while relying on the layers below
to handle detail. This keeps systems organized, scalable, and easier to
maintain.

\subsubsection{Try It Yourself}\label{try-it-yourself-44}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take the task ``plan a birthday party.'' Write it in three layers:
  top-level (plan party), mid-level (organize food, guests,
  entertainment), low-level (buy cake, send invitations).
\item
  Write pseudocode for ``plan a trip.'' How many layers of abstraction
  can you create?
\item
  Reflect: have you ever tried to do everything at once without layering
  tasks? How did it feel compared to working step by step?
\end{enumerate}

\subsection{46. Choosing the Right Level of
Abstraction}\label{choosing-the-right-level-of-abstraction}

Abstraction is powerful, but it works best when you choose the right
level of detail. Too high-level, and the step feels vague. Too
low-level, and you drown in detail. The sweet spot is an abstraction
that is clear, meaningful, and usable for the task at hand.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-45}

Imagine giving someone directions. If you say \emph{``go north''}, it's
too abstract---they'll get lost. If you say \emph{``take 27 tiny steps,
then turn your foot 32 degrees''}, it's overwhelming. The right level is
something like \emph{``walk two blocks, then turn left.''}

\subsubsection{Deep Dive}\label{deep-dive-15}

The ``right level'' depends on context and audience:

\begin{itemize}
\tightlist
\item
  For humans, ``boil water'' is enough.
\item
  For a robot, you may need ``heat liquid until it reaches 100°C.''
\item
  For an engineer, ``engage heating element until thermostat sensor
  reads threshold.''
\end{itemize}

Each level is valid in its own setting. Abstraction works when it
provides enough clarity for the current problem, but not so much detail
that it distracts. Good algorithm design often involves adjusting the
level of abstraction depending on who (or what) will use it.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-43}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Too vague: not usable}
\KeywordTok{def}\NormalTok{ make\_breakfast():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Prepare breakfast"}\NormalTok{)}

\CommentTok{\# Too detailed: overwhelming}
\KeywordTok{def}\NormalTok{ make\_breakfast\_detailed():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Move right arm 30cm"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Grip fridge handle with fingers"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Rotate wrist to open door"}\NormalTok{)}
    \CommentTok{\# ... dozens of micro{-}steps}

\CommentTok{\# Just right: balanced abstraction}
\KeywordTok{def}\NormalTok{ make\_breakfast\_balanced():}
\NormalTok{    fry\_eggs()}
\NormalTok{    toast\_bread()}
\NormalTok{    brew\_tea()}

\KeywordTok{def}\NormalTok{ fry\_eggs(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Frying eggs..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ toast\_bread(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Toasting bread..."}\NormalTok{)}
\KeywordTok{def}\NormalTok{ brew\_tea(): }\BuiltInTok{print}\NormalTok{(}\StringTok{"Brewing tea..."}\NormalTok{)}

\NormalTok{make\_breakfast\_balanced()}
\end{Highlighting}
\end{Shaded}

The balanced version provides meaningful steps without unnecessary
complexity.

\subsubsection{When It Matters}\label{when-it-matters-43}

Choosing the right level of abstraction matters because it keeps
instructions practical. The goal is clarity: detailed enough to execute,
simple enough to understand.

\subsubsection{Try It Yourself}\label{try-it-yourself-45}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write instructions for washing a car at three levels: vague (3 steps),
  overly detailed (15 steps), and balanced (5--7 steps). Compare them.
\item
  In programming, outline ``sort a list.'' What would be the high-level
  description? What would be the low-level details?
\item
  Reflect: when have you received instructions that were either too
  vague or too detailed? How did it affect your ability to complete the
  task?
\end{enumerate}

\subsection{47. When Hiding Too Much Causes
Trouble}\label{when-hiding-too-much-causes-trouble}

Abstraction hides details to make life easier, but if you hide too much,
important information disappears. This can lead to mistakes,
inefficiency, or even failure. The challenge is knowing which details
are safe to hide and which must remain visible.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-46}

Imagine using a GPS that only tells you \emph{``drive for 2 hours''}
without showing the turns. Too much is hidden, and you risk getting
lost. The tool feels simple, but it's unusable because critical details
are missing.

\subsubsection{Deep Dive}\label{deep-dive-16}

Abstraction fails when the interface does not expose enough for the user
to make good decisions. For example:

\begin{itemize}
\tightlist
\item
  A programming function that ``saves a file'' but doesn't tell you
  where it saved it.
\item
  A data visualization that shows only averages, hiding important
  outliers.
\item
  A tool that gives ``success'' or ``failure'' without error details,
  making debugging impossible.
\end{itemize}

Good abstraction balances clarity with transparency: it hides internal
mechanics but exposes just enough information for correct, effective
use.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-44}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Bad abstraction: hides too much}
\KeywordTok{def}\NormalTok{ save\_file(data):}
    \CommentTok{\# Imagine this saves to a hidden location}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"File saved!"}\NormalTok{)  }\CommentTok{\# But where? The user doesn\textquotesingle{}t know.}

\CommentTok{\# Better abstraction: reveals necessary detail}
\KeywordTok{def}\NormalTok{ save\_file\_explicit(data, filename):}
    \ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(filename, }\StringTok{"w"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
\NormalTok{        f.write(data)}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"File saved to }\SpecialCharTok{\{}\NormalTok{filename}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{save\_file(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{save\_file\_explicit(}\StringTok{"Hello"}\NormalTok{, }\StringTok{"output.txt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The second version hides low-level file operations but still tells the
user where the file went.

\subsubsection{When It Matters}\label{when-it-matters-44}

Abstraction matters most when missing details affect correctness or
usability. Hiding too much turns helpful simplification into a
frustrating barrier.

\subsubsection{Try It Yourself}\label{try-it-yourself-46}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Think of a smartphone app you use. What details does it hide? Which
  hidden detail would cause problems if you needed it?
\item
  Write pseudocode for logging in to a system. How much detail can you
  safely hide? Which parts must remain visible to the user?
\item
  Reflect: have you ever been stuck because a system or tool didn't tell
  you enough? What should have been revealed?
\end{enumerate}

\subsection{48. Abstraction as Human
Communication}\label{abstraction-as-human-communication}

Abstraction is not only for machines---it's how humans communicate
complex ideas quickly. When we talk, we rarely explain every detail.
Instead, we use shared abstractions: words, phrases, or concepts that
bundle meaning. This allows us to exchange ideas efficiently without
drowning in detail.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-47}

Imagine telling a friend, \emph{``Let's meet at the café.''} That phrase
hides countless details: the café's address, how you'll travel there,
when you'll leave home. Yet your friend understands enough to act. The
abstraction works because both of you share context.

\subsubsection{Deep Dive}\label{deep-dive-17}

Human communication relies on layers of abstraction. A teacher says
\emph{``solve the equation''} instead of repeating the rules of algebra.
A doctor says \emph{``rest and hydrate''} instead of listing every
biological process involved.

Abstraction saves time and mental effort, but it depends on shared
understanding. If one person doesn't know the abstraction (``café'' or
``equation''), communication fails. This mirrors computing: abstraction
works only if the contract between users is clear.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-45}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Communication abstraction in programming}
\KeywordTok{def}\NormalTok{ plan\_meeting(person, place):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Meeting }\SpecialCharTok{\{}\NormalTok{person}\SpecialCharTok{\}}\SpecialStringTok{ at }\SpecialCharTok{\{}\NormalTok{place}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Simple abstraction hides detail}
\NormalTok{plan\_meeting(}\StringTok{"Alice"}\NormalTok{, }\StringTok{"café"}\NormalTok{)}

\CommentTok{\# Internally, more detail could be hidden here:}
\KeywordTok{def}\NormalTok{ travel\_to\_place(place):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Walking to bus stop..."}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Taking bus to }\SpecialCharTok{\{}\NormalTok{place}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The first function communicates clearly at a high level, while the
second shows hidden steps if needed.

\subsubsection{When It Matters}\label{when-it-matters-45}

Abstraction in communication matters because it lets people collaborate
efficiently. Shared abstractions form the language of teamwork,
teaching, and daily life. Without them, conversations would be painfully
detailed and slow.

\subsubsection{Try It Yourself}\label{try-it-yourself-47}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Think of three phrases you use daily (e.g., ``do homework,'' ``check
  email,'' ``make dinner''). What hidden steps do they contain?
\item
  Write pseudocode for the phrase ``go shopping.'' Break it into hidden
  subtasks.
\item
  Reflect: have you ever misunderstood someone because their abstraction
  (``finish the project'') was too vague? What detail would have
  clarified it?
\end{enumerate}

\subsection{49. Reusing Abstractions Across
Problems}\label{reusing-abstractions-across-problems}

One of the biggest strengths of abstraction is reuse. Once you've built
an abstract step, you can apply it to many problems without rewriting
it. Instead of reinventing solutions, you treat the abstraction like a
tool that fits into different contexts.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-48}

Think of a can opener. Once invented, it's useful for every can---you
don't need a new tool for each brand. Similarly, once an algorithmic
abstraction like \emph{``sort a list''} exists, it can be reused in
dozens of situations: arranging names, ranking scores, or organizing
files.

\subsubsection{Deep Dive}\label{deep-dive-18}

Reusability is the difference between solving problems once and solving
them forever. Abstractions like ``search,'' ``sort,'' and ``count''
become building blocks for new solutions. This is why programming
languages and libraries are filled with functions---each one is an
abstraction proven to work in many contexts.

Reusing abstractions saves time, prevents errors, and creates
consistency. Instead of writing new code, you rely on tested components.
The more powerful the abstraction, the broader its applications.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-46}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Reusable abstraction: sum of a list}
\KeywordTok{def}\NormalTok{ sum\_list(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\CommentTok{\# Reuse in different contexts}
\KeywordTok{def}\NormalTok{ average(nums):}
    \ControlFlowTok{return}\NormalTok{ sum\_list(nums) }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(nums)}

\KeywordTok{def}\NormalTok{ total\_expenses(expenses):}
    \ControlFlowTok{return}\NormalTok{ sum\_list(expenses)}

\KeywordTok{def}\NormalTok{ total\_grades(grades):}
    \ControlFlowTok{return}\NormalTok{ sum\_list(grades)}

\BuiltInTok{print}\NormalTok{(average([}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{]))        }\CommentTok{\# Reuse in math}
\BuiltInTok{print}\NormalTok{(total\_expenses([}\DecValTok{50}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{25}\NormalTok{])) }\CommentTok{\# Reuse in budgeting}
\BuiltInTok{print}\NormalTok{(total\_grades([}\DecValTok{80}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{100}\NormalTok{]))   }\CommentTok{\# Reuse in school}
\end{Highlighting}
\end{Shaded}

The same \texttt{sum\_list} abstraction is reused across three unrelated
problems.

\subsubsection{When It Matters}\label{when-it-matters-46}

Reusing abstractions matters because it transforms isolated solutions
into universal tools. It builds efficiency and reliability into systems,
making them easier to expand and maintain.

\subsubsection{Try It Yourself}\label{try-it-yourself-48}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three abstractions from daily life (e.g., \emph{``send a
  message,''} \emph{``make coffee,''} \emph{``take notes''}). Where else
  could each be reused?
\item
  Think of the abstraction \emph{``search for an item.''} List three
  very different situations where this applies.
\item
  Reflect: in school or work, when have you solved a problem once and
  then reused the same idea later? What did that save you?
\end{enumerate}

\subsection{50. Mini-Project: Abstract a Recipe into Ingredients →
Method →
Result}\label{mini-project-abstract-a-recipe-into-ingredients-method-result}

Recipes are natural examples of abstraction. They take a complex
process---turning raw ingredients into a dish---and reduce it into three
main parts: ingredients (inputs), method (steps), and result (output).
This mirrors the way algorithms are structured.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-49}

Think of a recipe card. At the top is the name (\emph{``Pancakes''}).
Below it is a short list of ingredients, then step-by-step instructions,
and finally a picture of the finished dish. The recipe doesn't tell you
the chemistry of starch or the physics of heat---it abstracts those
details into simple, human-friendly steps.

\subsubsection{Deep Dive}\label{deep-dive-19}

Recipes show how abstraction makes complex processes shareable and
reusable. Anyone who understands the format (ingredients → method →
result) can follow it. This is the same way algorithms are documented in
pseudocode or flowcharts.

Breaking tasks into these three categories ensures clarity:

\begin{itemize}
\tightlist
\item
  Ingredients (inputs): what you need to start.
\item
  Method (process): what to do in sequence.
\item
  Result (output): what you expect at the end.
\end{itemize}

This abstraction is so universal that it applies not only to cooking but
also to programming, engineering, and science experiments.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-47}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Abstracting a recipe into input → process → output}

\KeywordTok{def}\NormalTok{ make\_pancakes(ingredients):}
    \CommentTok{\# Ingredients (input)}
\NormalTok{    flour }\OperatorTok{=}\NormalTok{ ingredients[}\StringTok{"flour"}\NormalTok{]}
\NormalTok{    eggs }\OperatorTok{=}\NormalTok{ ingredients[}\StringTok{"eggs"}\NormalTok{]}
\NormalTok{    milk }\OperatorTok{=}\NormalTok{ ingredients[}\StringTok{"milk"}\NormalTok{]}

    \CommentTok{\# Method (process)}
\NormalTok{    batter }\OperatorTok{=}\NormalTok{ mix(flour, eggs, milk)}
\NormalTok{    cooked }\OperatorTok{=}\NormalTok{ fry(batter)}

    \CommentTok{\# Result (output)}
    \ControlFlowTok{return} \SpecialStringTok{f"Pancakes ready: }\SpecialCharTok{\{}\NormalTok{cooked}\SpecialCharTok{\}}\SpecialStringTok{"}

\KeywordTok{def}\NormalTok{ mix(flour, eggs, milk): }
    \ControlFlowTok{return} \StringTok{"smooth batter"}

\KeywordTok{def}\NormalTok{ fry(batter): }
    \ControlFlowTok{return} \StringTok{"golden pancakes"}

\BuiltInTok{print}\NormalTok{(make\_pancakes(\{}\StringTok{"flour"}\NormalTok{: }\DecValTok{200}\NormalTok{, }\StringTok{"eggs"}\NormalTok{: }\DecValTok{2}\NormalTok{, }\StringTok{"milk"}\NormalTok{: }\DecValTok{300}\NormalTok{\}))}
\end{Highlighting}
\end{Shaded}

The algorithm ignores the chemistry of cooking---it abstracts them into
simple steps like \emph{mix} and \emph{fry}.

\subsubsection{When It Matters}\label{when-it-matters-47}

Abstracting into ingredients, method, and result matters because it
ensures anyone can follow the process. It provides a universal structure
for sharing solutions without overloading with hidden details.

\subsubsection{Try It Yourself}\label{try-it-yourself-49}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Pick your favorite dish. Write down its ingredients, method, and
  result in recipe format.
\item
  Abstract a non-cooking task (like \emph{sending an email} or
  \emph{packing for a trip}) into the same format: inputs, process,
  output.
\item
  Reflect: why do recipe cards work so well for humans? How does this
  mirror the way algorithms are shared?
\end{enumerate}

\section{Chapter 6. Representing data: numbers, text, and simple
records}\label{chapter-6.-representing-data-numbers-text-and-simple-records}

\subsection{51. Numbers: Integers
vs.~Fractions}\label{numbers-integers-vs.-fractions}

Algorithms often begin with numbers, but not all numbers are the same.
Integers are whole numbers like 3, --7, or 0. Fractions (or decimals)
represent parts of a whole, like ½ or 3.75. Computers treat them
differently because they require different ways of storing and
calculating. Understanding the distinction is key to designing
algorithms that handle numbers correctly.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-50}

Picture a set of building blocks. Integers are full-sized
blocks---whole, solid, and countable. Fractions are like splitting a
block into smaller slices. Both are numbers, but they behave differently
when used in tasks like dividing, measuring, or storing in memory.

\subsubsection{Deep Dive}\label{deep-dive-20}

\begin{itemize}
\tightlist
\item
  Integers are exact. Adding or multiplying them always gives another
  integer (within limits). They're perfect for counting discrete things:
  number of students, apples, or pages.
\item
  Fractions (floats/decimals) allow precision beyond whole units. They
  are used for measuring continuous things: weight, distance, or money.
\item
  Computers store integers in fixed-size containers (8-bit, 32-bit,
  etc.), which makes them exact but limited in range. Fractions are
  usually stored in floating-point format, which allows decimals but
  introduces rounding errors.
\end{itemize}

This distinction affects correctness. For example, adding 0.1 + 0.2 in a
computer may not give exactly 0.3, because floating-point math has
limits. Good algorithms must anticipate this difference.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-48}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Integers: exact arithmetic}
\NormalTok{a }\OperatorTok{=} \DecValTok{5}
\NormalTok{b }\OperatorTok{=} \DecValTok{3}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Integer sum:"}\NormalTok{, a }\OperatorTok{+}\NormalTok{ b)     }\CommentTok{\# 8}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Integer division:"}\NormalTok{, a }\OperatorTok{//}\NormalTok{ b)  }\CommentTok{\# 1 (floor division)}

\CommentTok{\# Fractions (floats): approximate arithmetic}
\NormalTok{x }\OperatorTok{=} \FloatTok{0.1}
\NormalTok{y }\OperatorTok{=} \FloatTok{0.2}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Fraction sum:"}\NormalTok{, x }\OperatorTok{+}\NormalTok{ y)   }\CommentTok{\# 0.30000000000000004}

\CommentTok{\# Mixing integers and floats}
\NormalTok{z }\OperatorTok{=}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b   }\CommentTok{\# result is float}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Division result:"}\NormalTok{, z)    }\CommentTok{\# 1.666...}
\end{Highlighting}
\end{Shaded}

Here we see integers give exact results, while fractions introduce
approximation.

\subsubsection{When It Matters}\label{when-it-matters-48}

Distinguishing between integers and fractions matters because algorithms
must match the type of data they work on. Using the wrong type can lead
to errors, inefficiency, or even crashes in real systems.

\subsubsection{Try It Yourself}\label{try-it-yourself-50}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down five examples from daily life where you'd use integers
  (e.g., number of books) and five where you'd use fractions (e.g.,
  length of a table).
\item
  In programming, what happens if you divide two integers? Try it in
  Python---what's the difference between \texttt{/} and \texttt{//}?
\item
  Reflect: why do you think banks often avoid floating-point numbers and
  instead use integers (like counting cents instead of dollars)?
\end{enumerate}

\subsection{52. Text: Characters, Words,
Sentences}\label{text-characters-words-sentences}

Not all data is numeric. Algorithms also work with text, which is built
from smaller units. At the lowest level are characters (letters, digits,
symbols). Characters form words, and words join into sentences.
Understanding these layers helps algorithms read, search, and transform
text just like they handle numbers.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-51}

Imagine Lego blocks. A single block is like a character. A small
structure made of blocks is like a word. Put many structures together,
and you get a sentence. Algorithms treat text the same way: small units
combine into larger, meaningful ones.

\subsubsection{Deep Dive}\label{deep-dive-21}

\begin{itemize}
\tightlist
\item
  Characters: the atomic units of text. Stored as codes (like ASCII or
  Unicode). For example, \texttt{\textquotesingle{}A\textquotesingle{}}
  is code 65 in ASCII. Unicode expands this to include all languages and
  symbols.
\item
  Words: sequences of characters separated by spaces or punctuation.
  Useful for searching or counting (e.g., word frequency in an essay).
\item
  Sentences: groups of words ending with punctuation (\texttt{.},
  \texttt{!}, \texttt{?}). Algorithms for grammar checking or
  summarization use this layer.
\end{itemize}

Working with text means algorithms must handle structure, spacing, and
sometimes hidden rules (like capitalization, accents, or multi-language
characters). Unlike numbers, text doesn't follow strict arithmetic---it
requires parsing and interpretation.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-49}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Characters}
\NormalTok{text }\OperatorTok{=} \StringTok{"Hello"}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Characters:"}\NormalTok{, }\BuiltInTok{list}\NormalTok{(text))  }\CommentTok{\# [\textquotesingle{}H\textquotesingle{}, \textquotesingle{}e\textquotesingle{}, \textquotesingle{}l\textquotesingle{}, \textquotesingle{}l\textquotesingle{}, \textquotesingle{}o\textquotesingle{}]}

\CommentTok{\# Words}
\NormalTok{sentence }\OperatorTok{=} \StringTok{"Hello world from algorithms"}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Words:"}\NormalTok{, sentence.split())  }\CommentTok{\# [\textquotesingle{}Hello\textquotesingle{}, \textquotesingle{}world\textquotesingle{}, \textquotesingle{}from\textquotesingle{}, \textquotesingle{}algorithms\textquotesingle{}]}

\CommentTok{\# Sentences}
\NormalTok{paragraph }\OperatorTok{=} \StringTok{"Hello world. Algorithms are fun! Let\textquotesingle{}s learn."}
\ImportTok{import}\NormalTok{ re}
\NormalTok{sentences }\OperatorTok{=}\NormalTok{ re.split(}\VerbatimStringTok{r\textquotesingle{}}\PreprocessorTok{[.!?]}\VerbatimStringTok{\textquotesingle{}}\NormalTok{, paragraph)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sentences:"}\NormalTok{, [s.strip() }\ControlFlowTok{for}\NormalTok{ s }\KeywordTok{in}\NormalTok{ sentences }\ControlFlowTok{if}\NormalTok{ s.strip()])}
\end{Highlighting}
\end{Shaded}

Here, text is processed at three levels: characters, words, and
sentences.

\subsubsection{When It Matters}\label{when-it-matters-49}

Text is everywhere---search engines, chat apps, social media, books.
Algorithms need to recognize and process these different layers
correctly to provide meaningful results.

\subsubsection{Try It Yourself}\label{try-it-yourself-51}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take the sentence \emph{``Algorithms are powerful tools.''} List its
  characters, then its words, then identify the sentence as a whole.
\item
  In Python, write code to count how many words are in a given string.
\item
  Reflect: why do you think computers need Unicode instead of just
  ASCII? What real-world problems would ASCII-only systems face?
\end{enumerate}

\subsection{53. Lists: Ordered
Collections}\label{lists-ordered-collections}

A list is a way of grouping data items in order. Unlike single numbers
or words, a list holds many values at once---like a to-do list, shopping
list, or playlist. Lists let algorithms process multiple pieces of
information systematically, keeping them in sequence.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-52}

Imagine a row of lockers in a hallway, each with a number. The hallway
is the list, the locker numbers are the positions, and inside each
locker is a value. To get something, you look up the locker by its
number.

\subsubsection{Deep Dive}\label{deep-dive-22}

Lists are one of the most common data representations:

\begin{itemize}
\tightlist
\item
  Ordered: items keep their position (first, second, third).
\item
  Indexed: each item has a number (index) to access it quickly.
\item
  Flexible: lists can hold numbers, words, or even other lists.
\end{itemize}

Lists are the foundation for many algorithms. Searching, sorting,
filtering, and scanning all start with lists. They also illustrate
trade-offs: lists make sequential access easy, but inserting or deleting
in the middle may be slow.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-50}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Creating a list}
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{40}\NormalTok{]}

\CommentTok{\# Access by index (0{-}based)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"First number:"}\NormalTok{, numbers[}\DecValTok{0}\NormalTok{])  }\CommentTok{\# 10}

\CommentTok{\# Updating an element}
\NormalTok{numbers[}\DecValTok{2}\NormalTok{] }\OperatorTok{=} \DecValTok{35}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Updated list:"}\NormalTok{, numbers)     }\CommentTok{\# [10, 20, 35, 40]}

\CommentTok{\# Adding elements}
\NormalTok{numbers.append(}\DecValTok{50}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"After append:"}\NormalTok{, numbers)     }\CommentTok{\# [10, 20, 35, 40, 50]}

\CommentTok{\# Iterating through a list}
\ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ numbers:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Item:"}\NormalTok{, n)}
\end{Highlighting}
\end{Shaded}

This shows lists as ordered, indexable, and modifiable collections.

\subsubsection{When It Matters}\label{when-it-matters-50}

Lists matter because most real-world data comes in groups: grades for a
class, daily temperatures, or messages in a chat. Algorithms rely on
lists as the basic container to manage and manipulate such sequences.

\subsubsection{Try It Yourself}\label{try-it-yourself-52}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three real-world lists you use daily (e.g., tasks,
  groceries, contacts). How are they ordered?
\item
  In Python, create a list of five numbers. Write code to print the
  first, last, and middle items.
\item
  Reflect: why is order important in a playlist or queue? What problems
  would arise if order were lost?
\end{enumerate}

\subsection{54. Tables: Rows and Columns}\label{tables-rows-and-columns}

A table organizes data into rows and columns, making it easy to compare
and analyze. Each row represents one record (like a student), and each
column represents an attribute (like age or grade). Tables extend the
idea of lists by giving structure in two dimensions instead of one.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-53}

Imagine a classroom attendance sheet. Each row is a student. Each column
is a piece of information---name, age, attendance, grade. The table is
like a grid where rows and columns intersect to form cells.

\subsubsection{Deep Dive}\label{deep-dive-23}

Tables are powerful because they capture relationships across multiple
attributes:

\begin{itemize}
\tightlist
\item
  Rows (records): a single unit of data (e.g., one student).
\item
  Columns (fields): categories describing each record (e.g., name,
  grade).
\item
  Cells: the intersection, holding the actual value.
\end{itemize}

Algorithms use tables for storing, searching, filtering, and summarizing
structured data. In databases, tables are the foundation for queries
(SQL). They allow operations like ``find all students with grade A'' or
``average the ages.''

Tables highlight the importance of structure: while lists track order,
tables track both order and attributes, making them richer containers
for information.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-51}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Representing a table as a list of dictionaries (Python{-}style)}

\NormalTok{students }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Alice"}\NormalTok{, }\StringTok{"age"}\NormalTok{: }\DecValTok{14}\NormalTok{, }\StringTok{"grade"}\NormalTok{: }\StringTok{"A"}\NormalTok{\},}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Bob"}\NormalTok{, }\StringTok{"age"}\NormalTok{: }\DecValTok{15}\NormalTok{, }\StringTok{"grade"}\NormalTok{: }\StringTok{"B"}\NormalTok{\},}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Clara"}\NormalTok{, }\StringTok{"age"}\NormalTok{: }\DecValTok{14}\NormalTok{, }\StringTok{"grade"}\NormalTok{: }\StringTok{"A"}\NormalTok{\}}
\NormalTok{]}

\CommentTok{\# Accessing rows}
\BuiltInTok{print}\NormalTok{(}\StringTok{"First student:"}\NormalTok{, students[}\DecValTok{0}\NormalTok{])}

\CommentTok{\# Accessing columns (attributes)}
\NormalTok{grades }\OperatorTok{=}\NormalTok{ [s[}\StringTok{"grade"}\NormalTok{] }\ControlFlowTok{for}\NormalTok{ s }\KeywordTok{in}\NormalTok{ students]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"All grades:"}\NormalTok{, grades)}

\CommentTok{\# Filtering rows}
\NormalTok{a\_students }\OperatorTok{=}\NormalTok{ [s }\ControlFlowTok{for}\NormalTok{ s }\KeywordTok{in}\NormalTok{ students }\ControlFlowTok{if}\NormalTok{ s[}\StringTok{"grade"}\NormalTok{] }\OperatorTok{==} \StringTok{"A"}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"A students:"}\NormalTok{, a\_students)}
\end{Highlighting}
\end{Shaded}

This shows how rows (students) and columns (attributes) combine into a
table-like structure.

\subsubsection{When It Matters}\label{when-it-matters-51}

Tables matter whenever you deal with structured data: school records,
financial spreadsheets, hospital logs, or even sports stats. They allow
algorithms to organize, query, and summarize information effectively.

\subsubsection{Try It Yourself}\label{try-it-yourself-53}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Draw a small table for three friends with columns: Name, Favorite
  Color, Age. Fill in the rows.
\item
  In Python, represent this table using a list of dictionaries. Write
  code to print all the favorite colors.
\item
  Reflect: why do you think spreadsheets are so widely used? How does
  the table structure make them easy to understand?
\end{enumerate}

\subsection{55. Simple Records: Name--Value
Pairs}\label{simple-records-namevalue-pairs}

A record is a way to group related pieces of information about one
thing. Each piece is stored as a name--value pair: the name tells you
what the data means, and the value holds the actual information. Records
make data self-explanatory and easy to work with.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-54}

Think of a student ID card. It might say \emph{Name: Alice, Age: 14,
Grade: A}. Each field has a label (the name) and a piece of information
(the value). Together, all the pairs form a record about Alice.

\subsubsection{Deep Dive}\label{deep-dive-24}

Records are a more flexible structure than lists because they attach
meaning to each value. Instead of remembering \emph{``the second item is
the age,''} you just look up by the field name.

Key points:

\begin{itemize}
\tightlist
\item
  Name: describes the attribute (e.g., \texttt{"age"}).
\item
  Value: the actual data (e.g., \texttt{14}).
\item
  Record: a collection of name--value pairs describing one entity.
\end{itemize}

Records are the backbone of databases and programming. They appear as
objects in many languages, dictionaries in Python, or rows in database
tables. By grouping data into records, algorithms can store, query, and
update information in a structured way.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-52}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# A record represented as a dictionary in Python}
\NormalTok{student }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"name"}\NormalTok{: }\StringTok{"Alice"}\NormalTok{,}
    \StringTok{"age"}\NormalTok{: }\DecValTok{14}\NormalTok{,}
    \StringTok{"grade"}\NormalTok{: }\StringTok{"A"}
\NormalTok{\}}

\CommentTok{\# Accessing values by name}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Name:"}\NormalTok{, student[}\StringTok{"name"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Age:"}\NormalTok{, student[}\StringTok{"age"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Grade:"}\NormalTok{, student[}\StringTok{"grade"}\NormalTok{])}

\CommentTok{\# Updating a value}
\NormalTok{student[}\StringTok{"grade"}\NormalTok{] }\OperatorTok{=} \StringTok{"A+"}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Updated record:"}\NormalTok{, student)}
\end{Highlighting}
\end{Shaded}

This example shows how names make values self-explanatory and easy to
manage.

\subsubsection{When It Matters}\label{when-it-matters-52}

Records matter whenever you need to store complex information about
entities---students, employees, books, or transactions. By attaching
names to values, algorithms can interpret data correctly without relying
on position alone.

\subsubsection{Try It Yourself}\label{try-it-yourself-54}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a record for your favorite book with fields: Title, Author,
  Year. Write it out as name--value pairs.
\item
  In Python, represent a record for a movie and update one of its fields
  (e.g., change the rating).
\item
  Reflect: what would be harder---storing information about 100 students
  in plain lists, or in records with field names? Why?
\end{enumerate}

\subsection{56. Choosing the Right Representation for
Clarity}\label{choosing-the-right-representation-for-clarity}

The way you represent data shapes how easy it is to understand and use.
Sometimes a list is best, sometimes a table, sometimes a record. The
right choice depends on the problem. Clear representation makes
algorithms simpler and less error-prone.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-55}

Imagine planning a trip. If you only write a list of cities, you miss
details like travel time. If you use a table, you can compare costs and
routes. If you make records, each city entry can hold extra info like
hotels or landmarks. The format you choose decides how clearly you can
plan.

\subsubsection{Deep Dive}\label{deep-dive-25}

\begin{itemize}
\tightlist
\item
  A list works well when order matters (like steps in a recipe).
\item
  A table is best when comparing across categories (like student
  grades).
\item
  A record is ideal when describing one entity with multiple attributes
  (like a profile).
\end{itemize}

Choosing poorly can create confusion: storing student records as plain
lists means you must remember which index is age, grade, or name. A
record makes it explicit.

Clarity also improves collaboration---others can understand and reuse
your data structures without guesswork. Algorithms that begin with good
representation often require fewer steps and fewer corrections later.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-53}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Three different representations of the same data}

\CommentTok{\# List: simple, but unclear}
\NormalTok{student\_list }\OperatorTok{=}\NormalTok{ [}\StringTok{"Alice"}\NormalTok{, }\DecValTok{14}\NormalTok{, }\StringTok{"A"}\NormalTok{]}

\CommentTok{\# Table: comparing multiple students}
\NormalTok{students\_table }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    [}\StringTok{"Name"}\NormalTok{, }\StringTok{"Age"}\NormalTok{, }\StringTok{"Grade"}\NormalTok{],}
\NormalTok{    [}\StringTok{"Alice"}\NormalTok{, }\DecValTok{14}\NormalTok{, }\StringTok{"A"}\NormalTok{],}
\NormalTok{    [}\StringTok{"Bob"}\NormalTok{, }\DecValTok{15}\NormalTok{, }\StringTok{"B"}\NormalTok{]}
\NormalTok{]}

\CommentTok{\# Record: self{-}explanatory}
\NormalTok{student\_record }\OperatorTok{=}\NormalTok{ \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Alice"}\NormalTok{, }\StringTok{"age"}\NormalTok{: }\DecValTok{14}\NormalTok{, }\StringTok{"grade"}\NormalTok{: }\StringTok{"A"}\NormalTok{\}}

\BuiltInTok{print}\NormalTok{(}\StringTok{"List:"}\NormalTok{, student\_list)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Table:"}\NormalTok{, students\_table)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Record:"}\NormalTok{, student\_record)}
\end{Highlighting}
\end{Shaded}

Each structure works, but the record makes meaning clearest.

\subsubsection{When It Matters}\label{when-it-matters-53}

Choosing the right representation matters because clarity prevents
mistakes, improves communication, and makes algorithms easier to design.
The right structure aligns with the problem, reducing unnecessary
complexity.

\subsubsection{Try It Yourself}\label{try-it-yourself-55}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Represent your daily schedule as: (a) a list, (b) a table, (c) a
  record. Which feels clearest?
\item
  Write pseudocode for storing three contacts. Try both lists and
  records. Which is easier to read and use?
\item
  Reflect: think of a time when unclear data (like poorly labeled tables
  or confusing spreadsheets) slowed you down. How could better
  representation have helped?
\end{enumerate}

\subsection{57. Trade-Offs Between
Representations}\label{trade-offs-between-representations}

No single data representation is perfect. Each has strengths and
weaknesses, and choosing one means accepting trade-offs. Lists, tables,
and records each shine in certain contexts but may create extra work in
others. Algorithms must weigh these trade-offs to stay efficient and
clear.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-56}

Imagine carrying groceries. A bag can hold many things quickly but makes
it hard to find one item. A tray keeps items organized but is harder to
carry long distances. A labeled box keeps everything neat but takes more
time to pack. Each choice is useful, but the right one depends on the
situation.

\subsubsection{Deep Dive}\label{deep-dive-26}

\begin{itemize}
\tightlist
\item
  Lists: simple and compact, but meaning is hidden in positions. Great
  for sequences, bad for descriptive data.
\item
  Tables: structured and easy to compare, but rigid---every row must
  have the same columns.
\item
  Records: flexible and self-descriptive, but harder to compare side by
  side at scale.
\end{itemize}

In real algorithms, trade-offs go beyond clarity. They affect speed,
memory, and usability. For example, searching for a student's grade in a
list of lists is slower and less readable than searching in a list of
records. On the other hand, tables are better for bulk operations like
sorting or filtering large datasets.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-54}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Three ways to represent student data}

\CommentTok{\# List: compact, but unclear which value is which}
\NormalTok{student\_list }\OperatorTok{=}\NormalTok{ [}\StringTok{"Alice"}\NormalTok{, }\DecValTok{14}\NormalTok{, }\StringTok{"A"}\NormalTok{]}

\CommentTok{\# Table: great for comparing multiple students}
\NormalTok{students\_table }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    [}\StringTok{"Name"}\NormalTok{, }\StringTok{"Age"}\NormalTok{, }\StringTok{"Grade"}\NormalTok{],}
\NormalTok{    [}\StringTok{"Alice"}\NormalTok{, }\DecValTok{14}\NormalTok{, }\StringTok{"A"}\NormalTok{],}
\NormalTok{    [}\StringTok{"Bob"}\NormalTok{, }\DecValTok{15}\NormalTok{, }\StringTok{"B"}\NormalTok{]}
\NormalTok{]}

\CommentTok{\# Record: clear, but harder to compare at scale}
\NormalTok{student\_record }\OperatorTok{=}\NormalTok{ \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Alice"}\NormalTok{, }\StringTok{"age"}\NormalTok{: }\DecValTok{14}\NormalTok{, }\StringTok{"grade"}\NormalTok{: }\StringTok{"A"}\NormalTok{\}}

\CommentTok{\# Trade{-}off demo: finding Alice\textquotesingle{}s grade}
\BuiltInTok{print}\NormalTok{(}\StringTok{"From list:"}\NormalTok{, student\_list[}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"From table:"}\NormalTok{, students\_table[}\DecValTok{1}\NormalTok{][}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"From record:"}\NormalTok{, student\_record[}\StringTok{"grade"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

All three work, but clarity, comparison, and simplicity differ.

\subsubsection{When It Matters}\label{when-it-matters-54}

Trade-offs matter because the wrong representation can make an algorithm
confusing, slow, or error-prone. The right choice balances clarity,
efficiency, and the kind of tasks you need to perform.

\subsubsection{Try It Yourself}\label{try-it-yourself-56}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Represent a group of books as a list, a table, and records. Which
  version makes it easiest to find ``the author of book X''?
\item
  In Python, store three students using both tables and records. Which
  feels clearer to update when you add a new field (like ``email'')?
\item
  Reflect: think of a spreadsheet you've used. What trade-offs did its
  table format make compared to a simpler list?
\end{enumerate}

\subsection{58. When Representation Shapes the
Algorithm}\label{when-representation-shapes-the-algorithm}

The way data is represented doesn't just change how it looks---it can
change how the algorithm itself works. Some problems are simple with one
representation but complicated with another. The representation can
shape, simplify, or even limit the algorithm you design.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-57}

Imagine storing class attendance. If you keep it as a plain list of
names, finding who was absent takes time. If you store it as a table
with columns for each day, the same question becomes easier. If you use
records with ``present'' or ``absent,'' the algorithm changes again. The
representation shapes the method you choose.

\subsubsection{Deep Dive}\label{deep-dive-27}

Representation and algorithm design are tightly linked:

\begin{itemize}
\tightlist
\item
  A list may require scanning from start to finish to find an item
  (linear search).
\item
  A sorted list enables binary search, which is much faster.
\item
  A hash map (record/dictionary) allows constant-time lookups with no
  scanning.
\end{itemize}

The same task---finding one student's grade---looks different depending
on representation. In one, you loop through a list. In another, you
index into a dictionary instantly.

This is why computer scientists often say: \emph{``Choose the right data
structure, and the algorithm writes itself.''}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-55}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Three representations, same task: find Alice\textquotesingle{}s grade}

\CommentTok{\# List of lists (slow, must scan all)}
\NormalTok{students\_list }\OperatorTok{=}\NormalTok{ [[}\StringTok{"Alice"}\NormalTok{, }\StringTok{"A"}\NormalTok{], [}\StringTok{"Bob"}\NormalTok{, }\StringTok{"B"}\NormalTok{]]}
\ControlFlowTok{for}\NormalTok{ s }\KeywordTok{in}\NormalTok{ students\_list:}
    \ControlFlowTok{if}\NormalTok{ s[}\DecValTok{0}\NormalTok{] }\OperatorTok{==} \StringTok{"Alice"}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"List:"}\NormalTok{, s[}\DecValTok{1}\NormalTok{])}

\CommentTok{\# Sorted list (faster with binary search)}
\ImportTok{import}\NormalTok{ bisect}
\NormalTok{names }\OperatorTok{=}\NormalTok{ [}\StringTok{"Alice"}\NormalTok{, }\StringTok{"Bob"}\NormalTok{]}
\NormalTok{grades }\OperatorTok{=}\NormalTok{ [}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{]}
\NormalTok{i }\OperatorTok{=}\NormalTok{ bisect.bisect\_left(names, }\StringTok{"Alice"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sorted list:"}\NormalTok{, grades[i])}

\CommentTok{\# Record/dictionary (fastest: direct access)}
\NormalTok{students\_dict }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Alice"}\NormalTok{: }\StringTok{"A"}\NormalTok{, }\StringTok{"Bob"}\NormalTok{: }\StringTok{"B"}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Dictionary:"}\NormalTok{, students\_dict[}\StringTok{"Alice"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

The same problem has three algorithms, depending on representation.

\subsubsection{When It Matters}\label{when-it-matters-55}

Representation matters because it can turn a slow, clumsy algorithm into
a fast and elegant one. The wrong choice can make even simple problems
unnecessarily hard.

\subsubsection{Try It Yourself}\label{try-it-yourself-57}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Store a group of contacts as (a) a list, (b) a sorted list, (c) a
  dictionary. Which makes ``find phone number for Sam'' easiest?
\item
  Write pseudocode for checking attendance using both a list and a
  table. How does the algorithm change?
\item
  Reflect: can you think of a time when changing the way you
  \emph{organized} information made the task much easier?
\end{enumerate}

\subsection{59. Converting Between
Representations}\label{converting-between-representations}

Sometimes one representation isn't enough. You may start with data in
one form (like a list) but need it in another (like a table or record)
to solve the problem more effectively. Conversion between
representations lets you adapt algorithms to new needs without losing
the data.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-58}

Think of information like notes on scraps of paper. If you want to
compare them, you rewrite them neatly into a table. If you want to
describe one person in detail, you turn their row into a record. The
data stays the same, but the structure changes to fit the task.

\subsubsection{Deep Dive}\label{deep-dive-28}

\begin{itemize}
\tightlist
\item
  Lists → Tables: combine several lists into a grid (e.g., names, ages,
  grades into a student table).
\item
  Tables → Records: turn one row of a table into a dictionary/object
  with named fields.
\item
  Records → Lists: flatten a record into a simple sequence if only order
  matters.
\end{itemize}

Conversion is common in real systems: CSV files (tables) might be loaded
into dictionaries (records) in Python, or database rows may be
transformed into objects in code. The choice depends on the algorithm
you plan to run afterward.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-56}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Converting between representations}

\CommentTok{\# List of lists}
\NormalTok{students\_list }\OperatorTok{=}\NormalTok{ [[}\StringTok{"Alice"}\NormalTok{, }\DecValTok{14}\NormalTok{, }\StringTok{"A"}\NormalTok{], [}\StringTok{"Bob"}\NormalTok{, }\DecValTok{15}\NormalTok{, }\StringTok{"B"}\NormalTok{]]}

\CommentTok{\# Convert list → record}
\NormalTok{students\_records }\OperatorTok{=}\NormalTok{ [\{}\StringTok{"name"}\NormalTok{: s[}\DecValTok{0}\NormalTok{], }\StringTok{"age"}\NormalTok{: s[}\DecValTok{1}\NormalTok{], }\StringTok{"grade"}\NormalTok{: s[}\DecValTok{2}\NormalTok{]\} }\ControlFlowTok{for}\NormalTok{ s }\KeywordTok{in}\NormalTok{ students\_list]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"As records:"}\NormalTok{, students\_records)}

\CommentTok{\# Convert record → table (list of lists)}
\NormalTok{students\_table }\OperatorTok{=}\NormalTok{ [[s[}\StringTok{"name"}\NormalTok{], s[}\StringTok{"age"}\NormalTok{], s[}\StringTok{"grade"}\NormalTok{]] }\ControlFlowTok{for}\NormalTok{ s }\KeywordTok{in}\NormalTok{ students\_records]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"As table:"}\NormalTok{, students\_table)}
\end{Highlighting}
\end{Shaded}

Here the same data is reshaped depending on the task.

\subsubsection{When It Matters}\label{when-it-matters-56}

Conversion matters because no single structure fits every problem.
Algorithms often need data in different shapes at different stages, and
the ability to convert ensures flexibility and power.

\subsubsection{Try It Yourself}\label{try-it-yourself-58}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a list of three students with names, ages, and grades. Convert
  it into a table with rows and columns.
\item
  In Python, try converting a record
  \texttt{\{name:\ "Alice",\ age:\ 14\}} into a simple list
  \texttt{{[}"Alice",\ 14{]}}.
\item
  Reflect: why do you think so many real-world systems use
  ``import/export'' functions (e.g., CSV, JSON, Excel)? What role does
  conversion play?
\end{enumerate}

\subsection{60. Real-World Example: Storing Student
Info}\label{real-world-example-storing-student-info}

Let's bring lists, tables, and records together in a real example:
storing student information. A school might track each student's name,
age, and grade. The representation you choose shapes how easily you can
access, update, and use the data.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-59}

Imagine three different notebooks:

\begin{itemize}
\tightlist
\item
  One is just a long list of values, where you must remember what each
  number means.
\item
  Another is a table, neatly laid out with rows for students and columns
  for attributes.
\item
  The last is a record book, where each page describes one student with
  labeled fields.
\end{itemize}

All three store the same data, but the experience of using them is very
different.

\subsubsection{Deep Dive}\label{deep-dive-29}

\begin{itemize}
\tightlist
\item
  List approach: Compact but unclear. You need to remember positions.
  Example: \texttt{{[}"Alice",\ 14,\ "A"{]}}.
\item
  Table approach: Good for comparison. Each row is a student, and
  columns keep categories consistent.
\item
  Record approach: Self-explanatory. Fields like \texttt{"name"},
  \texttt{"age"}, and \texttt{"grade"} make meaning obvious.
\end{itemize}

In real systems:

\begin{itemize}
\tightlist
\item
  Spreadsheets use tables.
\item
  Databases often represent rows as records.
\item
  Programming languages allow all three, but records
  (objects/dictionaries) are usually the clearest.
\end{itemize}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-57}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Three ways to store the same student info}

\CommentTok{\# List: compact but positional}
\NormalTok{student\_list }\OperatorTok{=}\NormalTok{ [}\StringTok{"Alice"}\NormalTok{, }\DecValTok{14}\NormalTok{, }\StringTok{"A"}\NormalTok{]}

\CommentTok{\# Table: easy to compare many students}
\NormalTok{students\_table }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    [}\StringTok{"Name"}\NormalTok{, }\StringTok{"Age"}\NormalTok{, }\StringTok{"Grade"}\NormalTok{],}
\NormalTok{    [}\StringTok{"Alice"}\NormalTok{, }\DecValTok{14}\NormalTok{, }\StringTok{"A"}\NormalTok{],}
\NormalTok{    [}\StringTok{"Bob"}\NormalTok{, }\DecValTok{15}\NormalTok{, }\StringTok{"B"}\NormalTok{]}
\NormalTok{]}

\CommentTok{\# Record: self{-}descriptive}
\NormalTok{student\_record }\OperatorTok{=}\NormalTok{ \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Alice"}\NormalTok{, }\StringTok{"age"}\NormalTok{: }\DecValTok{14}\NormalTok{, }\StringTok{"grade"}\NormalTok{: }\StringTok{"A"}\NormalTok{\}}

\BuiltInTok{print}\NormalTok{(}\StringTok{"List:"}\NormalTok{, student\_list)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Table:"}\NormalTok{, students\_table)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Record:"}\NormalTok{, student\_record)}
\end{Highlighting}
\end{Shaded}

Each structure solves the same problem in a different way.

\subsubsection{When It Matters}\label{when-it-matters-57}

This example shows why representation matters. The right choice depends
on your goal: speed, clarity, or comparison. A good algorithm starts
with a representation that matches the problem.

\subsubsection{Try It Yourself}\label{try-it-yourself-59}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Represent your own student info (name, age, favorite subject) as a
  list, a table row, and a record. Which feels clearest?
\item
  Add three students into a table format. How easy is it to compare
  ages?
\item
  Reflect: if you were designing a school database, which representation
  would you choose and why?
\end{enumerate}

\section{Chapter 7. Correctness as promise:
pre/postconditions}\label{chapter-7.-correctness-as-promise-prepostconditions}

\subsection{61. Defining Correctness: Doing the Right
Job}\label{defining-correctness-doing-the-right-job}

An algorithm is correct if it always produces the right result for every
valid input. Correctness is not about speed or elegance---it is about
trust. If you give the algorithm what it expects, it must return exactly
what it promises.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-60}

Think of a calculator. When you press \texttt{2\ +\ 2}, you expect
\texttt{4} every time. If sometimes it gave \texttt{5}, you would never
trust it again. Correctness is the guarantee that the tool does the job
it claims, without surprises.

\subsubsection{Deep Dive}\label{deep-dive-30}

Correctness can be described in terms of specifications:

\begin{itemize}
\tightlist
\item
  Preconditions: what must be true before the algorithm runs (e.g., the
  input list is not empty).
\item
  Postconditions: what must be true after the algorithm runs (e.g., the
  output list is sorted).
\end{itemize}

An algorithm is correct if it always transforms inputs into outputs that
satisfy its specification.

Correctness does not mean usefulness. An algorithm could be correct but
inefficient (like sorting numbers by writing them on cards and asking
friends to arrange them). Correctness is the foundation; efficiency
comes later.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-58}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Correct algorithm: sum of numbers}
\KeywordTok{def}\NormalTok{ sum\_list(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\BuiltInTok{print}\NormalTok{(sum\_list([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]))  }\CommentTok{\# Expected: 6}

\CommentTok{\# Incorrect algorithm: forgets last number}
\KeywordTok{def}\NormalTok{ bad\_sum\_list(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums[:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]:  }\CommentTok{\# skips last item}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\BuiltInTok{print}\NormalTok{(bad\_sum\_list([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]))  }\CommentTok{\# Wrong: 3 instead of 6}
\end{Highlighting}
\end{Shaded}

The first version meets the specification; the second fails---it is
incorrect.

\subsubsection{When It Matters}\label{when-it-matters-58}

Correctness matters whenever results must be trusted: in banking,
medicine, navigation, or even everyday apps. An algorithm that is fast
but wrong is worse than useless---it is dangerous.

\subsubsection{Try It Yourself}\label{try-it-yourself-60}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down a simple algorithm for ``find the largest number in a
  list.'' What would its precondition and postcondition be?
\item
  Try to come up with a case where an algorithm might look correct at
  first but fails for certain inputs (like an empty list).
\item
  Reflect: in your own experience, have you trusted a tool or app only
  to find it gave wrong results? How did that affect your confidence?
\end{enumerate}

\subsection{62. Preconditions: What Must Hold Before
Running}\label{preconditions-what-must-hold-before-running}

A precondition is a requirement that must be true before an algorithm
begins. If the precondition is not met, the algorithm cannot guarantee
correctness. Preconditions define the ``starting line'' so the algorithm
knows it is working with valid input.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-61}

Imagine a washing machine. The precondition is that clothes must be
inside, detergent must be added, and the door must be closed. If you
skip any of these, the machine cannot do its job properly.

\subsubsection{Deep Dive}\label{deep-dive-31}

Preconditions set the rules for acceptable inputs:

\begin{itemize}
\tightlist
\item
  Example: a square root algorithm requires the input number to be
  non-negative.
\item
  Example: a divide algorithm requires the divisor not to be zero.
\item
  Example: a sorting algorithm might require the input to be a list, not
  a single number.
\end{itemize}

Preconditions protect both the algorithm and the user. They prevent
wasted effort on impossible tasks and provide clear boundaries of
responsibility: the user ensures the input is valid, the algorithm
ensures the output is correct.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-59}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Square root algorithm with precondition}
\ImportTok{import}\NormalTok{ math}

\KeywordTok{def}\NormalTok{ safe\_sqrt(x):}
    \ControlFlowTok{assert}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: x must be non{-}negative"}
    \ControlFlowTok{return}\NormalTok{ math.sqrt(x)}

\BuiltInTok{print}\NormalTok{(safe\_sqrt(}\DecValTok{9}\NormalTok{))   }\CommentTok{\# Works: 3.0}
\BuiltInTok{print}\NormalTok{(safe\_sqrt(}\DecValTok{0}\NormalTok{))   }\CommentTok{\# Works: 0.0}
\CommentTok{\# print(safe\_sqrt({-}4)) \# Would raise error: precondition not met}
\end{Highlighting}
\end{Shaded}

Here the precondition (\texttt{x\ \textgreater{}=\ 0}) must hold. If it
doesn't, the algorithm refuses to run.

\subsubsection{When It Matters}\label{when-it-matters-59}

Preconditions matter because they prevent invalid inputs from producing
nonsense or crashes. They define the safe zone in which an algorithm can
be trusted.

\subsubsection{Try It Yourself}\label{try-it-yourself-61}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write down the preconditions for these tasks:

  \begin{itemize}
  \tightlist
  \item
    Finding the maximum in a list.
  \item
    Dividing two numbers.
  \item
    Accessing the first item of a list.
  \end{itemize}
\item
  In Python, write a function \texttt{average(nums)} that checks a
  precondition before dividing (the list must not be empty).
\item
  Reflect: have you ever used a tool that broke because you didn't set
  it up correctly first? What was the ``precondition'' you missed?
\end{enumerate}

\subsection{63. Postconditions: What Must Hold After
Running}\label{postconditions-what-must-hold-after-running}

A postcondition is a guarantee about the state of the output once an
algorithm has finished. If the preconditions were satisfied at the
start, the postconditions must always hold at the end. They are the
``promises'' an algorithm makes to prove it did its job correctly.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-62}

Imagine ordering food at a restaurant. The precondition is that you must
place an order and pay. The postcondition is that you receive exactly
the meal you asked for, not something random. The process in between may
be hidden, but the end result is guaranteed.

\subsubsection{Deep Dive}\label{deep-dive-32}

Postconditions express correctness in a measurable way:

\begin{itemize}
\tightlist
\item
  A sorting algorithm must return a list where each element is less than
  or equal to the next.
\item
  A search algorithm must return either the correct position of an item
  or a clear signal it wasn't found.
\item
  A payment algorithm must reduce the account balance by the correct
  amount.
\end{itemize}

They can also include side effects: ``the file exists on disk'' or ``the
database row is updated.'' Together, preconditions and postconditions
form a contract: if you give valid input, the algorithm guarantees valid
output.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-60}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sorting with postcondition check}
\KeywordTok{def}\NormalTok{ sort\_numbers(nums):}
\NormalTok{    result }\OperatorTok{=} \BuiltInTok{sorted}\NormalTok{(nums)}
    \CommentTok{\# Postcondition: list must be non{-}decreasing}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(result) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{):}
        \ControlFlowTok{assert}\NormalTok{ result[i] }\OperatorTok{\textless{}=}\NormalTok{ result[i }\OperatorTok{+} \DecValTok{1}\NormalTok{], }\StringTok{"Postcondition failed!"}
    \ControlFlowTok{return}\NormalTok{ result}

\BuiltInTok{print}\NormalTok{(sort\_numbers([}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]))   }\CommentTok{\# [1, 2, 3]}
\BuiltInTok{print}\NormalTok{(sort\_numbers([}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{]))   }\CommentTok{\# [4, 5, 6]}
\end{Highlighting}
\end{Shaded}

Here, the postcondition ensures the output is sorted before it is
returned.

\subsubsection{When It Matters}\label{when-it-matters-60}

Postconditions matter because they give confidence. They allow users and
systems to trust that the algorithm delivered exactly what it promised,
regardless of how it was implemented inside.

\subsubsection{Try It Yourself}\label{try-it-yourself-62}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write down postconditions for these algorithms:

  \begin{itemize}
  \tightlist
  \item
    Reversing a string.
  \item
    Finding the maximum number in a list.
  \item
    Calculating an average.
  \end{itemize}
\item
  In Python, write a function that finds the maximum of a list and
  asserts the postcondition that every element in the list is less than
  or equal to the result.
\item
  Reflect: have you ever used software where the ``output'' didn't match
  the promise (like a download that didn't open, or a payment that
  didn't go through)? What postcondition failed?
\end{enumerate}

\subsection{64. Simple Example: Square Root Requires Non-Negative
Input}\label{simple-example-square-root-requires-non-negative-input}

A square root algorithm is a classic case where preconditions and
postconditions are clear. The precondition: the input must be
non-negative. The postcondition: the output squared must equal the input
(within rounding error). This small example shows how correctness is
defined in practice.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-63}

Think of drawing a square. If the area of the square is 9, the side
length must be 3. The square root algorithm takes the area and gives you
the side length. But if the area is negative, the problem doesn't make
sense---there's no real square with negative area.

\subsubsection{Deep Dive}\label{deep-dive-33}

\begin{itemize}
\tightlist
\item
  Precondition: Input \(x \geq 0\). Negative numbers are invalid unless
  you extend into complex numbers.
\item
  Postcondition: Output \(y\) must satisfy \(y^2 \approx x\). The
  approximation is needed because floating-point arithmetic can't always
  be exact.
\end{itemize}

This example highlights why contracts matter: without the precondition,
the algorithm could crash or return nonsense. Without the postcondition,
you can't be sure it worked correctly.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-61}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ math}

\KeywordTok{def}\NormalTok{ safe\_sqrt(x):}
    \CommentTok{\# Precondition: x must be non{-}negative}
    \ControlFlowTok{assert}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: input must be non{-}negative"}
\NormalTok{    y }\OperatorTok{=}\NormalTok{ math.sqrt(x)}
    \CommentTok{\# Postcondition: y * y must equal x (within tolerance)}
    \ControlFlowTok{assert} \BuiltInTok{abs}\NormalTok{((y }\OperatorTok{*}\NormalTok{ y) }\OperatorTok{{-}}\NormalTok{ x) }\OperatorTok{\textless{}} \FloatTok{1e{-}9}\NormalTok{, }\StringTok{"Postcondition failed"}
    \ControlFlowTok{return}\NormalTok{ y}

\BuiltInTok{print}\NormalTok{(safe\_sqrt(}\DecValTok{9}\NormalTok{))   }\CommentTok{\# 3.0}
\BuiltInTok{print}\NormalTok{(safe\_sqrt(}\DecValTok{0}\NormalTok{))   }\CommentTok{\# 0.0}
\CommentTok{\# print(safe\_sqrt({-}4))  \# Raises precondition error}
\end{Highlighting}
\end{Shaded}

Here both the precondition and postcondition are checked, ensuring
correctness.

\subsubsection{When It Matters}\label{when-it-matters-61}

This matters in scientific, engineering, and financial applications,
where using an invalid input could produce catastrophic results.
Correctness checks keep algorithms safe and trustworthy.

\subsubsection{Try It Yourself}\label{try-it-yourself-63}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write the precondition and postcondition for an algorithm that divides
  two numbers.
\item
  Do the same for an algorithm that finds the maximum value in a list.
\item
  Reflect: why is it dangerous to ignore preconditions when designing
  real-world systems (like medical devices or banking software)?
\end{enumerate}

\subsection{65. Another Example: Sorting Means Output Must Be
Ordered}\label{another-example-sorting-means-output-must-be-ordered}

A sorting algorithm shows correctness through its postcondition: the
output list must be in non-decreasing order. No matter what steps the
algorithm uses inside---swapping, merging, partitioning---the end result
must always meet this condition.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-64}

Imagine lining up students by height. The process might differ: one
teacher may compare pairs, another may group tall and short students,
but the final picture should always be the same---a line where each
student is as tall or taller than the one before.

\subsubsection{Deep Dive}\label{deep-dive-34}

\begin{itemize}
\tightlist
\item
  Precondition: Input must be a list of comparable items (you can't sort
  apples and numbers together without rules).
\item
  Postcondition: For every position \(i\), the condition
  \texttt{list{[}i{]}\ \textless{}=\ list{[}i+1{]}} must hold across the
  whole output.
\item
  Secondary guarantee: The output must contain the same items as the
  input, just reordered.
\end{itemize}

This example illustrates that correctness doesn't care about how the
algorithm works---only that the contract is fulfilled. That's why
multiple sorting algorithms (bubble sort, merge sort, quicksort) are all
considered correct.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-62}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ is\_sorted(lst):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(lst) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{):}
        \ControlFlowTok{if}\NormalTok{ lst[i] }\OperatorTok{\textgreater{}}\NormalTok{ lst[i }\OperatorTok{+} \DecValTok{1}\NormalTok{]:}
            \ControlFlowTok{return} \VariableTok{False}
    \ControlFlowTok{return} \VariableTok{True}

\KeywordTok{def}\NormalTok{ safe\_sort(lst):}
\NormalTok{    result }\OperatorTok{=} \BuiltInTok{sorted}\NormalTok{(lst)   }\CommentTok{\# use built{-}in sort}
    \CommentTok{\# Postcondition 1: list is sorted}
    \ControlFlowTok{assert}\NormalTok{ is\_sorted(result), }\StringTok{"Postcondition failed: list not sorted"}
    \CommentTok{\# Postcondition 2: same items remain}
    \ControlFlowTok{assert} \BuiltInTok{sorted}\NormalTok{(lst) }\OperatorTok{==}\NormalTok{ result, }\StringTok{"Postcondition failed: items changed"}
    \ControlFlowTok{return}\NormalTok{ result}

\BuiltInTok{print}\NormalTok{(safe\_sort([}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]))   }\CommentTok{\# [1, 2, 3]}
\BuiltInTok{print}\NormalTok{(safe\_sort([}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{])) }\CommentTok{\# [4, 4, 5, 6]}
\end{Highlighting}
\end{Shaded}

Here, correctness is checked by ensuring order and preserving items.

\subsubsection{When It Matters}\label{when-it-matters-62}

Sorting is everywhere---search engines, rankings, file systems. If
sorting fails, downstream algorithms that assume order will break.
Correctness guarantees that these later steps work as expected.

\subsubsection{Try It Yourself}\label{try-it-yourself-64}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down the precondition and postcondition for sorting a list of
  names alphabetically.
\item
  In Python, create a function that checks whether a list is sorted.
  Test it on both sorted and unsorted lists.
\item
  Reflect: why is it important to guarantee not only that the list is
  ordered but also that the items are preserved?
\end{enumerate}

\subsection{66. Preconditions as Safety
Guards}\label{preconditions-as-safety-guards}

Preconditions act like safety guards. They prevent an algorithm from
starting unless the input is valid. Instead of running blindly and
producing nonsense, the algorithm stops early and warns you.
Preconditions are like a security gate: they check the ticket before you
enter.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-65}

Think of riding a roller coaster. The ride won't start unless the
seatbelt is locked. That's the precondition. If the condition isn't met,
the system refuses to proceed---keeping everyone safe.

\subsubsection{Deep Dive}\label{deep-dive-35}

Preconditions are usually expressed as checks:

\begin{itemize}
\tightlist
\item
  Mathematical examples: denominator ≠ 0 before division; input ≥ 0
  before square root.
\item
  Programming examples: list not empty before finding maximum; file
  exists before reading it.
\item
  System examples: user logged in before accessing data.
\end{itemize}

By enforcing preconditions, algorithms avoid undefined states. They
don't ``fix'' bad input; they reject it. This separation of
responsibility is powerful: the user ensures inputs are valid, the
algorithm ensures outputs are correct.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-63}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ divide(a, b):}
    \CommentTok{\# Precondition: b must not be zero}
    \ControlFlowTok{assert}\NormalTok{ b }\OperatorTok{!=} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: divisor must not be zero"}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}

\BuiltInTok{print}\NormalTok{(divide(}\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{))   }\CommentTok{\# 5.0}
\CommentTok{\# print(divide(10, 0)) \# Raises error: precondition not met}
\end{Highlighting}
\end{Shaded}

The guard ensures division only happens when safe.

\subsubsection{When It Matters}\label{when-it-matters-63}

Preconditions matter because they protect algorithms from invalid
states. Without them, programs may crash, return wrong results, or
silently corrupt data.

\subsubsection{Try It Yourself}\label{try-it-yourself-65}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write preconditions for these algorithms:

  \begin{itemize}
  \tightlist
  \item
    Calculating an average.
  \item
    Accessing the first element in a list.
  \item
    Finding a square root.
  \end{itemize}
\item
  Modify a Python function you've written before to include at least one
  precondition check.
\item
  Reflect: have you ever seen an error message like \emph{``file not
  found''} or \emph{``invalid password''}? How was that a precondition
  guard?
\end{enumerate}

\subsection{67. Postconditions as Promises
Delivered}\label{postconditions-as-promises-delivered}

A postcondition is the algorithm's promise: if it starts with valid
input, it guarantees a correct and predictable output. No matter what
happens inside, when the algorithm finishes, the postcondition must hold
true.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-66}

Think of ordering a package online. The precondition is that you pay for
it. The postcondition is that the package arrives at your door. How the
store processes the order is hidden---but the end result is guaranteed.

\subsubsection{Deep Dive}\label{deep-dive-36}

Postconditions can describe different kinds of promises:

\begin{itemize}
\tightlist
\item
  Mathematical: ``the result squared equals the input'' (square root).
\item
  Ordering: ``the output list is sorted'' (sorting).
\item
  Containment: ``the output contains all and only the original items''
  (search or filter).
\item
  State changes: ``a file now exists on disk'' or ``the user's balance
  is reduced.''
\end{itemize}

By defining postconditions, you don't need to know how the algorithm
works inside. You just check the promise. This makes algorithms reliable
building blocks for bigger systems.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-64}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ find\_max(nums):}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition: list must not be empty"}
\NormalTok{    result }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(nums)}
    \CommentTok{\# Postcondition: result must be \textgreater{}= every element in the list}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
        \ControlFlowTok{assert}\NormalTok{ result }\OperatorTok{\textgreater{}=}\NormalTok{ n, }\StringTok{"Postcondition failed"}
    \ControlFlowTok{return}\NormalTok{ result}

\BuiltInTok{print}\NormalTok{(find\_max([}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{]))  }\CommentTok{\# 7}
\end{Highlighting}
\end{Shaded}

The postcondition ensures the result is truly the maximum.

\subsubsection{When It Matters}\label{when-it-matters-64}

Postconditions matter because they create trust. They let users and
systems rely on an algorithm as a dependable component, confident that
if the input is valid, the output will always meet the contract.

\subsubsection{Try It Yourself}\label{try-it-yourself-66}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write down the postcondition for these tasks:

  \begin{itemize}
  \tightlist
  \item
    Reversing a string.
  \item
    Summing numbers in a list.
  \item
    Checking if a number is prime.
  \end{itemize}
\item
  In Python, write a function \texttt{reverse(text)} that asserts the
  postcondition: reversing twice returns the original string.
\item
  Reflect: can you think of a time when software produced an output that
  didn't match its promise? What postcondition was broken?
\end{enumerate}

\subsection{68. Testing Against Correctness
Conditions}\label{testing-against-correctness-conditions}

Algorithms aren't trustworthy until they are tested against their
preconditions and postconditions. Testing is like asking: \emph{``Did
the input meet the rules before we began?''} and \emph{``Did the output
keep the promises when we finished?''} These checks confirm that
correctness conditions are satisfied in practice, not just in theory.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-67}

Imagine a pilot's checklist. Before takeoff, they check preconditions:
fuel filled, engines ready, weather clear. After landing, they check
postconditions: wheels locked, engines off, passengers safe. Testing an
algorithm works the same way---before and after checks ensure safety.

\subsubsection{Deep Dive}\label{deep-dive-37}

\begin{itemize}
\tightlist
\item
  Precondition testing: confirms inputs are valid. If not, the algorithm
  should refuse to run.
\item
  Postcondition testing: confirms outputs are valid. If not, the
  algorithm must signal failure.
\item
  Benefits: prevents hidden bugs, ensures trust in algorithms, and makes
  failures clear rather than silent.
\end{itemize}

In practice, correctness tests may use assertions, unit tests, or even
formal proofs. While proofs are mathematical, everyday programming often
uses automated tests to check conditions quickly and repeatedly.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-65}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ average(nums):}
    \CommentTok{\# Precondition: list must not be empty}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: nums must not be empty"}
    
\NormalTok{    result }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(nums) }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(nums)}
    
    \CommentTok{\# Postcondition: result must lie between min and max}
    \ControlFlowTok{assert} \BuiltInTok{min}\NormalTok{(nums) }\OperatorTok{\textless{}=}\NormalTok{ result }\OperatorTok{\textless{}=} \BuiltInTok{max}\NormalTok{(nums), }\StringTok{"Postcondition failed"}
    \ControlFlowTok{return}\NormalTok{ result}

\BuiltInTok{print}\NormalTok{(average([}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{]))  }\CommentTok{\# 4.0}
\CommentTok{\# print(average([]))       \# Error: precondition not met}
\end{Highlighting}
\end{Shaded}

The checks ensure the algorithm is only run on safe inputs and delivers
valid outputs.

\subsubsection{When It Matters}\label{when-it-matters-65}

Testing correctness conditions matters because unchecked algorithms can
silently fail, causing hidden errors in larger systems. Clear tests
expose mistakes early, before they cause real damage.

\subsubsection{Try It Yourself}\label{try-it-yourself-67}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function \texttt{min\_value(nums)} with a precondition that
  the list is not empty, and a postcondition that the result is ≤ every
  element.
\item
  Test your function on both valid and invalid inputs. Does it behave
  correctly?
\item
  Reflect: why is it better for an algorithm to raise an error when a
  precondition fails rather than trying to ``guess'' what to do?
\end{enumerate}

\subsection{69. Why Correctness Matters in Real
Systems}\label{why-correctness-matters-in-real-systems}

Correctness is not just a classroom idea---it is the backbone of trust
in real systems. An algorithm that runs fast but produces the wrong
answer is dangerous. In areas like banking, healthcare, or navigation, a
single incorrect result can cause huge losses or even risk lives.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-68}

Imagine an elevator system. If the algorithm controlling the doors is
incorrect---sometimes opening between floors---the whole system becomes
unsafe. Correctness is the promise that the elevator works exactly as
intended, every time.

\subsubsection{Deep Dive}\label{deep-dive-38}

\begin{itemize}
\tightlist
\item
  Banking: an algorithm that transfers money must debit and credit
  accounts correctly, or people lose trust in the system.
\item
  Healthcare: a diagnostic tool must not mislabel results---incorrect
  outputs could harm patients.
\item
  Navigation: GPS algorithms must compute correct routes; a small
  mistake could send drivers to the wrong destination.
\item
  Safety systems: airbag deployment, airplane autopilots, and medical
  pumps all depend on guaranteed correctness.
\end{itemize}

In these domains, correctness is more important than speed or elegance.
That's why engineers often pair correctness guarantees (via
preconditions and postconditions) with rigorous testing and even formal
verification.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-66}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: transferring money between accounts}

\KeywordTok{def}\NormalTok{ transfer(balance\_a, balance\_b, amount):}
    \CommentTok{\# Preconditions}
    \ControlFlowTok{assert}\NormalTok{ amount }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: amount must be non{-}negative"}
    \ControlFlowTok{assert}\NormalTok{ balance\_a }\OperatorTok{\textgreater{}=}\NormalTok{ amount, }\StringTok{"Precondition failed: insufficient funds"}
    
\NormalTok{    new\_a }\OperatorTok{=}\NormalTok{ balance\_a }\OperatorTok{{-}}\NormalTok{ amount}
\NormalTok{    new\_b }\OperatorTok{=}\NormalTok{ balance\_b }\OperatorTok{+}\NormalTok{ amount}
    
    \CommentTok{\# Postconditions}
    \ControlFlowTok{assert}\NormalTok{ new\_a }\OperatorTok{+}\NormalTok{ new\_b }\OperatorTok{==}\NormalTok{ balance\_a }\OperatorTok{+}\NormalTok{ balance\_b, }\StringTok{"Postcondition failed: money lost or created"}
    
    \ControlFlowTok{return}\NormalTok{ new\_a, new\_b}

\BuiltInTok{print}\NormalTok{(transfer(}\DecValTok{100}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{30}\NormalTok{))  }\CommentTok{\# (70, 80)}
\end{Highlighting}
\end{Shaded}

Here, correctness ensures no money is lost or created during the
transfer.

\subsubsection{When It Matters}\label{when-it-matters-66}

Correctness matters whenever people rely on algorithms for safety,
fairness, or financial accuracy. Without it, systems lose credibility,
and their outputs may do more harm than good.

\subsubsection{Try It Yourself}\label{try-it-yourself-68}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  List three real-world systems (outside of computing) where correctness
  is absolutely critical. What could go wrong if they failed?
\item
  Write pseudocode for checking into a flight. What preconditions and
  postconditions would you set?
\item
  Reflect: have you ever lost trust in a system (like a website or app)
  because it gave the wrong result? What happened?
\end{enumerate}

\subsection{70. Exercise: Define Pre/Postconditions for ``Reverse a
String''}\label{exercise-define-prepostconditions-for-reverse-a-string}

Reversing a string is a simple task but a great way to practice
correctness. The algorithm takes an input string and outputs the same
string with its characters in reverse order. Preconditions and
postconditions make the promise precise.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-69}

Imagine beads on a string. The input string is the beads in order:
A-B-C-D. Reversing it flips them to D-C-B-A. The beads don't change,
only their positions.

\subsubsection{Deep Dive}\label{deep-dive-39}

\begin{itemize}
\item
  Precondition: The input must be a valid string (not \texttt{None}, not
  a number).
\item
  Postconditions:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    The output string has the same length as the input.
  \item
    Each character in the output appears in the input the same number of
    times.
  \item
    The output is the input's characters in reverse order.
  \end{enumerate}
\end{itemize}

This ensures the algorithm does not lose, add, or alter characters---it
only flips their order.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-67}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ reverse\_string(s):}
    \CommentTok{\# Precondition: must be a string}
    \ControlFlowTok{assert} \BuiltInTok{isinstance}\NormalTok{(s, }\BuiltInTok{str}\NormalTok{), }\StringTok{"Precondition failed: input must be a string"}
    
\NormalTok{    result }\OperatorTok{=}\NormalTok{ s[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
    
    \CommentTok{\# Postcondition 1: same length}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(result) }\OperatorTok{==} \BuiltInTok{len}\NormalTok{(s), }\StringTok{"Postcondition failed: length changed"}
    \CommentTok{\# Postcondition 2: same characters}
    \ControlFlowTok{assert} \BuiltInTok{sorted}\NormalTok{(result) }\OperatorTok{==} \BuiltInTok{sorted}\NormalTok{(s), }\StringTok{"Postcondition failed: characters changed"}
    \CommentTok{\# Postcondition 3: reversing twice restores original}
    \ControlFlowTok{assert}\NormalTok{ result[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{==}\NormalTok{ s, }\StringTok{"Postcondition failed: not a proper reverse"}
    
    \ControlFlowTok{return}\NormalTok{ result}

\BuiltInTok{print}\NormalTok{(reverse\_string(}\StringTok{"hello"}\NormalTok{))  }\CommentTok{\# "olleh"}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-67}

Even simple tasks need correctness. If a reverse algorithm dropped or
altered characters, it could break larger systems like text editors,
encryption, or search tools.

\subsubsection{Try It Yourself}\label{try-it-yourself-69}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write the precondition and postcondition for reversing a list of
  numbers instead of a string.
\item
  Test the algorithm with empty strings, single-character strings, and
  very long strings. Do the postconditions still hold?
\item
  Reflect: why is it useful to define correctness even for simple
  operations? How does this habit help with bigger algorithms?
\end{enumerate}

\subsection{70. Exercise: Define Pre/Postconditions for ``Reverse a
String''}\label{exercise-define-prepostconditions-for-reverse-a-string-1}

Reversing a string is a simple task but a great way to practice
correctness. The algorithm takes an input string and outputs the same
string with its characters in reverse order. Preconditions and
postconditions make the promise precise.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-70}

Imagine beads on a string. The input string is the beads in order:
A-B-C-D. Reversing it flips them to D-C-B-A. The beads don't change,
only their positions.

\subsubsection{Deep Dive}\label{deep-dive-40}

\begin{itemize}
\item
  Precondition: The input must be a valid string (not \texttt{None}, not
  a number).
\item
  Postconditions:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    The output string has the same length as the input.
  \item
    Each character in the output appears in the input the same number of
    times.
  \item
    The output is the input's characters in reverse order.
  \end{enumerate}
\end{itemize}

This ensures the algorithm does not lose, add, or alter characters---it
only flips their order.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-68}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ reverse\_string(s):}
    \CommentTok{\# Precondition: must be a string}
    \ControlFlowTok{assert} \BuiltInTok{isinstance}\NormalTok{(s, }\BuiltInTok{str}\NormalTok{), }\StringTok{"Precondition failed: input must be a string"}
    
\NormalTok{    result }\OperatorTok{=}\NormalTok{ s[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
    
    \CommentTok{\# Postcondition 1: same length}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(result) }\OperatorTok{==} \BuiltInTok{len}\NormalTok{(s), }\StringTok{"Postcondition failed: length changed"}
    \CommentTok{\# Postcondition 2: same characters}
    \ControlFlowTok{assert} \BuiltInTok{sorted}\NormalTok{(result) }\OperatorTok{==} \BuiltInTok{sorted}\NormalTok{(s), }\StringTok{"Postcondition failed: characters changed"}
    \CommentTok{\# Postcondition 3: reversing twice restores original}
    \ControlFlowTok{assert}\NormalTok{ result[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{==}\NormalTok{ s, }\StringTok{"Postcondition failed: not a proper reverse"}
    
    \ControlFlowTok{return}\NormalTok{ result}

\BuiltInTok{print}\NormalTok{(reverse\_string(}\StringTok{"hello"}\NormalTok{))  }\CommentTok{\# "olleh"}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-68}

Even simple tasks need correctness. If a reverse algorithm dropped or
altered characters, it could break larger systems like text editors,
encryption, or search tools.

\subsubsection{Try It Yourself}\label{try-it-yourself-70}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write the precondition and postcondition for reversing a list of
  numbers instead of a string.
\item
  Test the algorithm with empty strings, single-character strings, and
  very long strings. Do the postconditions still hold?
\item
  Reflect: why is it useful to define correctness even for simple
  operations? How does this habit help with bigger algorithms?
\end{enumerate}

\section{Chapter 8. Cost as effort: time, memory, and
simplicity}\label{chapter-8.-cost-as-effort-time-memory-and-simplicity}

\subsection{71. Algorithms as Resource
Consumers}\label{algorithms-as-resource-consumers}

Every algorithm uses resources to do its work. Just like a car needs
fuel and space on the road, an algorithm needs time (how long it takes
to run) and memory (how much space it needs to store data). Some also
require other resources like network access, battery power, or human
effort. Thinking of algorithms as consumers of resources helps us
measure their efficiency.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-71}

Imagine baking a cake. You need both time (baking for 30 minutes) and
space (countertop, oven space). If the recipe takes too long or requires
too much space, it may not be practical. Algorithms face the same
constraints: too slow or too memory-hungry, and they can't be used in
real systems.

\subsubsection{Deep Dive}\label{deep-dive-41}

\begin{itemize}
\tightlist
\item
  Time resource: measured in steps, operations, or seconds. Different
  algorithms solving the same problem may take wildly different times.
\item
  Memory resource: measured in how much data the algorithm stores
  temporarily (variables, lists, tables).
\item
  Other resources: battery on a phone, bandwidth on a network, or even
  programmer time (simplicity vs.~complexity).
\end{itemize}

Seeing algorithms as consumers forces us to ask: \emph{Can this run fast
enough? Can it fit into memory? Is it simple enough to maintain?}
Efficiency isn't just a bonus---it can decide whether an algorithm is
usable.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-69}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Compare two algorithms for summing numbers}

\CommentTok{\# Algorithm 1: direct sum (efficient)}
\KeywordTok{def}\NormalTok{ fast\_sum(nums):}
    \ControlFlowTok{return} \BuiltInTok{sum}\NormalTok{(nums)}

\CommentTok{\# Algorithm 2: repeated copying (wastes memory and time)}
\KeywordTok{def}\NormalTok{ slow\_sum(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        nums }\OperatorTok{=}\NormalTok{ nums }\OperatorTok{+}\NormalTok{ [}\DecValTok{0}\NormalTok{]  }\CommentTok{\# wasteful: creates new list each time}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\NormalTok{data }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1000}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Fast:"}\NormalTok{, fast\_sum(data))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Slow:"}\NormalTok{, slow\_sum(data))}
\end{Highlighting}
\end{Shaded}

Both give the same result, but one wastes far more time and memory.

\subsubsection{When It Matters}\label{when-it-matters-69}

Thinking of algorithms as resource consumers matters because computers
have limits. Efficient algorithms allow us to process bigger problems,
save energy, and respond faster---critical for systems like search
engines, medical devices, or online payments.

\subsubsection{Try It Yourself}\label{try-it-yourself-71}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Make a list of three real-life processes (like cooking, commuting,
  studying). For each, write what resources they consume (time, space,
  effort).
\item
  In Python, write a function to reverse a list. Can you do it two
  different ways---one efficient (in-place) and one inefficient (by
  creating new copies)?
\item
  Reflect: can you think of a time when a tool or app felt ``too slow''
  or ``used too much storage''? How would you describe its resource
  consumption?
\end{enumerate}

\subsection{72. Time Cost: Steps, Delays,
Waiting}\label{time-cost-steps-delays-waiting}

The time cost of an algorithm is how long it takes to finish. This
includes every step it performs and any waiting involved. Faster
algorithms use fewer steps for the same job. Slower ones may repeat
unnecessary work or handle data inefficiently.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-72}

Think of standing in a line at the grocery store. Each customer
represents a ``step.'' A short line means you get through quickly. A
long line means you wait longer. Algorithms are like checkout lines: the
number of steps decides how long you wait for the result.

\subsubsection{Deep Dive}\label{deep-dive-42}

\begin{itemize}
\tightlist
\item
  Steps as time units: In computer science, time is often measured by
  counting steps instead of seconds, because real hardware speeds
  differ.
\item
  Delays: Some algorithms may need to pause for resources (waiting for
  data to load from disk or across the internet).
\item
  Comparisons: An algorithm that takes 100 steps is usually better than
  one that takes 10,000 steps, even if both give the same answer.
\item
  Scalability: Time cost grows with input size. A method that works fine
  for 10 items may become unusable for 10 million.
\end{itemize}

This is why time analysis is central: it predicts whether an algorithm
will finish quickly enough for real-world use.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-70}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Counting steps in two algorithms}

\CommentTok{\# Linear search: may check each item}
\KeywordTok{def}\NormalTok{ linear\_search(nums, target):}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return} \VariableTok{True}
    \ControlFlowTok{return} \VariableTok{False}

\CommentTok{\# Constant{-}time check: uses a set}
\KeywordTok{def}\NormalTok{ set\_search(nums, target):}
\NormalTok{    s }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(nums)  }\CommentTok{\# convert to set (one{-}time cost)}
    \ControlFlowTok{return}\NormalTok{ target }\KeywordTok{in}\NormalTok{ s}

\NormalTok{data }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1000000}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Linear search:"}\NormalTok{, linear\_search(data, }\DecValTok{999999}\NormalTok{))  }\CommentTok{\# may take many steps}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Set search:"}\NormalTok{, set\_search(data, }\DecValTok{999999}\NormalTok{))        }\CommentTok{\# very fast lookup}
\end{Highlighting}
\end{Shaded}

Both find the number, but the second reduces time cost dramatically.

\subsubsection{When It Matters}\label{when-it-matters-70}

Time cost matters because users expect quick results. A web search that
takes 10 seconds feels broken, while one that takes 0.1 seconds feels
seamless. In real systems, time efficiency often decides which algorithm
is chosen.

\subsubsection{Try It Yourself}\label{try-it-yourself-72}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Search for your name in a written list of 20 names. Count how many
  steps it takes. How does this compare to searching in alphabetical
  order?
\item
  In Python, try writing a loop that counts from 1 to 1,000,000. Then
  try \texttt{sum(range(1000000))}. Which feels faster?
\item
  Reflect: can you think of an app or website where you stopped using it
  because it was too slow? How would you describe its time cost?
\end{enumerate}

\subsection{73. Memory Cost: Storage and
Reuse}\label{memory-cost-storage-and-reuse}

The memory cost of an algorithm is how much space it uses to store data
while running. Some algorithms keep everything in memory at once, while
others reuse space efficiently. Memory isn't infinite---using too much
can slow a program or even cause it to fail.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-73}

Think of packing for a trip. If you bring every piece of clothing you
own, your suitcase overflows. If you carefully choose and reuse outfits,
you save space. Algorithms face the same challenge: how to fit
everything needed without wasting memory.

\subsubsection{Deep Dive}\label{deep-dive-43}

\begin{itemize}
\tightlist
\item
  Working memory: variables, lists, and tables that exist while the
  algorithm runs.
\item
  Extra copies: some algorithms make unnecessary duplicates of data,
  doubling memory use.
\item
  In-place algorithms: reuse the same space, overwriting as they go.
\item
  Trade-offs: sometimes using more memory reduces time (like caching
  results). Other times, conserving memory makes the algorithm slower
  but more space-efficient.
\end{itemize}

Analyzing memory cost is about finding the right balance for the problem
and the hardware it runs on.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-71}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Inefficient: creates extra copies of the list}
\KeywordTok{def}\NormalTok{ copy\_reverse(nums):}
\NormalTok{    new\_list }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        new\_list }\OperatorTok{=}\NormalTok{ [n] }\OperatorTok{+}\NormalTok{ new\_list  }\CommentTok{\# builds new list every step}
    \ControlFlowTok{return}\NormalTok{ new\_list}

\CommentTok{\# Efficient: reverses in place}
\KeywordTok{def}\NormalTok{ in\_place\_reverse(nums):}
\NormalTok{    nums.reverse()}
    \ControlFlowTok{return}\NormalTok{ nums}

\NormalTok{data }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Copy reverse:"}\NormalTok{, copy\_reverse(data))      }\CommentTok{\# uses more memory}
\BuiltInTok{print}\NormalTok{(}\StringTok{"In{-}place reverse:"}\NormalTok{, in\_place\_reverse(data))  }\CommentTok{\# reuses memory}
\end{Highlighting}
\end{Shaded}

The first wastes memory by creating many copies; the second is more
efficient.

\subsubsection{When It Matters}\label{when-it-matters-71}

Memory cost matters in devices with limited resources (phones, IoT
sensors) or with massive data (databases, big data systems). An
algorithm that uses less memory can handle bigger problems and run on
smaller machines.

\subsubsection{Try It Yourself}\label{try-it-yourself-73}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three examples of memory use in daily life (e.g., carrying
  papers in a backpack, photos on your phone, food in a fridge). How
  does limited space affect your choices?
\item
  In Python, try duplicating a list with \texttt{list1\ +\ list2}. Then
  compare it with \texttt{list1.extend(list2)}. Which one uses more
  memory?
\item
  Reflect: can you think of a time when your computer or phone slowed
  down because too many apps or files were open? How does that relate to
  memory cost?
\end{enumerate}

\subsection{74. Simplicity as a Cost
Dimension}\label{simplicity-as-a-cost-dimension}

Besides time and memory, algorithms also carry a simplicity cost. Some
algorithms are easy to understand, implement, and debug; others are
complex and error-prone. A simple algorithm might be slower but safer,
while a complex one might be fast but harder to trust or maintain.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-74}

Think of a recipe. A simple one says: \emph{``Boil pasta, add sauce,
serve.''} A complex one lists dozens of steps, measurements, and rare
ingredients. Both may give you dinner, but the simple recipe is easier
to follow and less likely to go wrong.

\subsubsection{Deep Dive}\label{deep-dive-44}

\begin{itemize}
\tightlist
\item
  Simplicity helps humans: Clear algorithms are easier to learn,
  explain, and debug.
\item
  Complexity hides risks: A faster algorithm with tangled logic may
  introduce hidden bugs.
\item
  Trade-offs: Sometimes we accept slower, simpler solutions because they
  are ``good enough'' and safer to maintain.
\item
  Real-world lesson: In many companies, ``code readability'' and
  ``maintainability'' are valued as highly as speed.
\end{itemize}

Thus, simplicity is a cost measured in human effort---not in machine
resources.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-72}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Simple but less efficient: bubble sort}
\KeywordTok{def}\NormalTok{ bubble\_sort(nums):}
\NormalTok{    n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(nums)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, n}\OperatorTok{{-}}\NormalTok{i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
            \ControlFlowTok{if}\NormalTok{ nums[j] }\OperatorTok{\textgreater{}}\NormalTok{ nums[j}\OperatorTok{+}\DecValTok{1}\NormalTok{]:}
\NormalTok{                nums[j], nums[j}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ nums[j}\OperatorTok{+}\DecValTok{1}\NormalTok{], nums[j]}
    \ControlFlowTok{return}\NormalTok{ nums}

\CommentTok{\# More complex but efficient: quicksort}
\KeywordTok{def}\NormalTok{ quick\_sort(nums):}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{\textless{}=} \DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ nums}
\NormalTok{    pivot }\OperatorTok{=}\NormalTok{ nums[}\DecValTok{0}\NormalTok{]}
\NormalTok{    left }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ nums[}\DecValTok{1}\NormalTok{:] }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}=}\NormalTok{ pivot]}
\NormalTok{    right }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ nums[}\DecValTok{1}\NormalTok{:] }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}}\NormalTok{ pivot]}
    \ControlFlowTok{return}\NormalTok{ quick\_sort(left) }\OperatorTok{+}\NormalTok{ [pivot] }\OperatorTok{+}\NormalTok{ quick\_sort(right)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Bubble sort:"}\NormalTok{, bubble\_sort([}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{2}\NormalTok{]))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Quick sort:"}\NormalTok{, quick\_sort([}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{2}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

Both sort numbers correctly. Bubble sort is simpler to read but slower.
Quicksort is faster but trickier to understand.

\subsubsection{When It Matters}\label{when-it-matters-72}

Simplicity matters when algorithms will be read, reused, or modified by
humans. A simple algorithm may save more time in maintenance than it
loses in execution speed.

\subsubsection{Try It Yourself}\label{try-it-yourself-74}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Think of a daily task (like making coffee). Write one version as a
  very simple recipe, and another as a detailed, complex version. Which
  feels more practical?
\item
  Write a Python function to compute factorials using recursion (simple,
  but may be inefficient). Then write it using loops (slightly more
  complex). Compare them.
\item
  Reflect: in your own work, have you seen something ``too clever'' that
  was hard to maintain? Would a simpler version have been better?
\end{enumerate}

\subsection{75. Human Cost vs.~Machine
Cost}\label{human-cost-vs.-machine-cost}

When judging algorithms, we balance machine cost (time and memory)
against human cost (effort to design, implement, and maintain).
Sometimes a machine-efficient algorithm is too complex for people to
work with. Other times, a simpler algorithm saves human effort even if
it runs a bit slower.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-75}

Imagine two routes to school. One is a twisting shortcut that saves 5
minutes but is hard to remember. The other is a straight road that takes
a little longer but is easy to follow. Machines and humans face the same
trade-off---what's easy for one may be costly for the other.

\subsubsection{Deep Dive}\label{deep-dive-45}

\begin{itemize}
\item
  Machine cost: measured in steps (time), memory usage, energy
  consumption.
\item
  Human cost: measured in clarity, ease of debugging, training needed,
  and risk of mistakes.
\item
  Trade-offs in practice:

  \begin{itemize}
  \tightlist
  \item
    A brute-force algorithm may be slower (high machine cost) but simple
    to write (low human cost).
  \item
    A highly optimized algorithm may be fast (low machine cost) but
    difficult to maintain (high human cost).
  \end{itemize}
\item
  Engineering balance: In real systems, correctness and maintainability
  often matter more than shaving off milliseconds of machine time.
\end{itemize}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-73}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Brute force: simple for humans, costly for machines}
\KeywordTok{def}\NormalTok{ has\_duplicate\_bruteforce(nums):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(nums)):}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(i}\OperatorTok{+}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(nums)):}
            \ControlFlowTok{if}\NormalTok{ nums[i] }\OperatorTok{==}\NormalTok{ nums[j]:}
                \ControlFlowTok{return} \VariableTok{True}
    \ControlFlowTok{return} \VariableTok{False}

\CommentTok{\# Optimized: efficient for machines, slightly harder for humans}
\KeywordTok{def}\NormalTok{ has\_duplicate\_set(nums):}
    \ControlFlowTok{return} \BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{!=} \BuiltInTok{len}\NormalTok{(}\BuiltInTok{set}\NormalTok{(nums))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Brute force:"}\NormalTok{, has\_duplicate\_bruteforce([}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{1}\NormalTok{]))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Set method:"}\NormalTok{, has\_duplicate\_set([}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{1}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

Both solve the same problem. The brute-force version is easier to read
but slower. The set-based version is faster but requires knowledge of
sets.

\subsubsection{When It Matters}\label{when-it-matters-73}

Balancing human vs.~machine cost matters in real projects. A fast but
unmaintainable algorithm may cause long-term problems. A slightly slower
but simpler one may save months of human effort.

\subsubsection{Try It Yourself}\label{try-it-yourself-75}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write pseudocode for finding the maximum in a list: first a
  brute-force approach (check all pairs), then the simple linear
  approach. Which is easier to understand? Which is faster?
\item
  In Python, solve the same problem using both a manual loop and the
  built-in \texttt{max()} function. Compare human vs.~machine cost.
\item
  Reflect: think of a time when you chose the ``easier but slower''
  method in real life. Did it save you human effort overall?
\end{enumerate}

\subsection{76. Why Cost Matters Even for Small
Tasks}\label{why-cost-matters-even-for-small-tasks}

Even tiny algorithms---like adding numbers or searching a short
list---consume resources. While small tasks may seem trivial, cost still
matters because tasks often scale up. An algorithm that works fine for
10 items may become painfully slow for 10 million. Thinking about cost
early prevents surprises later.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-76}

Imagine walking to a nearby shop. One extra block doesn't matter. But if
you had to walk the same extra block a million times, it would be
exhausting. Small inefficiencies add up quickly when repeated at scale.

\subsubsection{Deep Dive}\label{deep-dive-46}

\begin{itemize}
\tightlist
\item
  Hidden growth: A few wasted steps are harmless for small inputs but
  disastrous for large ones.
\item
  Compounding effects: Algorithms often run inside loops or larger
  systems, multiplying their cost.
\item
  Real-world lesson: Software that feels fine in a demo may collapse
  when handling real-world data sizes.
\end{itemize}

This is why computer scientists care about growth rates (Big-O). The
absolute numbers matter less than how the algorithm scales with input.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-74}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: summing numbers}

\CommentTok{\# Inefficient: quadratic growth (adds overhead each loop)}
\KeywordTok{def}\NormalTok{ slow\_sum(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(nums)):}
\NormalTok{        total }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(nums[:i}\OperatorTok{+}\DecValTok{1}\NormalTok{])  }\CommentTok{\# recalculates each time}
    \ControlFlowTok{return}\NormalTok{ total}

\CommentTok{\# Efficient: linear growth}
\KeywordTok{def}\NormalTok{ fast\_sum(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\NormalTok{small }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\NormalTok{large }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{100000}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Small input (slow):"}\NormalTok{, slow\_sum(small))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Small input (fast):"}\NormalTok{, fast\_sum(small))}
\CommentTok{\# For large input, slow\_sum would be unbearably slow}
\end{Highlighting}
\end{Shaded}

Both work for small inputs, but only the efficient one scales.

\subsubsection{When It Matters}\label{when-it-matters-74}

Cost matters for small tasks because small inefficiencies, multiplied
millions of times, become bottlenecks. Thinking ahead ensures algorithms
are usable not just today but in larger, future scenarios.

\subsubsection{Try It Yourself}\label{try-it-yourself-76}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down two daily routines (like tying shoelaces or making tea).
  Imagine repeating each 100 times. How does the cost change?
\item
  In Python, write a function that finds the maximum of a list by
  scanning once, and another by repeatedly sorting the list. Compare
  them for 10 items vs.~10,000.
\item
  Reflect: have you ever used an app that felt fine with small data but
  slowed down when your data grew? What ``hidden cost'' appeared?
\end{enumerate}

\subsection{77. Balancing Trade-Offs Between
Costs}\label{balancing-trade-offs-between-costs}

Algorithms rarely minimize every cost at once. Sometimes you save time
by using more memory. Other times you keep things simple but lose
efficiency. Balancing trade-offs means choosing the right balance of
time, memory, and simplicity for the situation.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-77}

Imagine carrying groceries home. If you take one big trip, it's fast
(low time cost) but heavy (high effort). If you take several small
trips, it's lighter (low effort) but slower (high time cost). No option
is ``perfect''---you choose based on what matters most.

\subsubsection{Deep Dive}\label{deep-dive-47}

\begin{itemize}
\tightlist
\item
  Time vs.~Memory: Storing extra data (like a lookup table) can make
  searches faster, but it costs memory.
\item
  Simplicity vs.~Efficiency: A brute-force algorithm may be easier to
  understand but slower.
\item
  Short-term vs.~Long-term: A complex optimization might save machine
  time but increase human maintenance cost.
\end{itemize}

In practice, engineers ask: \emph{Which cost is most critical here?} For
a mobile app, battery and memory might matter more. For a stock trading
system, speed might matter more than simplicity.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-75}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: checking if a number has been seen before}

\CommentTok{\# Time{-}efficient, uses more memory}
\KeywordTok{def}\NormalTok{ seen\_with\_set(nums):}
\NormalTok{    seen }\OperatorTok{=} \BuiltInTok{set}\NormalTok{()}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
        \ControlFlowTok{if}\NormalTok{ n }\KeywordTok{in}\NormalTok{ seen:}
            \ControlFlowTok{return} \VariableTok{True}
\NormalTok{        seen.add(n)}
    \ControlFlowTok{return} \VariableTok{False}

\CommentTok{\# Memory{-}efficient, slower}
\KeywordTok{def}\NormalTok{ seen\_with\_loops(nums):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(nums)):}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(i}\OperatorTok{+}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(nums)):}
            \ControlFlowTok{if}\NormalTok{ nums[i] }\OperatorTok{==}\NormalTok{ nums[j]:}
                \ControlFlowTok{return} \VariableTok{True}
    \ControlFlowTok{return} \VariableTok{False}

\NormalTok{data }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{10000}\NormalTok{)) }\OperatorTok{+}\NormalTok{ [}\DecValTok{9999}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Set method:"}\NormalTok{, seen\_with\_set(data))   }\CommentTok{\# Fast, uses memory}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Loop method:"}\NormalTok{, seen\_with\_loops(data)) }\CommentTok{\# Slow, uses no extra memory}
\end{Highlighting}
\end{Shaded}

Both solve the same problem but optimize different costs.

\subsubsection{When It Matters}\label{when-it-matters-75}

Balancing trade-offs matters because no single algorithm is ``best'' in
all situations. The right choice depends on context: available hardware,
input size, and the importance of speed vs.~clarity vs.~memory.

\subsubsection{Try It Yourself}\label{try-it-yourself-77}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Think of a daily task like cooking. How could you save time by using
  more resources (like pre-cut ingredients)? How could you save
  resources by spending more time?
\item
  In Python, write two versions of an algorithm to compute squares of
  numbers: one stores them all in memory, another computes them on the
  fly. Compare costs.
\item
  Reflect: when have you chosen a ``good enough'' solution in life
  instead of the most efficient one? What trade-offs did you balance?
\end{enumerate}

\subsection{78. Example: Linear Search vs.~Binary
Search}\label{example-linear-search-vs.-binary-search}

Searching for an item shows how different algorithms trade time and
simplicity. Linear search checks each element one by one until it finds
the target. Binary search repeatedly halves the list, jumping directly
to where the item could be. Linear search is simple but slow on large
lists; binary search is faster but requires sorted input.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-78}

Imagine looking for a word in a dictionary. With linear search, you
check every word from page 1 onward until you find it. With binary
search, you open the book halfway, decide if the word is before or
after, then repeat. The second method takes far fewer steps.

\subsubsection{Deep Dive}\label{deep-dive-48}

\begin{itemize}
\item
  Linear search

  \begin{itemize}
  \tightlist
  \item
    Precondition: None (list can be unsorted).
  \item
    Postcondition: Either find the item or report it's not there.
  \item
    Time cost: Up to \emph{n} steps (where \emph{n} is list size).
  \item
    Simplicity cost: Very low---easy to implement.
  \end{itemize}
\item
  Binary search

  \begin{itemize}
  \tightlist
  \item
    Precondition: Input list must be sorted.
  \item
    Postcondition: Correct position found or absence reported.
  \item
    Time cost: About \emph{log₂(n)} steps---much faster on large inputs.
  \item
    Simplicity cost: Higher---requires more careful coding.
  \end{itemize}
\end{itemize}

This comparison shows how different choices of representation (sorted
vs.~unsorted) change the algorithm's efficiency.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-76}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Linear search}
\KeywordTok{def}\NormalTok{ linear\_search(nums, target):}
    \ControlFlowTok{for}\NormalTok{ i, n }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(nums):}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ i}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}

\CommentTok{\# Binary search (iterative)}
\KeywordTok{def}\NormalTok{ binary\_search(nums, target):}
\NormalTok{    left, right }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{{-}} \DecValTok{1}
    \ControlFlowTok{while}\NormalTok{ left }\OperatorTok{\textless{}=}\NormalTok{ right:}
\NormalTok{        mid }\OperatorTok{=}\NormalTok{ (left }\OperatorTok{+}\NormalTok{ right) }\OperatorTok{//} \DecValTok{2}
        \ControlFlowTok{if}\NormalTok{ nums[mid] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ mid}
        \ControlFlowTok{elif}\NormalTok{ nums[mid] }\OperatorTok{\textless{}}\NormalTok{ target:}
\NormalTok{            left }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{+} \DecValTok{1}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            right }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{{-}} \DecValTok{1}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}

\NormalTok{unsorted\_data }\OperatorTok{=}\NormalTok{ [}\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\NormalTok{sorted\_data }\OperatorTok{=} \BuiltInTok{sorted}\NormalTok{(unsorted\_data)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Linear:"}\NormalTok{, linear\_search(unsorted\_data, }\DecValTok{5}\NormalTok{))  }\CommentTok{\# Works unsorted}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Binary:"}\NormalTok{, binary\_search(sorted\_data, }\DecValTok{5}\NormalTok{))    }\CommentTok{\# Needs sorted input}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-76}

Linear search is fine for small or unsorted data, but binary search is
critical when lists are large and sorted. The choice depends on context:
if sorting is cheap or already guaranteed, binary search wins;
otherwise, linear search may be simpler.

\subsubsection{Try It Yourself}\label{try-it-yourself-78}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Try linear and binary search on lists of size 10, 1000, and 1,000,000.
  Count steps or measure time. How do results differ?
\item
  Write down the precondition for binary search. What happens if you
  violate it?
\item
  Reflect: can you think of times in daily life where you ``searched
  linearly'' (like scanning every shelf in a store) versus ``searched
  like binary'' (like guessing a number by halving the range)?
\end{enumerate}

\subsection{79. Example: Copying Data vs.~In-Place
Work}\label{example-copying-data-vs.-in-place-work}

Some algorithms make copies of data to work safely, while others modify
the data in place. Copying is simpler and safer because the original
data is preserved, but it costs more memory and sometimes more time.
In-place work saves memory and can be faster, but it risks overwriting
or losing the original information.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-79}

Imagine editing a document. One way is to make a photocopy and mark
changes on the copy---safe, but uses extra paper. Another way is to
write directly on the original---efficient, but risky if you make a
mistake.

\subsubsection{Deep Dive}\label{deep-dive-49}

\begin{itemize}
\item
  Copying approach:

  \begin{itemize}
  \tightlist
  \item
    Keeps the original data intact.
  \item
    Useful when multiple versions are needed.
  \item
    Higher memory and time cost, especially for large datasets.
  \end{itemize}
\item
  In-place approach:

  \begin{itemize}
  \tightlist
  \item
    Reuses the same memory.
  \item
    Saves space and can improve performance.
  \item
    Must be carefully designed to avoid errors (e.g., overwriting needed
    values).
  \end{itemize}
\end{itemize}

In practice, systems often balance both: copy when safety matters, work
in place when efficiency is critical.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-77}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Copying approach: returns a new reversed list}
\KeywordTok{def}\NormalTok{ reverse\_copy(lst):}
    \ControlFlowTok{return}\NormalTok{ lst[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\CommentTok{\# In{-}place approach: modifies the list directly}
\KeywordTok{def}\NormalTok{ reverse\_in\_place(lst):}
\NormalTok{    left, right }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\BuiltInTok{len}\NormalTok{(lst) }\OperatorTok{{-}} \DecValTok{1}
    \ControlFlowTok{while}\NormalTok{ left }\OperatorTok{\textless{}}\NormalTok{ right:}
\NormalTok{        lst[left], lst[right] }\OperatorTok{=}\NormalTok{ lst[right], lst[left]}
\NormalTok{        left, right }\OperatorTok{=}\NormalTok{ left }\OperatorTok{+} \DecValTok{1}\NormalTok{, right }\OperatorTok{{-}} \DecValTok{1}
    \ControlFlowTok{return}\NormalTok{ lst}

\NormalTok{data1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\NormalTok{data2 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Copy result:"}\NormalTok{, reverse\_copy(data1))   }\CommentTok{\# [4, 3, 2, 1]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Original after copy:"}\NormalTok{, data1)         }\CommentTok{\# Unchanged}

\BuiltInTok{print}\NormalTok{(}\StringTok{"In{-}place result:"}\NormalTok{, reverse\_in\_place(data2)) }\CommentTok{\# [4, 3, 2, 1]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Original after in{-}place:"}\NormalTok{, data2)           }\CommentTok{\# Changed}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-77}

Copying is safer for situations where original data must be preserved
(like backups or audit logs). In-place work is vital for memory-limited
systems or massive datasets where copying would be too costly.

\subsubsection{Try It Yourself}\label{try-it-yourself-79}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function that sorts a list by making a copy first, and another
  that sorts it in place. Compare memory use and behavior.
\item
  In daily life, when do you work with a ``copy'' (like saving a draft)
  versus directly editing the ``original''?
\item
  Reflect: if you were writing an algorithm for a phone app with very
  limited memory, would you prefer in-place work or copying? Why?
\end{enumerate}

\subsection{80. Practical Exercise: Estimate Cost of Doubling Numbers in
a
List}\label{practical-exercise-estimate-cost-of-doubling-numbers-in-a-list}

Let's practice cost analysis with a simple algorithm: take a list of
numbers and produce a new list where every number is doubled. This task
looks easy, but it lets us measure time cost (how many steps it takes)
and memory cost (how much space it needs).

\subsubsection{Picture in Your Head}\label{picture-in-your-head-80}

Imagine a stack of flashcards with numbers written on them. You flip
each card, write down double the number on a new card, and stack it
aside. The process takes one step per card, and you end up with two
stacks: the original and the doubled copy.

\subsubsection{Deep Dive}\label{deep-dive-50}

\begin{itemize}
\item
  Time cost:

  \begin{itemize}
  \tightlist
  \item
    The algorithm must touch each number once.
  \item
    If there are \emph{n} numbers, the work grows in proportion to
    \emph{n} (linear time).
  \end{itemize}
\item
  Memory cost:

  \begin{itemize}
  \tightlist
  \item
    If you create a new list, you use extra space equal to \emph{n}.
  \item
    If you overwrite the numbers in place, you use no extra memory
    beyond a loop counter.
  \end{itemize}
\end{itemize}

This small exercise shows how even simple tasks can be analyzed for
efficiency.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-78}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Doubling numbers by creating a new list (extra memory)}
\KeywordTok{def}\NormalTok{ double\_with\_copy(nums):}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        result.append(n }\OperatorTok{*} \DecValTok{2}\NormalTok{)}
    \ControlFlowTok{return}\NormalTok{ result}

\CommentTok{\# Doubling numbers in place (reuses memory)}
\KeywordTok{def}\NormalTok{ double\_in\_place(nums):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(nums)):}
\NormalTok{        nums[i] }\OperatorTok{*=} \DecValTok{2}
    \ControlFlowTok{return}\NormalTok{ nums}

\NormalTok{data1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\NormalTok{data2 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Copy version:"}\NormalTok{, double\_with\_copy(data1))   }\CommentTok{\# [2, 4, 6, 8]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Original after copy:"}\NormalTok{, data1)              }\CommentTok{\# [1, 2, 3, 4]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"In{-}place version:"}\NormalTok{, double\_in\_place(data2)) }\CommentTok{\# [2, 4, 6, 8]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Original after in{-}place:"}\NormalTok{, data2)           }\CommentTok{\# Modified}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-78}

Even tiny differences---copy vs.~in-place---matter when lists are very
large. Copying a billion numbers doubles the memory use. On a small
dataset, either approach is fine. On large systems, these trade-offs
decide whether the program runs at all.

\subsubsection{Try It Yourself}\label{try-it-yourself-80}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down how many steps it takes to double a list of 5 numbers, 50
  numbers, and 500 numbers. Notice the pattern.
\item
  Try both copy and in-place versions in Python with a very large list
  (e.g., 1 million numbers). Which uses more memory?
\item
  Reflect: in your daily life, when do you keep both an original and a
  modified copy (like photos) versus just editing the original? How does
  this mirror algorithm costs?
\end{enumerate}

\section{Chapter 9. Algorithms vs
Heuristics}\label{chapter-9.-algorithms-vs-heuristics}

\subsection{81. Exact vs.~Approximate
Solutions}\label{exact-vs.-approximate-solutions}

Algorithms aim for exact solutions, but sometimes an approximate answer
is good enough. Exactness means always producing the mathematically
correct result. Approximation means producing a result that is close,
but not guaranteed to be perfect. Choosing between them depends on the
problem and context.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-81}

Think of measuring a table. With a precise ruler, you find it is exactly
152.4 cm long. With your arm span, you estimate it's ``about 1.5
meters.'' Both answers may be useful, but only one is exact.

\subsubsection{Deep Dive}\label{deep-dive-51}

\begin{itemize}
\item
  Exact algorithms:

  \begin{itemize}
  \tightlist
  \item
    Always give the correct answer.
  \item
    Example: sorting numbers into ascending order.
  \item
    Often slower for complex problems.
  \end{itemize}
\item
  Approximate algorithms (heuristics):

  \begin{itemize}
  \tightlist
  \item
    Give ``good enough'' answers faster.
  \item
    Example: finding a short travel route with a GPS---may not be the
    absolute shortest, but still practical.
  \item
    Useful when exact solutions are too expensive in time or memory.
  \end{itemize}
\end{itemize}

Approximation is not about laziness; it's about practicality. In some
domains, an answer that is ``close enough'' in seconds is more valuable
than the perfect answer in hours.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-79}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Exact solution: find the maximum}
\KeywordTok{def}\NormalTok{ exact\_max(nums):}
    \ControlFlowTok{return} \BuiltInTok{max}\NormalTok{(nums)}

\CommentTok{\# Approximate solution: check only part of the list}
\KeywordTok{def}\NormalTok{ approx\_max(nums):}
\NormalTok{    sample }\OperatorTok{=}\NormalTok{ nums[::}\DecValTok{10}\NormalTok{]  }\CommentTok{\# take every 10th number}
    \ControlFlowTok{return} \BuiltInTok{max}\NormalTok{(sample)}

\NormalTok{data }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1000000}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Exact max:"}\NormalTok{, exact\_max(data))      }\CommentTok{\# Always 999999}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Approx max:"}\NormalTok{, approx\_max(data))    }\CommentTok{\# Close, but may miss the true max}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-79}

Exactness matters in banking, medicine, and safety-critical systems.
Approximation is fine in search engines, recommendations, and real-time
systems where speed matters more than perfection.

\subsubsection{Try It Yourself}\label{try-it-yourself-81}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three tasks where only an exact answer is acceptable (e.g.,
  calculating your paycheck).
\item
  Write down three tasks where an approximate answer is acceptable
  (e.g., finding a restaurant nearby).
\item
  In Python, try approximating the sum of 1 to 1,000,000 by adding only
  every 100th number. Compare it to the exact sum. How close is it?
\end{enumerate}

\subsection{82. Heuristics in Everyday Life:
Shortcuts}\label{heuristics-in-everyday-life-shortcuts}

A heuristic is a shortcut: a rule of thumb that gives a good answer
quickly, even if it's not perfect. Humans use heuristics all the
time---when we don't want to calculate exactly, we estimate. Algorithms
can also use heuristics to solve problems faster.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-82}

Imagine choosing a checkout line at the supermarket. Instead of counting
how many items each person has, you just pick the shortest-looking line.
It's not guaranteed to be the fastest, but it usually works well enough.

\subsubsection{Deep Dive}\label{deep-dive-52}

\begin{itemize}
\item
  Heuristics trade accuracy for speed. They often ignore some details to
  save time.
\item
  Examples in life: guessing instead of measuring, using past
  experience, following habits.
\item
  Examples in algorithms:

  \begin{itemize}
  \tightlist
  \item
    Nearest-neighbor search in maps: ``pick the closest city and
    continue.''
  \item
    Greedy algorithms: ``always take the best option right now.''
  \item
    Search engines: ranking results by relevance instead of scanning
    everything perfectly.
  \end{itemize}
\end{itemize}

Heuristics aren't wrong---they are practical. The key is knowing when
``good enough'' really is good enough.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-80}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Exact: find the restaurant with shortest distance}
\KeywordTok{def}\NormalTok{ exact\_choice(distances):}
    \ControlFlowTok{return} \BuiltInTok{min}\NormalTok{(distances)}

\CommentTok{\# Heuristic: pick the first option under a threshold}
\KeywordTok{def}\NormalTok{ heuristic\_choice(distances, threshold}\OperatorTok{=}\DecValTok{5}\NormalTok{):}
    \ControlFlowTok{for}\NormalTok{ d }\KeywordTok{in}\NormalTok{ distances:}
        \ControlFlowTok{if}\NormalTok{ d }\OperatorTok{\textless{}}\NormalTok{ threshold:}
            \ControlFlowTok{return}\NormalTok{ d}
    \ControlFlowTok{return} \BuiltInTok{min}\NormalTok{(distances)}

\NormalTok{distances }\OperatorTok{=}\NormalTok{ [}\DecValTok{12}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Exact choice:"}\NormalTok{, exact\_choice(distances))       }\CommentTok{\# 2}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Heuristic choice:"}\NormalTok{, heuristic\_choice(distances)) }\CommentTok{\# 3 (fast guess)}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-80}

Heuristics matter when problems are too big or complex for exact
solutions in reasonable time. They keep systems responsive and usable,
even if the answer isn't perfect.

\subsubsection{Try It Yourself}\label{try-it-yourself-82}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three heuristics you use in daily life (like choosing a
  seat, finding a parking spot, or estimating prices).
\item
  In Python, write a heuristic function that finds a ``good enough''
  maximum by sampling only 1/5 of a list.
\item
  Reflect: can you think of a time when a shortcut worked well, and a
  time when it failed? What does that teach about using heuristics?
\end{enumerate}

\subsection{83. When Heuristics Save
Effort}\label{when-heuristics-save-effort}

Heuristics are useful because they often save time, memory, and energy.
Instead of working through every possibility, a heuristic narrows the
search space to something manageable. This means we can solve problems
that would otherwise be too slow or too costly to handle.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-83}

Imagine searching for your friend in a large park. The exact method
would be checking every tree, bench, and path. The heuristic method is
heading straight to the ice cream stand---because you know your friend
likes ice cream. It saves you a lot of effort.

\subsubsection{Deep Dive}\label{deep-dive-53}

\begin{itemize}
\tightlist
\item
  Search problems: Chess has billions of possible moves. Exact analysis
  is impossible. Heuristics guide the computer to promising moves first.
\item
  Optimization problems: Finding the best delivery route may be too
  expensive. A heuristic like ``always deliver to the closest house
  next'' saves effort.
\item
  Everyday algorithms: Spell checkers use heuristics to suggest likely
  corrections without exploring all possible words.
\end{itemize}

Heuristics don't guarantee perfection, but they keep tasks feasible by
focusing effort where it matters most.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-81}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Exact: check every pair for closest distance}
\KeywordTok{def}\NormalTok{ exact\_closest(nums):}
\NormalTok{    best }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(}\StringTok{"inf"}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(nums)):}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(i}\OperatorTok{+}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(nums)):}
\NormalTok{            best }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(best, }\BuiltInTok{abs}\NormalTok{(nums[i] }\OperatorTok{{-}}\NormalTok{ nums[j]))}
    \ControlFlowTok{return}\NormalTok{ best}

\CommentTok{\# Heuristic: assume sorted neighbors are closest}
\KeywordTok{def}\NormalTok{ heuristic\_closest(nums):}
\NormalTok{    nums }\OperatorTok{=} \BuiltInTok{sorted}\NormalTok{(nums)}
\NormalTok{    best }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(}\StringTok{"inf"}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(nums)}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
\NormalTok{        best }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(best, }\BuiltInTok{abs}\NormalTok{(nums[i] }\OperatorTok{{-}}\NormalTok{ nums[i}\OperatorTok{+}\DecValTok{1}\NormalTok{]))}
    \ControlFlowTok{return}\NormalTok{ best}

\NormalTok{data }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{8}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Exact closest:"}\NormalTok{, exact\_closest(data))      }\CommentTok{\# Guaranteed answer}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Heuristic closest:"}\NormalTok{, heuristic\_closest(data))  }\CommentTok{\# Same here, but faster}
\end{Highlighting}
\end{Shaded}

Here the heuristic (sorting + comparing neighbors) saves effort compared
to checking every pair.

\subsubsection{When It Matters}\label{when-it-matters-81}

Heuristics matter in huge problems where exact methods are impractical.
They give usable answers within limits of time and memory, which is
often more valuable than the perfect answer too late.

\subsubsection{Try It Yourself}\label{try-it-yourself-83}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Think of three real-life tasks where checking every option is
  impossible (like browsing every restaurant in a city). What heuristic
  would you use?
\item
  In Python, generate a list of random numbers and compare the runtime
  of \texttt{exact\_closest} vs.~\texttt{heuristic\_closest}.
\item
  Reflect: can you think of a system (like GPS or search engines) that
  likely uses heuristics? Why would exact solutions be too costly?
\end{enumerate}

\subsection{84. When Heuristics Lead to
Mistakes}\label{when-heuristics-lead-to-mistakes}

Heuristics are shortcuts, and shortcuts sometimes fail. Because
heuristics ignore details to save effort, they can give answers that are
wrong or misleading. These mistakes are the trade-off for speed and
simplicity.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-84}

Imagine choosing the shortest-looking checkout line at the grocery
store. It looks fast, but then one shopper pulls out 200 coupons. Your
heuristic (``pick the shortest line'') saved thought, but it backfired.

\subsubsection{Deep Dive}\label{deep-dive-54}

\begin{itemize}
\tightlist
\item
  Search errors: A GPS using ``always take the shortest road segment''
  may send you onto tiny streets with heavy traffic.
\item
  Optimization errors: A greedy heuristic for knapsack problems may fill
  the bag with big items but leave no room for small ones that add more
  total value.
\item
  Everyday life: Spell-check heuristics sometimes suggest the wrong word
  (``from'' → ``form'').
\end{itemize}

The risk of heuristics is that their local, simplified logic may miss
the true best answer globally. That's why heuristics are chosen
carefully, often combined with checks or fallback strategies.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-82}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Knapsack problem (simplified): maximize value with weight limit}

\NormalTok{items }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Laptop"}\NormalTok{, }\StringTok{"value"}\NormalTok{: }\DecValTok{500}\NormalTok{, }\StringTok{"weight"}\NormalTok{: }\DecValTok{5}\NormalTok{\},}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Book"}\NormalTok{, }\StringTok{"value"}\NormalTok{: }\DecValTok{100}\NormalTok{, }\StringTok{"weight"}\NormalTok{: }\DecValTok{2}\NormalTok{\},}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"Phone"}\NormalTok{, }\StringTok{"value"}\NormalTok{: }\DecValTok{300}\NormalTok{, }\StringTok{"weight"}\NormalTok{: }\DecValTok{1}\NormalTok{\},}
\NormalTok{]}

\CommentTok{\# Heuristic: pick items with highest value first}
\KeywordTok{def}\NormalTok{ greedy\_knapsack(items, max\_weight):}
\NormalTok{    chosen, total\_value, total\_weight }\OperatorTok{=}\NormalTok{ [], }\DecValTok{0}\NormalTok{, }\DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in} \BuiltInTok{sorted}\NormalTok{(items, key}\OperatorTok{=}\KeywordTok{lambda}\NormalTok{ x: x[}\StringTok{"value"}\NormalTok{], reverse}\OperatorTok{=}\VariableTok{True}\NormalTok{):}
        \ControlFlowTok{if}\NormalTok{ total\_weight }\OperatorTok{+}\NormalTok{ item[}\StringTok{"weight"}\NormalTok{] }\OperatorTok{\textless{}=}\NormalTok{ max\_weight:}
\NormalTok{            chosen.append(item[}\StringTok{"name"}\NormalTok{])}
\NormalTok{            total\_value }\OperatorTok{+=}\NormalTok{ item[}\StringTok{"value"}\NormalTok{]}
\NormalTok{            total\_weight }\OperatorTok{+=}\NormalTok{ item[}\StringTok{"weight"}\NormalTok{]}
    \ControlFlowTok{return}\NormalTok{ chosen, total\_value}

\BuiltInTok{print}\NormalTok{(greedy\_knapsack(items, }\DecValTok{3}\NormalTok{))  }
\CommentTok{\# Mistake: picks "Laptop" (500, weight 5) is skipped, but greedy logic may miss better combos}
\end{Highlighting}
\end{Shaded}

The greedy heuristic may fail to find the truly best combination.

\subsubsection{When It Matters}\label{when-it-matters-82}

Mistakes matter in critical domains---navigation, finance,
healthcare---where a ``good enough'' answer may not be acceptable. In
these cases, heuristics must be balanced with checks or used only when
risks are low.

\subsubsection{Try It Yourself}\label{try-it-yourself-84}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three real-life heuristics that sometimes fail (e.g.,
  ``pick the shortest route,'' ``buy the cheapest product,'' ``follow
  the crowd'').
\item
  In Python, try modifying the knapsack example so the greedy heuristic
  picks suboptimal items. Can you show the mistake?
\item
  Reflect: when is a heuristic mistake acceptable (like a wrong
  restaurant suggestion), and when is it dangerous (like a medical
  misdiagnosis)?
\end{enumerate}

\subsection{85. Algorithms as Guarantees, Heuristics as
Guesses}\label{algorithms-as-guarantees-heuristics-as-guesses}

An algorithm guarantees the right answer if given valid input. A
heuristic is a guess---often good, sometimes wrong. The key difference
is reliability: algorithms provide certainty, heuristics provide speed
with risk.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-85}

Think of doing math homework. Using the proper formula gives you the
exact right answer every time (algorithm). Estimating by rounding
numbers in your head is faster but may miss the mark (heuristic).

\subsubsection{Deep Dive}\label{deep-dive-55}

\begin{itemize}
\item
  Algorithms:

  \begin{itemize}
  \tightlist
  \item
    Formal, precise steps.
  \item
    Correctness can be proven.
  \item
    Examples: sorting a list, finding the shortest path with Dijkstra's
    algorithm.
  \end{itemize}
\item
  Heuristics:

  \begin{itemize}
  \tightlist
  \item
    Informal, practical shortcuts.
  \item
    No guarantee of correctness.
  \item
    Examples: ``always go toward the goal'' in a maze, ``pick the
    cheapest item first'' in a shopping problem.
  \end{itemize}
\end{itemize}

Heuristics are often wrapped inside algorithms. For instance, a search
algorithm may use a heuristic to decide which branch to explore first,
even though the underlying logic still ensures eventual correctness.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-83}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Algorithm: exact sorting}
\KeywordTok{def}\NormalTok{ algorithm\_sort(nums):}
    \ControlFlowTok{return} \BuiltInTok{sorted}\NormalTok{(nums)}

\CommentTok{\# Heuristic: guess "almost sorted" by leaving small disorder}
\KeywordTok{def}\NormalTok{ heuristic\_sort(nums):}
    \CommentTok{\# Quick but not guaranteed to be correct}
    \ControlFlowTok{return}\NormalTok{ nums[:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ [nums[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]] }\ControlFlowTok{if}\NormalTok{ nums }\ControlFlowTok{else}\NormalTok{ nums}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Algorithm sort:"}\NormalTok{, algorithm\_sort([}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{]))   }\CommentTok{\# [1,2,3]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Heuristic sort:"}\NormalTok{, heuristic\_sort([}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{]))   }\CommentTok{\# [3,1,2] (wrong)}
\end{Highlighting}
\end{Shaded}

The algorithm guarantees correctness; the heuristic may fail.

\subsubsection{When It Matters}\label{when-it-matters-83}

\begin{itemize}
\tightlist
\item
  Use algorithms when correctness is critical (banking, safety, data
  integrity).
\item
  Use heuristics when speed is more important than perfection
  (recommendations, games, real-time navigation).
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-85}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write two solutions to the same problem: (a) an algorithm, (b) a
  heuristic. Example: finding a restaurant (exact = check all reviews,
  heuristic = pick the busiest).
\item
  In Python, write a function that checks if a list is sorted
  (algorithm) and another that just checks the first and last elements
  (heuristic). Compare results.
\item
  Reflect: can you recall a time when a heuristic worked fine and a time
  when it failed badly? What did that teach you about guarantees
  vs.~guesses?
\end{enumerate}

\subsection{86. Combining Algorithms and
Heuristics}\label{combining-algorithms-and-heuristics}

In practice, many systems mix algorithms (for guarantees) with
heuristics (for speed). The algorithm ensures correctness, while the
heuristic guides it toward faster solutions. This combination often
balances reliability with efficiency.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-86}

Imagine searching for a lost phone at home. The algorithmic way is to
check every room systematically. The heuristic way is to first check
common spots like the sofa or desk. By combining them, you start with
the likely spots (heuristic) but fall back to a full search (algorithm)
if needed.

\subsubsection{Deep Dive}\label{deep-dive-56}

\begin{itemize}
\tightlist
\item
  Algorithms alone: reliable, but can be slow for large or complex
  problems.
\item
  Heuristics alone: quick, but may miss the best answer.
\item
  Combination: use heuristics to guide algorithms, saving time while
  preserving correctness.
\end{itemize}

Examples:

\begin{itemize}
\tightlist
\item
  A* search: an algorithm guaranteed to find the shortest path, guided
  by a heuristic ``estimate distance to goal.''
\item
  Chess engines: algorithms search possible moves but rely on heuristics
  to evaluate board positions.
\item
  Search engines: algorithms index documents, but heuristics rank
  results by relevance.
\end{itemize}

This balance is a hallmark of real-world computing.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-84}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Exact algorithm: breadth{-}first search for shortest path}
\ImportTok{from}\NormalTok{ collections }\ImportTok{import}\NormalTok{ deque}

\KeywordTok{def}\NormalTok{ bfs\_shortest\_path(graph, start, goal):}
\NormalTok{    queue }\OperatorTok{=}\NormalTok{ deque([(start, [start])])}
\NormalTok{    visited }\OperatorTok{=} \BuiltInTok{set}\NormalTok{()}
    \ControlFlowTok{while}\NormalTok{ queue:}
\NormalTok{        node, path }\OperatorTok{=}\NormalTok{ queue.popleft()}
        \ControlFlowTok{if}\NormalTok{ node }\OperatorTok{==}\NormalTok{ goal:}
            \ControlFlowTok{return}\NormalTok{ path}
        \ControlFlowTok{if}\NormalTok{ node }\KeywordTok{not} \KeywordTok{in}\NormalTok{ visited:}
\NormalTok{            visited.add(node)}
            \ControlFlowTok{for}\NormalTok{ neighbor }\KeywordTok{in}\NormalTok{ graph.get(node, []):}
\NormalTok{                queue.append((neighbor, path }\OperatorTok{+}\NormalTok{ [neighbor]))}
    \ControlFlowTok{return} \VariableTok{None}

\CommentTok{\# Heuristic: guess by going toward nodes that "look closer" to goal}
\KeywordTok{def}\NormalTok{ greedy\_path(graph, start, goal, heuristic):}
\NormalTok{    path }\OperatorTok{=}\NormalTok{ [start]}
\NormalTok{    node }\OperatorTok{=}\NormalTok{ start}
    \ControlFlowTok{while}\NormalTok{ node }\OperatorTok{!=}\NormalTok{ goal }\KeywordTok{and}\NormalTok{ graph[node]:}
\NormalTok{        node }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(graph[node], key}\OperatorTok{=}\KeywordTok{lambda}\NormalTok{ n: heuristic(n, goal))}
\NormalTok{        path.append(node)}
    \ControlFlowTok{return}\NormalTok{ path}

\NormalTok{graph }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"A"}\NormalTok{: [}\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{],}
    \StringTok{"B"}\NormalTok{: [}\StringTok{"D"}\NormalTok{],}
    \StringTok{"C"}\NormalTok{: [}\StringTok{"D"}\NormalTok{],}
    \StringTok{"D"}\NormalTok{: [}\StringTok{"E"}\NormalTok{],}
    \StringTok{"E"}\NormalTok{: []}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ simple\_heuristic(n, goal): }\ControlFlowTok{return} \BuiltInTok{abs}\NormalTok{(}\BuiltInTok{ord}\NormalTok{(goal) }\OperatorTok{{-}} \BuiltInTok{ord}\NormalTok{(n))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"BFS (algorithm):"}\NormalTok{, bfs\_shortest\_path(graph, }\StringTok{"A"}\NormalTok{, }\StringTok{"E"}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Greedy (heuristic):"}\NormalTok{, greedy\_path(graph, }\StringTok{"A"}\NormalTok{, }\StringTok{"E"}\NormalTok{, simple\_heuristic))}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-84}

Combining algorithms and heuristics matters when problems are too large
for pure algorithms but too important for pure guesses. The mix brings
both speed and trust.

\subsubsection{Try It Yourself}\label{try-it-yourself-86}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Think of a task like finding a restaurant. Write an algorithmic
  approach (check all options) and a heuristic approach (choose the
  closest). How could you combine them?
\item
  In Python, implement a simple search that first checks a heuristic
  guess, then falls back to scanning all items if not found.
\item
  Reflect: can you think of a system (maps, games, search engines) where
  you can see both algorithmic guarantees and heuristic shortcuts at
  play?
\end{enumerate}

\subsection{87. Real Example: Spelling
Correction}\label{real-example-spelling-correction}

Spelling correction combines algorithms with heuristics. The algorithm
ensures valid suggestions by comparing words carefully, while heuristics
speed things up by guessing likely errors. Together, they make tools
like autocorrect and search engines both fast and useful.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-87}

Imagine a friend mishears your name. They try spelling it a few ways
until it ``looks right.'' Autocorrect does the same---it checks possible
alternatives and then guesses the most likely one based on context.

\subsubsection{Deep Dive}\label{deep-dive-57}

\begin{itemize}
\item
  Algorithmic part:

  \begin{itemize}
  \tightlist
  \item
    Compute similarity between words (like ``kitten'' → ``sitting'').
  \item
    Methods include edit distance (minimum steps to change one word into
    another).
  \end{itemize}
\item
  Heuristic part:

  \begin{itemize}
  \tightlist
  \item
    Guess common mistakes (swap nearby keys, missing letters).
  \item
    Rank corrections by frequency in a dictionary or past usage.
  \end{itemize}
\end{itemize}

This combination balances correctness (the algorithm measures
similarity) and speed (heuristics prune unlikely candidates).

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-85}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Algorithm: compute edit distance (Levenshtein)}
\KeywordTok{def}\NormalTok{ edit\_distance(a, b):}
\NormalTok{    dp }\OperatorTok{=}\NormalTok{ [[}\DecValTok{0}\NormalTok{]}\OperatorTok{*}\NormalTok{(}\BuiltInTok{len}\NormalTok{(b)}\OperatorTok{+}\DecValTok{1}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(a)}\OperatorTok{+}\DecValTok{1}\NormalTok{)]}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(a)}\OperatorTok{+}\DecValTok{1}\NormalTok{):}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(b)}\OperatorTok{+}\DecValTok{1}\NormalTok{):}
            \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{                dp[i][j] }\OperatorTok{=}\NormalTok{ j}
            \ControlFlowTok{elif}\NormalTok{ j }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{                dp[i][j] }\OperatorTok{=}\NormalTok{ i}
            \ControlFlowTok{elif}\NormalTok{ a[i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{==}\NormalTok{ b[j}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]:}
\NormalTok{                dp[i][j] }\OperatorTok{=}\NormalTok{ dp[i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{][j}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
            \ControlFlowTok{else}\NormalTok{:}
\NormalTok{                dp[i][j] }\OperatorTok{=} \DecValTok{1} \OperatorTok{+} \BuiltInTok{min}\NormalTok{(dp[i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{][j], dp[i][j}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], dp[i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{][j}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
    \ControlFlowTok{return}\NormalTok{ dp[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{][}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\CommentTok{\# Heuristic: pick correction with smallest distance from candidates}
\NormalTok{dictionary }\OperatorTok{=}\NormalTok{ [}\StringTok{"cat"}\NormalTok{, }\StringTok{"bat"}\NormalTok{, }\StringTok{"rat"}\NormalTok{, }\StringTok{"mat"}\NormalTok{]}
\NormalTok{word }\OperatorTok{=} \StringTok{"cta"}

\NormalTok{suggestion }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(dictionary, key}\OperatorTok{=}\KeywordTok{lambda}\NormalTok{ w: edit\_distance(word, w))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Correction for"}\NormalTok{, word, }\StringTok{"→"}\NormalTok{, suggestion)}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-85}

Spelling correction matters in tools we use every day---search engines,
messaging apps, word processors. Without heuristics, correction would be
too slow. Without algorithms, corrections would be unreliable. Together,
they strike the right balance.

\subsubsection{Try It Yourself}\label{try-it-yourself-87}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Misspell three common words (like ``recieve,'' ``teh,'' ``frend'').
  Try to think of how a correction system might suggest fixes.
\item
  Implement a Python function that suggests the closest match from a
  given dictionary using \texttt{edit\_distance}.
\item
  Reflect: have you ever seen autocorrect make a funny or wrong
  suggestion? Was it the heuristic guessing badly, or the algorithm's
  limitation?
\end{enumerate}

\subsection{88. Real Example: Route
Planning}\label{real-example-route-planning}

Route planning, like in GPS apps, blends algorithms and heuristics. The
algorithm ensures you eventually find a valid path from start to
destination. The heuristic guesses which roads are more promising (like
those closer to the goal), making the search faster.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-88}

Imagine you're in a city with many intersections. You could
systematically explore every road until you find the destination
(algorithm). Or, you could head ``generally toward downtown'' based on
landmarks (heuristic). A GPS combines both: systematic search with a
guiding estimate.

\subsubsection{Deep Dive}\label{deep-dive-58}

\begin{itemize}
\item
  Algorithmic part:

  \begin{itemize}
  \tightlist
  \item
    Graph search (roads = edges, intersections = nodes).
  \item
    Guarantees a path exists if one is possible.
  \item
    Examples: Dijkstra's algorithm, breadth-first search.
  \end{itemize}
\item
  Heuristic part:

  \begin{itemize}
  \tightlist
  \item
    Estimate remaining distance to goal.
  \item
    Guide the algorithm to check promising roads first.
  \item
    Example: A* search uses straight-line distance as a heuristic.
  \end{itemize}
\end{itemize}

This saves time: instead of exploring every possible road, the algorithm
is pulled toward the goal.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-86}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ heapq}

\KeywordTok{def}\NormalTok{ a\_star(graph, start, goal, heuristic):}
\NormalTok{    pq }\OperatorTok{=}\NormalTok{ [(}\DecValTok{0}\NormalTok{, start, [start])]}
\NormalTok{    visited }\OperatorTok{=} \BuiltInTok{set}\NormalTok{()}
    \ControlFlowTok{while}\NormalTok{ pq:}
\NormalTok{        cost, node, path }\OperatorTok{=}\NormalTok{ heapq.heappop(pq)}
        \ControlFlowTok{if}\NormalTok{ node }\OperatorTok{==}\NormalTok{ goal:}
            \ControlFlowTok{return}\NormalTok{ path}
        \ControlFlowTok{if}\NormalTok{ node }\KeywordTok{in}\NormalTok{ visited:}
            \ControlFlowTok{continue}
\NormalTok{        visited.add(node)}
        \ControlFlowTok{for}\NormalTok{ neighbor, dist }\KeywordTok{in}\NormalTok{ graph.get(node, []):}
\NormalTok{            new\_cost }\OperatorTok{=}\NormalTok{ cost }\OperatorTok{+}\NormalTok{ dist}
\NormalTok{            heapq.heappush(pq, (new\_cost }\OperatorTok{+}\NormalTok{ heuristic(neighbor, goal), neighbor, path }\OperatorTok{+}\NormalTok{ [neighbor]))}
    \ControlFlowTok{return} \VariableTok{None}

\CommentTok{\# Graph: nodes are cities, edges have distances}
\NormalTok{graph }\OperatorTok{=}\NormalTok{ \{}
    \StringTok{"A"}\NormalTok{: [(}\StringTok{"B"}\NormalTok{, }\DecValTok{2}\NormalTok{), (}\StringTok{"C"}\NormalTok{, }\DecValTok{4}\NormalTok{)],}
    \StringTok{"B"}\NormalTok{: [(}\StringTok{"D"}\NormalTok{, }\DecValTok{7}\NormalTok{)],}
    \StringTok{"C"}\NormalTok{: [(}\StringTok{"D"}\NormalTok{, }\DecValTok{1}\NormalTok{)],}
    \StringTok{"D"}\NormalTok{: [(}\StringTok{"E"}\NormalTok{, }\DecValTok{3}\NormalTok{)],}
    \StringTok{"E"}\NormalTok{: []}
\NormalTok{\}}

\KeywordTok{def}\NormalTok{ straight\_line(a, b):}
    \ControlFlowTok{return} \BuiltInTok{abs}\NormalTok{(}\BuiltInTok{ord}\NormalTok{(a) }\OperatorTok{{-}} \BuiltInTok{ord}\NormalTok{(b))  }\CommentTok{\# toy heuristic: letter distance}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Route A → E:"}\NormalTok{, a\_star(graph, }\StringTok{"A"}\NormalTok{, }\StringTok{"E"}\NormalTok{, straight\_line))}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-86}

Route planning algorithms keep maps usable in real time. Without
heuristics, they'd take too long to calculate routes. Without
algorithms, they'd give unreliable paths. Together, they balance speed
and correctness.

\subsubsection{Try It Yourself}\label{try-it-yourself-88}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Draw a small ``city'' with 5 intersections and roads. Write down the
  shortest route from home to school. How would a heuristic help you
  find it faster?
\item
  Modify the Python code with your own graph (e.g., rooms in a house, or
  airports connected by flights).
\item
  Reflect: have you ever had GPS suggest a weird or bad route? Was it
  because of a poor heuristic (bad guess) or the algorithm lacking
  real-world data (like traffic)?
\end{enumerate}

\subsection{89. Evaluating ``Good Enough'' in
Context}\label{evaluating-good-enough-in-context}

Sometimes, the perfect solution is too expensive. Instead, we settle for
a solution that is ``good enough.'' What counts as ``good enough''
depends on the context: in some cases, an approximate answer is fine; in
others, only exactness will do.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-89}

Imagine baking cookies. You don't need each cookie to weigh exactly 20
grams. If they're roughly the same size, that's good enough. But if
you're making medicine capsules, the weight must be exact every time.
Context decides whether approximation is acceptable.

\subsubsection{Deep Dive}\label{deep-dive-59}

\begin{itemize}
\item
  Flexible contexts: Search engines, recommendations, route planning. A
  close-enough result is useful because it's fast.
\item
  Strict contexts: Banking, medical devices, safety systems. Errors are
  unacceptable---algorithms must be exact.
\item
  Trade-offs:

  \begin{itemize}
  \tightlist
  \item
    Heuristics save time and memory, but risk small mistakes.
  \item
    Algorithms guarantee correctness, but may be slower or harder to
    build.
  \end{itemize}
\end{itemize}

The key is evaluating the cost of being wrong. If mistakes are
low-impact, ``good enough'' saves effort. If mistakes are costly,
exactness is non-negotiable.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-87}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Exact: compute average exactly}
\KeywordTok{def}\NormalTok{ exact\_average(nums):}
    \ControlFlowTok{return} \BuiltInTok{sum}\NormalTok{(nums) }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(nums)}

\CommentTok{\# Approximate: sample a few numbers to estimate}
\KeywordTok{def}\NormalTok{ approx\_average(nums, step}\OperatorTok{=}\DecValTok{10}\NormalTok{):}
\NormalTok{    sample }\OperatorTok{=}\NormalTok{ nums[::step]}
    \ControlFlowTok{return} \BuiltInTok{sum}\NormalTok{(sample) }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(sample)}

\NormalTok{data }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{100001}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Exact average:"}\NormalTok{, exact\_average(data))     }\CommentTok{\# 50000.5}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Approx average:"}\NormalTok{, approx\_average(data))   }\CommentTok{\# Close, but not exact}
\end{Highlighting}
\end{Shaded}

The approximate method is much faster on huge lists, but it sacrifices
accuracy.

\subsubsection{When It Matters}\label{when-it-matters-87}

``Good enough'' matters in systems where speed, memory, or simplicity is
more valuable than perfection. In contexts where errors are costly, we
must stick to exact algorithms.

\subsubsection{Try It Yourself}\label{try-it-yourself-89}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three problems where ``good enough'' is acceptable (like
  finding a restaurant or predicting the weather).
\item
  Write down three problems where only exact answers work (like payroll
  or medical dosage).
\item
  In Python, test the \texttt{approx\_average} function with different
  step sizes (5, 10, 100). How does accuracy change? How much time do
  you save?
\end{enumerate}

\subsection{90. Exercise: Design a Heuristic for Picking a
Restaurant}\label{exercise-design-a-heuristic-for-picking-a-restaurant}

Choosing a restaurant is a problem with many possible answers. The exact
approach would be to evaluate every restaurant---menu, price, distance,
reviews---and then pick the best. But that's slow and impractical.
Instead, we use a heuristic: a shortcut rule that usually gives a good
enough answer quickly.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-90}

Imagine walking through a street full of restaurants. The algorithmic
way is to read every menu, compare every price, and calculate the best
choice. The heuristic way is to say, \emph{``Pick the first place that
looks busy and affordable.''} It may not be perfect, but it works fast.

\subsubsection{Deep Dive}\label{deep-dive-60}

Possible heuristics for picking a restaurant:

\begin{itemize}
\tightlist
\item
  Popularity heuristic: choose the one with the longest line.
\item
  Distance heuristic: choose the closest one within walking range.
\item
  Budget heuristic: choose the first one under a set price.
\item
  Ambience heuristic: choose the one that ``looks nice.''
\item
  Combination heuristic: mix rules, like ``closest place with at least 3
  stars.''
\end{itemize}

These shortcuts reflect what real people (and apps) do---reduce options
quickly using a few key signals.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-88}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{restaurants }\OperatorTok{=}\NormalTok{ [}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"A"}\NormalTok{, }\StringTok{"distance"}\NormalTok{: }\DecValTok{2}\NormalTok{, }\StringTok{"rating"}\NormalTok{: }\FloatTok{4.5}\NormalTok{, }\StringTok{"price"}\NormalTok{: }\DecValTok{20}\NormalTok{\},}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"B"}\NormalTok{, }\StringTok{"distance"}\NormalTok{: }\DecValTok{1}\NormalTok{, }\StringTok{"rating"}\NormalTok{: }\FloatTok{3.5}\NormalTok{, }\StringTok{"price"}\NormalTok{: }\DecValTok{10}\NormalTok{\},}
\NormalTok{    \{}\StringTok{"name"}\NormalTok{: }\StringTok{"C"}\NormalTok{, }\StringTok{"distance"}\NormalTok{: }\DecValTok{5}\NormalTok{, }\StringTok{"rating"}\NormalTok{: }\FloatTok{5.0}\NormalTok{, }\StringTok{"price"}\NormalTok{: }\DecValTok{40}\NormalTok{\},}
\NormalTok{]}

\CommentTok{\# Heuristic: pick closest restaurant with rating \textgreater{}= 4}
\KeywordTok{def}\NormalTok{ pick\_restaurant(data, min\_rating}\OperatorTok{=}\DecValTok{4}\NormalTok{):}
\NormalTok{    candidates }\OperatorTok{=}\NormalTok{ [r }\ControlFlowTok{for}\NormalTok{ r }\KeywordTok{in}\NormalTok{ data }\ControlFlowTok{if}\NormalTok{ r[}\StringTok{"rating"}\NormalTok{] }\OperatorTok{\textgreater{}=}\NormalTok{ min\_rating]}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ candidates:}
        \ControlFlowTok{return} \VariableTok{None}
    \ControlFlowTok{return} \BuiltInTok{min}\NormalTok{(candidates, key}\OperatorTok{=}\KeywordTok{lambda}\NormalTok{ r: r[}\StringTok{"distance"}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Choice:"}\NormalTok{, pick\_restaurant(restaurants))}
\end{Highlighting}
\end{Shaded}

This heuristic skips perfect evaluation and instead picks quickly using
distance + rating.

\subsubsection{When It Matters}\label{when-it-matters-88}

Heuristics like this matter in everyday decision-making and in apps like
Yelp, Google Maps, or Uber Eats. Users don't need perfection---they need
a good enough choice quickly.

\subsubsection{Try It Yourself}\label{try-it-yourself-90}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write your own restaurant heuristic: maybe ``cheapest above 4 stars,''
  or ``closest under \$30.''
\item
  In Python, extend the code so users can prioritize price, distance, or
  rating differently.
\item
  Reflect: can you think of times when your shortcut rule for picking a
  place worked well, and times when it failed? What caused the
  difference?
\end{enumerate}

\section{Chapter 10. A tiny tool box}\label{chapter-10.-a-tiny-tool-box}

\subsection{91. Recipe 1: Summing a List of
Numbers}\label{recipe-1-summing-a-list-of-numbers}

Summing a list is one of the simplest algorithms: add numbers one by one
until you reach the total. It shows the core idea of an
algorithm---clear steps, input, and output---without extra complexity.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-91}

Imagine counting coins on a table. You pick them up one at a time,
adding their values to a running total. At the end, the pile is empty,
and you have the sum.

\subsubsection{Deep Dive}\label{deep-dive-61}

\begin{itemize}
\tightlist
\item
  Input: a list of numbers, like \texttt{{[}3,\ 7,\ 2{]}}.
\item
  Process: start with total = 0, then add each number to total.
\item
  Output: the final total.
\end{itemize}

Key points:

\begin{itemize}
\tightlist
\item
  The algorithm works for any size list, including very long ones.
\item
  It is deterministic: the same input always gives the same result.
\item
  Cost is proportional to the number of items---linear time.
\end{itemize}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-89}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ sum\_list(nums):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ total}

\BuiltInTok{print}\NormalTok{(sum\_list([}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{]))   }\CommentTok{\# 12}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-89}

Summing matters because totals are everywhere: bills, grades, scores,
statistics. The same simple idea scales up to huge systems like
databases and spreadsheets.

\subsubsection{Try It Yourself}\label{try-it-yourself-91}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write the steps of the algorithm in plain words for summing
  \texttt{{[}5,\ 10,\ 15{]}}.
\item
  Modify the code so it prints the running total after each addition.
  What do you see?
\item
  Reflect: why is summing a good ``first recipe'' for learning
  algorithms? Can you think of bigger problems that depend on summing
  (like averages or totals in shopping carts)?
\end{enumerate}

\subsection{92. Why Summing Matters: Totals
Everywhere}\label{why-summing-matters-totals-everywhere}

Summing isn't just a toy example---it's a fundamental pattern. Totals
appear in finance, science, sports, and daily life. Anytime you combine
individual pieces into one grand total, you're applying the same simple
algorithm.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-92}

Think of a shopping cart at the supermarket. Each item has a price. The
cashier doesn't guess the total---they add them up one by one. The
``sum'' gives the final bill.

\subsubsection{Deep Dive}\label{deep-dive-62}

\begin{itemize}
\tightlist
\item
  Finance: add transactions to calculate account balances.
\item
  Science: sum measurements to compute averages, totals, or
  probabilities.
\item
  Sports: sum points or times to find winners.
\item
  Programming: summing is the foundation of many more advanced
  operations like averages, variances, dot products, and even training
  machine learning models.
\end{itemize}

Because summing shows up everywhere, it's often optimized at the
hardware level (e.g., CPU instructions). It's the simplest form of an
aggregate operation, where many values are combined into one.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-90}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Shopping cart total}
\NormalTok{cart }\OperatorTok{=}\NormalTok{ [}\FloatTok{12.99}\NormalTok{, }\FloatTok{3.50}\NormalTok{, }\FloatTok{4.25}\NormalTok{, }\FloatTok{7.80}\NormalTok{]}

\KeywordTok{def}\NormalTok{ total\_price(items):}
\NormalTok{    total }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ price }\KeywordTok{in}\NormalTok{ items:}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ price}
    \ControlFlowTok{return}\NormalTok{ total}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Cart total:"}\NormalTok{, total\_price(cart))  }\CommentTok{\# 28.54}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-90}

Summing matters because it's a universal operation: quick, reliable, and
flexible. The same idea can scale from counting coins in your pocket to
analyzing billions of data points.

\subsubsection{Try It Yourself}\label{try-it-yourself-92}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write three examples from your daily life where you use summing
  without thinking (like counting steps, adding scores, or totaling
  bills).
\item
  In Python, extend the \texttt{total\_price} function to also return
  the average price by dividing the sum by the number of items.
\item
  Reflect: how does the simple act of summing enable more complex tasks
  like budgeting, grading, or scientific analysis?
\end{enumerate}

\subsection{93. Recipe 2: Finding the Maximum
Element}\label{recipe-2-finding-the-maximum-element}

Finding the maximum means identifying the largest item in a list. The
algorithm works by scanning through the items one by one, always
remembering the biggest seen so far.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-93}

Imagine a school holding a tallest-student contest. You line up all the
students and compare them one by one. Each time you meet someone taller
than the current champion, you update your record. At the end, the
tallest student remains.

\subsubsection{Deep Dive}\label{deep-dive-63}

\begin{itemize}
\item
  Input: a list of numbers or comparable items (e.g., heights, scores).
\item
  Process:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Assume the first item is the maximum.
  \item
    Compare each new item to the current maximum.
  \item
    If larger, update the maximum.
  \end{enumerate}
\item
  Output: the largest value.
\end{itemize}

Key points:

\begin{itemize}
\tightlist
\item
  Deterministic: same input always gives the same maximum.
\item
  Time cost: linear---must check each item at least once.
\item
  Preconditions: list must not be empty, or else ``maximum'' has no
  meaning.
\end{itemize}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-91}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ find\_max(nums):}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: list must not be empty"}
\NormalTok{    max\_val }\OperatorTok{=}\NormalTok{ nums[}\DecValTok{0}\NormalTok{]}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums[}\DecValTok{1}\NormalTok{:]:}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textgreater{}}\NormalTok{ max\_val:}
\NormalTok{            max\_val }\OperatorTok{=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ max\_val}

\BuiltInTok{print}\NormalTok{(find\_max([}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{5}\NormalTok{]))  }\CommentTok{\# 9}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-91}

Maximum-finding matters in contexts like:

\begin{itemize}
\tightlist
\item
  Sports: highest score wins.
\item
  Business: largest sale, biggest customer.
\item
  Science: peak value in an experiment.
\item
  Everyday life: hottest day of the year, tallest building in town.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-93}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down the step-by-step procedure to find the maximum of
  \texttt{{[}8,\ 3,\ 10,\ 2{]}}. Which comparisons do you make?
\item
  Modify the Python code so it also returns the position (index) of the
  maximum value.
\item
  Reflect: why is ``maximum'' such a natural and common operation in
  life? Can you think of situations where finding the minimum instead is
  more important?
\end{enumerate}

\subsection{94. Why Max Matters: Biggest, Fastest,
Strongest}\label{why-max-matters-biggest-fastest-strongest}

The maximum isn't just a number---it represents the best in a group.
Whether it's the fastest runner, the highest score, or the strongest
signal, finding the maximum tells us who or what stands out above the
rest.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-94}

Think of a sports competition. Out of many runners, only one crosses the
finish line first. The maximum value is that winner---the single
measurement that represents the peak of performance.

\subsubsection{Deep Dive}\label{deep-dive-64}

\begin{itemize}
\tightlist
\item
  Competitions: gold medal goes to the maximum score or fastest time.
\item
  Science \& engineering: maximum stress a material can handle before
  breaking.
\item
  Business: maximum sales in a quarter or record-breaking revenue.
\item
  Everyday life: the hottest temperature this summer, or the highest
  balance your account ever reached.
\end{itemize}

The importance of maximum lies in decision-making. By knowing the
maximum, we can set benchmarks, detect anomalies, or highlight the best
performer.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-92}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Track the fastest runner}
\NormalTok{runners }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Alice"}\NormalTok{: }\FloatTok{12.5}\NormalTok{, }\StringTok{"Bob"}\NormalTok{: }\FloatTok{11.8}\NormalTok{, }\StringTok{"Cara"}\NormalTok{: }\FloatTok{13.2}\NormalTok{\}  }\CommentTok{\# times in seconds}

\KeywordTok{def}\NormalTok{ fastest\_runner(data):}
    \CommentTok{\# Minimum time = maximum performance}
\NormalTok{    winner }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(data, key}\OperatorTok{=}\NormalTok{data.get)}
    \ControlFlowTok{return}\NormalTok{ winner, data[winner]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Fastest runner:"}\NormalTok{, fastest\_runner(runners))}
\end{Highlighting}
\end{Shaded}

Here, the ``best'' is expressed as the minimum time, which is
effectively the maximum performance.

\subsubsection{When It Matters}\label{when-it-matters-92}

Max matters because it defines goals, boundaries, and extremes. It shows
what's possible in a dataset, highlights outliers, and often determines
winners or failures.

\subsubsection{Try It Yourself}\label{try-it-yourself-94}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  List three examples in daily life where you naturally look for the
  maximum (like tallest building, most expensive item, highest grade).
\item
  In Python, adapt the \texttt{fastest\_runner} function to find the
  slowest runner instead.
\item
  Reflect: why do humans instinctively value maximums? How does this
  instinct show up in sports, business, and personal achievements?
\end{enumerate}

\subsection{95. Recipe 3: Counting Items That Meet a
Condition}\label{recipe-3-counting-items-that-meet-a-condition}

Counting items with a condition means scanning through a list and
tallying only those that match a rule. It's like taking attendance: you
don't just count everyone, you count only those present.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-95}

Imagine a classroom where the teacher asks, \emph{``How many students
brought their homework today?''} The teacher doesn't count all
students---only those who raise their hands. That's conditional
counting.

\subsubsection{Deep Dive}\label{deep-dive-65}

\begin{itemize}
\item
  Input: a list of items and a condition (e.g., ``is even,'' ``score
  above 50'').
\item
  Process:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Start with count = 0.
  \item
    For each item, check if it satisfies the condition.
  \item
    If yes, add 1 to the count.
  \end{enumerate}
\item
  Output: the final count of matching items.
\end{itemize}

Key points:

\begin{itemize}
\tightlist
\item
  Works for any type of data as long as you can define a condition.
\item
  Time cost: linear---must check each item once.
\item
  Useful for filtering and statistics.
\end{itemize}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-93}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ count\_even(nums):}
\NormalTok{    count }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums:}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{            count }\OperatorTok{+=} \DecValTok{1}
    \ControlFlowTok{return}\NormalTok{ count}

\BuiltInTok{print}\NormalTok{(count\_even([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]))  }\CommentTok{\# 3}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-93}

Conditional counting is everywhere:

\begin{itemize}
\tightlist
\item
  Surveys: how many answered ``yes.''
\item
  Sports: how many goals scored in the first half.
\item
  Business: how many sales exceeded \$100.
\item
  Systems: how many requests failed in the last hour.
\end{itemize}

It's a foundational pattern for data analysis.

\subsubsection{Try It Yourself}\label{try-it-yourself-95}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write an algorithm to count how many numbers in
  \texttt{{[}10,\ 20,\ 25,\ 30,\ 45{]}} are greater than 20.
\item
  In Python, modify the code to count how many words in a list start
  with the letter ``A.''
\item
  Reflect: how does conditional counting form the basis of reports,
  dashboards, and analytics in real-world systems?
\end{enumerate}

\subsection{96. Why Counting Matters: Filters and
Tallies}\label{why-counting-matters-filters-and-tallies}

Counting under conditions turns raw data into meaningful information. It
helps us filter out noise and focus on what matters. Instead of being
overwhelmed by all the data, we ask: \emph{``How many fit this rule?''}
and get a clear number.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-96}

Think of a basket of fruit. If you just want to know how many fruits are
inside, you count them all. But if you only want apples, you count only
the apples. Conditional counting transforms the basket from a jumble
into useful tallies.

\subsubsection{Deep Dive}\label{deep-dive-66}

\begin{itemize}
\tightlist
\item
  Filtering: identify subsets of data (e.g., customers who spent over
  \$100).
\item
  Tallies: produce summaries like totals, frequencies, or proportions.
\item
  Decision-making: knowing not just ``what's there'' but ``how much of
  it matters.''
\end{itemize}

This pattern underpins data science, statistics, and even daily
decisions. Counting with conditions is the simplest form of querying
data---the core of database systems.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-94}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Count how many students passed}
\NormalTok{scores }\OperatorTok{=}\NormalTok{ [}\DecValTok{45}\NormalTok{, }\DecValTok{67}\NormalTok{, }\DecValTok{82}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{74}\NormalTok{]}

\KeywordTok{def}\NormalTok{ count\_passed(data, threshold}\OperatorTok{=}\DecValTok{50}\NormalTok{):}
    \ControlFlowTok{return} \BuiltInTok{sum}\NormalTok{(}\DecValTok{1} \ControlFlowTok{for}\NormalTok{ s }\KeywordTok{in}\NormalTok{ data }\ControlFlowTok{if}\NormalTok{ s }\OperatorTok{\textgreater{}=}\NormalTok{ threshold)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Students passed:"}\NormalTok{, count\_passed(scores))  }\CommentTok{\# 4}
\end{Highlighting}
\end{Shaded}

The code filters scores using a rule and tallies the matches.

\subsubsection{When It Matters}\label{when-it-matters-94}

Counting matters in:

\begin{itemize}
\tightlist
\item
  Education: how many students passed or failed.
\item
  E-commerce: how many orders shipped vs.~pending.
\item
  Healthcare: how many patients meet a risk factor.
\item
  Everyday life: how many emails are unread.
\end{itemize}

By turning raw data into counts, we transform complexity into actionable
insight.

\subsubsection{Try It Yourself}\label{try-it-yourself-96}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three daily-life situations where you naturally count
  conditionally (like ``how many red lights on the way,'' ``how many
  unread texts,'' ``how many ripe bananas'').
\item
  In Python, write a function that counts how many numbers in a list are
  negative.
\item
  Reflect: why does counting with conditions feel so natural to humans?
  How does this instinct scale up to computers handling millions of
  records?
\end{enumerate}

\subsection{97. Combining Recipes: Average = Sum ÷
Count}\label{combining-recipes-average-sum-count}

The average is built from two simple recipes: summing values and
counting how many values there are. Once you know the total and the
count, dividing one by the other gives the average. It shows how small
building blocks combine into a more powerful tool.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-97}

Imagine a classroom of students. You add up all their test scores (sum).
Then you note how many students took the test (count). Finally, you
divide the total score by the number of students. That final number is
the class average.

\subsubsection{Deep Dive}\label{deep-dive-67}

\begin{itemize}
\item
  Input: a list of numbers.
\item
  Process:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Compute the sum of all numbers.
  \item
    Compute the count of numbers.
  \item
    Divide sum ÷ count.
  \end{enumerate}
\item
  Output: the average.
\end{itemize}

Key points:

\begin{itemize}
\tightlist
\item
  Average is meaningful only if count \textgreater{} 0.
\item
  Average smooths data---useful for detecting trends or typical values.
\item
  Building from simpler recipes demonstrates algorithm composition:
  small, reusable parts solving bigger problems.
\end{itemize}

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-95}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ average(nums):}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: list must not be empty"}
\NormalTok{    total }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(nums)       }\CommentTok{\# recipe 1: sum}
\NormalTok{    count }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(nums)       }\CommentTok{\# recipe 3: count}
    \ControlFlowTok{return}\NormalTok{ total }\OperatorTok{/}\NormalTok{ count    }\CommentTok{\# combine}

\BuiltInTok{print}\NormalTok{(average([}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{40}\NormalTok{]))  }\CommentTok{\# 25.0}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-95}

Averages appear everywhere:

\begin{itemize}
\tightlist
\item
  Education: average grade.
\item
  Finance: average monthly spending.
\item
  Sports: batting averages, shooting percentages.
\item
  Science: average measurements smooth out noise.
\end{itemize}

They give a simple ``center point'' that makes large sets of data easier
to interpret.

\subsubsection{Try It Yourself}\label{try-it-yourself-97}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three real-life examples where averages are used (like
  temperatures, exam results, or sports stats).
\item
  In Python, extend the \texttt{average} function so it also returns the
  sum and count alongside the average.
\item
  Reflect: why does breaking down ``average'' into sum + count make it
  easier to understand and implement?
\end{enumerate}

\subsection{98. Practice: Min from Max with a
Trick}\label{practice-min-from-max-with-a-trick}

Finding the minimum (smallest item) in a list can be done directly, but
there's also a neat trick: you can reuse the maximum recipe by flipping
the comparisons. This shows how algorithms are often mirrors of each
other---once you understand one, you almost get the other for free.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-98}

Think of a tallest-student contest. To find the shortest instead, you
don't invent a brand-new contest---you just flip the rule: instead of
updating when someone is taller, you update when someone is shorter.

\subsubsection{Deep Dive}\label{deep-dive-68}

\begin{itemize}
\item
  Input: a list of numbers.
\item
  Process:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Assume the first item is the minimum.
  \item
    Compare each new item to the current minimum.
  \item
    If smaller, update the minimum.
  \end{enumerate}
\item
  Output: the smallest value.
\end{itemize}

This is almost identical to maximum-finding---just one word changes in
the comparison (\texttt{\textgreater{}} → \texttt{\textless{}}).

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-96}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ find\_min(nums):}
    \ControlFlowTok{assert} \BuiltInTok{len}\NormalTok{(nums) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{, }\StringTok{"Precondition failed: list must not be empty"}
\NormalTok{    min\_val }\OperatorTok{=}\NormalTok{ nums[}\DecValTok{0}\NormalTok{]}
    \ControlFlowTok{for}\NormalTok{ n }\KeywordTok{in}\NormalTok{ nums[}\DecValTok{1}\NormalTok{:]:}
        \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}}\NormalTok{ min\_val:   }\CommentTok{\# flipped comparison}
\NormalTok{            min\_val }\OperatorTok{=}\NormalTok{ n}
    \ControlFlowTok{return}\NormalTok{ min\_val}

\BuiltInTok{print}\NormalTok{(find\_min([}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{5}\NormalTok{]))  }\CommentTok{\# 2}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-96}

The minimum is as common as the maximum:

\begin{itemize}
\tightlist
\item
  Finance: lowest stock price in a week.
\item
  Weather: coldest day of the year.
\item
  Sports: slowest lap in a race.
\item
  Everyday life: cheapest item on a menu.
\end{itemize}

Understanding the relationship between max and min reinforces the idea
that many algorithms are duals---one is just the inverse of the other.

\subsubsection{Try It Yourself}\label{try-it-yourself-98}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write the step-by-step comparisons needed to find the minimum in
  \texttt{{[}8,\ 3,\ 10,\ 2{]}}.
\item
  Modify the Python code so it also returns the index of the minimum
  value.
\item
  Reflect: why is it powerful to see maximum and minimum as mirror
  recipes? How does this mindset help when learning new algorithms?
\end{enumerate}

\subsection{99. Reuse: These Three Recipes Show Up
Everywhere}\label{reuse-these-three-recipes-show-up-everywhere}

The three basic recipes---sum, max, and count---aren't just beginner
exercises. They are building blocks that appear inside more complex
algorithms. Once you master them, you'll start noticing them everywhere,
often hidden inside larger tasks.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-99}

Imagine a toolbox with only three simple tools: a hammer, a screwdriver,
and a wrench. At first they seem basic, but with them you can build
furniture, fix machines, or assemble toys. Sum, max, and count play the
same role in algorithm design.

\subsubsection{Deep Dive}\label{deep-dive-69}

\begin{itemize}
\tightlist
\item
  Sum underlies averages, variances, cumulative totals, and financial
  reports.
\item
  Max (and min) power ranking systems, optimization, leaderboards, and
  anomaly detection.
\item
  Count enables filtering, frequency tables, histograms, and probability
  estimates.
\end{itemize}

When algorithms combine these primitives, they create more advanced
analytics, like ``top 10 search results,'' ``average time per user,'' or
``total sales by region.''

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-97}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Example: compute average score and top performer}
\NormalTok{scores }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Alice"}\NormalTok{: }\DecValTok{82}\NormalTok{, }\StringTok{"Bob"}\NormalTok{: }\DecValTok{90}\NormalTok{, }\StringTok{"Cara"}\NormalTok{: }\DecValTok{77}\NormalTok{\}}

\KeywordTok{def}\NormalTok{ summary(data):}
\NormalTok{    total }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(data.values())             }\CommentTok{\# sum}
\NormalTok{    count }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(data)                      }\CommentTok{\# count}
\NormalTok{    average }\OperatorTok{=}\NormalTok{ total }\OperatorTok{/}\NormalTok{ count                }\CommentTok{\# average from sum ÷ count}
\NormalTok{    top }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(data, key}\OperatorTok{=}\NormalTok{data.get)          }\CommentTok{\# max}
    \ControlFlowTok{return}\NormalTok{ \{}\StringTok{"average"}\NormalTok{: average, }\StringTok{"top"}\NormalTok{: top\}}

\BuiltInTok{print}\NormalTok{(summary(scores))  }\CommentTok{\# \{\textquotesingle{}average\textquotesingle{}: 83.0, \textquotesingle{}top\textquotesingle{}: \textquotesingle{}Bob\textquotesingle{}\}}
\end{Highlighting}
\end{Shaded}

This combines all three recipes in one short function.

\subsubsection{When It Matters}\label{when-it-matters-97}

These recipes matter because they scale: whether you're handling 3 items
or 3 billion, the same ideas apply. Databases, spreadsheets, and
analytics systems depend heavily on these primitives.

\subsubsection{Try It Yourself}\label{try-it-yourself-99}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write down three real-world reports that rely on sum, max, or count
  (like ``monthly expenses,'' ``highest scorer in class,'' or ``number
  of completed tasks'').
\item
  In Python, write a function that returns the min, max, sum, and count
  of a list of numbers.
\item
  Reflect: why is it powerful to recognize these recurring recipes? How
  does seeing patterns reduce the effort of learning new algorithms?
\end{enumerate}

\subsection{100. Capstone Exercise: Analyze a Week of Expenses with Sum,
Max,
Count}\label{capstone-exercise-analyze-a-week-of-expenses-with-sum-max-count}

Let's combine the three recipes---sum, max, and count---into a single
practical task: analyzing expenses for one week. With these tools, you
can calculate the total spent, the biggest single expense, and the
number of purchases. This turns raw numbers into insights you can act
on.

\subsubsection{Picture in Your Head}\label{picture-in-your-head-100}

Imagine you keep all your receipts from Monday to Sunday in a pile. You
add them up to see how much you spent (sum). You check which receipt was
the largest (max). You count the total number of receipts (count). In a
few steps, you understand your spending habits.

\subsubsection{Deep Dive}\label{deep-dive-70}

\begin{itemize}
\tightlist
\item
  Sum: gives the total money spent over the week.
\item
  Max: highlights the largest expense---maybe a warning or a special
  event.
\item
  Count: shows how many times you spent money, not just how much.
\end{itemize}

Together, these three measures already form a small ``report.'' In fact,
many financial dashboards use these exact calculations as their first
layer of analysis.

\subsubsection{Tiny Code Recipe}\label{tiny-code-recipe-98}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expenses }\OperatorTok{=}\NormalTok{ [}\FloatTok{12.5}\NormalTok{, }\FloatTok{7.0}\NormalTok{, }\FloatTok{20.0}\NormalTok{, }\FloatTok{5.5}\NormalTok{, }\FloatTok{15.0}\NormalTok{, }\FloatTok{30.0}\NormalTok{, }\FloatTok{10.0}\NormalTok{]  }\CommentTok{\# 7 days}

\KeywordTok{def}\NormalTok{ analyze\_expenses(data):}
\NormalTok{    total }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(data)              }\CommentTok{\# sum}
\NormalTok{    biggest }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(data)            }\CommentTok{\# max}
\NormalTok{    count }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(data)              }\CommentTok{\# count}
\NormalTok{    average }\OperatorTok{=}\NormalTok{ total }\OperatorTok{/}\NormalTok{ count        }\CommentTok{\# combine into average}
    \ControlFlowTok{return}\NormalTok{ \{}
        \StringTok{"total"}\NormalTok{: total,}
        \StringTok{"biggest"}\NormalTok{: biggest,}
        \StringTok{"count"}\NormalTok{: count,}
        \StringTok{"average"}\NormalTok{: average}
\NormalTok{    \}}

\BuiltInTok{print}\NormalTok{(analyze\_expenses(expenses))}
\CommentTok{\# \{\textquotesingle{}total\textquotesingle{}: 100.0, \textquotesingle{}biggest\textquotesingle{}: 30.0, \textquotesingle{}count\textquotesingle{}: 7, \textquotesingle{}average\textquotesingle{}: 14.2857...\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{When It Matters}\label{when-it-matters-98}

Analyzing expenses like this matters in personal finance, business
budgets, or even project tracking. Simple algorithms uncover patterns:
are you spending too much, too often, or on single big purchases?

\subsubsection{Try It Yourself}\label{try-it-yourself-100}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Track your own expenses for a week. Write them in a list and run the
  analysis function. What insights do you get?
\item
  Modify the code to also report the smallest expense and the day it
  happened.
\item
  Reflect: how do sum, max, and count---so simple on their own---become
  powerful when combined in real-world tasks?
\end{enumerate}




\end{document}
